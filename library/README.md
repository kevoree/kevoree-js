# Kevoree Library

## Create your own Kevoree-JS component

> TODO: This documentation is a bit outdated, use with caution

### Step 1
First of all, you need to set up your environment in order to use all the tools provided by Kevoree.

```sh
mkdir kevoree-comp-fakeconsole
cd $_
```

Let start with a fresh new folder. We will name it `kevoree-comp-fakeconsole` just to follow the naming convention __kevoree-TYPE-NAME__. So, we are going to create a new Kevoree component which name is __fakeconsole__.  
The purpose of this component will be to display incoming messages (received from its input port) in a list, and allow users to enter messages in a field and send them to whoever is connected to its ouput port.  

##### If you already have __node__ and __npm__ installed, you can directly go to __Step 2__
If you don't have node, nor npm, you should get it from NodeJS official website (npm is now bundled with node):  
 
 * [NodeJS website](http://nodejs.org/download/)
 
Now you should be able to do:
```sh
$ node --version
v0.10.20
```

```sh
$ npm --version
1.3.11
```

Yay, let's go!


### Step 2
Now that you have `npm` you can install [`yo`](http://yeoman.io)
```sh
npm install -g yo
```
Yeoman ( `yo` ) is a tool that automates project scaffolding. We have created a Yeoman generator for Kevoree that handles all the boring stuffs related to project creation (decent folder tree, well-formed package.json file, kevoree related dependencies, etc.)  
```sh
npm install -g generator-kevoree
```
Now you have Kevoree's yo generator available. So you can scaffold your new project
```sh
yo kevoree
```
By doing so, `yo` should greet you and start asking some question about your project:
![yo kevoree prompt 0](http://i39.tinypic.com/idhel0.png)

The first question is about the Kevoree entity type you want to create. In our case, you want to create a new __component__.  
Then `yo` will ask for a name, in our case __FakeConsole__.  
![yo kevoree prompt 1](http://i39.tinypic.com/254y22x.png)  
And finally, `yo` will create and generate all the files needed for that project.  
![yo kevoree processing](http://i44.tinypic.com/2rx8efr.png)  

Your project should be created now and you should have a folder structure that looks like this:
![yo kevoree folder tree](http://i41.tinypic.com/25suaog.png)

### Step 3
 >  Ok, fine, `yo` created a lot of files for me. What should I do with them ? huh ?
 
Fair enough, lets describe what's what:

| Files/Folder                | Function                                                            | Tell me more!
| ----------------------------|---------------------------------------------------------------------|------------------------------------------------------------------------|
| package.json                | used by `npm` to handle you project                                 | [check this out](http://package.json.nodejitsu.com/)                   |
| kevoree-comp-fakeconsole.js | your module entry point                                             | specified in package.json by `"main": "./kevoree-comp-fakeconsole.js"` |
| node_modules/               | your module dependencies                                            | this is where all your project dependencies will be downloaded         |
| kevlib.json                 | a Kevoree model representing your entities                          | this file has been generated by `kevoree-gen-model` *|
| lib/                        | where you should put your source files (convention-ish folder name) | ... |
| lib/FakeConsole.js          | the generated skeleton of your new FakeConsole Kevoree component    | ... |

\* `kevoree-gen-model` has been added to your project dependencies by `yo kevoree`, and it will be executed each time you run `npm install` or `npm publish`.  `kevoree-gen-model` parses your files in order to find Kevoree entities and update your `kevlib.json`

### Step 4
Start your favorite editor so we can finally write some code for our component in `lib/FakeConsole.js` !  

```javascript
// if you have already created your own Component extending AbstractComponent
// you can replace AbstractComponent here and use your own
// ex: var MyComp = require('./path/to/MyComp')
// the only thing needed is that the top level component extends AbstractComponent :)
var AbstractComponent = require('kevoree-entities').AbstractComponent;

/**
 * Kevoree component
 * @type {FakeConsole}
 */
var FakeConsole = AbstractComponent.extend({
  toString: 'FakeConsole',

  /**
   * this method will be called by the Kevoree platform when your component has to start
   */
  start: function (_super) {
    _super.call(this);
    // TODO
  },

  /**
   * this method will be called by the Kevoree platform when your component has to stop
   */
  stop: function () {
    // TODO
  }
});

module.exports = FakeConsole;
```

The skeleton generated by `yo kevoree` uses [PseudoClass](https://github.com/lazd/PseudoClass) to give a bit of OOP to our entities.  
With __pseudoclass__ you can easily create inheritance by calling `ParentClass.extend({/* child definition */})`, so here we have `FakeConsole` that inherits from `AbstractComponent`.  
 > __AbstractComponent__ source-code is available in [`kevoree-entities/lib/AbstractComponent`](https://github.com/kevoree/kevoree-js/blob/master/library/kevoree-entities/lib/AbstractComponent.js)
 

##### Handle incoming messages using "Kevoree input ports":
To add an input port to a component, you just have to add a new function to your pseudoclass FakeConsole using a __predefined naming convention__:  

 * `in_XXX`: for input port
 
```javascript
var FakeConsole = AbstractComponent.extend({
  // ...

  in_inMsg: function (msg) {
    // TODO do something with incoming message
  }
});
```

So, here we have created a new input port named `inMsg`. This input port will be recognized by `kevoree-gen-model` when it will parse your code to generate a new Kevoree model for your project. (forgetting `in_` or `out_` before your port name will prevent **kevoree-gen-model** to understand that this is a port)

##### Handle message sending using "Kevoree output ports":
To add an output port to a component, you just have to add a new function to your pseudoclass FakeConsole using a __predefined naming convention__:  

 * `out_XXX`: for output port
 
```javascript
var FakeConsole = AbstractComponent.extend({
  // ...

  out_sendMsg: function () {}
});
```

So, here we have defined an output port named `sendMsg`, just by adding a new function to our pseudoclass. Pretty straightforward huh ?  
Just like our input port, `kevoree-gen-model` will be able to parse that function name and understand that we want a new __output port__ for our component because we used `out_` as a marker.

##### Well, lets test `kevoree-gen-model` and see if it is able to find those two ports!
Go back to your shell and type this in your project's root folder:
```sh
cp kevlib.json kevlib.json.bkp
npm install
diff kevlib.json kevlib.json.bkp
```

The `diff` command should give in stdo something like that:  
![new ports in model](http://i41.tinypic.com/2znn4eb.png)  
You should be able to see `required` and `provided` arrays with the name you used in your `FakeConsole.js` file.

> Wait dude, why does `npm install` launch `kevoree-gen-model` ??

Good question! If you take a closer look to `package.json` you should notice that there is a `scripts` directive with an action defined for `prepublish` events [(moar doc here!)](https://npmjs.org/doc/misc/npm-scripts.html)
```json
    "scripts": {
        "prepublish": "node node_modules/kevoree-gen-model"
    },
```
So, each time you run `npm publish`, this **prepublish** script should be run.

#### Step 5
Ok now that we have an input and an output port for our component, we can add some code to their function in order for them to really do stuff for us.  
> Just so you know, updating your `kevlib.json` model wasn't necessary for the moment. This file is only used by **Kevoree Web Editor** and **Kevoree Runtimes** to know what your library is made of and how to download and install it, so during the 'condig phase' there is no need to re-generate your Kevoree model. But don't worry I'll explain that in depth later.

##### Print incoming messages with `KevoreeUI` or `console.log()` if no UI available:
With __Kevoree JS__ there are 2 ways for you to run your components:

 * with `kevoree-nodejs-runtime`, which is a shell-based runtime platform
 * or with `kevoree-browser-runtime`, which is a browser-based runtime platform
 
When your components are hosted in a `kevoree-nodejs-runtime` they don't have access to KevoreeUI's DOM view. If they want to display something to users, they can do it traditionally with the native `console.log()` method or with the `KevoreeLogger` class which is a wrapper of the native Javascript `console` object.

Because we are very manly, we are going to handle both platforms in this tutorial. Here we go!  
Lets go back to our `in_inMsg` function we previously added to FakeConsole

```javascript
var FakeConsole = AbstractComponent.extend({
  // ...

  in_inMsg: function (msg) {
    // TODO do something with incoming message
  }
});
```

What we would like to do here, is to add the incoming message to a list of messages, regenerate some HTML, and give it to our `KevoreeUI` OR fall back to the `console` if we are on `kevoree-nodejs-runtime`.
And this is how :  

```javascript
var FakeConsole = AbstractComponent.extend({
  toString: 'FakeConsole',

  construct: function () {
    this.messages = [];
  },

  // ...

  in_inMsg: function (msg) {
    this.messages.push('> '+msg);

	// callback function of setUIContent is bound to 'this' so you can refer to 'this' in it and get access to your component
    this.setUIContent(this.generateHTML(), function (err) {
      if (err) {
        // Something went wrong while setting view content - which means that we are certainly running on the
        // console-based platform: fall back to KevoreeLogger then
        this.log.info('========== FakeConsole ==========');
        for (var i in this.messages) {
          this.log.info(this.messages[i]);
        }
      }
    });
  },
  
  generateHTML: function () {
	html = '<ul>';
	for (var i in this.messages) {
		html += '<li>'+this.messages[i]+'</li>';
	}
	html += '</ul>';

    return html;
  },

  out_sendMsg: function () {}
});

module.exports = FakeConsole;
```
Well, this is pretty straightforward:  

 * create a message list in `construct()`
 * add message to list in our input port function
 * generate HTML with message list with some `<ul>` and `<li>`
 
And then we use AbstractComponent's API by calling `this.setUIContent(...)`. This method takes 2 parameters, the first one is some HTML in a string and the second is a callback `function (err) {...}`.  
> Note that `setUIContent(html, callback)` will bound the callback function to 'this'. Using the native Javascript `.bind()` method that allows one to change a function context. So, you can use `this` inside of your callback and it will refer to your component instance :)

If `err` is defined, then KevoreeUI did not managed to create a UI for your component, resulting in our case, to fall back to the use of `KevoreeLogger` because it must certainly mean that we are running on `kevoree-nodejs-runtime`. (yeah I'll improve this API asap to provide a better way to handle KevoreeUI's failures)  
And that's it for incoming messages. Good job folks!


##### Send messages through ouput 'sendMsg' port:
So, our output port definition should look like this currently:
```javascript
var FakeConsole = AbstractComponent.extend({
  // ...

  out_sendMsg: function () {}
});
```

Well that's not much, but __it is fine__. You are not supposed to write more there because this function will be bound later (at runtime) to another function by the Kevoree framework.  

However, we should use this function (even though it hasn't been bound yet) in our component to send messages to Kevoree channels when the user type something in an input field (for KevoreeUI) or never in shell-based platform because we are lazy and we don't want to deal with prompt for now.

To do such thing, we will add some code in the `start()` method of our component. This method is called when our component is started by the Kevoree runtime. Initiate UI on start-up seems legit :)

```javascript
var BTN_ID   = 'send-msg-btn',
    INPUT_ID = 'send-msg-input';

var FakeConsole = AbstractComponent.extend({
  // ...

  /**
   * this method will be called by the Kevoree runtime when your component has to start
   */
  start: function (_super) {
    _super.call(this); // this is mandatory, it allows your entity to get its this.log back from KevoreeCore
    this.log.debug('start method');

    this.setUIContent(this.generateHTML(), function (err) {
      if (!err) this.registerDOMListeners();
    });
  },

  // ...
  
  generateHTML: function () {
    var html = '<div>' +
      '<input id="'+INPUT_ID+'" type="text" placeholder="Say something :)"/>' +
      '<button id="'+BTN_ID+'">Send</button>' +
      '</div>';

    if (this.messages.length > 0) {
      html += '<ul>';
      for (var i in this.messages) {
        html += '<li>'+this.messages[i]+'</li>';
      }
      html += '</ul>';
    }

    return html;
  },

  registerDOMListeners: function () {
    var sendBtn    = this.getUIRoot().querySelector('#'+BTN_ID),
        inputField = this.getUIRoot().querySelector('#'+INPUT_ID);

    var sendMsg = function() {
      if (inputField.value.length > 0) {
        // add message to our message list
        this.messages.push('< '+inputField.value);
        // update message list
        this.updateMessageList();
        // send it through output port 'sendMsg'
        this.out_sendMsg(inputField.value);
      }
    }.bind(this);

    // send message on click event if value.length > 0
    sendBtn.onclick = sendMsg;

    // send message on 'enter' key keyup event if value.length > 0
    inputField.onkeyup = function (e) {
      if (e && e.keyCode && e.keyCode == 13) {
        // 'enter' key pressed
        sendMsg();
      }
    };
  }
});
```

We call `setUIContent(...)` with the returned string of `generateHTML()` (that we have improved a bit). On our `<input>` and `<button>` we have set IDs in order to find them later and bind to them listeners to trigger message sending.  
For the listeners we have used `getUIRoot()` from __AbstractComponent__'s API. This method returns your component's DOM root element. (which is, btw, a ShadowDOM element)  

The _magic_ happens in our inner function `sendMsg()`. To send a message through our output port, we only have to call its method like this:  
```javascript
self.out_sendMsg(inputField.value);
```

#### Step 6
Ok, so we have a new Kevoree component that should work now. Lets test it!  
The easiest way to test your component is to __publish__ them on `npm` registry. By doing so, and if you followed the naming convention (_kevoree-TYPE-NAME_) you will get access to it through the Kevoree Web Editor.

> Because `kevoree-comp-fakeconsole` already exist in npm registry, you won't be able to publish it.

But the procedure to publish a module on npm registry is really simple. And with the pre-configured `package.json` that `yo kevoree` made for you, you will only need to type 2 commands to get your module published:  

```sh
npm install
npm publish
```

`npm install` will install all npm dependencies required by your module and
`npm publish` will update your `kevlib.json` file using __kevoree-gen-model__, and publish your module on npm registry (you will need to create an account on npm in order to do so)

##### Test FakeConsole with KevoreeWebEditor & kevoree-browser-runtime
> Follow the installation steps described [here](https://github.com/kevoree/kevoree-js/blob/master/README.md) to set up Kevoree's tools.  

Once you have started your own __kevoree-browser-runtime__ server, you will be able to __start__ and __deploy__ a new node in your browser (http://localhost:42042), then open the web editor (http://localhost:3042):  

```
Kevoree Web Editor actions:
> File
> Open from node
> ws://localhost:8000  (this is the default port of the WebSocketGroup hosted by your kevoree-browser-runtime server platform)
```

Now you should see something like this in the Web editor:
![open from node browser runtime](https://github-camo.global.ssl.fastly.net/4a43f99d8596152b76ffa1b953289e007e6a9a0d/687474703a2f2f6934322e74696e797069632e636f6d2f333063796b6a6f2e706e67)

What you want to do, to test out __FakeConsole__, is loading the library in the Web editor and add it to `node0` (which is, by default, the node you just started in your browser at localhost:42042)  

```
Kevoree Web Editor actions:
> Model
> Load Core Libraries
> Click on 'Javascript' tab
> Select kevoree-comp-fakeconsole and kevoree-chan-local
> Click on 'Load'
```

Now you should see `FakeConsole` and `LocalChannel` in the Web editor Javascript libraries:
![KWE loaded fakeconsole](http://i43.tinypic.com/sy8mls.png)

So you can drag'n'drop FakeConsole component, and LocalChannel channel in the editor model zone to get something like this:  
![KWE model fakeconsoles](http://i43.tinypic.com/9j25uv.png)

And then, you double-click on `server-node` and click __PUSH__ in order for the Web editor to push this new model to __kevoree-browser-runtime__.  

![KWE push fakeconsoles model](http://i43.tinypic.com/2a8j9ki.png)

Voil√†!  
If you switch back to your opened browser tab on localhost:42042 (the browser runtime one), you should have two new tabs opened next to the _Console_.  
Those two tabs are your components UIs.  

![browser runtime fakeconsoles](http://i42.tinypic.com/1syskg.png)
![playing with consoles](http://i40.tinypic.com/21awkxu.png)

You should now be ready to start messing with __kevoree-js__ :)