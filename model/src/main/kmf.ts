import * as java from './java';

export interface KCallback<A> {
    (a: A): void;
}

export class KConfig {

    public static CAS_MAX_TRY: number = 1000;
    public static CALLBACK_HISTORY: number = 1000;
    public static LONG_SIZE: number = 53;
    public static PREFIX_SIZE: number = 16;
    public static BEGINNING_OF_TIME: number = -0x001FFFFFFFFFFFFE;
    public static END_OF_TIME: number = 0x001FFFFFFFFFFFFE;
    public static NULL_LONG: number = 0x001FFFFFFFFFFFFF;
    public static KEY_PREFIX_MASK: number = 0x0000001FFFFFFFFF;
    public static KEY_SEP: string = '|';
    public static ELEM_SEP: string = ';';
    public static VAL_SEP: string = ',';
    public static CHUNK_ELEM_SEP: string = '%';
    public static CHUNK_VAL_SEP: string = '$';
    public static CACHE_INIT_SIZE: number = 16;
    public static CACHE_LOAD_FACTOR: number = (<number>75 / <number>100);
}

export class KContentKey {

    public static NULL_KEY: Float64Array = new Float64Array([KConfig.END_OF_TIME, KConfig.END_OF_TIME, KConfig.END_OF_TIME]);
    public static GLOBAL_UNIVERSE_KEY: Float64Array = new Float64Array([KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG]);
    public universe: number;
    public time: number;
    public obj: number;
    public static toString(keys: Float64Array, keyIndex: number): string {
        var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
        var offset: number = keyIndex * 3;
        if (keys[offset] != KConfig.NULL_LONG) {
            util.Base64.encodeLongToBuffer(keys[offset], buffer);
        }
        buffer.append(KConfig.KEY_SEP);
        if (keys[offset + 1] != KConfig.NULL_LONG) {
            util.Base64.encodeLongToBuffer(keys[offset + 1], buffer);
        }
        buffer.append(KConfig.KEY_SEP);
        if (keys[offset + 2] != KConfig.NULL_LONG) {
            util.Base64.encodeLongToBuffer(keys[offset + 2], buffer);
        }
        return buffer.toString();
    }

    constructor(p_universeID: number, p_timeID: number, p_objID: number) {
        this.universe = p_universeID;
        this.time = p_timeID;
        this.obj = p_objID;
    }

    public static createObject(p_universeID: number, p_quantaID: number, p_objectID: number): KContentKey {
        return new KContentKey(p_universeID, p_quantaID, p_objectID);
    }

    public static createGlobalUniverseTree(): KContentKey {
        return new KContentKey(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG);
    }

    public static createRootUniverseTree(): KContentKey {
        return new KContentKey(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.END_OF_TIME);
    }

    public static createLastPrefix(): KContentKey {
        return new KContentKey(KConfig.END_OF_TIME, KConfig.NULL_LONG, KConfig.NULL_LONG);
    }

    public static create(payload: string): KContentKey {
        if (payload == null || payload.length == 0) {
            return null;
        } else {
            var key: KContentKey = new KContentKey(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG);
            var maxRead: number = payload.length;
            var indexStartElem: number = -1;
            var indexElem: number = 0;
            var partIndex: number = 0;
            for (var i: number = 0; i < maxRead; i++) {
                if (payload.charAt(i) == KConfig.KEY_SEP) {
                    if (indexStartElem != -1) {
                        try {
                            switch (partIndex) {
                                case 0:
                                    key.universe = util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                    break;
                                case 1:
                                    key.time = util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                    break;
                                case 2:
                                    key.obj = util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                    break;
                                default:
                                    break;
                            }
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    }
                    indexStartElem = -1;
                    indexElem = indexElem + 1;
                    partIndex++;
                } else {
                    if (indexStartElem == -1) {
                        indexStartElem = i;
                    }
                }
            }
            if (indexStartElem != -1) {
                try {
                    switch (partIndex) {
                        case 0:
                            key.universe = util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                            break;
                        case 1:
                            key.time = util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                            break;
                        case 2:
                            key.obj = util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                            break;
                        default:
                            break;
                    }
                } catch ($ex$) {
                    if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);;
                    } else {
                        throw $ex$;
                    }
                }
            }
            return key;
        }
    }

    public equals(param: any): boolean {
        if (param instanceof KContentKey) {
            var remote: KContentKey = <KContentKey>param;
            return remote.universe == this.universe && remote.time == this.time && remote.obj == this.obj;
        } else {
            return false;
        }
    }

}

export interface KListener {

    universe(): number;

    listenObjects(): Float64Array;

    listen(obj: KObject): void;

    destroy(): void;

    then(updatedObjects: KCallback<any>): void;

}

export interface KModel<A extends KUniverse<any, any>> {

    key(): number;

    newUniverse(): A;

    universe(key: number): A;

    manager(): memory.manager.KDataManager;

    metaModel(): meta.KMetaModel;

    defer(): defer.KDefer;

    setOperation(metaOperation: meta.KMetaOperation, operation: KOperation<any, any>): void;

    setOperationByName(metaClassName: string, metaOperationName: string, operation: KOperation<any, any>): void;

    save(callback: KCallback<any>): void;

    connect(callback: KCallback<any>): void;

    disconnect(callback: KCallback<any>): void;

    lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void;

    lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void;

    lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void;

    createPreparedLookup(size: number): KPreparedLookup;

    lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void;

    createByName(metaClassName: string, universe: number, time: number): KObject;

    create(clazz: meta.KMetaClass, universe: number, time: number): KObject;

    createListener(universe: number): KListener;

    createModelContext(): KModelContext;

    createTraversal(startingElements: KObject[]): traversal.KTraversal;

    createReusableTraversal(): traversal.KTraversal;

    indexByName(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;

    find(metaClass: meta.KMetaClass, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;

    findByName(indexName: string, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void;

    findAll(metaClass: meta.KMetaClass, universe: number, time: number, callback: KCallback<KObject[]>): void;

    findAllByName(indexName: string, universe: number, time: number, callback: KCallback<KObject[]>): void;

}

export interface KModelContext {

    set(originTime: number, maxTime: number, originUniverse: number, maxUniverse: number): void;

    originTime(): number;

    originUniverse(): number;

    maxTime(): number;

    maxUniverse(): number;

    listen(callback: KCallback<Float64Array>): void;

    model(): KModel<any>;

}

export interface KObject {

    universe(): number;

    now(): number;

    uuid(): number;

    metaClass(): meta.KMetaClass;

    visitAttributes(visitor: traversal.visitor.KModelAttributeVisitor): void;

    visit(visitor: traversal.visitor.KModelVisitor, callback: KCallback<any>): void;

    traversal(): traversal.KTraversal;

    jump(time: number, callback: KCallback<KObject>): void;

    select(query: string, callback: KCallback<any[]>): void;

    detach(cb: KCallback<any>): void;

    addByName(metaRelationName: string, objToAdd: KObject): void;

    add(metaRelation: meta.KMetaRelation, objToAdd: KObject): void;

    removeByName(metaRelationName: string, objToRemove: KObject): void;

    remove(metaRelation: meta.KMetaRelation, objToRemove: KObject): void;

    addAllByName(metaRelationName: string, objsToAdd: KObject[]): void;

    addAll(metaRelation: meta.KMetaRelation, objsToAdd: KObject[]): void;

    removeAllByName(metaRelationName: string, callback: KCallback<any>): void;

    removeAll(metaRelation: meta.KMetaRelation, callback: KCallback<any>): void;

    getRelationByName(metaRelationName: string, callback: KCallback<KObject[]>): void;

    getRelation(metaRelation: meta.KMetaRelation, callback: KCallback<KObject[]>): void;

    getRelationValuesByName(metaRelationName: string): Float64Array;

    getRelationValues(metaRelation: meta.KMetaRelation): Float64Array;

    get(metaAttribute: meta.KMetaAttribute): any;

    getByName(metaAttributeName: string): any;

    set(metaAttribute: meta.KMetaAttribute, payload: any): void;

    setByName(metaAttributeName: string, payload: any): void;

    enforceTimepoint(): void;

    timeDephasing(): number;

    allTimes(cb: KCallback<Float64Array>): void;

    timesBefore(endOfSearch: number, cb: KCallback<Float64Array>): void;

    timesAfter(beginningOfSearch: number, cb: KCallback<Float64Array>): void;

    timesBetween(beginningOfSearch: number, endOfSearch: number, cb: KCallback<Float64Array>): void;

    toJSON(): string;

    equals(other: any): boolean;

    referencesWith(o: KObject): meta.KMetaRelation[];

    invokeOperation(operation: meta.KMetaOperation, params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;

    invokeOperationByName(operationName: string, params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void;

    manager(): memory.manager.KDataManager;

    compare(target: KObject): meta.KMeta[];

}

export interface KObjectIndex extends KObject {

    getIndex(key: string): number;

    setIndex(key: string, value: number): void;

    values(): Float64Array;

}

export interface KObjectInfer extends KObject {

    genericTrain(dependencies: KObject[], expectedOutputs: any[], callback: KCallback<any>): void;

    genericTrainAll(trainingSet: KObject[][], expectedResultSet: any[][], callback: KCallback<any>): void;

    genericInfer(features: KObject[], callback: KCallback<any[]>): void;

    genericInferAll(features: KObject[][], callback: KCallback<any[][]>): void;

    resetLearning(): void;

}

export interface KOperation<SourceObject extends KObject, ResultType> {

    (source: SourceObject, params: any[], result: KCallback<ResultType>): void;

}

export interface KPreparedLookup {

    addLookupOperation(universe: number, time: number, uuid: number): void;

    flatLookup(): Float64Array;

}

export interface KType {

    name(): string;

    id(): number;

}

export interface KUniverse<A extends KView, B extends KUniverse<any, any>> {

    key(): number;

    time(timePoint: number): A;

    diverge(): B;

    equals(other: any): boolean;

    lookupAllTimes(uuid: number, times: Float64Array, cb: KCallback<KObject[]>): void;

    createListener(): KListener;

}

export interface KView {

    createByName(metaClassName: string): KObject;

    create(clazz: meta.KMetaClass): KObject;

    select(query: string, cb: KCallback<any[]>): void;

    lookup(key: number, cb: KCallback<KObject>): void;

    lookupAll(keys: Float64Array, cb: KCallback<KObject[]>): void;

    universe(): number;

    now(): number;

    model(): KModel<any>;

    json(): format.KModelFormat;

    equals(other: any): boolean;

}

export namespace abs {
    export class AbstractDataType implements KType {

        private _name: string;
        private _id: number;
        constructor(p_name: string, p_id: number) {
            this._name = p_name;
            this._id = p_id;
        }

        public name(): string {
            return this._name;
        }

        public id(): number {
            return this._id;
        }

    }

    export class AbstractKModel<A extends KUniverse<any, any>> implements KModel<A> {

        public _manager: memory.manager.internal.KInternalDataManager;
        private _key: number;
        constructor(p_manager: memory.manager.internal.KInternalDataManager) {
            this._manager = p_manager;
            this._manager.setModel(this);
            this._key = this._manager.nextModelKey();
        }

        public metaModel(): meta.KMetaModel {
            throw "Abstract method";
        }

        public connect(cb: KCallback<any>): void {
            this._manager.connect(cb);
        }

        public disconnect(cb: KCallback<any>): void {
            this._manager.close(cb);
        }

        public manager(): memory.manager.KDataManager {
            return this._manager;
        }

        public newUniverse(): A {
            var nextKey: number = this._manager.nextUniverseKey();
            var newDimension: A = this.internalCreateUniverse(nextKey);
            this._manager.initUniverse(nextKey, nextKey);
            return newDimension;
        }

        public internalCreateUniverse(universe: number): A {
            throw "Abstract method";
        }

        public internalCreateObject(universe: number, time: number, uuid: number, clazz: meta.KMetaClass, previousUniverse: number, previousTime: number): KObject {
            throw "Abstract method";
        }

        public createProxy(universe: number, time: number, uuid: number, clazz: meta.KMetaClass, previousUniverse: number, previousTime: number): KObject {
            return this.internalCreateObject(universe, time, uuid, clazz, previousUniverse, previousTime);
        }

        public universe(key: number): A {
            var newDimension: A = this.internalCreateUniverse(key);
            this._manager.initUniverse(key, key);
            return newDimension;
        }

        public save(callback: KCallback<any>): void {
            this._manager.save(callback);
        }

        public setOperation(metaOperation: meta.KMetaOperation, operation: KOperation<any, any>): void {
            this._manager.operationManager().register(metaOperation, operation);
        }

        public setOperationByName(metaClassName: string, metaOperationName: string, operation: KOperation<any, any>): void {
            var tempMC: meta.KMetaClass = this._manager.model().metaModel().metaClassByName(metaClassName);
            if (tempMC != null) {
                var tempMO: meta.KMetaOperation = tempMC.operation(metaOperationName);
                if (tempMO != null) {
                    this._manager.operationManager().register(tempMO, operation);
                } else {
                    throw new Error("MetaOperation not found with name " + metaOperationName + " on MetaClass " + metaClassName);
                }
            } else {
                throw new Error("MetaClass not found with name " + metaClassName);
            }
        }

        public defer(): defer.KDefer {
            return new defer.impl.Defer();
        }

        public key(): number {
            return this._key;
        }

        public create(clazz: meta.KMetaClass, universe: number, time: number): KObject {
            if (!util.Checker.isDefined(clazz)) {
                return null;
            }
            var newObj: KObject = this.internalCreateObject(universe, time, this._manager.nextObjectKey(), clazz, universe, time);
            if (newObj != null) {
                this._manager.initKObject(newObj);
            }
            return newObj;
        }

        public createByName(metaClassName: string, universe: number, time: number): KObject {
            return this.create(this._manager.model().metaModel().metaClassByName(metaClassName), universe, time);
        }

        public lookup(p_universe: number, p_time: number, p_uuid: number, callback: KCallback<KObject>): void {
            this._manager.lookup(p_universe, p_time, p_uuid, callback);
        }

        public lookupAllObjects(p_universe: number, p_time: number, p_uuids: Float64Array, callback: KCallback<KObject[]>): void {
            this._manager.lookupAllObjects(p_universe, p_time, p_uuids, callback);
        }

        public lookupAllTimes(p_universe: number, p_times: Float64Array, p_uuids: number, callback: KCallback<KObject[]>): void {
            this._manager.lookupAllTimes(p_universe, p_times, p_uuids, callback);
        }

        public createPreparedLookup(p_size: number): KPreparedLookup {
            return this._manager.createPreparedLookup(p_size);
        }

        public lookupPrepared(p_prepared: KPreparedLookup, p_callback: KCallback<KObject[]>): void {
            this._manager.lookupPrepared(p_prepared, p_callback);
        }

        public createListener(universe: number): KListener {
            return this._manager.createListener(universe);
        }

        public createModelContext(): KModelContext {
            return new abs.AbstractKModelContext(this);
        }

        public createTraversal(startingElements: KObject[]): traversal.KTraversal {
            return new traversal.impl.Traversal(startingElements);
        }

        public createReusableTraversal(): traversal.KTraversal {
            return new traversal.impl.Traversal(null);
        }

        public find(metaClass: meta.KMetaClass, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void {
            this.findByName(metaClass.metaName(), universe, time, attributes, callback);
        }

        public findByName(indexName: string, universe: number, time: number, attributes: string, callback: KCallback<KObject>): void {
            if (!util.Checker.isDefined(attributes)) {
                if (util.Checker.isDefined(callback)) {
                    callback(null);
                }
            } else {
                this._manager.index(universe, time, indexName,  (kObjectIndex : KObjectIndex) => {
                    var concat: string = "";
                    var params: memory.chunk.KStringMap<string> = this.buildParams(attributes);
                    if (params.size() == 0) {
                        concat = attributes;
                    } else {
                        var currentClass: meta.KMetaClass = this.metaModel().metaClassByName(indexName);
                        if (currentClass == null) {
                            concat = attributes;
                        } else {
                            var elems: meta.KMeta[] = currentClass.metaElements();
                            for (var i: number = 0; i < elems.length; i++) {
                                if (elems[i] != null && elems[i].metaType().equals(meta.MetaType.ATTRIBUTE) && (<meta.KMetaAttribute>elems[i]).key()) {
                                    var lvalue: string = params.get(elems[i].metaName());
                                    if (lvalue != null) {
                                        concat += lvalue;
                                    }
                                }
                            }
                        }
                    }
                    var objectUUID: number = kObjectIndex.getIndex(concat);
                    if (objectUUID == KConfig.NULL_LONG) {
                        if (util.Checker.isDefined(callback)) {
                            callback(null);
                        }
                    } else {
                        this._manager.lookup(universe, time, objectUUID, callback);
                    }
                });
            }
        }

        private buildParams(p_paramString: string): memory.chunk.KStringMap<string> {
            var params: memory.chunk.KStringMap<string> = new memory.chunk.impl.ArrayStringMap<string>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
            var iParam: number = 0;
            var lastStart: number = iParam;
            while (iParam < p_paramString.length){
                if (p_paramString.charAt(iParam) == traversal.query.impl.QueryEngine.VALS_SEP) {
                    var p: string = p_paramString.substring(lastStart, iParam).trim();
                    if (!util.PrimitiveHelper.equals(p, "")) {
                        var pArray: string[] = p.split(traversal.query.impl.QueryEngine.VAL_SEP);
                        if (pArray.length > 1) {
                            params.put(pArray[0].trim(), pArray[1].trim());
                        }
                    }
                    lastStart = iParam + 1;
                }
                iParam = iParam + 1;
            }
            var lastParam: string = p_paramString.substring(lastStart, iParam).trim();
            if (!util.PrimitiveHelper.equals(lastParam, "")) {
                var pArray: string[] = lastParam.split(traversal.query.impl.QueryEngine.VAL_SEP);
                if (pArray.length > 1) {
                    params.put(pArray[0].trim(), pArray[1].trim());
                }
            }
            return params;
        }

        public indexByName(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void {
            this._manager.index(universe, time, indexName, callback);
        }

        public findAll(metaClass: meta.KMetaClass, universe: number, time: number, callback: KCallback<KObject[]>): void {
            this.findAllByName(metaClass.metaName(), universe, time, callback);
        }

        public findAllByName(indexName: string, universe: number, time: number, callback: KCallback<KObject[]>): void {
            this._manager.index(universe, time, indexName,  (index : KObjectIndex) => {
                if (index == null) {
                    if (callback != null) {
                        callback(new Array());
                    }
                } else {
                    this._manager.lookupAllObjects(universe, time, index.values(), callback);
                }
            });
        }

    }

    export class AbstractKModelContext implements KModelContext {

        public static ORIGIN_TIME: number = 0;
        public static MAX_TIME: number = 1;
        public static ORIGIN_UNIVERSE: number = 2;
        public static MAX_UNIVERSE: number = 3;
        public static NB_ELEM: number = 4;
        private _callbacks: java.util.concurrent.atomic.AtomicReference<KCallback<any>[]>;
        private _bounds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
        private _origin: KModel<any>;
        constructor(p_origin: KModel<any>) {
            this._origin = p_origin;
            this._bounds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
            this._callbacks = new java.util.concurrent.atomic.AtomicReference<KCallback<any>[]>();
        }

        public set(p_originTime: number, p_maxTime: number, p_originUniverse: number, p_maxUniverse: number): void {
            var newBounds: Float64Array = new Float64Array([p_originTime, p_maxTime, p_originUniverse, p_maxUniverse]);
            this._bounds.set(newBounds);
            var currentStateListeners: KCallback<any>[] = this._callbacks.get();
            if (currentStateListeners != null) {
                for (var i: number = 0; i < currentStateListeners.length; i++) {
                    if (currentStateListeners[i] != null) {
                        currentStateListeners[i](newBounds);
                    }
                }
            }
        }

        public originTime(): number {
            return this._bounds.get()[AbstractKModelContext.ORIGIN_TIME];
        }

        public originUniverse(): number {
            return this._bounds.get()[AbstractKModelContext.ORIGIN_UNIVERSE];
        }

        public maxTime(): number {
            return this._bounds.get()[AbstractKModelContext.MAX_TIME];
        }

        public maxUniverse(): number {
            return this._bounds.get()[AbstractKModelContext.MAX_UNIVERSE];
        }

        public listen(new_callback: KCallback<Float64Array>): void {
            var previous: KCallback<any>[];
            var next: KCallback<any>[];
            do {
                previous = this._callbacks.get();
                var previousSize: number = 0;
                if (previous != null) {
                    previousSize = previous.length;
                }
                next = new Array();
                if (previous != null && previousSize > 0) {
                    java.lang.System.arraycopy(previous, 0, next, 0, previousSize);
                }
                next[previousSize] = new_callback;
            } while (!this._callbacks.compareAndSet(previous, next))
        }

        public model(): KModel<any> {
            return this._origin;
        }

    }

    export class AbstractKObject implements KObject {

        public _uuid: number;
        public _time: number;
        public _universe: number;
        public _metaClass: meta.KMetaClass;
        public _manager: memory.manager.internal.KInternalDataManager;
        private static OUT_OF_CACHE_MSG: string = "Out of cache Error";
        public _previousResolveds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
        public static UNIVERSE_PREVIOUS_INDEX: number = 0;
        public static TIME_PREVIOUS_INDEX: number = 1;
        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number) {
            this._universe = p_universe;
            this._time = p_time;
            this._uuid = p_uuid;
            this._metaClass = p_metaClass;
            this._manager = p_manager;
            this._previousResolveds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
            var initResolved: Float64Array = new Float64Array([p_actualUniverse, p_actualTime]);
            this._previousResolveds.set(initResolved);
        }

        public previousResolved(): java.util.concurrent.atomic.AtomicReference<Float64Array> {
            return this._previousResolveds;
        }

        public timeDephasing(): number {
            return this._time - this._previousResolveds.get()[AbstractKObject.TIME_PREVIOUS_INDEX];
        }

        public uuid(): number {
            return this._uuid;
        }

        public metaClass(): meta.KMetaClass {
            return this._metaClass;
        }

        public now(): number {
            return this._time;
        }

        public universe(): number {
            return this._universe;
        }

        public detach(callback: KCallback<any>): void {
            var selfPointer: KObject = this;
            var rawPayload: memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (rawPayload == null) {
                if (callback != null) {
                    callback(new Error(AbstractKObject.OUT_OF_CACHE_MSG));
                }
            } else {
                var collector: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                var metaElements: meta.KMeta[] = this._metaClass.metaElements();
                for (var i: number = 0; i < metaElements.length; i++) {
                    if (metaElements[i] != null && metaElements[i].metaType() == meta.MetaType.RELATION) {
                        var inboundsKeys: Float64Array = rawPayload.getLongArray(metaElements[i].index(), this._metaClass);
                        for (var j: number = 0; j < inboundsKeys.length; j++) {
                            collector.put(inboundsKeys[j], inboundsKeys[j]);
                        }
                        rawPayload.clearLongArray(metaElements[i].index(), this._metaClass);
                    }
                }
                var flatCollected: Float64Array = new Float64Array(collector.size());
                var indexI: Int32Array = new Int32Array(1);
                indexI[0] = 0;
                collector.each( (key : number, value : number) => {
                    flatCollected[indexI[0]] = value;
                    indexI[0]++;
                });
                this._manager.lookupAllObjects(this._universe, this._time, flatCollected,  (resolved : KObject[]) => {
                    for (var i: number = 0; i < resolved.length; i++) {
                        if (resolved[i] != null) {
                            var linkedReferences: meta.KMetaRelation[] = resolved[i].referencesWith(selfPointer);
                            for (var j: number = 0; j < linkedReferences.length; j++) {
                                (<abs.AbstractKObject>resolved[i]).internal_remove(linkedReferences[j], selfPointer, false);
                            }
                        }
                    }
                    if (callback != null) {
                        callback(null);
                    }
                });
            }
        }

        public select(query: string, cb: KCallback<any[]>): void {
            if (!util.Checker.isDefined(query)) {
                cb(new Array());
            } else {
                var singleRoot: KObject[] = new Array();
                singleRoot[0] = this;
                traversal.query.impl.QueryEngine.getINSTANCE().eval(query, singleRoot, this._manager.model().universe(this._universe).time(this._time), cb);
            }
        }

        public get(p_attribute: meta.KMetaAttribute): any {
            var transposed: meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
            if (transposed == null) {
                throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
                return transposed.strategy().extrapolate(this, transposed, this._manager);
            }
        }

        public getByName(attributeName: string): any {
            var transposed: meta.KMetaAttribute = this._metaClass.attribute(attributeName);
            if (transposed != null) {
                return transposed.strategy().extrapolate(this, transposed, this._manager);
            } else {
                return null;
            }
        }

        public set(p_attribute: meta.KMetaAttribute, payload: any): void {
            var transposed: meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
            if (transposed == null) {
                throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
                transposed.strategy().mutate(this, transposed, payload, this._manager);
            }
        }

        public setByName(attributeName: string, payload: any): void {
            var transposed: meta.KMetaAttribute = this._metaClass.attribute(attributeName);
            if (transposed != null) {
                transposed.strategy().mutate(this, transposed, payload, this._manager);
            } else {
                throw new Error("Bad API usage, " + attributeName + " not found on object");
            }
        }

        public addByName(relationName: string, objToAdd: KObject): void {
            var metaReference: meta.KMetaRelation = this._metaClass.reference(relationName);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + relationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_add(metaReference, objToAdd, true);
        }

        public add(p_metaReference: meta.KMetaRelation, objToAdd: KObject): void {
            var metaReference: meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_add(metaReference, objToAdd, true);
        }

        private internal_add(p_metaReference: meta.KMetaRelation, p_param: KObject, p_setOpposite: boolean): void {
            if (p_param == null) {
                throw new Error("Bad KMF usage, the objToAdd param should not be null in the add method of reference named " + p_metaReference.metaName() + " part of " + this.metaClass().metaName());
            }
            var raw: memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw != null) {
                if (p_metaReference.maxBound() < 0 || (p_metaReference.maxBound() > raw.getLongArraySize(p_metaReference.index(), this._metaClass))) {
                    if (raw.addLongToArray(p_metaReference.index(), p_param.uuid(), this._metaClass)) {
                        if (p_setOpposite) {
                            (<abs.AbstractKObject>p_param).internal_add(p_param.metaClass().reference(p_metaReference.oppositeName()), this, false);
                        }
                    }
                } else {
                    throw new Error("MaxBound constraint violated on relation " + p_metaReference.metaName() + " from metaClass " + this._metaClass.metaName());
                }
            }
        }

        public enforceTimepoint(): void {
            this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
        }

        public removeByName(relationName: string, objToAdd: KObject): void {
            var metaReference: meta.KMetaRelation = this._metaClass.reference(relationName);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + relationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_remove(metaReference, objToAdd, true);
        }

        public remove(p_metaReference: meta.KMetaRelation, objToRemove: KObject): void {
            var metaReference: meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_remove(metaReference, objToRemove, true);
        }

        private internal_remove(p_metaReference: meta.KMetaRelation, objToRemove: KObject, p_setOpposite: boolean): void {
            var payload: memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (payload != null) {
                if (payload.removeLongToArray(p_metaReference.index(), objToRemove.uuid(), this._metaClass)) {
                    if (p_setOpposite) {
                        (<abs.AbstractKObject>objToRemove).internal_remove(objToRemove.metaClass().reference(p_metaReference.oppositeName()), this, false);
                    }
                }
            }
        }

        public addAllByName(p_metaRelationName: string, objsToAdd: KObject[]): void {
            var metaReference: meta.KMetaRelation = this._metaClass.reference(p_metaRelationName);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            }
            for (var i: number = 0; i < objsToAdd.length; i++) {
                this.internal_add(metaReference, objsToAdd[i], true);
            }
        }

        public addAll(p_metaRelation: meta.KMetaRelation, objsToAdd: KObject[]): void {
            var transposedRelation: meta.KMetaRelation = this.internal_transpose_ref(p_metaRelation);
            if (transposedRelation == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaRelation.metaName() + " is not part of " + this.metaClass().metaName());
            }
            for (var i: number = 0; i < objsToAdd.length; i++) {
                this.internal_add(transposedRelation, objsToAdd[i], true);
            }
        }

        public removeAllByName(p_metaRelationName: string, callback: KCallback<any>): void {
            var metaReference: meta.KMetaRelation = this._metaClass.reference(p_metaRelationName);
            if (metaReference == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_removeAll(metaReference, callback);
        }

        public removeAll(p_metaRelation: meta.KMetaRelation, callback: KCallback<any>): void {
            var transposedRelation: meta.KMetaRelation = this.internal_transpose_ref(p_metaRelation);
            if (transposedRelation == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaRelation.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_removeAll(transposedRelation, callback);
        }

        private internal_removeAll(p_metaRelation: meta.KMetaRelation, callback: KCallback<any>): void {
            var selfPointer: KObject = this;
            var currentChunk: memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            this._manager.lookupAllObjects(this._universe, this._time, currentChunk.getLongArray(p_metaRelation.index(), this._metaClass),  (previousObjs : KObject[]) => {
                for (var i: number = 0; i < previousObjs.length; i++) {
                    if (previousObjs[i] != null) {
                        var oppositeRelation: meta.KMetaRelation = previousObjs[i].metaClass().reference(p_metaRelation.oppositeName());
                        (<abs.AbstractKObject>previousObjs[i]).internal_remove(oppositeRelation, selfPointer, false);
                    }
                }
                currentChunk.clearLongArray(p_metaRelation.index(), this._metaClass);
                if (callback != null) {
                    callback(null);
                }
            });
        }

        public size(p_metaReference: meta.KMetaRelation): number {
            var transposed: meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (transposed == null) {
                throw new Error("Bad KMF usage, the attribute named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
                var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                if (raw != null) {
                    var ref: any = raw.getPrimitiveType(transposed.index(), this._metaClass);
                    if (ref == null) {
                        return 0;
                    } else {
                        try {
                            var castedRefArray: Float64Array = <Float64Array>ref;
                            return castedRefArray.length;
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                                return 0;
                            } else {
                                throw $ex$;
                            }
                        }
                    }
                } else {
                    return 0;
                }
            }
        }

        public getRelationByName(p_metaRelationName: string, cb: KCallback<KObject[]>): void {
            var transposed: meta.KMetaRelation = this.internal_transpose_ref(this._metaClass.reference(p_metaRelationName));
            if (transposed == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            } else {
                this.internal_getRelation(transposed, cb);
            }
        }

        public getRelation(p_metaReference: meta.KMetaRelation, cb: KCallback<KObject[]>): void {
            var transposed: meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (transposed == null) {
                throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
                this.internal_getRelation(transposed, cb);
            }
        }

        private internal_getRelation(p_transposedRelation: meta.KMetaRelation, cb: KCallback<KObject[]>): void {
            var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw == null) {
                cb(new Array());
            } else {
                var o: Float64Array = raw.getLongArray(p_transposedRelation.index(), this._metaClass);
                if (o == null) {
                    cb(new Array());
                } else {
                    this._manager.lookupAllObjects(this._universe, this._time, o, cb);
                }
            }
        }

        public getRelationValuesByName(p_refName: string): Float64Array {
            var transposed: meta.KMetaRelation = this.internal_transpose_ref(this.metaClass().reference(p_refName));
            if (transposed == null) {
                throw new Error("Bad KMF usage, the reference named " + p_refName + " is not part of " + this.metaClass().metaName());
            } else {
                return this.internal_getRefValues(transposed);
            }
        }

        public getRelationValues(metaRelation: meta.KMetaRelation): Float64Array {
            var transposed: meta.KMetaRelation = this.internal_transpose_ref(metaRelation);
            if (transposed == null) {
                throw new Error("Bad KMF usage, the reference named " + metaRelation + " is not part of " + this.metaClass().metaName());
            } else {
                return this.internal_getRefValues(transposed);
            }
        }

        private internal_getRefValues(transposedReference: meta.KMetaRelation): Float64Array {
            var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw == null) {
                return new Float64Array(0);
            } else {
                var o: Float64Array = raw.getLongArray(transposedReference.index(), this._metaClass);
                if (o == null) {
                    return new Float64Array(0);
                } else {
                    return o;
                }
            }
        }

        public visitAttributes(visitor: traversal.visitor.KModelAttributeVisitor): void {
            if (!util.Checker.isDefined(visitor)) {
                return;
            }
            var metaElements: meta.KMeta[] = this.metaClass().metaElements();
            for (var i: number = 0; i < metaElements.length; i++) {
                if (metaElements[i] != null && metaElements[i].metaType() == meta.MetaType.ATTRIBUTE) {
                    var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[i];
                    visitor(metaAttribute, this.get(metaAttribute));
                }
            }
        }

        public visit(p_visitor: traversal.visitor.KModelVisitor, cb: KCallback<any>): void {
            this.internal_visit(p_visitor, cb, new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null), new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null));
        }

        private internal_visit(visitor: traversal.visitor.KModelVisitor, end: KCallback<any>, visited: memory.chunk.KLongLongMap, traversed: memory.chunk.KLongLongMap): void {
            if (!util.Checker.isDefined(visitor)) {
                return;
            }
            if (traversed != null) {
                traversed.put(this._uuid, this._uuid);
            }
            var toResolveIds: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
            var metaElements: meta.KMeta[] = this.metaClass().metaElements();
            for (var i: number = 0; i < metaElements.length; i++) {
                if (metaElements[i] != null && metaElements[i].metaType() == meta.MetaType.RELATION) {
                    var reference: meta.KMetaRelation = <meta.KMetaRelation>metaElements[i];
                    var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                    if (raw != null) {
                        var idArr: Float64Array = raw.getLongArray(reference.index(), this._metaClass);
                        if (idArr != null) {
                            try {
                                for (var k: number = 0; k < idArr.length; k++) {
                                    if (traversed == null || !traversed.contains(idArr[k])) {
                                        toResolveIds.put(idArr[k], idArr[k]);
                                    }
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                    }
                }
            }
            if (toResolveIds.size() == 0) {
                if (util.Checker.isDefined(end)) {
                    end(null);
                }
            } else {
                var trimmed: Float64Array = new Float64Array(toResolveIds.size());
                var inserted: Int32Array = new Int32Array([0]);
                toResolveIds.each( (key : number, value : number) => {
                    trimmed[inserted[0]] = value;
                    inserted[0]++;
                });
                this._manager.lookupAllObjects(this._universe, this._time, trimmed,  (resolvedArr : KObject[]) => {
                    var nextDeep: java.util.List<KObject> = new java.util.ArrayList<KObject>();
                    for (var i: number = 0; i < resolvedArr.length; i++) {
                        var resolved: KObject = resolvedArr[i];
                        var result: traversal.visitor.KVisitResult = traversal.visitor.KVisitResult.CONTINUE;
                        if (resolved != null) {
                            if (visitor != null && (visited == null || !visited.contains(resolved.uuid()))) {
                                result = visitor(resolved);
                            }
                            if (visited != null) {
                                visited.put(resolved.uuid(), resolved.uuid());
                            }
                        }
                        if (result != null && result.equals(traversal.visitor.KVisitResult.STOP)) {
                            if (util.Checker.isDefined(end)) {
                                end(null);
                            }
                        } else {
                            if (!util.Checker.isDefined(result)) {
                                result = traversal.visitor.KVisitResult.STOP;
                            }
                            if (resolved != null && result.equals(traversal.visitor.KVisitResult.CONTINUE)) {
                                if (traversed == null || !traversed.contains(resolved.uuid())) {
                                    nextDeep.add(resolved);
                                }
                            }
                        }
                    }
                    if (!nextDeep.isEmpty()) {
                        var index: Int32Array = new Int32Array(1);
                        index[0] = 0;
                        var next: java.util.List<KCallback<Error>> = new java.util.ArrayList<KCallback<Error>>();
                        next.add( (throwable : Error) => {
                            index[0] = index[0] + 1;
                            if (index[0] == nextDeep.size()) {
                                if (util.Checker.isDefined(end)) {
                                    end(null);
                                }
                            } else {
                                var abstractKObject: abs.AbstractKObject = <abs.AbstractKObject>nextDeep.get(index[0]);
                                abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                            }
                        });
                        var abstractKObject: abs.AbstractKObject = <abs.AbstractKObject>nextDeep.get(index[0]);
                        abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                    } else {
                        if (util.Checker.isDefined(end)) {
                            end(null);
                        }
                    }
                });
            }
        }

        public toJSON(): string {
            var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
            builder.append("{\"universe\":");
            builder.append(this._universe);
            builder.append(",\"time\":");
            builder.append(this._time);
            builder.append(",\"uuid\":");
            builder.append(this._uuid);
            var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw != null) {
                builder.append(",\"data\":");
                builder.append(raw.toJSON(this._manager.model().metaModel()));
            }
            builder.append("}");
            return builder.toString();
        }

        public toString(): string {
            return this.toJSON();
        }

        public equals(obj: any): boolean {
            if (!(obj instanceof abs.AbstractKObject)) {
                return false;
            } else {
                var casted: abs.AbstractKObject = <abs.AbstractKObject>obj;
                return casted._uuid == this._uuid && casted._time == this._time && casted._universe == this._universe;
            }
        }

        public hashCode(): number {
            return <number>(this._universe ^ this._time ^ this._uuid);
        }

        public jump(p_time: number, p_callback: KCallback<KObject>): void {
            this._manager.lookup(this._universe, p_time, this._uuid, p_callback);
        }

        public internal_transpose_ref(p: meta.KMetaRelation): meta.KMetaRelation {
            if (!util.Checker.isDefined(p)) {
                return null;
            } else {
                return <meta.KMetaRelation>this._metaClass.metaByName(p.metaName());
            }
        }

        public internal_transpose_att(p: meta.KMetaAttribute): meta.KMetaAttribute {
            if (!util.Checker.isDefined(p)) {
                return null;
            } else {
                return <meta.KMetaAttribute>this._metaClass.metaByName(p.metaName());
            }
        }

        public internal_transpose_op(p: meta.KMetaOperation): meta.KMetaOperation {
            if (!util.Checker.isDefined(p)) {
                return null;
            } else {
                return <meta.KMetaOperation>this._metaClass.metaByName(p.metaName());
            }
        }

        public traversal(): traversal.KTraversal {
            var singleRoot: KObject[] = new Array();
            singleRoot[0] = this;
            return new traversal.impl.Traversal(singleRoot);
        }

        public referencesWith(o: KObject): meta.KMetaRelation[] {
            if (util.Checker.isDefined(o)) {
                var raw: memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                if (raw != null) {
                    var metaElements: meta.KMeta[] = this.metaClass().metaElements();
                    var selected: java.util.List<meta.KMetaRelation> = new java.util.ArrayList<meta.KMetaRelation>();
                    for (var i: number = 0; i < metaElements.length; i++) {
                        if (metaElements[i] != null && metaElements[i].metaType() == meta.MetaType.RELATION) {
                            var rawI: Float64Array = raw.getLongArray((metaElements[i].index()), this._metaClass);
                            if (rawI != null) {
                                var oUUID: number = o.uuid();
                                for (var h: number = 0; h < rawI.length; h++) {
                                    if (rawI[h] == oUUID) {
                                        selected.add(<meta.KMetaRelation>metaElements[i]);
                                        break;
                                    }
                                }
                            }
                        }
                    }
                    return selected.toArray(new Array());
                } else {
                    return new Array();
                }
            } else {
                return new Array();
            }
        }

        public invokeOperation(p_operation: meta.KMetaOperation, p_params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void {
            this._manager.operationManager().invoke(this, p_operation, p_params, strategy, cb);
        }

        public invokeOperationByName(operationName: string, p_params: any[], strategy: operation.KOperationStrategy, cb: KCallback<any>): void {
            var metaOp: meta.KMetaOperation = this._metaClass.operation(operationName);
            if (metaOp == null) {
                throw new Error("Operation not founded with name " + operationName + " in the metaClass " + this._metaClass.metaName());
            }
            this._manager.operationManager().invoke(this, metaOp, p_params, strategy, cb);
        }

        public manager(): memory.manager.KDataManager {
            return this._manager;
        }

        private internal_times(start: number, end: number, cb: KCallback<Float64Array>): void {
            this._manager.resolveTimes(this._universe, this._uuid, start, end, cb);
        }

        public allTimes(cb: KCallback<Float64Array>): void {
            this.internal_times(KConfig.BEGINNING_OF_TIME, KConfig.END_OF_TIME, cb);
        }

        public timesBefore(endOfSearch: number, cb: KCallback<Float64Array>): void {
            this.internal_times(KConfig.BEGINNING_OF_TIME, endOfSearch, cb);
        }

        public timesAfter(beginningOfSearch: number, cb: KCallback<Float64Array>): void {
            this.internal_times(beginningOfSearch, KConfig.END_OF_TIME, cb);
        }

        public timesBetween(beginningOfSearch: number, endOfSearch: number, cb: KCallback<Float64Array>): void {
            this.internal_times(beginningOfSearch, endOfSearch, cb);
        }

        public compare(target: KObject): meta.KMeta[] {
            if (target.metaClass().index() != this.metaClass().index()) {
                throw new Error("Bad API usage, the object should be compare to a similar one (" + this.metaClass().metaName() + "/" + target.metaClass().metaName() + ")");
            }
            var elems: meta.KMeta[] = this.metaClass().metaElements();
            var result: meta.KMeta[] = new Array();
            var current: number = 0;
            for (var i: number = 0; i < elems.length; i++) {
                var m: meta.KMeta = elems[i];
                if (m.metaType().equals(meta.MetaType.ATTRIBUTE)) {
                    var attribute: meta.KMetaAttribute = <meta.KMetaAttribute>m;
                    var currentAttV: any = this.get(attribute);
                    var targetAttV: any = target.get(attribute);
                    if (currentAttV == null && targetAttV != null) {
                        result[current] = attribute;
                        current++;
                    } else {
                        if (currentAttV != null && targetAttV == null) {
                            result[current] = attribute;
                            current++;
                        } else {
                            if (currentAttV != null && targetAttV != null) {
                                switch (attribute.attributeTypeId()) {
                                    case meta.KPrimitiveTypes.BOOL_ID:
                                        var castedCurrentBool: boolean = <boolean>currentAttV;
                                        var castedTargetBool: boolean = <boolean>targetAttV;
                                        if (castedCurrentBool != castedTargetBool) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    case meta.KPrimitiveTypes.CONTINUOUS_ID:
                                        var castedCurrentDouble: number = <number>currentAttV;
                                        var castedTargetDouble: number = <number>targetAttV;
                                        if (castedCurrentDouble != castedTargetDouble) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    case meta.KPrimitiveTypes.DOUBLE_ID:
                                        var castedCurrentDoubleZ: number = <number>currentAttV;
                                        var castedTargetDoubleZ: number = <number>targetAttV;
                                        if (castedCurrentDoubleZ != castedTargetDoubleZ) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    case meta.KPrimitiveTypes.INT_ID:
                                        var castedCurrentInt: number = <number>currentAttV;
                                        var castedTargetInt: number = <number>targetAttV;
                                        if (castedCurrentInt != castedTargetInt) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    case meta.KPrimitiveTypes.LONG_ID:
                                        var castedCurrentLong: number = <number>currentAttV;
                                        var castedTargetLong: number = <number>targetAttV;
                                        if (castedCurrentLong != castedTargetLong) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    case meta.KPrimitiveTypes.STRING_ID:
                                        var castedCurrentString: string = <string>currentAttV;
                                        var castedTargetString: string = <string>targetAttV;
                                        if (!util.PrimitiveHelper.equals(castedCurrentString, castedTargetString)) {
                                            result[current] = attribute;
                                            current++;
                                        }
                                        break;
                                    default:
                                        if (meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                                            var castedCurrentEnum: meta.KLiteral = <meta.KLiteral>currentAttV;
                                            var castedTargetEnum: meta.KLiteral = <meta.KLiteral>targetAttV;
                                            if (castedCurrentEnum.index() != castedTargetEnum.index()) {
                                                result[current] = attribute;
                                                current++;
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                }
            }
            var trimmed: meta.KMeta[] = new Array();
            java.lang.System.arraycopy(result, 0, trimmed, 0, current);
            return trimmed;
        }

    }

    export class AbstractKObjectIndex extends abs.AbstractKObject implements KObjectIndex {

        constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number) {
            super(p_universe, p_time, p_uuid, meta.impl.MetaClassIndex.INSTANCE, p_manager, p_actualUniverse, p_actualTime);
        }

        public getIndex(key: string): number {
            var chunk: memory.chunk.KObjectIndexChunk = <memory.chunk.KObjectIndexChunk>this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            return chunk.get(key);
        }

        public setIndex(key: string, value: number): void {
            var chunk: memory.chunk.KObjectIndexChunk = <memory.chunk.KObjectIndexChunk>this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            chunk.put(key, value);
        }

        public values(): Float64Array {
            var chunk: memory.chunk.KObjectIndexChunk = <memory.chunk.KObjectIndexChunk>this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            var result: Float64Array = new Float64Array(chunk.size());
            var i: Int32Array = new Int32Array([0]);
            chunk.each( (key : string, value : number) => {
                if (value != KConfig.NULL_LONG) {
                    result[i[0]] = value;
                    i[0]++;
                }
            });
            if (result.length == i[0]) {
                return result;
            } else {
                var trimmedResult: Float64Array = new Float64Array(i[0]);
                java.lang.System.arraycopy(result, 0, trimmedResult, 0, i[0]);
                return trimmedResult;
            }
        }

    }

    export class AbstractKObjectInfer extends abs.AbstractKObject implements KObjectInfer {

        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: meta.KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
            super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
        }

        public genericTrain(dependencies: KObject[], expectedOutputs: any[], callback: KCallback<any>): void {
            var all_dependencies: KObject[][] = new Array(new Array());
            all_dependencies[0] = dependencies;
            var all_expectedOutputs: any[][] = null;
            if (expectedOutputs != null) {
                all_expectedOutputs = new Array(new Array());
                all_expectedOutputs[0] = expectedOutputs;
            }
            this.genericTrainAll(all_dependencies, all_expectedOutputs, callback);
        }

        public genericTrainAll(p_dependencies: KObject[][], p_outputs: any[][], callback: KCallback<any>): void {
            if (p_dependencies == null) {
                throw new Error("Dependencies are mandatory for KObjectInfer");
            }
            var selfObject: KObjectInfer = this;
            var selfView: KView = selfObject.manager().model().universe(this._universe).time(this._time);
            var waiter: defer.KDefer = this.manager().model().defer();
            for (var i: number = 0; i < p_dependencies.length; i++) {
                if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                    throw new Error("Bad number of arguments for allDependencies");
                }
                var loopDependencies: KObject[] = p_dependencies[i];
                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                    var loopInput: meta.KMetaInferInput = this._metaClass.inputs()[j];
                    if (util.PrimitiveHelper.equals(loopInput.metaName(), "this") || util.PrimitiveHelper.equals(loopInput.metaName(), "self")) {
                        loopInput.extractor().exec([selfObject], selfView, waiter.waitResult());
                    } else {
                        var dependency: meta.KMetaDependency = this._metaClass.dependencies().dependencyByName(loopInput.metaName());
                        if (dependency != null) {
                            loopInput.extractor().exec([loopDependencies[dependency.index()]], selfView, waiter.waitResult());
                        } else {
                            throw new Error("Bad API definition, " + loopInput.metaName() + " isn't defined as a dependency");
                        }
                    }
                }
            }
            waiter.then( (results : any[]) => {
                var extractedInputs: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
                var k: number = 0;
                for (var i: number = 0; i < p_dependencies.length; i++) {
                    for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                        var extracted: any[] = <any[]>results[k];
                        if (extracted != null && extracted.length > 0) {
                            extractedInputs.set(i, j, <number>extracted[0]);
                        }
                        k++;
                    }
                }
                var extractedOutputs: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(1, this._metaClass.outputs().length);
                for (var i: number = 0; i < p_dependencies.length; i++) {
                    for (var j: number = 0; j < this._metaClass.outputs().length; j++) {
                        var metaInferOutput: meta.KMetaInferOutput = this._metaClass.outputs()[j];
                        var currentOutputObject: any = null;
                        if (p_outputs != null) {
                            currentOutputObject = p_outputs[i][j];
                        }
                        extractedOutputs.set(i, j, this.internalConvertOutput(currentOutputObject, metaInferOutput));
                    }
                }
                this._metaClass.inferAlg().train(extractedInputs, extractedOutputs, selfObject, this._manager);
                if (callback != null) {
                    callback(null);
                }
            });
        }

        public genericInfer(dependencies: KObject[], callback: KCallback<any[]>): void {
            var all_dependencies: KObject[][] = new Array(new Array());
            all_dependencies[0] = dependencies;
            this.genericInferAll(all_dependencies,  (objects : any[][]) => {
                if (objects != null && objects.length > 0) {
                    callback(objects[0]);
                } else {
                    callback(null);
                }
            });
        }

        public genericInferAll(p_dependencies: KObject[][], callback: KCallback<any[][]>): void {
            if (p_dependencies == null) {
                throw new Error("Bad number of arguments for allDependencies");
            }
            var selfObject: KObjectInfer = this;
            var selfView: KView = selfObject.manager().model().universe(this._universe).time(this._time);
            var waiter: defer.KDefer = this.manager().model().defer();
            for (var i: number = 0; i < p_dependencies.length; i++) {
                if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                    throw new Error("Bad number of arguments for allDependencies");
                }
                var loopDependencies: KObject[] = p_dependencies[i];
                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                    var loopInput: meta.KMetaInferInput = this._metaClass.inputs()[j];
                    if (util.PrimitiveHelper.equals(loopInput.metaName(), "this") || util.PrimitiveHelper.equals(loopInput.metaName(), "self")) {
                        loopInput.extractor().exec([selfObject], selfView, waiter.waitResult());
                    } else {
                        var dependency: meta.KMetaDependency = this._metaClass.dependencies().dependencyByName(loopInput.metaName());
                        if (dependency != null) {
                            loopInput.extractor().exec([loopDependencies[dependency.index()]], selfView, waiter.waitResult());
                        } else {
                            throw new Error("Bad API definition, " + loopInput.metaName() + " isn't defined as a dependency");
                        }
                    }
                }
            }
            waiter.then( (results : any[]) => {
                var extractedInputs: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
                var k: number = 0;
                for (var i: number = 0; i < p_dependencies.length; i++) {
                    for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                        var extracted: any[] = <any[]>results[k];
                        if (extracted != null && extracted.length > 0) {
                            extractedInputs.set(i, j, <number>extracted[0]);
                        }
                        k++;
                    }
                }
                var extractedOutputs: util.maths.structure.KArray2D = this._metaClass.inferAlg().infer(extractedInputs, selfObject, this._manager);
                var result: any[][] = new Array(new Array());
                for (var i: number = 0; i < extractedOutputs.rows(); i++) {
                    result[i] = new Array();
                    for (var j: number = 0; j < extractedOutputs.columns(); j++) {
                        result[i][j] = this.internalReverseOutput(extractedOutputs.get(i, j), this._metaClass.outputs()[j]);
                    }
                }
                callback(result);
            });
        }

        public resetLearning(): void {
            throw new Error("Not Implemented Yet!");
        }

        private internalConvertOutput(output: any, metaOutput: meta.KMetaInferOutput): number {
            if (output == null) {
                return 0;
            }
            var typeId: number = metaOutput.attributeTypeId();
            switch (typeId) {
                case meta.KPrimitiveTypes.BOOL_ID:
                    if (<boolean>output) {
                        return 1.0;
                    } else {
                        return 0.0;
                    }
                case meta.KPrimitiveTypes.DOUBLE_ID:
                    return <number>output;
                case meta.KPrimitiveTypes.INT_ID:
                    return <number>output;
                case meta.KPrimitiveTypes.CONTINUOUS_ID:
                    return <number>output;
                case meta.KPrimitiveTypes.LONG_ID:
                    return <number>output;
                case meta.KPrimitiveTypes.STRING_ID:
                    throw new Error("String are not managed yet");
                default:
                    if (meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                        var metaEnum: meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                        if (output instanceof meta.impl.MetaLiteral) {
                            return <number>(<meta.impl.MetaLiteral>output).index();
                        } else {
                            var literal: meta.KMeta = metaEnum.literalByName(output.toString());
                            if (literal != null) {
                                return <number>literal.index();
                            }
                        }
                    }
                    return 0;
            }
        }

        private internalReverseOutput(inferred: number, metaOutput: meta.KMetaInferOutput): any {
            var typeId: number = metaOutput.attributeTypeId();
            switch (typeId) {
                case meta.KPrimitiveTypes.BOOL_ID:
                    if (inferred >= 0.5) {
                        return true;
                    } else {
                        return false;
                    }
                case meta.KPrimitiveTypes.DOUBLE_ID:
                    return inferred;
                case meta.KPrimitiveTypes.INT_ID:
                    return <number>inferred;
                case meta.KPrimitiveTypes.CONTINUOUS_ID:
                    return inferred;
                case meta.KPrimitiveTypes.LONG_ID:
                    return inferred;
                case meta.KPrimitiveTypes.STRING_ID:
                    throw new Error("String are not managed yet");
                default:
                    if (meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                        var ceiledInferred: number = this.math_ceil(inferred);
                        var metaEnum: meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                        return metaEnum.literal(ceiledInferred);
                    }
                    return null;
            }
        }

        private math_ceil(toCeilValue: number): number {
            return Math.round(toCeilValue);
        }

    }

    export class AbstractKUniverse<A extends KView, B extends KUniverse<any, any>> implements KUniverse<A, B> {

        public _universe: number;
        public _manager: memory.manager.internal.KInternalDataManager;
        constructor(p_key: number, p_manager: memory.manager.internal.KInternalDataManager) {
            this._universe = p_key;
            this._manager = p_manager;
        }

        public key(): number {
            return this._universe;
        }

        public time(timePoint: number): A {
            if (timePoint <= KConfig.END_OF_TIME && timePoint >= KConfig.BEGINNING_OF_TIME) {
                return this.internal_create(timePoint);
            } else {
                throw new Error("The selected Time " + timePoint + " is out of the range of KMF managed time");
            }
        }

        public internal_create(timePoint: number): A {
            throw "Abstract method";
        }

        public equals(obj: any): boolean {
            if (!(obj instanceof abs.AbstractKUniverse)) {
                return false;
            } else {
                var casted: abs.AbstractKUniverse<any, any> = <abs.AbstractKUniverse<any, any>>obj;
                return casted._universe == this._universe;
            }
        }

        public diverge(): B {
            var casted: abs.AbstractKModel<any> = <abs.AbstractKModel<any>>this._manager.model();
            var nextKey: number = this._manager.nextUniverseKey();
            var newUniverse: B = <B>casted.internalCreateUniverse(nextKey);
            this._manager.initUniverse(nextKey, this._universe);
            return newUniverse;
        }

        public lookupAllTimes(uuid: number, times: Float64Array, cb: KCallback<KObject[]>): void {
            this._manager.lookupAllTimes(this._universe, times, uuid, cb);
        }

        public createListener(): KListener {
            return this._manager.createListener(this._universe);
        }

    }

    export class AbstractKView implements KView {

        public _time: number;
        public _universe: number;
        public _manager: memory.manager.internal.KInternalDataManager;
        constructor(p_universe: number, _time: number, p_manager: memory.manager.internal.KInternalDataManager) {
            this._universe = p_universe;
            this._time = _time;
            this._manager = p_manager;
        }

        public now(): number {
            return this._time;
        }

        public universe(): number {
            return this._universe;
        }

        public model(): KModel<any> {
            return this._manager.model();
        }

        public select(query: string, cb: KCallback<any[]>): void {
            if (util.Checker.isDefined(cb)) {
                if (query == null || query.length == 0) {
                    cb(new Array());
                } else {
                    traversal.query.impl.QueryEngine.getINSTANCE().eval(query, new Array(), this, cb);
                }
            }
        }

        public lookup(kid: number, cb: KCallback<KObject>): void {
            this._manager.lookup(this._universe, this._time, kid, cb);
        }

        public lookupAll(keys: Float64Array, cb: KCallback<KObject[]>): void {
            this._manager.lookupAllObjects(this._universe, this._time, keys, cb);
        }

        public create(clazz: meta.KMetaClass): KObject {
            return this._manager.model().create(clazz, this._universe, this._time);
        }

        public createByName(metaClassName: string): KObject {
            return this.create(this._manager.model().metaModel().metaClassByName(metaClassName));
        }

        public json(): format.KModelFormat {
            return new format.json.JsonFormat(this._universe, this._time, this._manager);
        }

        public equals(obj: any): boolean {
            if (!util.Checker.isDefined(obj)) {
                return false;
            }
            if (!(obj instanceof abs.AbstractKView)) {
                return false;
            } else {
                var casted: abs.AbstractKView = <abs.AbstractKView>obj;
                return casted._time == this._time && casted._universe == this._universe;
            }
        }

    }

}
export namespace cdn {
    export interface KContentDeliveryDriver {

        get(keys: Float64Array, callback: KCallback<string[]>): void;

        atomicGetIncrement(key: Float64Array, cb: KCallback<number>): void;

        put(keys: Float64Array, values: string[], error: KCallback<Error>, excludeListener: number): void;

        remove(keys: Float64Array, error: KCallback<Error>): void;

        connect(callback: KCallback<Error>): void;

        close(callback: KCallback<Error>): void;

        addUpdateListener(interceptor: cdn.KContentUpdateListener): number;

        removeUpdateListener(id: number): void;

        peers(): string[];

        sendToPeer(peer: string, message: message.KMessage, callback: KCallback<message.KMessage>): void;

    }

    export interface KContentUpdateListener {

        onKeysUpdate(updatedKeys: Float64Array): void;

        onOperationCall(operationCallMessage: message.KMessage): void;

    }

    export namespace impl {
        export class MemoryContentDeliveryDriver implements cdn.KContentDeliveryDriver {

            private backend: memory.chunk.KStringMap<string> = new memory.chunk.impl.ArrayStringMap<string>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
            private additionalInterceptors: memory.chunk.impl.ArrayIntMap<cdn.KContentUpdateListener> = null;
            public atomicGetIncrement(key: Float64Array, cb: KCallback<number>): void {
                var result: string = this.backend.get(KContentKey.toString(key, 0));
                var nextV: number;
                var previousV: number;
                if (result != null) {
                    try {
                        previousV = util.PrimitiveHelper.parseShort(result);
                    } catch ($ex$) {
                        if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);;
                            previousV = util.PrimitiveHelper.SHORT_MIN_VALUE();
                        } else {
                            throw $ex$;
                        }
                    }
                } else {
                    previousV = 0;
                }
                if (previousV == util.PrimitiveHelper.SHORT_MAX_VALUE()) {
                    nextV = util.PrimitiveHelper.SHORT_MIN_VALUE();
                } else {
                    nextV = <number>(previousV + 1);
                }
                this.backend.put(KContentKey.toString(key, 0), "" + nextV);
                cb(previousV);
            }

            public get(keys: Float64Array, callback: KCallback<string[]>): void {
                var nbKeys: number = keys.length / 3;
                var values: string[] = new Array();
                for (var i: number = 0; i < nbKeys; i++) {
                    values[i] = this.backend.get(KContentKey.toString(keys, i));
                }
                if (callback != null) {
                    callback(values);
                }
            }

            public put(p_keys: Float64Array, p_values: string[], p_callback: KCallback<Error>, excludeListener: number): void {
                var nbKeys: number = p_keys.length / 3;
                for (var i: number = 0; i < nbKeys; i++) {
                    this.backend.put(KContentKey.toString(p_keys, i), p_values[i]);
                }
                if (this.additionalInterceptors != null) {
                    this.additionalInterceptors.each( (key : number, value : cdn.KContentUpdateListener) => {
                        if (value != null && key != excludeListener) {
                            value.onKeysUpdate(p_keys);
                        }
                    });
                }
                if (p_callback != null) {
                    p_callback(null);
                }
            }

            public remove(p_keys: Float64Array, callback: KCallback<Error>): void {
                var nbKeys: number = p_keys.length / 3;
                for (var i: number = 0; i < nbKeys; i++) {
                    this.backend.remove(KContentKey.toString(p_keys, i));
                }
                if (callback != null) {
                    callback(null);
                }
            }

            public connect(callback: KCallback<Error>): void {
                if (callback != null) {
                    callback(null);
                }
            }

            public close(callback: KCallback<Error>): void {
                this.backend.clear();
                callback(null);
            }

            private nextListenerID(): number {
                return Math.random();
            }

            public addUpdateListener(p_interceptor: cdn.KContentUpdateListener): number {
                if (this.additionalInterceptors == null) {
                    this.additionalInterceptors = new memory.chunk.impl.ArrayIntMap<cdn.KContentUpdateListener>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                }
                var newID: number = this.nextListenerID();
                this.additionalInterceptors.put(newID, p_interceptor);
                return newID;
            }

            public removeUpdateListener(id: number): void {
                if (this.additionalInterceptors != null) {
                    this.additionalInterceptors.remove(id);
                }
            }

            public peers(): string[] {
                return new Array();
            }

            public sendToPeer(peer: string, message: message.KMessage, callback: KCallback<message.KMessage>): void {
            }

        }

    }
}
export namespace defer {
    export interface KDefer {

        waitResult(): KCallback<any>;

        then(cb: KCallback<any[]>): void;

    }

    export namespace impl {
        export class Defer implements defer.KDefer {

            private _end: KCallback<any[]>;
            private _nbExpectedResult: number = 0;
            private _nbRecResult: number = 0;
            private _results: any[] = null;
            private _resultSize: number = 0;
            public waitResult(): KCallback<any> {
                return this.informEndOrRegister(-1, null, null);
            }

            public then(cb: KCallback<any[]>): void {
                this.informEndOrRegister(-1, null, cb);
            }

            private informEndOrRegister(p_indexToInsert: number, p_result: any, p_end: KCallback<any[]>): KCallback<any> {
                if (p_end == null) {
                    if (p_indexToInsert == -1) {
                        var toInsert: number = this._nbExpectedResult;
                        this._nbExpectedResult++;
                        if (this._results == null || this._resultSize < this._nbExpectedResult) {
                            var newResultSize: number = (this._nbExpectedResult == 0 ? 1 : this._nbExpectedResult << 1);
                            var newResults: any[] = new Array();
                            if (this._results != null) {
                                java.lang.System.arraycopy(this._results, 0, newResults, 0, this._resultSize);
                            }
                            this._resultSize = newResultSize;
                            this._results = newResults;
                        }
                        return  (o : any) => {
                            this.informEndOrRegister(toInsert, o, null);
                        };
                    } else {
                        this._results[p_indexToInsert] = p_result;
                        this._nbRecResult++;
                        if (this._end != null && (this._nbExpectedResult == this._nbRecResult)) {
                            var finalResults: any[] = this._results;
                            if (this._resultSize != this._nbExpectedResult) {
                                var newResults: any[] = new Array();
                                java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                                finalResults = newResults;
                            }
                            this._end(finalResults);
                        }
                    }
                } else {
                    this._end = p_end;
                    if (this._nbExpectedResult == this._nbRecResult) {
                        var finalResults: any[] = this._results;
                        if (this._resultSize != this._nbExpectedResult) {
                            var newResults: any[] = new Array();
                            java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                            finalResults = newResults;
                        }
                        this._end(finalResults);
                    }
                }
                return null;
            }

        }

    }
}
export namespace extrapolation {
    export interface Extrapolation {

        extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any;

        mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void;

    }

    export namespace impl {
        export class DiscreteExtrapolation implements extrapolation.Extrapolation {

            private static INSTANCE: extrapolation.impl.DiscreteExtrapolation;
            public static instance(): extrapolation.Extrapolation {
                if (DiscreteExtrapolation.INSTANCE == null) {
                    DiscreteExtrapolation.INSTANCE = new extrapolation.impl.DiscreteExtrapolation();
                }
                return DiscreteExtrapolation.INSTANCE;
            }

            public extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any {
                var payload: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (payload != null) {
                    if (meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                        var metaEnum: meta.KMetaEnum = (<abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                        return metaEnum.literal(<number>payload.getPrimitiveType(attribute.index(), current.metaClass()));
                    } else {
                        return payload.getPrimitiveType(attribute.index(), current.metaClass());
                    }
                } else {
                    return null;
                }
            }

            public mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void {
                var internalPreviousPayload: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (internalPreviousPayload != null) {
                    var toSetValue: any;
                    if (meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                        if (payload instanceof meta.impl.MetaLiteral) {
                            toSetValue = (<meta.KLiteral>payload).index();
                        } else {
                            var metaEnum: meta.KMetaEnum = (<abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                            var foundLiteral: meta.KLiteral = metaEnum.literalByName(payload.toString());
                            if (foundLiteral != null) {
                                toSetValue = foundLiteral.index();
                            } else {
                                toSetValue = null;
                            }
                        }
                    } else {
                        if (payload == null) {
                            toSetValue = null;
                        } else {
                            toSetValue = this.convert(attribute, payload);
                        }
                    }
                    var previousValue: any = internalPreviousPayload.getPrimitiveType(attribute.index(), current.metaClass());
                    if (previousValue == null && toSetValue == null) {
                        return;
                    }
                    if (previousValue != null && toSetValue != null) {
                        switch (attribute.attributeTypeId()) {
                            case meta.KPrimitiveTypes.BOOL_ID:
                                var previousBoolOrdinal: boolean = <boolean>previousValue;
                                var nextBoolOrdinal: boolean = <boolean>toSetValue;
                                if (previousBoolOrdinal == nextBoolOrdinal) {
                                    return;
                                }
                                break;
                            case meta.KPrimitiveTypes.CONTINUOUS_ID:
                                var previousContinuousOrdinal: number = <number>previousValue;
                                var nextContinuousOrdinal: number = <number>toSetValue;
                                if (previousContinuousOrdinal == nextContinuousOrdinal) {
                                    return;
                                }
                                break;
                            case meta.KPrimitiveTypes.DOUBLE_ID:
                                var previousDoubleOrdinal: number = <number>previousValue;
                                var nextDoubleOrdinal: number = <number>toSetValue;
                                if (previousDoubleOrdinal == nextDoubleOrdinal) {
                                    return;
                                }
                                break;
                            case meta.KPrimitiveTypes.INT_ID:
                                var previousIntOrdinal: number = <number>previousValue;
                                var nextIntOrdinal: number = <number>toSetValue;
                                if (previousIntOrdinal == nextIntOrdinal) {
                                    return;
                                }
                                break;
                            case meta.KPrimitiveTypes.LONG_ID:
                                var previousLongOrdinal: number = <number>previousValue;
                                var nextLongOrdinal: number = <number>toSetValue;
                                if (previousLongOrdinal == nextLongOrdinal) {
                                    return;
                                }
                                break;
                            case meta.KPrimitiveTypes.STRING_ID:
                                var previousString: string = <string>previousValue;
                                var nextString: string = <string>toSetValue;
                                if (util.PrimitiveHelper.equals(previousString, nextString)) {
                                    return;
                                }
                                break;
                            default:
                                if (meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                                    var previousEnumOrdinal: number = <number>previousValue;
                                    var nextEnumOrdinal: number = <number>toSetValue;
                                    if (previousEnumOrdinal == nextEnumOrdinal) {
                                        return;
                                    }
                                }
                                break;
                        }
                    }
                    var previousHash: string = null;
                    if (attribute.key()) {
                        var metas: meta.KMeta[] = current.metaClass().metaElements();
                        for (var i: number = 0; i < metas.length; i++) {
                            if (metas[i].metaType().equals(meta.MetaType.ATTRIBUTE) && (<meta.KMetaAttribute>metas[i]).key()) {
                                var loopElem: any = internalPreviousPayload.getPrimitiveType(metas[i].index(), current.metaClass());
                                if (loopElem != null) {
                                    if (previousHash == null) {
                                        previousHash = loopElem.toString();
                                    } else {
                                        previousHash += loopElem.toString();
                                    }
                                }
                            }
                        }
                    }
                    var internalPayload: memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                    if (internalPayload != null) {
                        internalPayload.setPrimitiveType(attribute.index(), toSetValue, current.metaClass());
                        var newHash: string = null;
                        if (attribute.key()) {
                            var metas: meta.KMeta[] = current.metaClass().metaElements();
                            for (var i: number = 0; i < metas.length; i++) {
                                if (metas[i].metaType().equals(meta.MetaType.ATTRIBUTE) && (<meta.KMetaAttribute>metas[i]).key()) {
                                    var loopElem: any = internalPayload.getPrimitiveType(metas[i].index(), current.metaClass());
                                    if (loopElem != null) {
                                        if (newHash == null) {
                                            newHash = loopElem.toString();
                                        } else {
                                            newHash += loopElem.toString();
                                        }
                                    }
                                }
                            }
                            var finalPreviousHash: string = previousHash;
                            var finalNewHash: string = newHash;
                            dataManager.index(current.universe(), current.now(), current.metaClass().metaName(),  (classIndex : KObjectIndex) => {
                                if (finalPreviousHash != null) {
                                    classIndex.setIndex(finalPreviousHash, KConfig.NULL_LONG);
                                }
                                if (finalNewHash != null) {
                                    classIndex.setIndex(finalNewHash, current.uuid());
                                }
                            });
                        }
                    }
                }
            }

            private convert(attribute: meta.KMetaAttribute, payload: any): any {
                return payload;
            }

        }

        export class DoublePolynomialExtrapolation implements extrapolation.Extrapolation {

            private static _TIMERR: number = 0.001;
            private static _maxDegree: number = 20;
            private static _maxTimeDegree: number = 7;
            private static TIMEDEG: number = 0;
            private static NUMSAMPLES: number = 1;
            private static POLYDEG: number = 2;
            private static STEP: number = 3;
            private static TIMEWEIGHT: number = 4;
            private static INSTANCE: extrapolation.impl.DoublePolynomialExtrapolation;
            public extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any {
                var raw: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (raw != null) {
                    var extrapolatedValue: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), current.now(), raw.time());
                    var attTypeId: number = attribute.attributeTypeId();
                    switch (attTypeId) {
                        case meta.KPrimitiveTypes.CONTINUOUS_ID:
                            return extrapolatedValue;
                        case meta.KPrimitiveTypes.DOUBLE_ID:
                            return extrapolatedValue;
                        default:
                            return null;
                    }
                } else {
                    return null;
                }
            }

            private getPolyWeightIndex(segment: memory.chunk.KObjectChunk, meta: meta.KMetaClass, index: number): number {
                return DoublePolynomialExtrapolation.TIMEWEIGHT + <number>segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEDEG, meta) + 1;
            }

            private getTime(num: number, segment: memory.chunk.KObjectChunk, meta: meta.KMetaClass, index: number): number {
                if (segment.getDoubleArraySize(index, meta) == 0) {
                    return 0.0;
                }
                var result: number = 0;
                var power: number = 1;
                if (segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEDEG, meta) == 0) {
                    return segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEWEIGHT, meta);
                }
                var t: number = num;
                var inferArraySize: number = segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, meta);
                for (var j: number = 0; j <= inferArraySize; j++) {
                    result += segment.getDoubleArrayElem(index, (j + DoublePolynomialExtrapolation.TIMEWEIGHT), meta) * power;
                    power = power * t;
                }
                return result;
            }

            private getLastTime(segment: memory.chunk.KObjectChunk, meta: meta.KMetaClass, index: number): number {
                return this.getTime(<number>segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, meta) - 1, segment, meta, index);
            }

            private extrapolateValue(segment: memory.chunk.KObjectChunk, meta: meta.KMetaClass, index: number, time: number, timeOrigin: number): number {
                if (segment.getDoubleArraySize(index, meta) == 0) {
                    return 0.0;
                }
                var result: number = 0;
                var power: number = 1;
                var inferSTEP: number = segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, meta);
                var polyw: number = this.getPolyWeightIndex(segment, meta, index);
                if (inferSTEP == 0) {
                    return segment.getDoubleArrayElem(index, polyw, meta);
                }
                var t: number = (time - timeOrigin) / inferSTEP;
                var inferArraySize: number = segment.getDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, meta);
                for (var j: number = 0; j <= inferArraySize; j++) {
                    result += segment.getDoubleArrayElem(index, (j + polyw), meta) * power;
                    power = power * t;
                }
                return result;
            }

            private maxErr(precision: number, degree: number): number {
                return precision / Math.pow(2, degree + 0.5);
            }

            public insert(time: number, value: number, timeOrigin: number, raw: memory.chunk.KObjectChunk, index: number, precision: number, metaClass: meta.KMetaClass): boolean {
                if (raw.getDoubleArraySize(index, metaClass) == 0) {
                    this.initial_feed(time, value, raw, index, metaClass);
                    return true;
                }
                if (raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, metaClass) == 1) {
                    raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, (time - timeOrigin), metaClass);
                }
                var timedeg: number = <number>raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEDEG, metaClass);
                var deg: number = <number>raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, metaClass);
                var num: number = <number>raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, metaClass);
                var maxError: number = this.maxErr(precision, deg);
                var normTime: number = (time - timeOrigin) / raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, metaClass);
                if (Math.abs(this.getTime(num, raw, metaClass, index) - time) > DoublePolynomialExtrapolation._TIMERR) {
                    if (timedeg < Math.min(num, DoublePolynomialExtrapolation._maxTimeDegree)) {
                        timedeg++;
                        var ss: number = Math.min(deg * 2, num);
                        var times: Float64Array = new Float64Array(ss + 1);
                        var values: Float64Array = new Float64Array(ss + 1);
                        for (var i: number = 0; i < ss; i++) {
                            times[i] = (i * num / ss);
                            values[i] = this.getTime(<number>times[i], raw, metaClass, index);
                        }
                        times[ss] = num;
                        values[ss] = normTime;
                        var pf: util.maths.PolynomialFit = new util.maths.PolynomialFit(timedeg);
                        pf.fit(times, values);
                        for (var i: number = 0; i < pf.getCoef().length; i++) {
                            raw.setDoubleArrayElem(index, i + DoublePolynomialExtrapolation.TIMEWEIGHT, pf.getCoef()[i], metaClass);
                        }
                        raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEDEG, timedeg, metaClass);
                    } else {
                        return false;
                    }
                }
                if (Math.abs(this.extrapolateValue(raw, metaClass, index, time, timeOrigin) - value) <= maxError) {
                    var nexNumSamples: number = raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, metaClass) + 1;
                    raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, nexNumSamples, metaClass);
                    return true;
                }
                var newMaxDegree: number = Math.min(num, DoublePolynomialExtrapolation._maxDegree);
                if (deg < newMaxDegree) {
                    deg++;
                    var ss: number = Math.min(deg * 2, num);
                    var times: Float64Array = new Float64Array(ss + 1);
                    var values: Float64Array = new Float64Array(ss + 1);
                    for (var i: number = 0; i < ss; i++) {
                        times[i] = this.getTime(i * num / ss, raw, metaClass, index);
                        values[i] = this.internal_extrapolate(times[i], raw, index, metaClass);
                    }
                    times[ss] = normTime;
                    values[ss] = value;
                    var pf: util.maths.PolynomialFit = new util.maths.PolynomialFit(deg);
                    pf.fit(times, values);
                    if (this.tempError(pf.getCoef(), times, values) <= maxError) {
                        var pWeight: number = this.getPolyWeightIndex(raw, metaClass, index);
                        raw.extendDoubleArray(index, (raw.getDoubleArraySize(index, metaClass) + 1), metaClass);
                        for (var i: number = 0; i < pf.getCoef().length; i++) {
                            raw.setDoubleArrayElem(index, i + pWeight, pf.getCoef()[i], metaClass);
                        }
                        raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, deg, metaClass);
                        raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, num + 1, metaClass);
                        return true;
                    }
                }
                return false;
            }

            private tempError(computedWeights: Float64Array, times: Float64Array, values: Float64Array): number {
                var maxErr: number = 0;
                var temp: number;
                for (var i: number = 0; i < times.length; i++) {
                    temp = Math.abs(values[i] - util.maths.PolynomialFit.extrapolate(times[i], computedWeights));
                    if (temp > maxErr) {
                        maxErr = temp;
                    }
                }
                return maxErr;
            }

            private internal_extrapolate(t: number, raw: memory.chunk.KObjectChunk, index: number, metaClass: meta.KMetaClass): number {
                var result: number = 0;
                var power: number = 1;
                var pWeight: number = this.getPolyWeightIndex(raw, metaClass, index);
                if (raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, metaClass) == 0) {
                    return raw.getDoubleArrayElem(index, pWeight, metaClass);
                }
                for (var j: number = 0; j <= raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, metaClass); j++) {
                    result += raw.getDoubleArrayElem(index, (j + pWeight), metaClass) * power;
                    power = power * t;
                }
                return result;
            }

            private initial_feed(time: number, value: number, raw: memory.chunk.KObjectChunk, index: number, metaClass: meta.KMetaClass): void {
                raw.extendDoubleArray(index, DoublePolynomialExtrapolation.TIMEWEIGHT + 2, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEDEG, 0, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.NUMSAMPLES, 1, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.POLYDEG, 0, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, 0, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEWEIGHT, 0, metaClass);
                raw.setDoubleArrayElem(index, DoublePolynomialExtrapolation.TIMEWEIGHT + 1, value, metaClass);
            }

            public mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void {
                var raw: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (raw.getDoubleArraySize(attribute.index(), current.metaClass()) == 0) {
                    raw = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                }
                if (!this.insert(current.now(), this.castNumber(payload), raw.time(), raw, attribute.index(), attribute.precision(), current.metaClass())) {
                    var prevTime: number = this.getLastTimeLong(raw, current.metaClass(), attribute.index()) + raw.time();
                    var val: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), prevTime, raw.time());
                    var newSegment: memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), prevTime, current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                    newSegment.clearDoubleArray(attribute.index(), current.metaClass());
                    this.insert(prevTime, val, prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                    this.insert(current.now(), this.castNumber(payload), prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                }
            }

            private getLastTimeLong(raw: memory.chunk.KObjectChunk, kMetaClass: meta.KMetaClass, index: number): number {
                return <number>(this.getLastTime(raw, kMetaClass, index) * raw.getDoubleArrayElem(index, DoublePolynomialExtrapolation.STEP, kMetaClass));
            }

            private castNumber(payload: any): number {
                return +payload;
            }

            public static instance(): extrapolation.Extrapolation {
                if (DoublePolynomialExtrapolation.INSTANCE == null) {
                    DoublePolynomialExtrapolation.INSTANCE = new extrapolation.impl.DoublePolynomialExtrapolation();
                }
                return DoublePolynomialExtrapolation.INSTANCE;
            }

        }

        export class PolynomialExtrapolation implements extrapolation.Extrapolation {

            private static _maxDegree: number = 20;
            private static DEGREE: number = 0;
            private static NUMSAMPLES: number = 1;
            private static STEP: number = 2;
            private static LASTTIME: number = 3;
            private static WEIGHTS: number = 4;
            private static INSTANCE: extrapolation.impl.PolynomialExtrapolation;
            public extrapolate(current: KObject, attribute: meta.KMetaAttribute, dataManager: memory.manager.internal.KInternalDataManager): any {
                var raw: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (raw != null) {
                    var extrapolatedValue: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), current.now(), raw.time());
                    var attTypeId: number = attribute.attributeTypeId();
                    switch (attTypeId) {
                        case meta.KPrimitiveTypes.CONTINUOUS_ID:
                            return extrapolatedValue;
                        case meta.KPrimitiveTypes.DOUBLE_ID:
                            return extrapolatedValue;
                        default:
                            return null;
                    }
                } else {
                    return null;
                }
            }

            private extrapolateValue(segment: memory.chunk.KObjectChunk, meta: meta.KMetaClass, index: number, time: number, timeOrigin: number): number {
                if (segment.getDoubleArraySize(index, meta) == 0) {
                    return 0.0;
                }
                var result: number = 0;
                var power: number = 1;
                var inferSTEP: number = segment.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, meta);
                if (inferSTEP == 0) {
                    return segment.getDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, meta);
                }
                var t: number = (time - timeOrigin) / inferSTEP;
                var inferArraySize: number = segment.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, meta);
                for (var j: number = 0; j <= inferArraySize; j++) {
                    result += segment.getDoubleArrayElem(index, (j + PolynomialExtrapolation.WEIGHTS), meta) * power;
                    power = power * t;
                }
                return result;
            }

            private maxErr(precision: number, degree: number): number {
                return precision / Math.pow(2, degree + 3);
            }

            public insert(time: number, value: number, timeOrigin: number, raw: memory.chunk.KObjectChunk, index: number, precision: number, metaClass: meta.KMetaClass): boolean {
                if (raw.getDoubleArraySize(index, metaClass) == 0) {
                    this.initial_feed(time, value, raw, index, metaClass);
                    return true;
                }
                if (raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass) == 1) {
                    var timeStep: number = time - timeOrigin;
                    if (timeStep == 0) {
                        raw.setDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, value, metaClass);
                        return true;
                    } else {
                        raw.setDoubleArrayElem(index, PolynomialExtrapolation.STEP, <number>timeStep, metaClass);
                    }
                }
                var deg: number = <number>raw.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, metaClass);
                var num: number = <number>raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass);
                var stp: number = raw.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, metaClass);
                var maxError: number = this.maxErr(precision, deg);
                if (Math.abs(this.extrapolateValue(raw, metaClass, index, time, timeOrigin) - value) <= maxError) {
                    var nexNumSamples: number = raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass) + 1;
                    raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, nexNumSamples, metaClass);
                    raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                    return true;
                }
                var newMaxDegree: number = Math.min(num, PolynomialExtrapolation._maxDegree);
                if (deg < newMaxDegree) {
                    deg++;
                    var ss: number = num * 2;
                    var times: Float64Array = new Float64Array(ss + 1);
                    var values: Float64Array = new Float64Array(ss + 1);
                    var inc: number = 0;
                    if (ss > 1) {
                        inc = raw.getDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, metaClass) / (stp * (ss - 1));
                    }
                    for (var i: number = 0; i < ss; i++) {
                        times[i] = i * inc;
                        values[i] = this.internal_extrapolate(times[i], raw, index, metaClass);
                    }
                    times[ss] = (time - timeOrigin) / stp;
                    values[ss] = value;
                    var pf: util.maths.PolynomialFit = new util.maths.PolynomialFit(deg);
                    pf.fit(times, values);
                    if (this.tempError(pf.getCoef(), times, values) <= maxError) {
                        raw.extendDoubleArray(index, (raw.getDoubleArraySize(index, metaClass) + 1), metaClass);
                        for (var i: number = 0; i < pf.getCoef().length; i++) {
                            raw.setDoubleArrayElem(index, i + PolynomialExtrapolation.WEIGHTS, pf.getCoef()[i], metaClass);
                        }
                        raw.setDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, deg, metaClass);
                        raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, num + 1, metaClass);
                        raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                        return true;
                    }
                }
                return false;
            }

            private tempError(computedWeights: Float64Array, times: Float64Array, values: Float64Array): number {
                var maxErr: number = 0;
                var temp: number;
                for (var i: number = 0; i < times.length; i++) {
                    temp = Math.abs(values[i] - util.maths.PolynomialFit.extrapolate(times[i], computedWeights));
                    if (temp > maxErr) {
                        maxErr = temp;
                    }
                }
                return maxErr;
            }

            private internal_extrapolate(t: number, raw: memory.chunk.KObjectChunk, index: number, metaClass: meta.KMetaClass): number {
                var result: number = 0;
                var power: number = 1;
                if (raw.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, metaClass) == 0) {
                    return raw.getDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, metaClass);
                }
                for (var j: number = 0; j <= raw.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, metaClass); j++) {
                    result += raw.getDoubleArrayElem(index, (j + PolynomialExtrapolation.WEIGHTS), metaClass) * power;
                    power = power * t;
                }
                return result;
            }

            private initial_feed(time: number, value: number, raw: memory.chunk.KObjectChunk, index: number, metaClass: meta.KMetaClass): void {
                raw.extendDoubleArray(index, PolynomialExtrapolation.WEIGHTS + 1, metaClass);
                raw.setDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, 0, metaClass);
                raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, 1, metaClass);
                raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, 0, metaClass);
                raw.setDoubleArrayElem(index, PolynomialExtrapolation.STEP, 0, metaClass);
                raw.setDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, value, metaClass);
            }

            public mutate(current: KObject, attribute: meta.KMetaAttribute, payload: any, dataManager: memory.manager.internal.KInternalDataManager): void {
                var raw: memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                if (raw.getDoubleArraySize(attribute.index(), current.metaClass()) == 0) {
                    raw = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                }
                if (!this.insert(current.now(), this.castNumber(payload), raw.time(), raw, attribute.index(), attribute.precision(), current.metaClass())) {
                    var prevTime: number = <number>raw.getDoubleArrayElem(attribute.index(), PolynomialExtrapolation.LASTTIME, current.metaClass()) + raw.time();
                    var newSegment: memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), prevTime, current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                    var metaElements: meta.KMeta[] = current.metaClass().metaElements();
                    for (var i: number = 0; i < metaElements.length; i++) {
                        if (metaElements[i].metaType().equals(meta.MetaType.ATTRIBUTE)) {
                            var att: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[i];
                            if (att.strategy() == this) {
                                newSegment.clearDoubleArray(att.index(), current.metaClass());
                                if (att.index() != attribute.index()) {
                                    var val: number = this.extrapolateValue(raw, current.metaClass(), att.index(), prevTime, raw.time());
                                    this.insert(prevTime, val, prevTime, newSegment, att.index(), att.precision(), current.metaClass());
                                    var newTime: number = <number>raw.getDoubleArrayElem(att.index(), PolynomialExtrapolation.LASTTIME, current.metaClass()) + raw.time();
                                    if (newTime >= current.now()) {
                                        val = this.extrapolateValue(raw, current.metaClass(), att.index(), newTime, raw.time());
                                        this.insert(newTime, val, prevTime, newSegment, att.index(), att.precision(), current.metaClass());
                                    }
                                }
                            }
                        }
                    }
                    var val: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), prevTime, raw.time());
                    this.insert(prevTime, val, prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                    this.insert(current.now(), this.castNumber(payload), prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                }
            }

            private castNumber(payload: any): number {
                return +payload;
            }

            public static instance(): extrapolation.Extrapolation {
                if (PolynomialExtrapolation.INSTANCE == null) {
                    PolynomialExtrapolation.INSTANCE = new extrapolation.impl.PolynomialExtrapolation();
                }
                return PolynomialExtrapolation.INSTANCE;
            }

        }

    }
}
export namespace format {
    export interface KModelFormat {

        save(model: KObject, cb: KCallback<string>): void;

        load(payload: string, cb: KCallback<any>): void;

    }

    export namespace json {
        export class JsonFormat implements format.KModelFormat {

            public static KEY_META: string = "@class";
            public static KEY_UUID: string = "@uuid";
            private _manager: memory.manager.internal.KInternalDataManager;
            private _universe: number;
            private _time: number;
            private static NULL_PARAM_MSG: string = "one parameter is null";
            constructor(p_universe: number, p_time: number, p_manager: memory.manager.internal.KInternalDataManager) {
                this._manager = p_manager;
                this._universe = p_universe;
                this._time = p_time;
            }

            public save(model: KObject, cb: KCallback<string>): void {
                if (util.Checker.isDefined(model) && util.Checker.isDefined(cb)) {
                    format.json.JsonModelSerializer.serialize(model, cb);
                } else {
                    throw new Error(JsonFormat.NULL_PARAM_MSG);
                }
            }

            public load(payload: string, cb: KCallback<any>): void {
                if (util.Checker.isDefined(payload)) {
                    format.json.JsonModelLoader.load(this._manager, this._universe, this._time, payload, cb);
                } else {
                    throw new Error(JsonFormat.NULL_PARAM_MSG);
                }
            }

        }

        export class JsonModelLoader {

            public static load(manager: memory.manager.internal.KInternalDataManager, universe: number, time: number, payload: string, callback: KCallback<Error>): void {
                if (payload == null) {
                    callback(null);
                } else {
                    var toLoadObj = JSON.parse(payload);
                    var rootElem = [];
                    var mappedKeys: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1,-1,-1,null);
                    for(var i = 0; i < toLoadObj.length; i++) {
                        var elem = toLoadObj[i];
                        var kid = elem[format.json.JsonFormat.KEY_UUID];
                        mappedKeys.put(<number>kid, manager.nextObjectKey());
                    }
                    for(var i = 0; i < toLoadObj.length; i++) {
                        var elemRaw = toLoadObj[i];
                        var elem2 = new memory.chunk.impl.ArrayStringMap<any>(Object.keys(elemRaw).length, KConfig.CACHE_LOAD_FACTOR);
                        for(var ik in elemRaw){ elem2[ik] = elemRaw[ik]; }
                        try {
                            format.json.JsonModelLoader.loadObj(elem2, manager, universe, time, mappedKeys, rootElem);
                        } catch(e){ console.error(e); }
                    }
                    if (callback != null) { callback(null); }
                }
            }

            private static loadObj(p_param: memory.chunk.impl.ArrayStringMap<any>, manager: memory.manager.internal.KInternalDataManager, universe: number, time: number, p_mappedKeys: memory.chunk.KLongLongMap, p_rootElem: KObject[]): void {
                var kid: number = util.PrimitiveHelper.parseLong(p_param.get(format.json.JsonFormat.KEY_UUID).toString());
                var m: string = p_param.get(format.json.JsonFormat.KEY_META).toString();
                var metaClass: meta.KMetaClass = manager.model().metaModel().metaClassByName(m);
                var current: KObject = (<abs.AbstractKModel<any>>manager.model()).createProxy(universe, time, p_mappedKeys.get(kid), metaClass, universe, time);
                manager.initKObject(current);
                var raw: memory.chunk.KObjectChunk = manager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<abs.AbstractKObject>current).previousResolved());
                p_param.each( (metaKey : string, payload_content : any) => {
                    var metaElement: meta.KMeta = metaClass.metaByName(metaKey);
                    if (payload_content != null) {
                        if (metaElement != null && metaElement.metaType().equals(meta.MetaType.ATTRIBUTE)) {
                            var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>metaElement;
                            var metaAttId: number = metaAttribute.attributeTypeId();
                            switch (metaAttId) {
                                case meta.KPrimitiveTypes.CONTINUOUS_ID:
                                    var plainRawSet: string[] = <string[]>p_param.get(metaAttribute.metaName());
                                    var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                                    for (var l: number = 0; l < plainRawSet.length; l++) {
                                        try {
                                            convertedRaw[l] = util.PrimitiveHelper.parseDouble(plainRawSet[l]);
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    raw.setPrimitiveType(metaElement.index(), convertedRaw, current.metaClass());
                                    break;
                                default:
                                    var converted: any = null;
                                    var rawPayload: string = p_param.get(metaElement.metaName()).toString();
                                    switch (metaAttId) {
                                        case meta.KPrimitiveTypes.STRING_ID:
                                            converted = format.json.JsonString.unescape(rawPayload);
                                            break;
                                        case meta.KPrimitiveTypes.LONG_ID:
                                            converted = util.PrimitiveHelper.parseLong(rawPayload);
                                            break;
                                        case meta.KPrimitiveTypes.INT_ID:
                                            converted = util.PrimitiveHelper.parseInt(rawPayload);
                                            break;
                                        case meta.KPrimitiveTypes.BOOL_ID:
                                            converted = util.PrimitiveHelper.parseBoolean(rawPayload);
                                            break;
                                        case meta.KPrimitiveTypes.DOUBLE_ID:
                                            converted = util.PrimitiveHelper.parseDouble(rawPayload);
                                            break;
                                    }
                                    raw.setPrimitiveType(metaElement.index(), converted, current.metaClass());
                                    break;
                            }
                        } else {
                            if (metaElement != null && metaElement.metaType() == meta.MetaType.RELATION) {
                                try {
                                    raw.setPrimitiveType(metaElement.index(), format.json.JsonModelLoader.transposeArr(<java.util.ArrayList<string>>payload_content, p_mappedKeys), current.metaClass());
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                            }
                        }
                    }
                });
            }

            private static transposeArr(plainRawSet: java.util.ArrayList<string>, p_mappedKeys: memory.chunk.KLongLongMap): Float64Array {
                if (plainRawSet == null) {
                    return null;
                }
                var sizeOfL: number = format.json.JsonModelLoader.sizeOfList(plainRawSet);
                var convertedRaw: Float64Array = new Float64Array(sizeOfL);
                for (var l: number = 0; l < sizeOfL; l++) {
                    try {
                        var converted: number = util.PrimitiveHelper.parseLong(format.json.JsonModelLoader.getString(plainRawSet, l));
                        if (p_mappedKeys.contains(converted)) {
                            converted = p_mappedKeys.get(converted);
                        }
                        convertedRaw[l] = converted;
                    } catch ($ex$) {
                        if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);;
                        } else {
                            throw $ex$;
                        }
                    }
                }
                return convertedRaw;
            }

            private static sizeOfList(plainRawSet: java.util.ArrayList<string>): number {
                if(plainRawSet != null && plainRawSet != undefined){
                    if(plainRawSet.size != undefined){
                        return plainRawSet.size();
                    } else {
                        return plainRawSet.length;
                    }
                }
            }

            private static getString(plainRawSet: java.util.ArrayList<string>, l: number): string {
                if(plainRawSet.get != undefined){
                    return plainRawSet.get(l);
                } else {
                    return plainRawSet[l];
                }
            }

        }

        export class JsonModelSerializer {

            public static serialize(model: KObject, callback: KCallback<string>): void {
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                builder.append("[\n");
                format.json.JsonModelSerializer.printJSON(model, builder);
                model.visit( (elem : KObject) => {
                    var isRoot2: boolean = false;
                    builder.append(",\n");
                    try {
                        format.json.JsonModelSerializer.printJSON(elem, builder);
                    } catch ($ex$) {
                        if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);;
                            builder.append("{}");
                        } else {
                            throw $ex$;
                        }
                    }
                    return traversal.visitor.KVisitResult.CONTINUE;
                },  (throwable : Error) => {
                    builder.append("\n]\n");
                    callback(builder.toString());
                });
            }

            public static printJSON(elem: KObject, builder: java.lang.StringBuilder): void {
                if (elem != null) {
                    var raw: memory.chunk.KObjectChunk = (<abs.AbstractKObject>elem)._manager.closestChunk(elem.universe(), elem.now(), elem.uuid(), elem.metaClass(), (<abs.AbstractKObject>elem).previousResolved());
                    if (raw != null) {
                        builder.append(format.json.JsonRaw.encode(raw, elem.uuid(), elem.metaClass()));
                    }
                }
            }

        }

        export class JsonObjectReader {

            private readObject:any;
            public parseObject(payload:string):void {
                this.readObject = JSON.parse(payload);
            }
            public get(name:string):any {
                return this.readObject[name];
            }
            public getAsStringArray(name:string):string[] {
                return <string[]> this.readObject[name];
            }
            public keys():string[] {
                var keysArr = []
                for (var key in this.readObject) {
                    keysArr.push(key);
                }
                return keysArr;
            }
        }

        export class JsonRaw {

            public static encode(raw: memory.chunk.KObjectChunk, uuid: number, p_metaClass: meta.KMetaClass): string {
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                builder.append("{\"@class\":\"");
                builder.append(p_metaClass.metaName());
                builder.append("\",\"@uuid\":");
                builder.append(uuid);
                var metaElements: meta.KMeta[] = p_metaClass.metaElements();
                for (var i: number = 0; i < metaElements.length; i++) {
                    var loopMeta: meta.KMeta = metaElements[i];
                    if (loopMeta != null && loopMeta.metaType().equals(meta.MetaType.ATTRIBUTE)) {
                        var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>loopMeta;
                        var metaAttId: number = metaAttribute.attributeTypeId();
                        if (metaAttId == meta.KPrimitiveTypes.CONTINUOUS_ID) {
                            var inferAtt: Float64Array = raw.getDoubleArray(loopMeta.index(), p_metaClass);
                            if (inferAtt != null) {
                                builder.append(",\"");
                                builder.append(loopMeta.metaName());
                                builder.append("\":[");
                                for (var j: number = 0; j < inferAtt.length; j++) {
                                    if (j != 0) {
                                        builder.append(",");
                                    }
                                    builder.append(inferAtt[j]);
                                }
                                builder.append("]");
                            }
                        } else {
                            var payload_res: any = raw.getPrimitiveType(loopMeta.index(), p_metaClass);
                            if (payload_res != null) {
                                builder.append(",\"");
                                builder.append(loopMeta.metaName());
                                builder.append("\":\"");
                                if (metaAttId == meta.KPrimitiveTypes.STRING_ID) {
                                    builder.append(format.json.JsonString.encode(payload_res.toString()));
                                } else {
                                    builder.append(payload_res.toString());
                                }
                                builder.append("\"");
                            }
                        }
                    } else {
                        if (loopMeta != null && loopMeta.metaType().equals(meta.MetaType.RELATION)) {
                            var refPayload: Float64Array = raw.getLongArray(loopMeta.index(), p_metaClass);
                            if (refPayload != null) {
                                builder.append(",\"");
                                builder.append(loopMeta.metaName());
                                builder.append("\":[");
                                for (var j: number = 0; j < refPayload.length; j++) {
                                    if (j != 0) {
                                        builder.append(",");
                                    }
                                    builder.append(refPayload[j]);
                                }
                                builder.append("]");
                            }
                        }
                    }
                }
                builder.append("}");
                return builder.toString();
            }

        }

        export class JsonString {

            private static ESCAPE_CHAR: string = '\\';
            public static encodeBuffer(buffer: java.lang.StringBuilder, chain: string): void {
                if (chain == null) {
                    return;
                }
                var i: number = 0;
                while (i < chain.length){
                    var ch: string = chain.charAt(i);
                    if (ch == '"') {
                        buffer.append(JsonString.ESCAPE_CHAR);
                        buffer.append('"');
                    } else {
                        if (ch == JsonString.ESCAPE_CHAR) {
                            buffer.append(JsonString.ESCAPE_CHAR);
                            buffer.append(JsonString.ESCAPE_CHAR);
                        } else {
                            if (ch == '\n') {
                                buffer.append(JsonString.ESCAPE_CHAR);
                                buffer.append('n');
                            } else {
                                if (ch == '\r') {
                                    buffer.append(JsonString.ESCAPE_CHAR);
                                    buffer.append('r');
                                } else {
                                    if (ch == '\t') {
                                        buffer.append(JsonString.ESCAPE_CHAR);
                                        buffer.append('t');
                                    } else {
                                        if (ch == '\u2028') {
                                            buffer.append(JsonString.ESCAPE_CHAR);
                                            buffer.append('u');
                                            buffer.append('2');
                                            buffer.append('0');
                                            buffer.append('2');
                                            buffer.append('8');
                                        } else {
                                            if (ch == '\u2029') {
                                                buffer.append(JsonString.ESCAPE_CHAR);
                                                buffer.append('u');
                                                buffer.append('2');
                                                buffer.append('0');
                                                buffer.append('2');
                                                buffer.append('9');
                                            } else {
                                                buffer.append(ch);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    i = i + 1;
                }
            }

            public static encode(p_chain: string): string {
                var sb: java.lang.StringBuilder = new java.lang.StringBuilder();
                format.json.JsonString.encodeBuffer(sb, p_chain);
                return sb.toString();
            }

            public static unescape(p_src: string): string {
                if (p_src == null) {
                    return null;
                }
                if (p_src.length == 0) {
                    return p_src;
                }
                var builder: java.lang.StringBuilder = null;
                var i: number = 0;
                while (i < p_src.length){
                    var current: string = p_src.charAt(i);
                    if (current == JsonString.ESCAPE_CHAR) {
                        if (builder == null) {
                            builder = new java.lang.StringBuilder();
                            builder.append(p_src.substring(0, i));
                        }
                        i++;
                        var current2: string = p_src.charAt(i);
                        switch (current2) {
                            case '"':
                                builder.append('\"');
                                break;
                            case '\\':
                                builder.append(current2);
                                break;
                            case '/':
                                builder.append(current2);
                                break;
                            case 'b':
                                builder.append('\b');
                                break;
                            case 'f':
                                builder.append('\f');
                                break;
                            case 'n':
                                builder.append('\n');
                                break;
                            case 'r':
                                builder.append('\r');
                                break;
                            case 't':
                                builder.append('\t');
                                break;
                            case '{':
                                builder.append("\\{");
                                break;
                            case '}':
                                builder.append("\\}");
                                break;
                            case '[':
                                builder.append("\\[");
                                break;
                            case ']':
                                builder.append("\\]");
                                break;
                            case ',':
                                builder.append("\\,");
                                break;
                        }
                    } else {
                        if (builder != null) {
                            builder = builder.append(current);
                        }
                    }
                    i++;
                }
                if (builder != null) {
                    return builder.toString();
                } else {
                    return p_src;
                }
            }

        }

    }
    export namespace xmi {
    }
}
export namespace infer {
    export interface KInferAlg {

        train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void;

        infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D;

    }

    export class KInferAlgFactory {

        public static build(name: string): infer.KInferAlg {
            if (util.PrimitiveHelper.equals(name, "BinaryPerceptron")) {
                return new infer.impl.BinaryPerceptronAlg();
            } else {
                if (util.PrimitiveHelper.equals(name, "LinearRegression")) {
                    return new infer.impl.LinearRegressionAlg();
                } else {
                    if (util.PrimitiveHelper.equals(name, "KMeanCluster")) {
                        return new infer.impl.KMeanClusterAlg();
                    } else {
                        if (util.PrimitiveHelper.equals(name, "GaussianProfiler")) {
                            return new infer.impl.GaussianProfiler();
                        } else {
                            if (util.PrimitiveHelper.equals(name, "GaussianClassifier")) {
                                return new infer.impl.GaussianClassifierAlg();
                            } else {
                                if (util.PrimitiveHelper.equals(name, "GaussianAnomalyDetection")) {
                                    return new infer.impl.GaussianAnomalyDetectionAlg();
                                } else {
                                    if (util.PrimitiveHelper.equals(name, "Winnow")) {
                                        return new infer.impl.WinnowAlg();
                                    } else {
                                        if (util.PrimitiveHelper.equals(name, "EmptyInfer")) {
                                            return new infer.impl.EmptyInfer();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return null;
        }

    }

    export namespace impl {
        export class BinaryPerceptronAlg implements infer.KInferAlg {

            private iterations: number = 5;
            private alpha: number = 1;
            private rand: java.util.Random = new java.util.Random();
            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length + 1;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble() * 0.1, origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var iter: number = 0; iter < this.iterations; iter++) {
                    for (var row: number = 0; row < trainingSet.rows(); row++) {
                        var h: number = this.sigmoid(trainingSet, row, state);
                        var error: number = this.alpha * (expectedResultSet.get(row, 0) - h);
                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                            state.add(j, error * trainingSet.get(row, j));
                        }
                        state.add(origin.metaClass().inputs().length, error);
                    }
                }
            }

            private addUp(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.impl.Array1D): number {
                var res: number = 0;
                for (var i: number = 0; i < features.columns(); i++) {
                    res = res + state.get(i) * features.get(row, i);
                }
                res = res + state.get(features.columns());
                return res;
            }

            private sigmoid(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.impl.Array1D): number {
                return 1 / (1 + Math.exp(-this.addUp(features, row, state)));
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length + 1;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var inst: number = 0; inst < features.rows(); inst++) {
                    if (this.sigmoid(features, inst, state) >= 0.5) {
                        result.set(inst, 0, 1.0);
                    } else {
                        result.set(inst, 0, 0);
                    }
                }
                return result;
            }

        }

        export class EmptyInfer implements infer.KInferAlg {

            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void {
            }

            public infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var res: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), currentInferObject.metaClass().outputs().length);
                for (var i: number = 0; i < res.rows() * res.columns(); i++) {
                    res.setAtIndex(i, 42);
                }
                return res;
            }

        }

        export class GaussianAnomalyDetectionAlg implements infer.KInferAlg {

            private _alpha: number = 0.5;
            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            public getProba(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): number {
                var prob: number = 0;
                var avg: Float64Array = this.getAvg(state, meta);
                var variance: Float64Array = this.getVariance(state, avg, meta);
                prob = util.maths.Distribution.gaussianArray(features, row, avg, variance);
                return prob;
            }

            public getAvg(state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): Float64Array {
                var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(meta.origin().inputs().length * GaussianAnomalyDetectionAlg.NUMOFFIELDS);
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        avg[i] = state.get(GaussianAnomalyDetectionAlg.NUMOFFIELDS * i + GaussianAnomalyDetectionAlg.SUM) / total;
                    }
                }
                return avg;
            }

            public getVariance(state: util.maths.structure.KArray1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array {
                var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(meta.origin().inputs().length * GaussianAnomalyDetectionAlg.NUMOFFIELDS);
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        variances[i] = state.get(GaussianAnomalyDetectionAlg.NUMOFFIELDS * i + GaussianAnomalyDetectionAlg.SUMSQUARE) / total - avg[i] * avg[i];
                    }
                }
                return variances;
            }

            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var alpha: number = <number>origin.getByName("alpha");
                if (alpha == null) {
                    alpha = this._alpha;
                }
                var length: number = origin.metaClass().inputs().length;
                var size: number = (length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 2);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var i: number = 0; i < trainingSet.rows(); i++) {
                    var output: number = <number>expectedResultSet.get(i, 0);
                    if (output == 0) {
                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                            if (state.get(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS) == 0) {
                                state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MIN, trainingSet.get(i, j));
                                state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MAX, trainingSet.get(i, j));
                                state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.SUM, trainingSet.get(i, j));
                                state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.SUMSQUARE, trainingSet.get(i, j) * trainingSet.get(i, j));
                            } else {
                                if (trainingSet.get(i, j) < state.get(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MIN)) {
                                    state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MIN, trainingSet.get(i, j));
                                }
                                if (trainingSet.get(i, j) > state.get(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MAX)) {
                                    state.set(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.MAX, trainingSet.get(i, j));
                                }
                                state.add(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.SUM, trainingSet.get(i, j));
                                state.add(j * GaussianAnomalyDetectionAlg.NUMOFFIELDS + GaussianAnomalyDetectionAlg.SUMSQUARE, trainingSet.get(i, j) * trainingSet.get(i, j));
                            }
                        }
                        state.add(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS, 1);
                        var newEpsilon: number = this.getProba(trainingSet, i, state, origin.metaClass().dependencies());
                        var epsilon: number = state.get(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
                        if (newEpsilon < epsilon) {
                            state.set(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1, epsilon + alpha * (newEpsilon - epsilon));
                        }
                    } else {
                        var newEpsilon: number = this.getProba(trainingSet, i, state, origin.metaClass().dependencies());
                        var epsilon: number = state.get(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
                        if (newEpsilon > epsilon) {
                            state.set(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1, epsilon + alpha * (newEpsilon - epsilon));
                        }
                    }
                }
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var length: number = origin.metaClass().inputs().length;
                var size: number = (length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 2);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                var epsilon: number = state.get(length * GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
                for (var i: number = 0; i < features.rows(); i++) {
                    if (this.getProba(features, i, state, origin.metaClass().dependencies()) >= epsilon) {
                        result.set(i, 0, 0);
                    } else {
                        result.set(i, 0, 1);
                    }
                }
                return result;
            }

        }

        export class GaussianClassifierAlg implements infer.KInferAlg {

            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            private getIndex(input: number, output: number, field: number, meta: meta.KMetaDependencies): number {
                return output * (GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianClassifierAlg.NUMOFFIELDS * input + field;
            }

            private getCounter(output: number, meta: meta.KMetaDependencies): number {
                return output * (GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length;
            }

            public getAvg(output: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): Float64Array {
                var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(this.getCounter(output, meta));
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        avg[i] = state.get(this.getIndex(i, output, GaussianClassifierAlg.SUM, meta)) / total;
                    }
                }
                return avg;
            }

            public getVariance(output: number, state: util.maths.structure.KArray1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array {
                var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(this.getCounter(output, meta));
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        variances[i] = state.get(this.getIndex(i, output, GaussianClassifierAlg.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                    }
                }
                return variances;
            }

            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
                var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * GaussianClassifierAlg.NUMOFFIELDS + 1);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var i: number = 0; i < trainingSet.rows(); i++) {
                    var output: number = <number>expectedResultSet.get(i, 0);
                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                        if (state.get(this.getCounter(output, origin.metaClass().dependencies())) == 0) {
                            state.set(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, output, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, output, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                        } else {
                            if (trainingSet.get(i, j) < state.get(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                                state.set(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            }
                            if (trainingSet.get(i, j) > state.get(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                                state.set(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            }
                            state.add(this.getIndex(j, output, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.add(this.getIndex(j, output, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                        }
                        if (state.get(this.getCounter(maxOutput, origin.metaClass().dependencies())) == 0) {
                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                        } else {
                            if (trainingSet.get(i, j) < state.get(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                                state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            }
                            if (trainingSet.get(i, j) > state.get(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                                state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            }
                            state.add(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                            state.add(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                        }
                    }
                    state.add(this.getCounter(output, origin.metaClass().dependencies()), 1);
                    state.add(this.getCounter(maxOutput, origin.metaClass().dependencies()), 1);
                }
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
                var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * GaussianClassifierAlg.NUMOFFIELDS + 1);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.KArray1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var j: number = 0; j < features.rows(); j++) {
                    var maxprob: number = 0;
                    var prob: number = 0;
                    for (var output: number = 0; output < maxOutput; output++) {
                        prob = this.getProba(features, j, output, state, origin.metaClass().dependencies());
                        if (prob > maxprob) {
                            maxprob = prob;
                            result.set(j, 0, output);
                        }
                    }
                }
                return result;
            }

            public getProba(features: util.maths.structure.KArray2D, row: number, output: number, state: util.maths.structure.KArray1D, meta: meta.KMetaDependencies): number {
                var prob: number = 0;
                var avg: Float64Array = this.getAvg(output, state, meta);
                var variance: Float64Array = this.getVariance(output, state, avg, meta);
                prob = util.maths.Distribution.gaussianArray(features, row, avg, variance);
                return prob;
            }

            public getAllProba(features: Float64Array, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies, maxOutput: number): Float64Array {
                var results: Float64Array = new Float64Array(maxOutput);
                for (var i: number = 0; i < maxOutput; i++) {
                    var avg: Float64Array = this.getAvg(i, state, meta);
                    var variance: Float64Array = this.getVariance(i, state, avg, meta);
                    results[i] = util.maths.Distribution.gaussian(features, avg, variance);
                }
                return results;
            }

        }

        export class GaussianProfiler implements infer.KInferAlg {

            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            public maxTimeSlots: number = 24;
            private getIndex(input: number, output: number, field: number, meta: meta.KMetaDependencies): number {
                return output * (GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1) + 1) + GaussianProfiler.NUMOFFIELDS * input + field;
            }

            private getCounter(output: number, meta: meta.KMetaDependencies): number {
                return output * (GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1) + 1) + GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1);
            }

            public getAvg(output: number, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies): Float64Array {
                var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(this.getCounter(output, meta));
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        avg[i] = state.get(this.getIndex(i, output, GaussianProfiler.SUM, meta)) / total;
                    }
                }
                return avg;
            }

            public getVariance(output: number, state: util.maths.structure.impl.Array1D, avg: Float64Array, meta: meta.KMetaDependencies): Float64Array {
                var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
                var total: number = state.get(this.getCounter(output, meta));
                if (total != 0) {
                    for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                        variances[i] = state.get(this.getIndex(i, output, GaussianProfiler.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                    }
                }
                return variances;
            }

            public train(trainingSet: util.maths.structure.KArray2D, expectedResult: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dep: meta.KMetaDependencies = origin.metaClass().dependencies();
                var dependenciesIndex: number = dep.index();
                var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * GaussianProfiler.NUMOFFIELDS + 1);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(dep.index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, dep.index(), ks, origin.metaClass());
                for (var i: number = 0; i < trainingSet.rows(); i++) {
                    var output: number = <number>trainingSet.get(i, 0);
                    for (var j: number = 1; j < origin.metaClass().inputs().length; j++) {
                        if (state.get(this.getCounter(output, dep)) == 0) {
                            state.set(this.getIndex(j - 1, output, GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, output, GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, output, GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, output, GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                        } else {
                            if (trainingSet.get(i, j) < state.get(this.getIndex(j - 1, output, GaussianProfiler.MIN, dep))) {
                                state.set(this.getIndex(j - 1, output, GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                            }
                            if (trainingSet.get(i, j) > state.get(this.getIndex(j - 1, output, GaussianProfiler.MAX, dep))) {
                                state.set(this.getIndex(j - 1, output, GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                            }
                            state.add(this.getIndex(j - 1, output, GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                            state.add(this.getIndex(j - 1, output, GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                        }
                        if (state.get(this.getCounter(this.maxTimeSlots, dep)) == 0) {
                            state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                            state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                        } else {
                            if (trainingSet.get(i, j) < state.get(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MIN, dep))) {
                                state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                            }
                            if (trainingSet.get(i, j) > state.get(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MAX, dep))) {
                                state.set(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                            }
                            state.add(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                            state.add(this.getIndex(j - 1, this.maxTimeSlots, GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                        }
                    }
                    state.add(this.getCounter(output, dep), 1);
                    state.add(this.getCounter(this.maxTimeSlots, dep), 1);
                }
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dep: meta.KMetaDependencies = origin.metaClass().dependencies();
                var dependenciesIndex: number = dep.index();
                var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * GaussianProfiler.NUMOFFIELDS + 1);
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, dep.index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var j: number = 0; j < features.rows(); j++) {
                    var output: number = <number>features.get(j, 0);
                    var values: Float64Array = new Float64Array(features.columns() - 1);
                    for (var i: number = 0; i < features.columns() - 1; i++) {
                        values[i] = features.get(j, i + 1);
                    }
                    if (values[0] >= 0) {
                        result.set(j, 0, this.getProba(values, output, state, dep));
                    } else {
                        if (values[0] == -1) {
                            result.set(j, 0, this.getAvg(output, state, dep)[0]);
                        } else {
                            if (values[0] == -2) {
                                result.set(j, 0, state.get(this.getIndex(0, output, GaussianProfiler.MIN, dep)));
                            } else {
                                if (values[0] == -3) {
                                    result.set(j, 0, state.get(this.getIndex(0, output, GaussianProfiler.MAX, dep)));
                                }
                            }
                        }
                    }
                }
                return result;
            }

            public getProba(features: Float64Array, output: number, state: util.maths.structure.impl.Array1D, meta: meta.KMetaDependencies): number {
                var prob: number = 0;
                var avg: Float64Array = this.getAvg(output, state, meta);
                var variance: Float64Array = this.getVariance(output, state, avg, meta);
                prob = util.maths.Distribution.gaussian(features, avg, variance);
                return prob;
            }

        }

        export class KMeanClusterAlg implements infer.KInferAlg {

            private k: number = 3;
            private iterations: number = 100;
            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                if (trainingSet.rows() < this.k) {
                    throw new Error("training setPrimitiveType not enough");
                }
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = this.k * origin.metaClass().inputs().length;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < this.k; i++) {
                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                            ks.setDoubleArrayElem(dependenciesIndex, j + i * origin.metaClass().inputs().length, trainingSet.get(i, j), origin.metaClass());
                        }
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var iter: number = 0; iter < this.iterations; iter++) {
                    var temporalClassification: number;
                    var centroids: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(this.k, origin.metaClass().inputs().length);
                    var counters: Int32Array = new Int32Array(this.k);
                    for (var i: number = 0; i < trainingSet.rows(); i++) {
                        temporalClassification = this.classify(trainingSet, i, state);
                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                            centroids.add(temporalClassification, j, trainingSet.get(i, j));
                        }
                        counters[temporalClassification]++;
                    }
                    for (var i: number = 0; i < this.k; i++) {
                        if (counters[i] != 0) {
                            for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                state.set(j + i * origin.metaClass().inputs().length, centroids.get(i, j) / counters[i]);
                            }
                        } else {
                            var rand: java.util.Random = new java.util.Random();
                            var pos: number = rand.nextInt(trainingSet.rows());
                            for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                state.set(j + i * origin.metaClass().inputs().length, trainingSet.get(pos, j));
                            }
                        }
                    }
                }
            }

            private classify(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.impl.Array1D): number {
                var maxdistance: number = -1;
                var classNum: number = -1;
                for (var i: number = 0; i < this.k; i++) {
                    var currentdist: number = 0;
                    for (var j: number = 0; j < features.columns(); j++) {
                        currentdist += (features.get(row, j) - state.get(i * features.columns() + j)) * (features.get(row, j) - state.get(i * features.columns() + j));
                    }
                    if (maxdistance < 0) {
                        maxdistance = currentdist;
                        classNum = i;
                    } else {
                        if (currentdist < maxdistance) {
                            maxdistance = currentdist;
                            classNum = i;
                        }
                    }
                }
                return classNum;
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = this.k * origin.metaClass().inputs().length;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var inst: number = 0; inst < features.rows(); inst++) {
                    result.set(inst, 0, this.classify(features, inst, state));
                }
                return result;
            }

        }

        export class LinearRegressionAlg implements infer.KInferAlg {

            private alpha: number = 0.005;
            private gamma: number = 0.000;
            private iterations: number = 10;
            private static rand: java.util.Random = new java.util.Random();
            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length + 1;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, LinearRegressionAlg.rand.nextDouble(), origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var i: number = 0; i < this.iterations; i++) {
                    for (var row: number = 0; row < trainingSet.rows(); row++) {
                        var h: number = this.estimate(trainingSet, row, state);
                        var error: number = -this.alpha * (h - expectedResultSet.get(row, 0));
                        for (var feature: number = 0; feature < origin.metaClass().inputs().length; feature++) {
                            state.set(feature, state.get(feature) * (1 - this.alpha * this.gamma) + error * trainingSet.get(row, feature));
                        }
                        state.add(origin.metaClass().inputs().length, error);
                    }
                }
            }

            private estimate(training: util.maths.structure.KArray2D, row: number, state: util.maths.structure.impl.Array1D): number {
                var result: number = 0;
                for (var i: number = 0; i < training.columns(); i++) {
                    result = result + training.get(row, i) * state.get(i);
                }
                result = result + state.get(training.columns());
                return result;
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length + 1;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var results: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var i: number = 0; i < features.rows(); i++) {
                    results.set(i, 0, this.estimate(features, i, state));
                }
                return results;
            }

        }

        export class RecommendationAlg implements infer.KInferAlg {

            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): void {
            }

            public infer(features: util.maths.structure.KArray2D, currentInferObject: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                return new util.maths.structure.impl.NativeArray2D(1, 1);
            }

        }

        export class StatInferAlg implements infer.KInferAlg {

            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQuare: number = 3;
            private static NUMOFFIELDS: number = 4;
            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(dependenciesIndex, StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1, origin.metaClass());
                    for (var i: number = 0; i < StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(StatInferAlg.NUMOFFIELDS * trainingSet.columns() + 1, 0, dependenciesIndex, ks, origin.metaClass());
                for (var i: number = 0; i < trainingSet.rows(); i++) {
                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                        if (state.get(StatInferAlg.NUMOFFIELDS * trainingSet.columns()) == 0) {
                            state.set(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            state.set(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            state.set(StatInferAlg.SUM + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            state.set(StatInferAlg.SUMSQuare + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                        } else {
                            if (trainingSet.get(i, j) < state.get(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS)) {
                                state.set(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            }
                            if (trainingSet.get(i, j) > state.get(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS)) {
                                state.set(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            }
                            state.add(StatInferAlg.SUM + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                            state.add(StatInferAlg.SUMSQuare + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                        }
                    }
                    state.add(StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length, 1);
                }
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<abs.AbstractKObject>origin).previousResolved());
                var tempres: Float64Array = this.getAvgAll(ks, origin.metaClass().dependencies());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(1, tempres.length);
                for (var i: number = 0; i < tempres.length; i++) {
                    result.set(0, i, tempres[i]);
                }
                return result;
            }

            public getAvgAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array {
                var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                    result[i] = this.getAvg(i, ks, meta);
                }
                return result;
            }

            public getMinAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array {
                var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                    result[i] = this.getMin(i, ks, meta);
                }
                return result;
            }

            public getMaxAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): Float64Array {
                var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                    result[i] = this.getMax(i, ks, meta);
                }
                return result;
            }

            public getVarianceAll(ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies, avgs: Float64Array): Float64Array {
                var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                    result[i] = this.getVariance(i, ks, meta, avgs[i]);
                }
                return result;
            }

            public getAvg(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number {
                if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                    return 0;
                }
                var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                if (count == 0) {
                    return 0;
                }
                return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.SUM, meta.origin()) / count;
            }

            public getMin(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number {
                if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                    return 0;
                }
                var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                if (count == 0) {
                    return 0;
                }
                return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.MIN, meta.origin());
            }

            public getMax(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies): number {
                if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                    return 0;
                }
                var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                if (count == 0) {
                    return 0;
                }
                return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.MAX, meta.origin());
            }

            public getVariance(featureNum: number, ks: memory.chunk.KObjectChunk, meta: meta.KMetaDependencies, avg: number): number {
                if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                    return 0;
                }
                var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                if (count == 0) {
                    return 0;
                }
                return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.SUMSQuare, meta.origin()) / count - avg * avg;
            }

        }

        export class WinnowAlg implements infer.KInferAlg {

            private alpha: number = 2;
            private beta: number = 2;
            private iterations: number = 1;
            private rand: java.util.Random = new java.util.Random();
            public train(trainingSet: util.maths.structure.KArray2D, expectedResultSet: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): void {
                var ks: memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<abs.AbstractKObject>origin).previousResolved()));
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                    for (var i: number = 0; i < size; i++) {
                        ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble(), origin.metaClass());
                    }
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                for (var iter: number = 0; iter < this.iterations; iter++) {
                    for (var inst: number = 0; inst < trainingSet.rows(); inst++) {
                        if (this.calculate(trainingSet, inst, state) == expectedResultSet.get(inst, 0)) {
                            continue;
                        }
                        if (expectedResultSet.get(inst, 0) == 0) {
                            for (var i: number = 0; i < size; i++) {
                                state.set(i, state.get(i) / this.beta);
                            }
                        } else {
                            for (var i: number = 0; i < size; i++) {
                                state.set(i, state.get(i) * this.alpha);
                            }
                        }
                    }
                }
            }

            private calculate(features: util.maths.structure.KArray2D, row: number, state: util.maths.structure.impl.Array1D): number {
                var result: number = 0;
                for (var i: number = 0; i < features.columns(); i++) {
                    result += state.get(i) * features.get(row, i);
                }
                if (result >= features.columns()) {
                    return 1.0;
                } else {
                    return 0.0;
                }
            }

            public infer(features: util.maths.structure.KArray2D, origin: KObject, manager: memory.manager.internal.KInternalDataManager): util.maths.structure.KArray2D {
                var ks: memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<abs.AbstractKObject>origin).previousResolved()));
                var dependenciesIndex: number = origin.metaClass().dependencies().index();
                var size: number = origin.metaClass().inputs().length;
                if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                    return null;
                }
                var state: util.maths.structure.impl.Array1D = new util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(features.rows(), 1);
                for (var inst: number = 0; inst < features.rows(); inst++) {
                    result.set(inst, 0, this.calculate(features, inst, state));
                }
                return result;
            }

        }

    }
}
export namespace memory {
    export interface KChunk {

        serialize(metaModel: meta.KMetaModel): string;

        init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void;

        counter(): number;

        inc(): number;

        dec(): number;

        free(metaModel: meta.KMetaModel): void;

        type(): number;

        space(): memory.space.KChunkSpace;

        getFlags(): number;

        setFlags(bitsToEnable: number, bitsToDisable: number): void;

        universe(): number;

        time(): number;

        obj(): number;

        dependencies(): Float64Array;

        addDependency(universe: number, time: number, uuid: number): void;

    }

    export class KChunkFlags {

        public static DIRTY_BIT_INDEX: number = 0;
        public static DIRTY_BIT: number = 1 << KChunkFlags.DIRTY_BIT_INDEX;
        public static REMOVED_BIT_INDEX: number = 1;
        public static REMOVED_BIT: number = 1 << KChunkFlags.REMOVED_BIT_INDEX;
    }

    export interface KOffHeapChunk extends memory.KChunk {

        memoryAddress(): number;

        setMemoryAddress(address: number): void;

    }

    export namespace chunk {
        export interface KIntMap<V> {

            contains(key: number): boolean;

            get(key: number): V;

            put(key: number, value: V): void;

            each(callback: memory.chunk.KIntMapCallBack<V>): void;

        }

        export interface KIntMapCallBack<V> {

            (key: number, value: V): void;

        }

        export interface KLongLongMap extends memory.KChunk {

            metaClassIndex(): number;

            contains(key: number): boolean;

            get(key: number): number;

            put(key: number, value: number): void;

            remove(key: number): void;

            each(callback: memory.chunk.KLongLongMapCallBack<any>): void;

            size(): number;

            clear(): void;

        }

        export interface KLongLongMapCallBack<V> {

            (key: number, value: number): void;

        }

        export interface KLongLongTree extends memory.chunk.KTree {

            insert(key: number, value: number): void;

            previousOrEqualValue(key: number): number;

            lookupValue(key: number): number;

        }

        export interface KLongMap<V> {

            contains(key: number): boolean;

            get(key: number): V;

            put(key: number, value: V): void;

            each(callback: memory.chunk.KLongMapCallBack<V>): void;

            size(): number;

            clear(): void;

        }

        export interface KLongMapCallBack<V> {

            (key: number, value: V): void;

        }

        export interface KLongTree extends memory.chunk.KTree {

            insertKey(key: number): void;

            previousOrEqual(key: number): number;

            lookup(key: number): number;

            range(startKey: number, endKey: number, walker: memory.chunk.KTreeWalker): void;

        }

        export interface KObjectChunk extends memory.KChunk {

            clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk;

            metaClassIndex(): number;

            toJSON(metaModel: meta.KMetaModel): string;

            setPrimitiveType(index: number, content: any, metaClass: meta.KMetaClass): void;

            getPrimitiveType(index: number, metaClass: meta.KMetaClass): any;

            getLongArray(index: number, metaClass: meta.KMetaClass): Float64Array;

            getLongArraySize(index: number, metaClass: meta.KMetaClass): number;

            getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number;

            addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean;

            removeLongToArray(index: number, previousRef: number, metaClass: meta.KMetaClass): boolean;

            clearLongArray(index: number, metaClass: meta.KMetaClass): void;

            getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array;

            getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number;

            getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number;

            setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void;

            extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void;

            clearDoubleArray(index: number, metaClass: meta.KMetaClass): void;

        }

        export interface KObjectIndexChunk extends memory.chunk.KObjectChunk, memory.chunk.KStringLongMap {

        }

        export interface KStringLongMap {

            contains(key: string): boolean;

            get(key: string): number;

            put(key: string, value: number): void;

            each(callback: memory.chunk.KStringLongMapCallBack): void;

            size(): number;

            clear(): void;

            remove(key: string): void;

        }

        export interface KStringLongMapCallBack {

            (key: string, value: number): void;

        }

        export interface KStringMap<V> {

            contains(key: string): boolean;

            get(key: string): V;

            put(key: string, value: V): void;

            each(callback: memory.chunk.KStringMapCallBack<V>): void;

            size(): number;

            clear(): void;

            remove(key: string): void;

        }

        export interface KStringMapCallBack<V> {

            (key: string, value: V): void;

        }

        export interface KTree extends memory.KChunk {

            size(): number;

        }

        export interface KTreeWalker {

            (t: number): void;

        }

        export namespace impl {
            export class AbstractArrayTree implements memory.KChunk {

                private static BLACK_LEFT: string = '{';
                private static BLACK_RIGHT: string = '}';
                private static RED_LEFT: string = '[';
                private static RED_RIGHT: string = ']';
                private static META_SIZE: number = 3;
                private static LOAD_FACTOR: number = (<number>75 / <number>100);
                public kvSize: number = 1;
                private _threshold: number = 0;
                private _root_index: number = -1;
                private _size: number = 0;
                private state: memory.chunk.impl.AbstractArrayTree.InternalState;
                private _space: memory.space.KChunkSpace;
                private _flags: java.util.concurrent.atomic.AtomicLong;
                private _counter: java.util.concurrent.atomic.AtomicInteger;
                private _universe: number;
                private _time: number;
                private _obj: number;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    this._universe = p_universe;
                    this._time = p_time;
                    this._obj = p_obj;
                    this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                    this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                    this._space = p_space;
                }

                public counter(): number {
                    return this._counter.get();
                }

                public inc(): number {
                    return this._counter.incrementAndGet();
                }

                public dec(): number {
                    return this._counter.decrementAndGet();
                }

                public universe(): number {
                    return this._universe;
                }

                public time(): number {
                    return this._time;
                }

                public obj(): number {
                    return this._obj;
                }

                public getFlags(): number {
                    return this._flags.get();
                }

                public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                    var val: number;
                    var nval: number;
                    do {
                        val = this._flags.get();
                        nval = val & ~bitsToDisable | bitsToEnable;
                    } while (!this._flags.compareAndSet(val, nval))
                }

                public space(): memory.space.KChunkSpace {
                    return this._space;
                }

                private allocate(capacity: number): void {
                    this.state = new memory.chunk.impl.AbstractArrayTree.InternalState(new Int32Array(capacity * AbstractArrayTree.META_SIZE), new Float64Array(capacity * this.kvSize), new Array());
                    this._threshold = <number>(capacity * AbstractArrayTree.LOAD_FACTOR);
                }

                private reallocate(newCapacity: number): void {
                    this._threshold = <number>(newCapacity * AbstractArrayTree.LOAD_FACTOR);
                    var new_back_kv: Float64Array = new Float64Array(newCapacity * this.kvSize);
                    if (this.state != null && this.state._back_kv != null) {
                        java.lang.System.arraycopy(this.state._back_kv, 0, new_back_kv, 0, this._size * this.kvSize);
                    }
                    var new_back_colors: boolean[] = new Array();
                    if (this.state != null && this.state._back_colors != null) {
                        java.lang.System.arraycopy(this.state._back_colors, 0, new_back_colors, 0, this._size);
                        for (var i: number = this._size; i < newCapacity; i++) {
                            new_back_colors[i] = false;
                        }
                    }
                    var new_back_meta: Int32Array = new Int32Array(newCapacity * AbstractArrayTree.META_SIZE);
                    if (this.state != null && this.state._back_meta != null) {
                        java.lang.System.arraycopy(this.state._back_meta, 0, new_back_meta, 0, this._size * AbstractArrayTree.META_SIZE);
                        for (var i: number = this._size * AbstractArrayTree.META_SIZE; i < newCapacity * AbstractArrayTree.META_SIZE; i++) {
                            new_back_meta[i] = -1;
                        }
                    }
                    this.state = new memory.chunk.impl.AbstractArrayTree.InternalState(new_back_meta, new_back_kv, new_back_colors);
                }

                public size(): number {
                    return this._size;
                }

                public key(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    return this.state._back_kv[p_currentIndex * this.kvSize];
                }

                private setKey(p_currentIndex: number, p_paramIndex: number): void {
                    this.state._back_kv[p_currentIndex * this.kvSize] = p_paramIndex;
                }

                public value(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    return this.state._back_kv[(p_currentIndex * this.kvSize) + 1];
                }

                private setValue(p_currentIndex: number, p_paramIndex: number): void {
                    this.state._back_kv[(p_currentIndex * this.kvSize) + 1] = p_paramIndex;
                }

                private left(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    return this.state._back_meta[p_currentIndex * AbstractArrayTree.META_SIZE];
                }

                private setLeft(p_currentIndex: number, p_paramIndex: number): void {
                    this.state._back_meta[p_currentIndex * AbstractArrayTree.META_SIZE] = p_paramIndex;
                }

                private right(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    return this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 1];
                }

                private setRight(p_currentIndex: number, p_paramIndex: number): void {
                    this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 1] = p_paramIndex;
                }

                private parent(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    return this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 2];
                }

                private setParent(p_currentIndex: number, p_paramIndex: number): void {
                    this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 2] = p_paramIndex;
                }

                private color(p_currentIndex: number): boolean {
                    if (p_currentIndex == -1) {
                        return true;
                    }
                    return this.state._back_colors[p_currentIndex];
                }

                private setColor(p_currentIndex: number, p_paramIndex: boolean): void {
                    this.state._back_colors[p_currentIndex] = p_paramIndex;
                }

                private grandParent(p_currentIndex: number): number {
                    if (p_currentIndex == -1) {
                        return -1;
                    }
                    if (this.parent(p_currentIndex) != -1) {
                        return this.parent(this.parent(p_currentIndex));
                    } else {
                        return -1;
                    }
                }

                private sibling(p_currentIndex: number): number {
                    if (this.parent(p_currentIndex) == -1) {
                        return -1;
                    } else {
                        if (p_currentIndex == this.left(this.parent(p_currentIndex))) {
                            return this.right(this.parent(p_currentIndex));
                        } else {
                            return this.left(this.parent(p_currentIndex));
                        }
                    }
                }

                private uncle(p_currentIndex: number): number {
                    if (this.parent(p_currentIndex) != -1) {
                        return this.sibling(this.parent(p_currentIndex));
                    } else {
                        return -1;
                    }
                }

                private previous(p_index: number): number {
                    var p: number = p_index;
                    if (this.left(p) != -1) {
                        p = this.left(p);
                        while (this.right(p) != -1){
                            p = this.right(p);
                        }
                        return p;
                    } else {
                        if (this.parent(p) != -1) {
                            if (p == this.right(this.parent(p))) {
                                return this.parent(p);
                            } else {
                                while (this.parent(p) != -1 && p == this.left(this.parent(p))){
                                    p = this.parent(p);
                                }
                                return this.parent(p);
                            }
                        } else {
                            return -1;
                        }
                    }
                }

                private next(p_index: number): number {
                    var p: number = p_index;
                    if (this.right(p) != -1) {
                        p = this.right(p);
                        while (this.left(p) != -1){
                            p = this.left(p);
                        }
                        return p;
                    } else {
                        if (this.parent(p) != -1) {
                            if (p == this.left(this.parent(p))) {
                                return this.parent(p);
                            } else {
                                while (this.parent(p) != -1 && p == this.right(this.parent(p))){
                                    p = this.parent(p);
                                }
                                return this.parent(p);
                            }
                        } else {
                            return -1;
                        }
                    }
                }

                public lookup(p_key: number): number {
                    var n: number = this._root_index;
                    if (n == -1) {
                        return KConfig.NULL_LONG;
                    }
                    while (n != -1){
                        if (p_key == this.key(n)) {
                            return this.key(n);
                        } else {
                            if (p_key < this.key(n)) {
                                n = this.left(n);
                            } else {
                                n = this.right(n);
                            }
                        }
                    }
                    return n;
                }

                public range(startKey: number, endKey: number, walker: memory.chunk.KTreeWalker): void {
                    var indexEnd: number = this.internal_previousOrEqual_index(endKey);
                    while (indexEnd != -1 && this.key(indexEnd) >= startKey){
                        walker(this.key(indexEnd));
                        indexEnd = this.previous(indexEnd);
                    }
                }

                public internal_previousOrEqual_index(p_key: number): number {
                    var p: number = this._root_index;
                    if (p == -1) {
                        return p;
                    }
                    while (p != -1){
                        if (p_key == this.key(p)) {
                            return p;
                        }
                        if (p_key > this.key(p)) {
                            if (this.right(p) != -1) {
                                p = this.right(p);
                            } else {
                                return p;
                            }
                        } else {
                            if (this.left(p) != -1) {
                                p = this.left(p);
                            } else {
                                var parent: number = this.parent(p);
                                var ch: number = p;
                                while (parent != -1 && ch == this.left(parent)){
                                    ch = parent;
                                    parent = this.parent(parent);
                                }
                                return parent;
                            }
                        }
                    }
                    return -1;
                }

                private rotateLeft(n: number): void {
                    var r: number = this.right(n);
                    this.replaceNode(n, r);
                    this.setRight(n, this.left(r));
                    if (this.left(r) != -1) {
                        this.setParent(this.left(r), n);
                    }
                    this.setLeft(r, n);
                    this.setParent(n, r);
                }

                private rotateRight(n: number): void {
                    var l: number = this.left(n);
                    this.replaceNode(n, l);
                    this.setLeft(n, this.right(l));
                    if (this.right(l) != -1) {
                        this.setParent(this.right(l), n);
                    }
                    this.setRight(l, n);
                    this.setParent(n, l);
                }

                private replaceNode(oldn: number, newn: number): void {
                    if (this.parent(oldn) == -1) {
                        this._root_index = newn;
                    } else {
                        if (oldn == this.left(this.parent(oldn))) {
                            this.setLeft(this.parent(oldn), newn);
                        } else {
                            this.setRight(this.parent(oldn), newn);
                        }
                    }
                    if (newn != -1) {
                        this.setParent(newn, this.parent(oldn));
                    }
                }

                private insertCase1(n: number): void {
                    if (this.parent(n) == -1) {
                        this.setColor(n, true);
                    } else {
                        this.insertCase2(n);
                    }
                }

                private insertCase2(n: number): void {
                    if (!this.color(this.parent(n))) {
                        this.insertCase3(n);
                    }
                }

                private insertCase3(n: number): void {
                    if (!this.color(this.uncle(n))) {
                        this.setColor(this.parent(n), true);
                        this.setColor(this.uncle(n), true);
                        this.setColor(this.grandParent(n), false);
                        this.insertCase1(this.grandParent(n));
                    } else {
                        this.insertCase4(n);
                    }
                }

                private insertCase4(n_n: number): void {
                    var n: number = n_n;
                    if (n == this.right(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                        this.rotateLeft(this.parent(n));
                        n = this.left(n);
                    } else {
                        if (n == this.left(this.parent(n)) && this.parent(n) == this.right(this.grandParent(n))) {
                            this.rotateRight(this.parent(n));
                            n = this.right(n);
                        }
                    }
                    this.insertCase5(n);
                }

                private insertCase5(n: number): void {
                    this.setColor(this.parent(n), true);
                    this.setColor(this.grandParent(n), false);
                    if (n == this.left(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                        this.rotateRight(this.grandParent(n));
                    } else {
                        this.rotateLeft(this.grandParent(n));
                    }
                }

                public serialize(metaModel: meta.KMetaModel): string {
                    if (this._root_index == -1) {
                        return "0";
                    }
                    var savedRoot: number = this._root_index;
                    var internalState: memory.chunk.impl.AbstractArrayTree.InternalState = this.state;
                    var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                    var treeSize: number = 0;
                    for (var i: number = 0; i < internalState._back_meta.length / AbstractArrayTree.META_SIZE; i++) {
                        var parentIndex: number = internalState._back_meta[(i * AbstractArrayTree.META_SIZE) + 2];
                        if (parentIndex != -1 || i == savedRoot) {
                            var isOnLeft: boolean = false;
                            if (parentIndex != -1) {
                                isOnLeft = internalState._back_meta[parentIndex * AbstractArrayTree.META_SIZE] == i;
                            }
                            if (!this.color(i)) {
                                if (isOnLeft) {
                                    builder.append(AbstractArrayTree.BLACK_LEFT);
                                } else {
                                    builder.append(AbstractArrayTree.BLACK_RIGHT);
                                }
                            } else {
                                if (isOnLeft) {
                                    builder.append(AbstractArrayTree.RED_LEFT);
                                } else {
                                    builder.append(AbstractArrayTree.RED_RIGHT);
                                }
                            }
                            util.Base64.encodeLongToBuffer(internalState._back_kv[i * this.kvSize], builder);
                            builder.append(',');
                            if (parentIndex != -1) {
                                util.Base64.encodeIntToBuffer(parentIndex, builder);
                            }
                            if (this.kvSize > 1) {
                                builder.append(',');
                                util.Base64.encodeLongToBuffer(internalState._back_kv[(i * this.kvSize) + 1], builder);
                            }
                            treeSize++;
                        }
                    }
                    return util.Base64.encodeInt(treeSize) + "," + util.Base64.encodeInt(savedRoot) + builder.toString();
                }

                public init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void {
                    if (payload == null || payload.length == 0) {
                        return;
                    }
                    var initPos: number = 0;
                    var cursor: number = 0;
                    while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                        cursor++;
                    }
                    if (payload.charAt(cursor) == ',') {
                        this._size = util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                        cursor++;
                        initPos = cursor;
                    }
                    while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                        cursor++;
                    }
                    this._root_index = util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                    this.allocate(this._size);
                    for (var i: number = 0; i < this._size; i++) {
                        var offsetI: number = i * AbstractArrayTree.META_SIZE;
                        this.state._back_meta[offsetI] = -1;
                        this.state._back_meta[offsetI + 1] = -1;
                        this.state._back_meta[offsetI + 2] = -1;
                    }
                    var currentLoopIndex: number = 0;
                    while (cursor < payload.length){
                        while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                            cursor++;
                        }
                        if (cursor < payload.length) {
                            var elem: string = payload.charAt(cursor);
                            var isOnLeft: boolean = false;
                            if (elem == AbstractArrayTree.BLACK_LEFT || elem == AbstractArrayTree.RED_LEFT) {
                                isOnLeft = true;
                            }
                            if (elem == AbstractArrayTree.BLACK_LEFT || elem == AbstractArrayTree.BLACK_RIGHT) {
                                this.setColor(currentLoopIndex, false);
                            } else {
                                this.setColor(currentLoopIndex, true);
                            }
                            cursor++;
                            var beginChunk: number = cursor;
                            while (cursor < payload.length && payload.charAt(cursor) != ','){
                                cursor++;
                            }
                            var loopKey: number = util.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                            this.setKey(currentLoopIndex, loopKey);
                            cursor++;
                            beginChunk = cursor;
                            while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                cursor++;
                            }
                            if (cursor > beginChunk) {
                                var parentRaw: number = util.Base64.decodeToIntWithBounds(payload, beginChunk, cursor);
                                this.setParent(currentLoopIndex, parentRaw);
                                if (isOnLeft) {
                                    this.setLeft(parentRaw, currentLoopIndex);
                                } else {
                                    this.setRight(parentRaw, currentLoopIndex);
                                }
                            }
                            if (cursor < payload.length && payload.charAt(cursor) == ',') {
                                cursor++;
                                beginChunk = cursor;
                                while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                    cursor++;
                                }
                                if (cursor > beginChunk) {
                                    var currentValue: number = util.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                                    this.setValue(currentLoopIndex, currentValue);
                                }
                            }
                            currentLoopIndex++;
                        }
                    }
                }

                public free(p_metaModel: meta.KMetaModel): void {
                    this.state = null;
                    this._size = 0;
                    this._threshold = 0;
                }

                public internal_insert(p_key: number, p_value: number): void {
                    if ((this._size + 1) > this._threshold) {
                        var length: number = (this._size == 0 ? 1 : this._size << 1);
                        this.reallocate(length);
                    }
                    var newIndex: number = this._size;
                    if (newIndex == 0) {
                        this.setKey(newIndex, p_key);
                        if (this.kvSize == 2) {
                            this.setValue(newIndex, p_value);
                        }
                        this.setColor(newIndex, false);
                        this.setLeft(newIndex, -1);
                        this.setRight(newIndex, -1);
                        this.setParent(newIndex, -1);
                        this._root_index = newIndex;
                        this._size = 1;
                    } else {
                        var n: number = this._root_index;
                        while (true){
                            if (p_key == this.key(n)) {
                                return;
                            } else {
                                if (p_key < this.key(n)) {
                                    if (this.left(n) == -1) {
                                        this.setKey(newIndex, p_key);
                                        if (this.kvSize == 2) {
                                            this.setValue(newIndex, p_value);
                                        }
                                        this.setColor(newIndex, false);
                                        this.setLeft(newIndex, -1);
                                        this.setRight(newIndex, -1);
                                        this.setParent(newIndex, -1);
                                        this.setLeft(n, newIndex);
                                        this._size++;
                                        break;
                                    } else {
                                        n = this.left(n);
                                    }
                                } else {
                                    if (this.right(n) == -1) {
                                        this.setKey(newIndex, p_key);
                                        if (this.kvSize == 2) {
                                            this.setValue(newIndex, p_value);
                                        }
                                        this.setColor(newIndex, false);
                                        this.setLeft(newIndex, -1);
                                        this.setRight(newIndex, -1);
                                        this.setParent(newIndex, -1);
                                        this.setRight(n, newIndex);
                                        this._size++;
                                        break;
                                    } else {
                                        n = this.right(n);
                                    }
                                }
                            }
                        }
                        this.setParent(newIndex, n);
                    }
                    this.insertCase1(newIndex);
                    this.internal_set_dirty();
                }

                public internal_lookup_value(p_key: number): number {
                    var n: number = this._root_index;
                    if (n == -1) {
                        return KConfig.NULL_LONG;
                    }
                    while (n != -1){
                        if (p_key == this.key(n)) {
                            return this.value(n);
                        } else {
                            if (p_key < this.key(n)) {
                                n = this.left(n);
                            } else {
                                n = this.right(n);
                            }
                        }
                    }
                    return n;
                }

                private internal_set_dirty(): void {
                    if (this._space != null) {
                        if ((this._flags.get() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                            this._space.declareDirty(this);
                            this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                        }
                    } else {
                        this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                    }
                }

                public type(): number {
                    throw "Abstract method";
                }

                public dependencies(): Float64Array {
                    return null;
                }

                public addDependency(universe: number, time: number, uuid: number): void {
                    throw new Error("Not implemented yet");
                }

            }

            export namespace AbstractArrayTree {
                export class InternalState {

                    public _back_meta: Int32Array;
                    public _back_kv: Float64Array;
                    public _back_colors: boolean[];
                    constructor(_back_meta: Int32Array, _back_kv: Float64Array, _back_colors: boolean[]) {
                        this._back_meta = _back_meta;
                        this._back_kv = _back_kv;
                        this._back_colors = _back_colors;
                    }

                }


            }
            export class ArrayIntMap<V> implements memory.chunk.KIntMap<V> {

                constructor(initalCapacity: number, loadFactor : number) { }
                public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];}} }
                public get(key:number):V { return this[key]; }
                public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
                public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
                public size():number { return Object.keys(this).length; }
                public each(callback: (p : number, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
            }

            export class ArrayLongLongMap implements memory.chunk.KLongLongMap {

                public elementCount: number;
                public droppedCount: number;
                public state: memory.chunk.impl.ArrayLongLongMap.InternalState = null;
                public threshold: number;
                private initialCapacity: number = 16;
                private static loadFactor: number = (<number>75 / <number>100);
                private _flags: java.util.concurrent.atomic.AtomicLong;
                private _counter: java.util.concurrent.atomic.AtomicInteger;
                private _space: memory.space.KChunkSpace;
                private _universe: number;
                private _time: number;
                private _obj: number;
                private _metaClassIndex: number = -1;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    this._universe = p_universe;
                    this._time = p_time;
                    this._obj = p_obj;
                    this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                    this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                    this._space = p_space;
                    this.elementCount = 0;
                    this.droppedCount = 0;
                    var newstate: memory.chunk.impl.ArrayLongLongMap.InternalState = new memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                    for (var i: number = 0; i < this.initialCapacity; i++) {
                        newstate.elementNext[i] = -1;
                        newstate.elementHash[i] = -1;
                    }
                    this.state = newstate;
                    this.threshold = <number>(newstate.elementDataSize * ArrayLongLongMap.loadFactor);
                }

                public counter(): number {
                    return this._counter.get();
                }

                public inc(): number {
                    return this._counter.incrementAndGet();
                }

                public dec(): number {
                    return this._counter.decrementAndGet();
                }

                public clear(): void {
                    if (this.elementCount > 0) {
                        this.elementCount = 0;
                        this.droppedCount = 0;
                        var newstate: memory.chunk.impl.ArrayLongLongMap.InternalState = new memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                        for (var i: number = 0; i < this.initialCapacity; i++) {
                            newstate.elementNext[i] = -1;
                            newstate.elementHash[i] = -1;
                        }
                        this.state = newstate;
                        this.threshold = <number>(newstate.elementDataSize * ArrayLongLongMap.loadFactor);
                    }
                }

                public rehashCapacity(capacity: number): void {
                    var length: number = (capacity == 0 ? 1 : capacity << 1);
                    var newElementKV: Float64Array = new Float64Array(length * 2);
                    java.lang.System.arraycopy(this.state.elementKV, 0, newElementKV, 0, this.state.elementKV.length);
                    var newElementNext: Int32Array = new Int32Array(length);
                    var newElementHash: Int32Array = new Int32Array(length);
                    for (var i: number = 0; i < length; i++) {
                        newElementNext[i] = -1;
                        newElementHash[i] = -1;
                    }
                    for (var i: number = 0; i < this.state.elementNext.length; i++) {
                        if (this.state.elementNext[i] != -1) {
                            var index: number = (<number>this.state.elementKV[i * 2] & 0x7FFFFFFF) % length;
                            var currentHashedIndex: number = newElementHash[index];
                            if (currentHashedIndex != -1) {
                                newElementNext[i] = currentHashedIndex;
                            } else {
                                newElementNext[i] = -2;
                            }
                            newElementHash[index] = i;
                        }
                    }
                    this.state = new memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                    this.threshold = <number>(length * ArrayLongLongMap.loadFactor);
                }

                public each(callback: memory.chunk.KLongLongMapCallBack<any>): void {
                    var internalState: memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                    for (var i: number = 0; i < internalState.elementNext.length; i++) {
                        if (internalState.elementNext[i] != -1) {
                            callback(internalState.elementKV[i * 2], internalState.elementKV[i * 2 + 1]);
                        }
                    }
                }

                public metaClassIndex(): number {
                    return this._metaClassIndex;
                }

                public contains(key: number): boolean {
                    var internalState: memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return false;
                    }
                    var hash: number = <number>(key);
                    var index: number = (hash & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = internalState.elementHash[index];
                    while (m >= 0){
                        if (key == internalState.elementKV[m * 2]) {
                            return true;
                        }
                        m = internalState.elementNext[m];
                    }
                    return false;
                }

                public get(key: number): number {
                    var internalState: memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return KConfig.NULL_LONG;
                    }
                    var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = internalState.elementHash[index];
                    while (m >= 0){
                        if (key == internalState.elementKV[m * 2]) {
                            return internalState.elementKV[(m * 2) + 1];
                        } else {
                            m = internalState.elementNext[m];
                        }
                    }
                    return KConfig.NULL_LONG;
                }

                public put(key: number, value: number): void {
                    var entry: number = -1;
                    var index: number = -1;
                    var hash: number = <number>(key);
                    if (this.state.elementDataSize != 0) {
                        index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                        entry = this.findNonNullKeyEntry(key, index);
                    }
                    if (entry == -1) {
                        if (++this.elementCount > this.threshold) {
                            this.rehashCapacity(this.state.elementDataSize);
                            index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                        }
                        var newIndex: number = (this.elementCount + this.droppedCount - 1);
                        this.state.elementKV[newIndex * 2] = key;
                        this.state.elementKV[newIndex * 2 + 1] = value;
                        var currentHashedIndex: number = this.state.elementHash[index];
                        if (currentHashedIndex != -1) {
                            this.state.elementNext[newIndex] = currentHashedIndex;
                        } else {
                            this.state.elementNext[newIndex] = -2;
                        }
                        this.state.elementHash[index] = newIndex;
                    } else {
                        this.state.elementKV[entry + 1] = value;
                    }
                    this.internal_set_dirty();
                }

                public findNonNullKeyEntry(key: number, index: number): number {
                    var m: number = this.state.elementHash[index];
                    while (m >= 0){
                        if (key == this.state.elementKV[m * 2]) {
                            return m;
                        }
                        m = this.state.elementNext[m];
                    }
                    return -1;
                }

                public remove(key: number): void {
                    var internalState: memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return;
                    }
                    var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = this.state.elementHash[index];
                    var last: number = -1;
                    while (m >= 0){
                        if (key == this.state.elementKV[m * 2]) {
                            break;
                        }
                        last = m;
                        m = this.state.elementNext[m];
                    }
                    if (m == -1) {
                        return;
                    }
                    if (last == -1) {
                        if (this.state.elementNext[m] > 0) {
                            this.state.elementHash[index] = m;
                        } else {
                            this.state.elementHash[index] = -1;
                        }
                    } else {
                        this.state.elementNext[last] = this.state.elementNext[m];
                    }
                    this.state.elementNext[m] = -1;
                    this.elementCount--;
                    this.droppedCount++;
                }

                public size(): number {
                    return this.elementCount;
                }

                public init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void {
                    this._metaClassIndex = metaClassIndex;
                    if (payload == null || payload.length == 0) {
                        return;
                    }
                    var initPos: number = 0;
                    var cursor: number = 0;
                    while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != '/'){
                        cursor++;
                    }
                    if (cursor >= payload.length) {
                        return;
                    }
                    if (payload.charAt(cursor) == ',') {
                        this._metaClassIndex = metaModel.metaClassByName(payload.substring(initPos, cursor)).index();
                        cursor++;
                        initPos = cursor;
                    }
                    while (cursor < payload.length && payload.charAt(cursor) != '/'){
                        cursor++;
                    }
                    var nbElement: number = util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                    var length: number = (nbElement == 0 ? 1 : nbElement << 1);
                    var newElementKV: Float64Array = new Float64Array(length * 2);
                    var newElementNext: Int32Array = new Int32Array(length);
                    var newElementHash: Int32Array = new Int32Array(length);
                    for (var i: number = 0; i < length; i++) {
                        newElementNext[i] = -1;
                        newElementHash[i] = -1;
                    }
                    var temp_state: memory.chunk.impl.ArrayLongLongMap.InternalState = new memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                    while (cursor < payload.length){
                        cursor++;
                        var beginChunk: number = cursor;
                        while (cursor < payload.length && payload.charAt(cursor) != ':'){
                            cursor++;
                        }
                        var middleChunk: number = cursor;
                        while (cursor < payload.length && payload.charAt(cursor) != ','){
                            cursor++;
                        }
                        var loopKey: number = util.Base64.decodeToLongWithBounds(payload, beginChunk, middleChunk);
                        var loopVal: number = util.Base64.decodeToLongWithBounds(payload, middleChunk + 1, cursor);
                        var index: number = ((<number>(loopKey)) & 0x7FFFFFFF) % temp_state.elementDataSize;
                        var newIndex: number = this.elementCount;
                        temp_state.elementKV[newIndex * 2] = loopKey;
                        temp_state.elementKV[newIndex * 2 + 1] = loopVal;
                        var currentHashedIndex: number = temp_state.elementHash[index];
                        if (currentHashedIndex != -1) {
                            temp_state.elementNext[newIndex] = currentHashedIndex;
                        } else {
                            temp_state.elementNext[newIndex] = -2;
                        }
                        temp_state.elementHash[index] = newIndex;
                        this.elementCount++;
                    }
                    this.elementCount = nbElement;
                    this.droppedCount = 0;
                    this.state = temp_state;
                    this.threshold = <number>(length * ArrayLongLongMap.loadFactor);
                }

                public serialize(metaModel: meta.KMetaModel): string {
                    var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                    if (this._metaClassIndex != -1) {
                        buffer.append(metaModel.metaClass(this._metaClassIndex).metaName());
                        buffer.append(',');
                    }
                    util.Base64.encodeIntToBuffer(this.elementCount, buffer);
                    buffer.append('/');
                    var isFirst: boolean = true;
                    var internalState: memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                    for (var i: number = 0; i < internalState.elementNext.length; i++) {
                        if (internalState.elementNext[i] != -1) {
                            var loopKey: number = internalState.elementKV[i * 2];
                            var loopValue: number = internalState.elementKV[i * 2 + 1];
                            if (!isFirst) {
                                buffer.append(",");
                            }
                            isFirst = false;
                            util.Base64.encodeLongToBuffer(loopKey, buffer);
                            buffer.append(":");
                            util.Base64.encodeLongToBuffer(loopValue, buffer);
                        }
                    }
                    return buffer.toString();
                }

                public free(metaModel: meta.KMetaModel): void {
                    this.clear();
                }

                public type(): number {
                    return memory.space.KChunkTypes.LONG_LONG_MAP;
                }

                public space(): memory.space.KChunkSpace {
                    return this._space;
                }

                private internal_set_dirty(): void {
                    if (this._space != null) {
                        if ((this._flags.get() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                            this._space.declareDirty(this);
                            this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                        }
                    } else {
                        this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                    }
                }

                public getFlags(): number {
                    return this._flags.get();
                }

                public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                    var val: number;
                    var nval: number;
                    do {
                        val = this._flags.get();
                        nval = val & ~bitsToDisable | bitsToEnable;
                    } while (!this._flags.compareAndSet(val, nval))
                }

                public universe(): number {
                    return this._universe;
                }

                public time(): number {
                    return this._time;
                }

                public obj(): number {
                    return this._obj;
                }

                public dependencies(): Float64Array {
                    return null;
                }

                public addDependency(universe: number, time: number, uuid: number): void {
                    throw new Error("Not implemented yet");
                }

            }

            export namespace ArrayLongLongMap {
                export class InternalState {

                    public elementDataSize: number;
                    public elementKV: Float64Array;
                    public elementNext: Int32Array;
                    public elementHash: Int32Array;
                    constructor(elementDataSize: number, elementKV: Float64Array, elementNext: Int32Array, elementHash: Int32Array) {
                        this.elementDataSize = elementDataSize;
                        this.elementKV = elementKV;
                        this.elementNext = elementNext;
                        this.elementHash = elementHash;
                    }

                }


            }
            export class ArrayLongLongTree extends memory.chunk.impl.AbstractArrayTree implements memory.chunk.KLongLongTree {

                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    super(p_universe, p_time, p_obj, p_space);
                    this.kvSize = 2;
                }

                public previousOrEqualValue(p_key: number): number {
                    var result: number = this.internal_previousOrEqual_index(p_key);
                    if (result != -1) {
                        return this.value(result);
                    } else {
                        return KConfig.NULL_LONG;
                    }
                }

                public lookupValue(p_key: number): number {
                    return this.internal_lookup_value(p_key);
                }

                public insert(p_key: number, p_value: number): void {
                    this.internal_insert(p_key, p_value);
                }

                public type(): number {
                    return -1;
                }

            }

            export class ArrayLongMap<V> implements memory.chunk.KLongMap<V> {

                constructor(initalCapacity: number, loadFactor : number) { }
                public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];} } }
                public get(key:number):V { return this[key]; }
                public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
                public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
                public size():number { return Object.keys(this).length; }
                public each(callback: (p : number, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
            }

            export class ArrayLongTree extends memory.chunk.impl.AbstractArrayTree implements memory.chunk.KLongTree {

                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    super(p_universe, p_time, p_obj, p_space);
                }

                public previousOrEqual(key: number): number {
                    var result: number = this.internal_previousOrEqual_index(key);
                    if (result != -1) {
                        return this.key(result);
                    } else {
                        return KConfig.NULL_LONG;
                    }
                }

                public insertKey(p_key: number): void {
                    this.internal_insert(p_key, p_key);
                }

                public type(): number {
                    return memory.space.KChunkTypes.LONG_TREE;
                }

            }

            export class ArrayStringMap<V> implements memory.chunk.KStringMap<V> {

                constructor(initalCapacity: number, loadFactor : number) { }
                public clear():void { for(var p in this){ if(this.hasOwnProperty(p)){ delete this[p];} } }
                public get(key:string):V { return this[key]; }
                public put(key:string, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                public contains(key:string):boolean { return this.hasOwnProperty(key);}
                public remove(key:string):V { var tmp = this[key]; delete this[key]; return tmp; }
                public size():number { return Object.keys(this).length; }
                public each(callback: (p : string, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(<string>p,this[p]); } } }
            }

            export class HeapObjectChunk implements memory.chunk.KObjectChunk {

                private _space: memory.space.KChunkSpace;
                private _flags: java.util.concurrent.atomic.AtomicLong;
                private _counter: java.util.concurrent.atomic.AtomicInteger;
                private _dependencies: java.util.concurrent.atomic.AtomicReference<Float64Array>;
                private _universe: number;
                private _time: number;
                private _obj: number;
                private raw: any[];
                private _metaClassIndex: number = -1;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    this._universe = p_universe;
                    this._time = p_time;
                    this._obj = p_obj;
                    this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                    this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                    this._dependencies = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
                    this._space = p_space;
                }

                public space(): memory.space.KChunkSpace {
                    return this._space;
                }

                public metaClassIndex(): number {
                    return this._metaClassIndex;
                }

                public serialize(metaModel: meta.KMetaModel): string {
                    var metaClass: meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                    var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                    var isFirst: boolean = true;
                    var metaElements: meta.KMeta[] = metaClass.metaElements();
                    if (this.raw != null && metaElements != null) {
                        for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                            if (this.raw[i] != null) {
                                if (isFirst) {
                                    isFirst = false;
                                } else {
                                    builder.append(KConfig.CHUNK_ELEM_SEP);
                                }
                                util.Base64.encodeStringToBuffer(metaElements[i].metaName(), builder);
                                builder.append(KConfig.CHUNK_VAL_SEP);
                                if (metaElements[i].metaType() == meta.MetaType.ATTRIBUTE) {
                                    var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[i];
                                    var metaAttId: number = metaAttribute.attributeTypeId();
                                    switch (metaAttId) {
                                        case meta.KPrimitiveTypes.STRING_ID:
                                            util.Base64.encodeStringToBuffer(<string>this.raw[i], builder);
                                            break;
                                        case meta.KPrimitiveTypes.LONG_ID:
                                            util.Base64.encodeLongToBuffer(<number>this.raw[i], builder);
                                            break;
                                        case meta.KPrimitiveTypes.CONTINUOUS_ID:
                                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                                            util.Base64.encodeIntToBuffer(castedArr.length, builder);
                                            for (var j: number = 0; j < castedArr.length; j++) {
                                                builder.append(KConfig.CHUNK_VAL_SEP);
                                                util.Base64.encodeDoubleToBuffer(castedArr[j], builder);
                                            }
                                            break;
                                        case meta.KPrimitiveTypes.BOOL_ID:
                                            if (<boolean>this.raw[i]) {
                                                builder.append("1");
                                            } else {
                                                builder.append("0");
                                            }
                                            break;
                                        case meta.KPrimitiveTypes.DOUBLE_ID:
                                            util.Base64.encodeDoubleToBuffer(<number>this.raw[i], builder);
                                            break;
                                        case meta.KPrimitiveTypes.INT_ID:
                                            util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                            break;
                                        default:
                                            if (meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                                                util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                            }
                                            break;
                                    }
                                } else {
                                    if (metaElements[i].metaType() == meta.MetaType.RELATION) {
                                        var castedArr: Float64Array = <Float64Array>this.raw[i];
                                        util.Base64.encodeIntToBuffer(castedArr.length, builder);
                                        for (var j: number = 0; j < castedArr.length; j++) {
                                            builder.append(KConfig.CHUNK_VAL_SEP);
                                            util.Base64.encodeLongToBuffer(castedArr[j], builder);
                                        }
                                    } else {
                                        if (metaElements[i].metaType() == meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == meta.MetaType.INPUT || metaElements[i].metaType() == meta.MetaType.OUTPUT) {
                                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                                            util.Base64.encodeIntToBuffer(castedArr.length, builder);
                                            for (var j: number = 0; j < castedArr.length; j++) {
                                                builder.append(KConfig.CHUNK_VAL_SEP);
                                                util.Base64.encodeDoubleToBuffer(castedArr[j], builder);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    return builder.toString();
                }

                private loadObject(metaAttribute: meta.KMetaAttribute, p_payload: string, p_start: number, p_end: number): any {
                    var metaAttId: number = metaAttribute.attributeTypeId();
                    switch (metaAttId) {
                        case meta.KPrimitiveTypes.STRING_ID:
                            return util.Base64.decodeToStringWithBounds(p_payload, p_start, p_end);
                        case meta.KPrimitiveTypes.LONG_ID:
                            return util.Base64.decodeToLongWithBounds(p_payload, p_start, p_end);
                        case meta.KPrimitiveTypes.INT_ID:
                            return util.Base64.decodeToIntWithBounds(p_payload, p_start, p_end);
                        case meta.KPrimitiveTypes.BOOL_ID:
                            if (p_payload.charAt(p_start) == '1') {
                                return true;
                            } else {
                                return false;
                            }
                        case meta.KPrimitiveTypes.DOUBLE_ID:
                            return util.Base64.decodeToDoubleWithBounds(p_payload, p_start, p_end);
                        default:
                            return null;
                    }
                }

                public init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void {
                    if (this._metaClassIndex == -1) {
                        this._metaClassIndex = metaClassIndex;
                    }
                    if (this._metaClassIndex == -1) {
                        return;
                    }
                    var metaClass: meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                    this.raw = new Array();
                    if (payload != null) {
                        var i: number = 0;
                        var payloadSize: number = payload.length;
                        var previousMeta: meta.KMeta = null;
                        var previousValStart: number = 0;
                        var doubleArray: Float64Array = null;
                        var longArray: Float64Array = null;
                        var currentArrayIndex: number = -1;
                        while (i < payloadSize){
                            if (payload.charAt(i) == KConfig.CHUNK_ELEM_SEP) {
                                if (previousMeta != null) {
                                    if (previousMeta.metaType().equals(meta.MetaType.ATTRIBUTE) && (<meta.KMetaAttribute>previousMeta).attributeTypeId() != meta.KPrimitiveTypes.CONTINUOUS_ID) {
                                        this.raw[previousMeta.index()] = this.loadObject(<meta.KMetaAttribute>previousMeta, payload, previousValStart, i);
                                    } else {
                                        if (previousMeta.metaType().equals(meta.MetaType.RELATION) && longArray != null) {
                                            longArray[currentArrayIndex] = util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                                            this.raw[previousMeta.index()] = longArray;
                                            longArray = null;
                                        } else {
                                            if (doubleArray != null) {
                                                doubleArray[currentArrayIndex] = util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                                                this.raw[previousMeta.index()] = doubleArray;
                                                doubleArray = null;
                                            }
                                        }
                                    }
                                }
                                previousMeta = null;
                                previousValStart = i + 1;
                            } else {
                                if (payload.charAt(i) == KConfig.CHUNK_VAL_SEP) {
                                    if (previousMeta == null) {
                                        previousMeta = metaClass.metaByName(util.Base64.decodeToStringWithBounds(payload, previousValStart, i));
                                    } else {
                                        if (previousMeta.metaType().equals(meta.MetaType.RELATION)) {
                                            if (longArray == null) {
                                                longArray = new Float64Array(util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                                                currentArrayIndex = 0;
                                            } else {
                                                longArray[currentArrayIndex] = util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                                                currentArrayIndex++;
                                            }
                                        } else {
                                            if (doubleArray == null) {
                                                doubleArray = new Float64Array(util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                                                currentArrayIndex = 0;
                                            } else {
                                                doubleArray[currentArrayIndex] = util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                                                currentArrayIndex++;
                                            }
                                        }
                                    }
                                    previousValStart = i + 1;
                                }
                            }
                            i++;
                        }
                        if (previousMeta != null) {
                            if (previousMeta.metaType().equals(meta.MetaType.ATTRIBUTE) && (<meta.KMetaAttribute>previousMeta).attributeTypeId() != meta.KPrimitiveTypes.CONTINUOUS_ID) {
                                this.raw[previousMeta.index()] = this.loadObject(<meta.KMetaAttribute>previousMeta, payload, previousValStart, i);
                            } else {
                                if (previousMeta.metaType().equals(meta.MetaType.RELATION) && longArray != null) {
                                    longArray[currentArrayIndex] = util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                                    this.raw[previousMeta.index()] = longArray;
                                } else {
                                    if (doubleArray != null) {
                                        doubleArray[currentArrayIndex] = util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                                        this.raw[previousMeta.index()] = doubleArray;
                                    }
                                }
                            }
                        }
                    }
                }

                public counter(): number {
                    return this._counter.get();
                }

                public inc(): number {
                    return this._counter.incrementAndGet();
                }

                public dec(): number {
                    return this._counter.decrementAndGet();
                }

                public free(metaModel: meta.KMetaModel): void {
                    this.raw = null;
                }

                public type(): number {
                    return memory.space.KChunkTypes.OBJECT_CHUNK;
                }

                public getPrimitiveType(index: number, p_metaClass: meta.KMetaClass): any {
                    if (this.raw != null) {
                        return this.raw[index];
                    } else {
                        return null;
                    }
                }

                public getLongArraySize(index: number, metaClass: meta.KMetaClass): number {
                    var existing: Float64Array = <Float64Array>this.raw[index];
                    if (existing != null) {
                        return existing.length;
                    }
                    return 0;
                }

                public getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number {
                    var existing: Float64Array = <Float64Array>this.raw[index];
                    if (existing != null) {
                        return existing[refIndex];
                    } else {
                        return KConfig.NULL_LONG;
                    }
                }

                public getLongArray(index: number, p_metaClass: meta.KMetaClass): Float64Array {
                    var previousObj: any = this.raw[index];
                    if (previousObj != null) {
                        return <Float64Array>previousObj;
                    }
                    return null;
                }

                public addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean {
                    if (this.raw != null) {
                        var previous: Float64Array = <Float64Array>this.raw[index];
                        if (previous == null) {
                            previous = new Float64Array(1);
                            previous[0] = newRef;
                        } else {
                            for (var i: number = 0; i < previous.length; i++) {
                                if (previous[i] == newRef) {
                                    return false;
                                }
                            }
                            var incArray: Float64Array = new Float64Array(previous.length + 1);
                            java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                            incArray[previous.length] = newRef;
                            previous = incArray;
                        }
                        this.raw[index] = previous;
                        this.internal_set_dirty();
                        return true;
                    }
                    return false;
                }

                public removeLongToArray(index: number, refToRemove: number, metaClass: meta.KMetaClass): boolean {
                    if (this.raw != null) {
                        var previous: Float64Array = <Float64Array>this.raw[index];
                        if (previous != null) {
                            var indexToRemove: number = -1;
                            for (var i: number = 0; i < previous.length; i++) {
                                if (previous[i] == refToRemove) {
                                    indexToRemove = i;
                                    break;
                                }
                            }
                            if (indexToRemove != -1) {
                                if ((previous.length - 1) == 0) {
                                    this.raw[index] = null;
                                } else {
                                    var newArray: Float64Array = new Float64Array(previous.length - 1);
                                    java.lang.System.arraycopy(previous, 0, newArray, 0, indexToRemove);
                                    java.lang.System.arraycopy(previous, indexToRemove + 1, newArray, indexToRemove, previous.length - indexToRemove - 1);
                                    this.raw[index] = newArray;
                                }
                                this.internal_set_dirty();
                                return true;
                            }
                        }
                    }
                    return false;
                }

                public clearLongArray(index: number, metaClass: meta.KMetaClass): void {
                    this.raw[index] = null;
                }

                public getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array {
                    var previousObj: any = this.raw[index];
                    if (previousObj != null) {
                        return <Float64Array>previousObj;
                    }
                    return null;
                }

                public getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number {
                    var previousObj: any = this.raw[index];
                    if (previousObj != null) {
                        return (<Float64Array>previousObj).length;
                    }
                    return 0;
                }

                public getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number {
                    var res: Float64Array = this.getDoubleArray(index, metaClass);
                    if (util.Checker.isDefined(res)) {
                        return res[arrayIndex];
                    }
                    return 0;
                }

                public setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void {
                    var res: Float64Array = this.getDoubleArray(index, metaClass);
                    if (util.Checker.isDefined(res)) {
                        res[arrayIndex] = valueToInsert;
                        this.internal_set_dirty();
                    }
                }

                public extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void {
                    if (this.raw != null) {
                        var previous: Float64Array = <Float64Array>this.raw[index];
                        if (previous == null) {
                            previous = new Float64Array(newSize);
                        } else {
                            var incArray: Float64Array = new Float64Array(newSize);
                            java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                            previous = incArray;
                        }
                        this.raw[index] = previous;
                        this.internal_set_dirty();
                    }
                }

                public clearDoubleArray(index: number, metaClass: meta.KMetaClass): void {
                    this.raw[index] = null;
                }

                public setPrimitiveType(index: number, content: any, p_metaClass: meta.KMetaClass): void {
                    this.raw[index] = content;
                    this.internal_set_dirty();
                }

                public clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk {
                    if (this.raw == null) {
                        return new memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                    } else {
                        var cloned: any[] = new Array();
                        java.lang.System.arraycopy(this.raw, 0, cloned, 0, this.raw.length);
                        var clonedEntry: memory.chunk.impl.HeapObjectChunk = new memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                        clonedEntry.raw = cloned;
                        clonedEntry._metaClassIndex = this._metaClassIndex;
                        clonedEntry.internal_set_dirty();
                        return clonedEntry;
                    }
                }

                public toJSON(metaModel: meta.KMetaModel): string {
                    var metaClass: meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                    var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                    builder.append("{");
                    var isFirst: boolean = true;
                    var metaElements: meta.KMeta[] = metaClass.metaElements();
                    if (this.raw != null && metaElements != null) {
                        for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                            if (this.raw[i] != null) {
                                if (isFirst) {
                                    builder.append("\"");
                                    isFirst = false;
                                } else {
                                    builder.append(",\"");
                                }
                                builder.append(metaElements[i].metaName());
                                builder.append("\":");
                                if (metaElements[i].metaType() == meta.MetaType.ATTRIBUTE) {
                                    var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[i];
                                    var metaAttId: number = metaAttribute.attributeTypeId();
                                    switch (metaAttId) {
                                        case meta.KPrimitiveTypes.STRING_ID:
                                            builder.append("\"");
                                            builder.append(format.json.JsonString.encode(<string>this.raw[i]));
                                            builder.append("\"");
                                            break;
                                        case meta.KPrimitiveTypes.LONG_ID:
                                            builder.append(this.raw[i]);
                                            break;
                                        case meta.KPrimitiveTypes.CONTINUOUS_ID:
                                            builder.append("[");
                                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                                            for (var j: number = 0; j < castedArr.length; j++) {
                                                if (j != 0) {
                                                    builder.append(",");
                                                }
                                                builder.append(castedArr[j]);
                                            }
                                            builder.append("]");
                                            break;
                                        case meta.KPrimitiveTypes.BOOL_ID:
                                            if (<boolean>this.raw[i]) {
                                                builder.append("1");
                                            } else {
                                                builder.append("0");
                                            }
                                            break;
                                        case meta.KPrimitiveTypes.DOUBLE_ID:
                                            builder.append(this.raw[i]);
                                            break;
                                        case meta.KPrimitiveTypes.INT_ID:
                                            builder.append(this.raw[i]);
                                            break;
                                        default:
                                            if (meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                                                util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                            }
                                            break;
                                    }
                                } else {
                                    if (metaElements[i].metaType() == meta.MetaType.RELATION) {
                                        builder.append("[");
                                        var castedArr: Float64Array = <Float64Array>this.raw[i];
                                        for (var j: number = 0; j < castedArr.length; j++) {
                                            if (j != 0) {
                                                builder.append(",");
                                            }
                                            builder.append(castedArr[j]);
                                        }
                                        builder.append("]");
                                    } else {
                                        if (metaElements[i].metaType() == meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == meta.MetaType.INPUT || metaElements[i].metaType() == meta.MetaType.OUTPUT) {
                                            builder.append("[");
                                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                                            for (var j: number = 0; j < castedArr.length; j++) {
                                                if (j != 0) {
                                                    builder.append(",");
                                                }
                                                builder.append(castedArr[j]);
                                            }
                                            builder.append("]");
                                        }
                                    }
                                }
                            }
                        }
                    }
                    builder.append("}");
                    return builder.toString();
                }

                private internal_set_dirty(): void {
                    if (this._space != null) {
                        if ((this._flags.get() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                            this._space.declareDirty(this);
                            this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                        }
                    } else {
                        this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                    }
                }

                public getFlags(): number {
                    return this._flags.get();
                }

                public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                    var val: number;
                    var nval: number;
                    do {
                        val = this._flags.get();
                        nval = val & ~bitsToDisable | bitsToEnable;
                    } while (!this._flags.compareAndSet(val, nval))
                }

                public universe(): number {
                    return this._universe;
                }

                public time(): number {
                    return this._time;
                }

                public obj(): number {
                    return this._obj;
                }

                public dependencies(): Float64Array {
                    return this._dependencies.get();
                }

                public addDependency(universe: number, time: number, uuid: number): void {
                    var previousVal: Float64Array;
                    var newVal: Float64Array;
                    do {
                        previousVal = this._dependencies.get();
                        if (previousVal == null) {
                            newVal = new Float64Array([universe, time, uuid]);
                        } else {
                            newVal = new Float64Array(previousVal.length + 3);
                            var previousLength: number = previousVal.length;
                            java.lang.System.arraycopy(previousVal, 0, newVal, 0, previousLength);
                            newVal[previousLength] = universe;
                            newVal[previousLength + 1] = time;
                            newVal[previousLength + 2] = uuid;
                        }
                    } while (!this._dependencies.compareAndSet(previousVal, newVal))
                }

            }

            export class HeapObjectIndexChunk implements memory.chunk.KObjectIndexChunk {

                public elementCount: number;
                public droppedCount: number;
                public state: memory.chunk.impl.HeapObjectIndexChunk.InternalState = null;
                public threshold: number;
                private initialCapacity: number = 16;
                private static loadFactor: number = (<number>75 / <number>100);
                private _flags: java.util.concurrent.atomic.AtomicLong;
                private _counter: java.util.concurrent.atomic.AtomicInteger;
                private _space: memory.space.KChunkSpace;
                private _universe: number;
                private _time: number;
                private _obj: number;
                private _metaClassIndex: number = -1;
                private _dependencies: java.util.concurrent.atomic.AtomicReference<Float64Array>;
                constructor(p_universe: number, p_time: number, p_obj: number, p_space: memory.space.KChunkSpace) {
                    this._universe = p_universe;
                    this._time = p_time;
                    this._obj = p_obj;
                    this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                    this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                    this._space = p_space;
                    this.elementCount = 0;
                    this.droppedCount = 0;
                    var newstate: memory.chunk.impl.HeapObjectIndexChunk.InternalState = new memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.initialCapacity, new Array(), new Float64Array(this.initialCapacity), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                    for (var i: number = 0; i < this.initialCapacity; i++) {
                        newstate.elementNext[i] = -1;
                        newstate.elementHash[i] = -1;
                    }
                    this.state = newstate;
                    this.threshold = <number>(newstate.elementDataSize * HeapObjectIndexChunk.loadFactor);
                    this._dependencies = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
                }

                public clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: meta.KMetaModel): memory.chunk.KObjectChunk {
                    var cloned: memory.chunk.impl.HeapObjectIndexChunk = new memory.chunk.impl.HeapObjectIndexChunk(p_universe, p_time, p_obj, this._space);
                    cloned._metaClassIndex = this._metaClassIndex;
                    cloned.state = this.state.clone();
                    cloned.elementCount = this.elementCount;
                    cloned.droppedCount = this.droppedCount;
                    cloned.threshold = this.threshold;
                    cloned.internal_set_dirty();
                    return cloned;
                }

                public metaClassIndex(): number {
                    return this._metaClassIndex;
                }

                public toJSON(metaModel: meta.KMetaModel): string {
                    return null;
                }

                public setPrimitiveType(index: number, content: any, metaClass: meta.KMetaClass): void {
                }

                public getPrimitiveType(index: number, metaClass: meta.KMetaClass): any {
                    return null;
                }

                public getLongArray(index: number, metaClass: meta.KMetaClass): Float64Array {
                    return new Float64Array(0);
                }

                public getLongArraySize(index: number, metaClass: meta.KMetaClass): number {
                    return 0;
                }

                public getLongArrayElem(index: number, refIndex: number, metaClass: meta.KMetaClass): number {
                    return 0;
                }

                public addLongToArray(index: number, newRef: number, metaClass: meta.KMetaClass): boolean {
                    return false;
                }

                public removeLongToArray(index: number, previousRef: number, metaClass: meta.KMetaClass): boolean {
                    return false;
                }

                public clearLongArray(index: number, metaClass: meta.KMetaClass): void {
                }

                public getDoubleArray(index: number, metaClass: meta.KMetaClass): Float64Array {
                    return new Float64Array(0);
                }

                public getDoubleArraySize(index: number, metaClass: meta.KMetaClass): number {
                    return 0;
                }

                public getDoubleArrayElem(index: number, arrayIndex: number, metaClass: meta.KMetaClass): number {
                    return 0;
                }

                public setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: meta.KMetaClass): void {
                }

                public extendDoubleArray(index: number, newSize: number, metaClass: meta.KMetaClass): void {
                }

                public clearDoubleArray(index: number, metaClass: meta.KMetaClass): void {
                }

                public counter(): number {
                    return this._counter.get();
                }

                public inc(): number {
                    return this._counter.incrementAndGet();
                }

                public dec(): number {
                    return this._counter.decrementAndGet();
                }

                public clear(): void {
                    if (this.elementCount > 0) {
                        this.elementCount = 0;
                        this.droppedCount = 0;
                        var newstate: memory.chunk.impl.HeapObjectIndexChunk.InternalState = new memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.initialCapacity, new Array(), new Float64Array(this.initialCapacity), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                        for (var i: number = 0; i < this.initialCapacity; i++) {
                            newstate.elementNext[i] = -1;
                            newstate.elementHash[i] = -1;
                        }
                        this.state = newstate;
                        this.threshold = <number>(newstate.elementDataSize * HeapObjectIndexChunk.loadFactor);
                    }
                }

                public rehashCapacity(capacity: number): void {
                    var length: number = (capacity == 0 ? 1 : capacity << 1);
                    var newElementK: string[] = new Array();
                    var newElementV: Float64Array = new Float64Array(length * 2);
                    java.lang.System.arraycopy(this.state.elementK, 0, newElementK, 0, this.state.elementK.length);
                    java.lang.System.arraycopy(this.state.elementV, 0, newElementV, 0, this.state.elementV.length);
                    var newElementNext: Int32Array = new Int32Array(length);
                    var newElementHash: Int32Array = new Int32Array(length);
                    for (var i: number = 0; i < length; i++) {
                        newElementNext[i] = -1;
                        newElementHash[i] = -1;
                    }
                    for (var i: number = 0; i < this.state.elementNext.length; i++) {
                        if (this.state.elementNext[i] != -1) {
                            var index: number = (util.PrimitiveHelper.stringHash(this.state.elementK[i]) & 0x7FFFFFFF) % length;
                            var currentHashedIndex: number = newElementHash[index];
                            if (currentHashedIndex != -1) {
                                newElementNext[i] = currentHashedIndex;
                            } else {
                                newElementNext[i] = -2;
                            }
                            newElementHash[index] = i;
                        }
                    }
                    this.state = new memory.chunk.impl.HeapObjectIndexChunk.InternalState(length, newElementK, newElementV, newElementNext, newElementHash);
                    this.threshold = <number>(length * HeapObjectIndexChunk.loadFactor);
                }

                public each(callback: memory.chunk.KStringLongMapCallBack): void {
                    var internalState: memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                    for (var i: number = 0; i < internalState.elementNext.length; i++) {
                        if (internalState.elementNext[i] != -1) {
                            callback(internalState.elementK[i], internalState.elementV[i]);
                        }
                    }
                }

                public contains(key: string): boolean {
                    var internalState: memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return false;
                    }
                    var hash: number = util.PrimitiveHelper.stringHash(key);
                    var index: number = (hash & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = internalState.elementHash[index];
                    while (m >= 0){
                        if (key == internalState.elementK[m * 2]) {
                            return true;
                        }
                        m = internalState.elementNext[m];
                    }
                    return false;
                }

                public get(key: string): number {
                    var internalState: memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return KConfig.NULL_LONG;
                    }
                    var index: number = (util.PrimitiveHelper.stringHash(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = internalState.elementHash[index];
                    while (m >= 0){
                        if (util.PrimitiveHelper.equals(key, internalState.elementK[m])) {
                            return internalState.elementV[m];
                        } else {
                            m = internalState.elementNext[m];
                        }
                    }
                    return KConfig.NULL_LONG;
                }

                public put(key: string, value: number): void {
                    var entry: number = -1;
                    var index: number = -1;
                    var hash: number = util.PrimitiveHelper.stringHash(key);
                    if (this.state.elementDataSize != 0) {
                        index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                        entry = this.findNonNullKeyEntry(key, index);
                    }
                    if (entry == -1) {
                        if (++this.elementCount > this.threshold) {
                            this.rehashCapacity(this.state.elementDataSize);
                            index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                        }
                        var newIndex: number = (this.elementCount + this.droppedCount - 1);
                        this.state.elementK[newIndex] = key;
                        this.state.elementV[newIndex] = value;
                        var currentHashedIndex: number = this.state.elementHash[index];
                        if (currentHashedIndex != -1) {
                            this.state.elementNext[newIndex] = currentHashedIndex;
                        } else {
                            this.state.elementNext[newIndex] = -2;
                        }
                        this.state.elementHash[index] = newIndex;
                    } else {
                        this.state.elementV[entry] = value;
                    }
                    this.internal_set_dirty();
                }

                public findNonNullKeyEntry(key: string, index: number): number {
                    var m: number = this.state.elementHash[index];
                    while (m >= 0){
                        if (util.PrimitiveHelper.equals(key, this.state.elementK[m])) {
                            return m;
                        }
                        m = this.state.elementNext[m];
                    }
                    return -1;
                }

                public remove(key: string): void {
                    var internalState: memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                    if (this.state.elementDataSize == 0) {
                        return;
                    }
                    var index: number = (util.PrimitiveHelper.stringHash(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = this.state.elementHash[index];
                    var last: number = -1;
                    while (m >= 0){
                        if (util.PrimitiveHelper.equals(key, this.state.elementK[m])) {
                            break;
                        }
                        last = m;
                        m = this.state.elementNext[m];
                    }
                    if (m == -1) {
                        return;
                    }
                    if (last == -1) {
                        if (this.state.elementNext[m] > 0) {
                            this.state.elementHash[index] = m;
                        } else {
                            this.state.elementHash[index] = -1;
                        }
                    } else {
                        this.state.elementNext[last] = this.state.elementNext[m];
                    }
                    this.state.elementNext[m] = -1;
                    this.elementCount--;
                    this.droppedCount++;
                }

                public size(): number {
                    return this.elementCount;
                }

                public init(payload: string, metaModel: meta.KMetaModel, metaClassIndex: number): void {
                    if (this._metaClassIndex == -1) {
                        this._metaClassIndex = metaClassIndex;
                    }
                    if (payload == null || payload.length == 0) {
                        return;
                    }
                    var initPos: number = 1;
                    var cursor: number = 0;
                    while (cursor < payload.length && payload.charAt(cursor) != '/'){
                        cursor++;
                    }
                    var nbElement: number = util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                    var length: number = (nbElement == 0 ? 1 : nbElement << 1);
                    var newElementK: string[] = new Array();
                    var newElementV: Float64Array = new Float64Array(length);
                    var newElementNext: Int32Array = new Int32Array(length);
                    var newElementHash: Int32Array = new Int32Array(length);
                    for (var i: number = 0; i < length; i++) {
                        newElementNext[i] = -1;
                        newElementHash[i] = -1;
                    }
                    var temp_state: memory.chunk.impl.HeapObjectIndexChunk.InternalState = new memory.chunk.impl.HeapObjectIndexChunk.InternalState(length, newElementK, newElementV, newElementNext, newElementHash);
                    while (cursor < payload.length){
                        cursor++;
                        var beginChunk: number = cursor;
                        while (cursor < payload.length && payload.charAt(cursor) != ':'){
                            cursor++;
                        }
                        var middleChunk: number = cursor;
                        while (cursor < payload.length && payload.charAt(cursor) != ','){
                            cursor++;
                        }
                        var loopKey: string = util.Base64.decodeToStringWithBounds(payload, beginChunk, middleChunk);
                        var loopVal: number = util.Base64.decodeToLongWithBounds(payload, middleChunk + 1, cursor);
                        var index: number = (util.PrimitiveHelper.stringHash(loopKey) & 0x7FFFFFFF) % temp_state.elementDataSize;
                        var newIndex: number = this.elementCount;
                        temp_state.elementK[newIndex] = loopKey;
                        temp_state.elementV[newIndex] = loopVal;
                        var currentHashedIndex: number = temp_state.elementHash[index];
                        if (currentHashedIndex != -1) {
                            temp_state.elementNext[newIndex] = currentHashedIndex;
                        } else {
                            temp_state.elementNext[newIndex] = -2;
                        }
                        temp_state.elementHash[index] = newIndex;
                        this.elementCount++;
                    }
                    this.elementCount = nbElement;
                    this.droppedCount = 0;
                    this.state = temp_state;
                    this.threshold = <number>(length * HeapObjectIndexChunk.loadFactor);
                }

                public serialize(metaModel: meta.KMetaModel): string {
                    var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                    buffer.append("#");
                    util.Base64.encodeIntToBuffer(this.elementCount, buffer);
                    buffer.append('/');
                    var isFirst: boolean = true;
                    var internalState: memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                    for (var i: number = 0; i < internalState.elementNext.length; i++) {
                        if (internalState.elementNext[i] != -1) {
                            var loopKey: string = internalState.elementK[i];
                            var loopValue: number = internalState.elementV[i];
                            if (!isFirst) {
                                buffer.append(",");
                            }
                            isFirst = false;
                            util.Base64.encodeStringToBuffer(loopKey, buffer);
                            buffer.append(":");
                            util.Base64.encodeLongToBuffer(loopValue, buffer);
                        }
                    }
                    return buffer.toString();
                }

                public free(metaModel: meta.KMetaModel): void {
                    this.clear();
                }

                public type(): number {
                    return memory.space.KChunkTypes.LONG_LONG_MAP;
                }

                public space(): memory.space.KChunkSpace {
                    return this._space;
                }

                private internal_set_dirty(): void {
                    if (this._space != null) {
                        if ((this._flags.get() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                            this._space.declareDirty(this);
                            this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                        }
                    } else {
                        this.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                    }
                }

                public getFlags(): number {
                    return this._flags.get();
                }

                public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                    var val: number;
                    var nval: number;
                    do {
                        val = this._flags.get();
                        nval = val & ~bitsToDisable | bitsToEnable;
                    } while (!this._flags.compareAndSet(val, nval))
                }

                public universe(): number {
                    return this._universe;
                }

                public time(): number {
                    return this._time;
                }

                public obj(): number {
                    return this._obj;
                }

                public dependencies(): Float64Array {
                    return this._dependencies.get();
                }

                public addDependency(universe: number, time: number, uuid: number): void {
                    var previousVal: Float64Array;
                    var newVal: Float64Array;
                    do {
                        previousVal = this._dependencies.get();
                        if (previousVal == null) {
                            newVal = new Float64Array([universe, time, uuid]);
                        } else {
                            newVal = new Float64Array(previousVal.length + 3);
                            var previousLength: number = previousVal.length;
                            java.lang.System.arraycopy(previousVal, 0, newVal, 0, previousLength);
                            newVal[previousLength] = universe;
                            newVal[previousLength + 1] = time;
                            newVal[previousLength + 2] = uuid;
                        }
                    } while (!this._dependencies.compareAndSet(previousVal, newVal))
                }

            }

            export namespace HeapObjectIndexChunk {
                export class InternalState {

                    public elementDataSize: number;
                    public elementK: string[];
                    public elementV: Float64Array;
                    public elementNext: Int32Array;
                    public elementHash: Int32Array;
                    constructor(elementDataSize: number, elementK: string[], elementV: Float64Array, elementNext: Int32Array, elementHash: Int32Array) {
                        this.elementDataSize = elementDataSize;
                        this.elementK = elementK;
                        this.elementV = elementV;
                        this.elementNext = elementNext;
                        this.elementHash = elementHash;
                    }

                    public clone(): memory.chunk.impl.HeapObjectIndexChunk.InternalState {
                        var clonedElementK: string[] = new Array();
                        java.lang.System.arraycopy(this.elementK, 0, clonedElementK, 0, this.elementK.length);
                        var clonedElementV: Float64Array = new Float64Array(this.elementV.length);
                        java.lang.System.arraycopy(this.elementV, 0, clonedElementV, 0, this.elementV.length);
                        var clonedElementNext: Int32Array = new Int32Array(this.elementNext.length);
                        java.lang.System.arraycopy(this.elementNext, 0, clonedElementNext, 0, this.elementNext.length);
                        var clonedElementHash: Int32Array = new Int32Array(this.elementHash.length);
                        java.lang.System.arraycopy(this.elementHash, 0, clonedElementHash, 0, this.elementHash.length);
                        return new memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.elementDataSize, clonedElementK, clonedElementV, clonedElementNext, clonedElementHash);
                    }

                }


            }
        }
    }
    export namespace manager {
        export class DataManagerBuilder {

            private _driver: cdn.KContentDeliveryDriver;
            private _scheduler: scheduler.KScheduler;
            private _strategy: memory.strategy.KMemoryStrategy;
            private _blas: util.maths.structure.blas.KBlas;
            public driver(): cdn.KContentDeliveryDriver {
                if (this._driver == null) {
                    this._driver = new cdn.impl.MemoryContentDeliveryDriver();
                }
                return this._driver;
            }

            public blas(): util.maths.structure.blas.KBlas {
                if (this._blas == null) {
                    this._blas = new util.maths.structure.blas.impl.JavaBlas();
                }
                return this._blas;
            }

            public scheduler(): scheduler.KScheduler {
                if (this._scheduler == null) { this._scheduler = new scheduler.impl.DirectScheduler(); }
                return this._scheduler;
            }

            public strategy(): memory.strategy.KMemoryStrategy {
                if (this._strategy == null) {
                    this._strategy = new memory.strategy.impl.HeapMemoryStrategy();
                }
                return this._strategy;
            }

            public static create(): memory.manager.DataManagerBuilder {
                return new memory.manager.DataManagerBuilder();
            }

            public withContentDeliveryDriver(p_driver: cdn.KContentDeliveryDriver): memory.manager.DataManagerBuilder {
                this._driver = p_driver;
                return this;
            }

            public withScheduler(p_scheduler: scheduler.KScheduler): memory.manager.DataManagerBuilder {
                this._scheduler = p_scheduler;
                return this;
            }

            public withMemoryStrategy(p_strategy: memory.strategy.KMemoryStrategy): memory.manager.DataManagerBuilder {
                this._strategy = p_strategy;
                return this;
            }

            public withBlas(p_blas: util.maths.structure.blas.KBlas): memory.manager.DataManagerBuilder {
                this._blas = p_blas;
                return this;
            }

            public build(): memory.manager.internal.KInternalDataManager {
                return new memory.manager.impl.DataManager(this.driver(), this.scheduler(), this.strategy(), this.blas());
            }

            public static buildDefault(): memory.manager.internal.KInternalDataManager {
                return memory.manager.DataManagerBuilder.create().build();
            }

        }

        export interface KDataManager {

            index(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void;

            lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void;

            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void;

            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void;

            createPreparedLookup(size: number): KPreparedLookup;

            lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void;

            save(callback: KCallback<Error>): void;

            model(): KModel<any>;

            connect(callback: KCallback<Error>): void;

            close(callback: KCallback<Error>): void;

            blas(): util.maths.structure.blas.KBlas;

        }

        export namespace impl {
            export class DataManager implements memory.manager.KDataManager, memory.manager.internal.KInternalDataManager {

                private static UNIVERSE_NOT_CONNECTED_ERROR: string = "Please connect your createModel prior to create a universe or an object";
                private _operationManager: operation.KOperationManager;
                private _db: cdn.KContentDeliveryDriver;
                private _scheduler: scheduler.KScheduler;
                private _listenerManager: memory.manager.impl.ListenerManager;
                private _modelKeyCalculator: memory.manager.impl.KeyCalculator;
                private _resolver: memory.resolver.KResolver;
                private _space: memory.space.KChunkSpace;
                private _spaceManager: memory.space.KChunkSpaceManager;
                private _blas: util.maths.structure.blas.KBlas;
                private _objectKeyCalculator: memory.manager.impl.KeyCalculator = null;
                private _universeKeyCalculator: memory.manager.impl.KeyCalculator = null;
                private isConnected: boolean = false;
                private _prefix: number;
                private _model: KModel<any>;
                private static UNIVERSE_INDEX: number = 0;
                private static OBJ_INDEX: number = 1;
                private static GLO_TREE_INDEX: number = 2;
                private static zeroPrefix: number = 0;
                private currentCdnListener: number = -1;
                private static PREFIX_TO_SAVE_SIZE: number = 2;
                private static KEY_SIZE: number = 3;
                public setModel(p_model: KModel<any>): void {
                    this._model = p_model;
                }

                constructor(p_cdn: cdn.KContentDeliveryDriver, p_scheduler: scheduler.KScheduler, p_factory: memory.strategy.KMemoryStrategy, p_blas: util.maths.structure.blas.KBlas) {
                    this._space = p_factory.newSpace();
                    this._scheduler = p_scheduler;
                    this._spaceManager = p_factory.newSpaceManager(this._space, this._scheduler);
                    this._resolver = new memory.resolver.impl.DistortedTimeResolver(this._spaceManager, this);
                    this._listenerManager = new memory.manager.impl.ListenerManager();
                    this._modelKeyCalculator = new memory.manager.impl.KeyCalculator(DataManager.zeroPrefix, 0);
                    this._db = p_cdn;
                    this.attachContentDeliveryDriver(new cdn.impl.MemoryContentDeliveryDriver());
                    this._operationManager = new operation.impl.HashOperationManager(this);
                    this._blas = p_blas;
                }

                public model(): KModel<any> {
                    return this._model;
                }

                public blas(): util.maths.structure.blas.KBlas {
                    return this._blas;
                }

                public nextUniverseKey(): number {
                    if (this._universeKeyCalculator == null) {
                        throw new Error(DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                    }
                    return this._universeKeyCalculator.nextKey();
                }

                public nextObjectKey(): number {
                    if (this._objectKeyCalculator == null) {
                        throw new Error(DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                    }
                    return this._objectKeyCalculator.nextKey();
                }

                public nextModelKey(): number {
                    return this._modelKeyCalculator.nextKey();
                }

                public initUniverse(p_universe: number, p_parent: number): void {
                    var cached: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>this._space.get(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG);
                    if (cached != null && !cached.contains(p_universe)) {
                        cached.put(p_universe, p_parent);
                    }
                }

                public save(callback: KCallback<Error>): void {
                    var selfPointer: memory.manager.impl.DataManager = this;
                    this._scheduler.dispatch( () => {
                        var dirtyIterator: memory.space.KChunkIterator = selfPointer._space.detachDirties();
                        if (dirtyIterator.size() == 0) {
                            if (callback != null) {
                                callback(null);
                            }
                            return;
                        }
                        var toSaveKeys: Float64Array = new Float64Array((dirtyIterator.size() + DataManager.PREFIX_TO_SAVE_SIZE) * DataManager.KEY_SIZE);
                        var toSaveValues: string[] = new Array();
                        var i: number = 0;
                        var _mm: meta.KMetaModel = selfPointer._model.metaModel();
                        while (dirtyIterator.hasNext()){
                            var loopChunkKeys: Float64Array = dirtyIterator.next();
                            var loopChunk: memory.KChunk = selfPointer._spaceManager.getAndMark(loopChunkKeys[0], loopChunkKeys[1], loopChunkKeys[2]);
                            if (loopChunk != null && (loopChunk.getFlags() & memory.KChunkFlags.DIRTY_BIT) == memory.KChunkFlags.DIRTY_BIT && (loopChunk.getFlags() & memory.KChunkFlags.REMOVED_BIT) != memory.KChunkFlags.REMOVED_BIT) {
                                toSaveKeys[i * DataManager.KEY_SIZE] = loopChunk.universe();
                                toSaveKeys[i * DataManager.KEY_SIZE + 1] = loopChunk.time();
                                toSaveKeys[i * DataManager.KEY_SIZE + 2] = loopChunk.obj();
                                try {
                                    toSaveValues[i] = loopChunk.serialize(_mm);
                                    loopChunk.setFlags(0, memory.KChunkFlags.DIRTY_BIT);
                                    i++;
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                                selfPointer._spaceManager.unmarkMemoryElement(loopChunk);
                            }
                        }
                        toSaveKeys[i * DataManager.KEY_SIZE] = KConfig.BEGINNING_OF_TIME;
                        toSaveKeys[i * DataManager.KEY_SIZE + 1] = KConfig.NULL_LONG;
                        toSaveKeys[i * DataManager.KEY_SIZE + 2] = selfPointer._objectKeyCalculator.prefix();
                        toSaveValues[i] = "" + selfPointer._objectKeyCalculator.lastComputedIndex();
                        i++;
                        toSaveKeys[i * DataManager.KEY_SIZE] = KConfig.END_OF_TIME;
                        toSaveKeys[i * DataManager.KEY_SIZE + 1] = KConfig.NULL_LONG;
                        toSaveKeys[i * DataManager.KEY_SIZE + 2] = selfPointer._universeKeyCalculator.prefix();
                        toSaveValues[i] = "" + selfPointer._universeKeyCalculator.lastComputedIndex();
                        selfPointer._db.put(toSaveKeys, toSaveValues, callback, selfPointer.currentCdnListener);
                    });
                }

                public initKObject(obj: KObject): void {
                    this._resolver.indexObject(obj);
                }

                public preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk {
                    var resolvedChunk: memory.chunk.KObjectChunk = this._resolver.preciseChunk(universe, time, uuid, metaClass, previousResolution);
                    if (resolvedChunk != null) {
                        return resolvedChunk;
                    } else {
                        throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                    }
                }

                public closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk {
                    var resolvedChunk: memory.chunk.KObjectChunk = this._resolver.closestChunk(universe, time, uuid, metaClass, previousResolution);
                    if (resolvedChunk != null) {
                        return resolvedChunk;
                    } else {
                        throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                    }
                }

                public connect(connectCallback: KCallback<Error>): void {
                    if (this.isConnected) {
                        if (connectCallback != null) {
                            connectCallback(null);
                        }
                    }
                    if (this._db == null) {
                        if (connectCallback != null) {
                            connectCallback(new Error("Please attach a KDataBase AND a KBroker first !"));
                        }
                    } else {
                        var selfPointer: memory.manager.impl.DataManager = this;
                        selfPointer._scheduler.start();
                        selfPointer._scheduler.dispatch( () => {
                            selfPointer._db.connect( (throwable : Error) => {
                                if (throwable == null) {
                                    var mappings: string[] = selfPointer._operationManager.mappings();
                                    if (mappings != null && mappings.length >= 1) {
                                        var operationMapping: message.KMessage = new message.impl.Message();
                                        operationMapping.setType(message.impl.Message.OPERATION_MAPPING);
                                        operationMapping.setValues(mappings);
                                        selfPointer._db.sendToPeer(null, operationMapping, null);
                                    }
                                    selfPointer._db.atomicGetIncrement(new Float64Array([KConfig.END_OF_TIME, KConfig.NULL_LONG, KConfig.NULL_LONG]),  (newPrefix : number) => {
                                        selfPointer._prefix = newPrefix;
                                        var connectionKeys: Float64Array = new Float64Array([KConfig.BEGINNING_OF_TIME, KConfig.NULL_LONG, newPrefix, KConfig.END_OF_TIME, KConfig.NULL_LONG, newPrefix, KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG]);
                                        selfPointer._db.get(connectionKeys,  (strings : string[]) => {
                                            if (strings.length == 3) {
                                                var detected: Error = null;
                                                try {
                                                    var uniIndexPayload: string = strings[DataManager.UNIVERSE_INDEX];
                                                    if (uniIndexPayload == null || util.PrimitiveHelper.equals(uniIndexPayload, "")) {
                                                        uniIndexPayload = "0";
                                                    }
                                                    var objIndexPayload: string = strings[DataManager.OBJ_INDEX];
                                                    if (objIndexPayload == null || util.PrimitiveHelper.equals(objIndexPayload, "")) {
                                                        objIndexPayload = "0";
                                                    }
                                                    var globalUniverseTreePayload: string = strings[DataManager.GLO_TREE_INDEX];
                                                    var globalUniverseTree: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>selfPointer._spaceManager.createAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG, memory.space.KChunkTypes.LONG_LONG_MAP);
                                                    if (globalUniverseTreePayload != null) {
                                                        try {
                                                            globalUniverseTree.init(globalUniverseTreePayload, selfPointer.model().metaModel(), -1);
                                                        } catch ($ex$) {
                                                            if ($ex$ instanceof Error) {
                                                                var e: Error = <Error>$ex$;
                                                                console.error(e['stack']);;
                                                            } else {
                                                                throw $ex$;
                                                            }
                                                        }
                                                    }
                                                    var newUniIndex: number = util.PrimitiveHelper.parseLong(uniIndexPayload);
                                                    var newObjIndex: number = util.PrimitiveHelper.parseLong(objIndexPayload);
                                                    selfPointer._universeKeyCalculator = new memory.manager.impl.KeyCalculator(selfPointer._prefix, newUniIndex);
                                                    selfPointer._objectKeyCalculator = new memory.manager.impl.KeyCalculator(selfPointer._prefix, newObjIndex);
                                                    selfPointer.isConnected = true;
                                                } catch ($ex$) {
                                                    if ($ex$ instanceof Error) {
                                                        var e: Error = <Error>$ex$;
                                                        detected = e;
                                                    } else {
                                                        throw $ex$;
                                                    }
                                                }
                                                if (connectCallback != null) {
                                                    connectCallback(detected);
                                                }
                                            } else {
                                                if (connectCallback != null) {
                                                    connectCallback(new Error("Error while connecting the KDataStore..."));
                                                }
                                            }
                                        });
                                    });
                                } else {
                                    if (connectCallback != null) {
                                        connectCallback(throwable);
                                    }
                                }
                            });
                        });
                    }
                }

                public close(callback: KCallback<Error>): void {
                    if (this.isConnected) {
                        this._scheduler.stop();
                        this.isConnected = false;
                        if (this._db != null) {
                            this._db.close(callback);
                        } else {
                            if (callback != null) {
                                callback(null);
                            }
                        }
                    } else {
                        if (callback != null) {
                            callback(null);
                        }
                    }
                }

                public deleteUniverse(p_universe: KUniverse<any, any>, callback: KCallback<Error>): void {
                    throw new Error("Not implemented yet !");
                }

                public lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): void {
                    this._scheduler.dispatch(this._resolver.lookup(universe, time, uuid, callback));
                }

                public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): void {
                    this._scheduler.dispatch(this._resolver.lookupAllObjects(universe, time, uuids, callback));
                }

                public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): void {
                    this._scheduler.dispatch(this._resolver.lookupAllTimes(universe, times, uuid, callback));
                }

                public createPreparedLookup(p_size: number): KPreparedLookup {
                    return new memory.manager.impl.PreparedLookup(p_size);
                }

                public lookupPrepared(prepared: KPreparedLookup, callback: KCallback<KObject[]>): void {
                    this._scheduler.dispatch(this._resolver.lookupPrepared(prepared, callback));
                }

                public cdn(): cdn.KContentDeliveryDriver {
                    return this._db;
                }

                public scheduler(): scheduler.KScheduler {
                    return this._scheduler;
                }

                private attachContentDeliveryDriver(p_dataBase: cdn.KContentDeliveryDriver): void {
                    var selfPointer: memory.manager.impl.DataManager = this;
                    this.currentCdnListener = selfPointer._db.addUpdateListener({onKeysUpdate:function(updatedKeys: Float64Array){
                        var toLoadKeys: Float64Array = new Float64Array(updatedKeys.length);
                        var toInsertNotifyKey: number = 0;
                        var toNotifyKeys: Float64Array = new Float64Array(updatedKeys.length);
                        var nbElements: number = updatedKeys.length / DataManager.KEY_SIZE;
                        var toInsertKey: number = 0;
                        for (var i: number = 0; i < nbElements; i++) {
                            var currentChunk: memory.KChunk = selfPointer._spaceManager.getAndMark(updatedKeys[i * 3], updatedKeys[i * 3 + 1], updatedKeys[i * 3 + 2]);
                            if (currentChunk != null) {
                                if ((currentChunk.getFlags() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                                    toLoadKeys[toInsertKey * DataManager.KEY_SIZE] = updatedKeys[i * DataManager.KEY_SIZE];
                                    toLoadKeys[toInsertKey * DataManager.KEY_SIZE + 1] = updatedKeys[i * DataManager.KEY_SIZE + 1];
                                    toLoadKeys[toInsertKey * DataManager.KEY_SIZE + 2] = updatedKeys[i * DataManager.KEY_SIZE + 2];
                                    toInsertKey++;
                                }
                                selfPointer._spaceManager.unmarkMemoryElement(currentChunk);
                            }
                            if (selfPointer._listenerManager.isListened(updatedKeys[i * DataManager.KEY_SIZE + 2]) && updatedKeys[i * DataManager.KEY_SIZE] != KConfig.NULL_LONG && updatedKeys[i * DataManager.KEY_SIZE + 1] != KConfig.NULL_LONG && updatedKeys[i * DataManager.KEY_SIZE + 2] != KConfig.NULL_LONG) {
                                toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE] = updatedKeys[i * DataManager.KEY_SIZE];
                                toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE + 1] = updatedKeys[i * DataManager.KEY_SIZE + 1];
                                toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE + 2] = updatedKeys[i * DataManager.KEY_SIZE + 2];
                                toInsertNotifyKey++;
                            }
                        }
                        if (toInsertKey == 0 && toInsertNotifyKey == 0) {
                            return;
                        }
                        var trimmedToLoad: Float64Array = new Float64Array(toInsertKey * 3);
                        java.lang.System.arraycopy(toLoadKeys, 0, trimmedToLoad, 0, toInsertKey * 3);
                        var trimmedToNotify: Float64Array = new Float64Array(toInsertNotifyKey * 3);
                        java.lang.System.arraycopy(toNotifyKeys, 0, trimmedToNotify, 0, toInsertNotifyKey * 3);
                        var mm: meta.KMetaModel = selfPointer._model.metaModel();
                        selfPointer._db.get(trimmedToLoad,  (payloads : string[]) => {
                            for (var i: number = 0; i < payloads.length; i++) {
                                if (payloads[i] != null) {
                                    var currentChunk: memory.KChunk = selfPointer._spaceManager.getAndMark(trimmedToLoad[i * 3], trimmedToLoad[i * 3 + 1], trimmedToLoad[i * 3 + 2]);
                                    if (currentChunk != null) {
                                        currentChunk.init(payloads[i], mm, -1);
                                        selfPointer._spaceManager.unmarkMemoryElement(currentChunk);
                                    }
                                }
                            }
                            selfPointer._resolver.lookupPreciseKeys(trimmedToNotify,  (updatedObjects : KObject[]) => {
                                selfPointer._listenerManager.dispatch(updatedObjects);
                            })();
                        });
                    }, onOperationCall:function(operationCallMessage: message.KMessage){
                        selfPointer._operationManager.dispatch(operationCallMessage);
                    }                                });
                }

                public operationManager(): operation.KOperationManager {
                    return this._operationManager;
                }

                public createListener(p_universe: number): KListener {
                    return this._listenerManager.createListener(p_universe);
                }

                public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void {
                    this._resolver.resolveTimes(currentUniverse, currentUuid, startTime, endTime, callback);
                }

                public spaceSize(): number {
                    return this._space.size();
                }

                public printDebug(): void {
                    this._space.printDebug(this._model.metaModel());
                }

                public index(universe: number, time: number, indexName: string, callback: KCallback<KObjectIndex>): void {
                    var selfPointer: memory.manager.impl.DataManager = this;
                    selfPointer._scheduler.dispatch(selfPointer._resolver.lookup(universe, time, KConfig.END_OF_TIME,  (kObject : KObject) => {
                        var globalIndex: KObjectIndex = <KObjectIndex>kObject;
                        if (globalIndex == null) {
                            globalIndex = new meta.impl.GenericObjectIndex(universe, time, KConfig.END_OF_TIME, selfPointer, universe, time);
                            this.initKObject(globalIndex);
                        }
                        var indexUUID: number = globalIndex.getIndex(indexName);
                        if (indexUUID == KConfig.NULL_LONG) {
                            var nextKey: number = this.nextObjectKey();
                            var namedIndex: KObjectIndex = new meta.impl.GenericObjectIndex(universe, time, nextKey, selfPointer, universe, time);
                            this.initKObject(namedIndex);
                            globalIndex.setIndex(indexName, nextKey);
                            if (util.Checker.isDefined(callback)) {
                                callback(namedIndex);
                            }
                        } else {
                            selfPointer._scheduler.dispatch(selfPointer._resolver.lookup(universe, time, indexUUID,  (namedIndex : KObject) => {
                                if (util.Checker.isDefined(callback)) {
                                    callback(<KObjectIndex>namedIndex);
                                }
                            }));
                        }
                    }));
                }

            }

            export class HeapListener implements KListener {

                private _universe: number;
                private _listenerManager: memory.manager.impl.ListenerManager;
                private _id: number;
                public cb: KCallback<KObject>;
                public listenerID(): number {
                    return this._id;
                }

                constructor(p_universe: number, p_listenerManager: memory.manager.impl.ListenerManager, p_id: number) {
                    this._universe = p_universe;
                    this._listenerManager = p_listenerManager;
                    this._id = p_id;
                }

                public universe(): number {
                    return 0;
                }

                public listenObjects(): Float64Array {
                    return this._listenerManager._listener2Objects.get(this._id);
                }

                public listen(obj: KObject): void {
                    this._listenerManager.manageRegistration(this._id, obj);
                }

                public destroy(): void {
                    this._listenerManager.manageRegistration(this._id, null);
                }

                public then(p_cb: KCallback<any>): void {
                    this.cb = p_cb;
                }

            }

            export class KeyCalculator {

                private _prefix: string;
                private _currentIndex: number;
                constructor(prefix: number, currentIndex: number) {
                    this._prefix = "0x" + prefix.toString(KConfig.PREFIX_SIZE);
                    this._currentIndex = currentIndex;
                }

                public nextKey(): number {
                    if (this._currentIndex == KConfig.KEY_PREFIX_MASK) {
                        throw new Error("Object Index could not be created because it exceeded the capacity of the current prefix. Ask for a new prefix.");
                    }
                    this._currentIndex++;
                    var indexHex = this._currentIndex.toString(KConfig.PREFIX_SIZE);
                    var objectKey = parseInt(this._prefix + "000000000".substring(0,9-indexHex.length) + indexHex, KConfig.PREFIX_SIZE);
                    if (objectKey >= KConfig.NULL_LONG) {
                        throw new Error("Object Index exceeds teh maximum JavaScript number capacity. (2^"+KConfig.LONG_SIZE+")");
                    }
                    return objectKey;
                }

                public lastComputedIndex(): number {
                    return this._currentIndex;
                }

                public prefix(): number {
                    return parseInt(this._prefix,KConfig.PREFIX_SIZE);
                }

            }

            export class ListenerManager {

                private _keyGen: memory.manager.impl.KeyCalculator;
                public _listeners: memory.chunk.impl.ArrayLongMap<memory.manager.impl.HeapListener>;
                public _listener2Objects: memory.chunk.impl.ArrayLongMap<Float64Array>;
                public _obj2Listener: memory.chunk.impl.ArrayLongMap<Float64Array>;
                constructor() {
                    this._keyGen = new memory.manager.impl.KeyCalculator(<number>0, 0);
                    this._listeners = new memory.chunk.impl.ArrayLongMap<memory.manager.impl.HeapListener>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                    this._obj2Listener = new memory.chunk.impl.ArrayLongMap<Float64Array>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                    this._listener2Objects = new memory.chunk.impl.ArrayLongMap<Float64Array>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                }

                public clear(): void {
                    this._listeners.clear();
                    this._obj2Listener.clear();
                    this._listener2Objects.clear();
                }

                public createListener(p_universe: number): KListener {
                    var newListener: memory.manager.impl.HeapListener = new memory.manager.impl.HeapListener(p_universe, this, this._keyGen.nextKey());
                    this._listeners.put(newListener.listenerID(), newListener);
                    return newListener;
                }

                public manageRegistration(listenerID: number, origin: KObject): void {
                    if (origin != null) {
                        if (!this._listener2Objects.contains(listenerID)) {
                            var newRec: Float64Array = new Float64Array(1);
                            newRec[0] = origin.uuid();
                            this._listener2Objects.put(listenerID, newRec);
                        } else {
                            var previous: Float64Array = this._listener2Objects.get(listenerID);
                            var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                            java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                            newArrayRec[previous.length] = origin.uuid();
                            this._listener2Objects.put(listenerID, newArrayRec);
                        }
                        if (!this._obj2Listener.contains(origin.uuid())) {
                            var newRec: Float64Array = new Float64Array(1);
                            newRec[0] = listenerID;
                            this._obj2Listener.put(origin.uuid(), newRec);
                        } else {
                            var previous: Float64Array = this._obj2Listener.get(origin.uuid());
                            var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                            java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                            newArrayRec[previous.length] = listenerID;
                            this._obj2Listener.put(origin.uuid(), newArrayRec);
                        }
                    } else {
                        var objs: Float64Array = this._listener2Objects.get(listenerID);
                        if (objs != null) {
                            this._listener2Objects.remove(listenerID);
                            for (var i: number = 0; i < objs.length; i++) {
                                var registeredListener: Float64Array = this._obj2Listener.get(objs[i]);
                                var foundIndex: number = -1;
                                for (var j: number = 0; j < registeredListener.length; j++) {
                                    if (registeredListener[j] == listenerID) {
                                        foundIndex = j;
                                    }
                                }
                                if (foundIndex != -1) {
                                    if (foundIndex == 0) {
                                        var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                                        java.lang.System.arraycopy(objs, foundIndex, registeredListener2, 0, registeredListener.length - 1);
                                        this._obj2Listener.put(objs[i], registeredListener2);
                                    } else {
                                        var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                                        java.lang.System.arraycopy(objs, 0, registeredListener2, 0, foundIndex - 1);
                                        java.lang.System.arraycopy(objs, foundIndex + 1, registeredListener2, foundIndex, registeredListener.length - foundIndex - 1);
                                        this._obj2Listener.put(objs[i], registeredListener2);
                                    }
                                }
                            }
                        }
                    }
                }

                public isListened(obj: number): boolean {
                    var notifier: Float64Array = this._obj2Listener.get(obj);
                    if (notifier != null && notifier.length > 0) {
                        return true;
                    }
                    return false;
                }

                public dispatch(objects: KObject[]): void {
                    for (var i: number = 0; i < objects.length; i++) {
                        if (objects[i] != null) {
                            var notifier: Float64Array = this._obj2Listener.get(objects[i].uuid());
                            if (notifier != null && notifier.length > 0) {
                                for (var j: number = 0; j < notifier.length; j++) {
                                    var ll: memory.manager.impl.HeapListener = this._listeners.get(notifier[j]);
                                    var cb: KCallback<KObject> = ll.cb;
                                    if (cb != null) {
                                        cb(objects[i]);
                                    }
                                }
                            }
                        }
                    }
                }

            }

            export class PreparedLookup implements KPreparedLookup {

                private _size: number;
                private _flatStatement: Float64Array;
                private _current: number = -1;
                constructor(p_size: number) {
                    this._size = p_size;
                    this._flatStatement = new Float64Array(p_size * 3);
                    this._current = 0;
                }

                public addLookupOperation(universe: number, time: number, uuid: number): void {
                    if (this._current >= this._size) {
                        throw new Error("PreparedLookup is full, prepared capacity:" + this._size);
                    }
                    this._flatStatement[this._current * 3] = universe;
                    this._flatStatement[this._current * 3 + 1] = time;
                    this._flatStatement[this._current * 3 + 2] = uuid;
                    this._current++;
                }

                public flatLookup(): Float64Array {
                    return this._flatStatement;
                }

            }

        }
        export namespace internal {
            export interface KInternalDataManager extends memory.manager.KDataManager {

                createListener(universe: number): KListener;

                cdn(): cdn.KContentDeliveryDriver;

                scheduler(): scheduler.KScheduler;

                preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;

                closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;

                initKObject(obj: KObject): void;

                initUniverse(universe: number, parent: number): void;

                nextUniverseKey(): number;

                nextObjectKey(): number;

                nextModelKey(): number;

                deleteUniverse(universe: KUniverse<any, any>, callback: KCallback<Error>): void;

                operationManager(): operation.KOperationManager;

                setModel(model: KModel<any>): void;

                resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;

                spaceSize(): number;

                printDebug(): void;

            }

        }
    }
    export namespace resolver {
        export interface KResolver {

            lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): scheduler.KTask;

            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;

            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): scheduler.KTask;

            lookupPreciseKeys(keys: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask;

            lookupPrepared(preparedLookup: KPreparedLookup, callback: KCallback<KObject[]>): scheduler.KTask;

            preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;

            closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk;

            indexObject(obj: KObject): void;

            resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void;

            getRelatedKeysResultSize(): number;

            getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void;

        }

        export namespace impl {
            export class DistortedTimeResolver implements memory.resolver.KResolver {

                private static KEYS_SIZE: number = 3;
                private _spaceManager: memory.space.KChunkSpaceManager;
                private _manager: memory.manager.internal.KInternalDataManager;
                constructor(p_cache: memory.space.KChunkSpaceManager, p_manager: memory.manager.internal.KInternalDataManager) {
                    this._spaceManager = p_cache;
                    this._manager = p_manager;
                    this._spaceManager.setResolver(this);
                }

                public lookup(universe: number, time: number, uuid: number, callback: KCallback<KObject>): scheduler.KTask {
                    var selfPointer: memory.resolver.impl.DistortedTimeResolver = this;
                    return  () => {
                        try {
                            selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : memory.KChunk) => {
                                if (theGlobalUniverseOrderElement != null) {
                                    selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, uuid,  (theObjectUniverseOrderElement : memory.KChunk) => {
                                        if (theObjectUniverseOrderElement == null) {
                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(null);
                                        } else {
                                            var closestUniverse: number = memory.resolver.impl.DistortedTimeResolver.resolve_universe(<memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <memory.chunk.KLongLongMap>theObjectUniverseOrderElement, time, universe);
                                            selfPointer.getOrLoadAndMark(closestUniverse, KConfig.NULL_LONG, uuid,  (theObjectTimeTreeElement : memory.KChunk) => {
                                                if (theObjectTimeTreeElement == null) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(null);
                                                } else {
                                                    var closestTime: number = (<memory.chunk.KLongTree>theObjectTimeTreeElement).previousOrEqual(time);
                                                    if (closestTime == KConfig.NULL_LONG) {
                                                        selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                                        selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                        selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                        callback(null);
                                                        return;
                                                    }
                                                    selfPointer.getOrLoadAndMark(closestUniverse, closestTime, uuid,  (theObjectChunk : memory.KChunk) => {
                                                        if (theObjectChunk == null) {
                                                            selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                            callback(null);
                                                        } else {
                                                            var metaClassIndex: number = (<memory.chunk.KObjectChunk>theObjectChunk).metaClassIndex();
                                                            var newProxy: KObject;
                                                            if (metaClassIndex == meta.impl.MetaClassIndex.INSTANCE.index()) {
                                                                newProxy = new meta.impl.GenericObjectIndex(universe, time, uuid, selfPointer._manager, closestUniverse, closestTime);
                                                            } else {
                                                                var resolvedMetaClass: meta.KMetaClass = selfPointer._manager.model().metaModel().metaClass((<memory.chunk.KObjectChunk>theObjectChunk).metaClassIndex());
                                                                newProxy = (<abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuid, resolvedMetaClass, closestUniverse, closestTime);
                                                            }
                                                            selfPointer._spaceManager.register(newProxy);
                                                            callback(newProxy);
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                } else {
                                    callback(null);
                                }
                            });
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    };
                }

                public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask {
                    var selfPointer: memory.resolver.impl.DistortedTimeResolver = this;
                    return  () => {
                        try {
                            selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : memory.KChunk) => {
                                if (theGlobalUniverseOrderElement != null) {
                                    var tempObjectUniverseKeys: Float64Array = new Float64Array(uuids.length * 3);
                                    for (var i: number = 0; i < uuids.length; i++) {
                                        tempObjectUniverseKeys[i * 3] = KConfig.NULL_LONG;
                                        tempObjectUniverseKeys[i * 3 + 1] = KConfig.NULL_LONG;
                                        tempObjectUniverseKeys[i * 3 + 2] = uuids[i];
                                    }
                                    selfPointer.getOrLoadAndMarkAll(tempObjectUniverseKeys,  (objectUniverseOrderElements : memory.KChunk[]) => {
                                        if (objectUniverseOrderElements == null || objectUniverseOrderElements.length == 0) {
                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(new Array());
                                            return;
                                        }
                                        var tempObjectTimeTreeKeys: Float64Array = new Float64Array(uuids.length * 3);
                                        for (var i: number = 0; i < uuids.length; i++) {
                                            var closestUniverse: number = memory.resolver.impl.DistortedTimeResolver.resolve_universe(<memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <memory.chunk.KLongLongMap>objectUniverseOrderElements[i], time, universe);
                                            tempObjectTimeTreeKeys[i * 3] = closestUniverse;
                                            tempObjectTimeTreeKeys[i * 3 + 1] = KConfig.NULL_LONG;
                                            tempObjectTimeTreeKeys[i * 3 + 2] = uuids[i];
                                        }
                                        selfPointer.getOrLoadAndMarkAll(tempObjectTimeTreeKeys,  (objectTimeTreeElements : memory.KChunk[]) => {
                                            if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                                selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                callback(new Array());
                                                return;
                                            }
                                            var tempObjectChunkKeys: Float64Array = new Float64Array(uuids.length * 3);
                                            for (var i: number = 0; i < uuids.length; i++) {
                                                var closestTime: number = (<memory.chunk.KLongTree>objectTimeTreeElements[i]).previousOrEqual(time);
                                                if (closestTime != KConfig.NULL_LONG) {
                                                    tempObjectChunkKeys[i * 3] = tempObjectTimeTreeKeys[i * 3];
                                                    tempObjectChunkKeys[i * 3 + 1] = closestTime;
                                                    tempObjectChunkKeys[i * 3 + 2] = uuids[i];
                                                } else {
                                                    java.lang.System.arraycopy(KContentKey.NULL_KEY, 0, tempObjectChunkKeys, (i * 3), 3);
                                                }
                                            }
                                            selfPointer.getOrLoadAndMarkAll(tempObjectChunkKeys,  (theObjectChunks : memory.KChunk[]) => {
                                                if (theObjectChunks == null || theObjectChunks.length == 0) {
                                                    selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                                    selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(new Array());
                                                } else {
                                                    var finalResult: KObject[] = new Array();
                                                    for (var h: number = 0; h < theObjectChunks.length; h++) {
                                                        if (theObjectChunks[h] != null) {
                                                            finalResult[h] = (<abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuids[h], selfPointer._manager.model().metaModel().metaClass((<memory.chunk.KObjectChunk>theObjectChunks[h]).metaClassIndex()), tempObjectTimeTreeKeys[h * 3], tempObjectChunkKeys[h * 3 + 1]);
                                                        } else {
                                                            finalResult[h] = null;
                                                        }
                                                    }
                                                    selfPointer._spaceManager.registerAll(finalResult);
                                                    callback(finalResult);
                                                }
                                            });
                                        });
                                    });
                                }
                            });
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    };
                }

                public lookupPreciseKeys(keys: Float64Array, callback: KCallback<KObject[]>): scheduler.KTask {
                    var selfPointer: memory.resolver.impl.DistortedTimeResolver = this;
                    return  () => {
                        try {
                            selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : memory.KChunk) => {
                                if (theGlobalUniverseOrderElement != null) {
                                    var allOrderedKeys: Float64Array = new Float64Array(keys.length * 3);
                                    var insertIndex: number = 0;
                                    var nbKeys: number = keys.length / 3;
                                    for (var i: number = 0; i < nbKeys; i++) {
                                        allOrderedKeys[insertIndex] = KConfig.NULL_LONG;
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = KConfig.NULL_LONG;
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3];
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = KConfig.NULL_LONG;
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3];
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3 + 1];
                                        insertIndex++;
                                        allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                        insertIndex++;
                                    }
                                    selfPointer.getOrLoadAndMarkAll(allOrderedKeys,  (kChunks : memory.KChunk[]) => {
                                        if (kChunks == null || kChunks.length == 0) {
                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(new Array());
                                            return;
                                        } else {
                                            var finalResult: KObject[] = new Array();
                                            var insertIndex: number = 0;
                                            var previousClassIndex: number = -1;
                                            for (var h: number = 0; h < kChunks.length; h++) {
                                                if (kChunks[h] != null && kChunks[h].type() == memory.space.KChunkTypes.OBJECT_CHUNK) {
                                                    finalResult[insertIndex] = (<abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(kChunks[h].universe(), kChunks[h].time(), kChunks[h].obj(), selfPointer._manager.model().metaModel().metaClass(previousClassIndex), kChunks[h].universe(), kChunks[h].time());
                                                    insertIndex++;
                                                } else {
                                                    if (kChunks[h] != null && kChunks[h].type() == memory.space.KChunkTypes.LONG_LONG_MAP) {
                                                        var casted: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>kChunks[h];
                                                        previousClassIndex = casted.metaClassIndex();
                                                    }
                                                }
                                            }
                                            selfPointer._spaceManager.registerAll(finalResult);
                                            callback(finalResult);
                                        }
                                    });
                                }
                            });
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    };
                }

                public lookupPrepared(preparedLookup: KPreparedLookup, callback: KCallback<KObject[]>): scheduler.KTask {
                    var selfPointer: memory.resolver.impl.DistortedTimeResolver = this;
                    var nbObjs: number = preparedLookup.flatLookup().length / 3;
                    var flat: Float64Array = preparedLookup.flatLookup();
                    return  () => {
                        try {
                            selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : memory.KChunk) => {
                                if (theGlobalUniverseOrderElement != null) {
                                    var tempObjectUniverseKeys: Float64Array = new Float64Array(nbObjs * 3);
                                    for (var i: number = 0; i < nbObjs; i++) {
                                        tempObjectUniverseKeys[i * 3] = KConfig.NULL_LONG;
                                        tempObjectUniverseKeys[i * 3 + 1] = KConfig.NULL_LONG;
                                        tempObjectUniverseKeys[i * 3 + 2] = flat[i * 3 + 2];
                                    }
                                    selfPointer.getOrLoadAndMarkAll(tempObjectUniverseKeys,  (objectUniverseOrderElements : memory.KChunk[]) => {
                                        if (objectUniverseOrderElements == null || objectUniverseOrderElements.length == 0) {
                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(new Array());
                                            return;
                                        }
                                        var tempObjectTimeTreeKeys: Float64Array = new Float64Array(nbObjs * 3);
                                        for (var i: number = 0; i < nbObjs; i++) {
                                            var closestUniverse: number = memory.resolver.impl.DistortedTimeResolver.resolve_universe(<memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <memory.chunk.KLongLongMap>objectUniverseOrderElements[i], flat[i * 3 + 1], flat[i * 3]);
                                            tempObjectTimeTreeKeys[i * 3] = closestUniverse;
                                            tempObjectTimeTreeKeys[i * 3 + 1] = KConfig.NULL_LONG;
                                            tempObjectTimeTreeKeys[i * 3 + 2] = flat[i * 3 + 2];
                                        }
                                        selfPointer.getOrLoadAndMarkAll(tempObjectTimeTreeKeys,  (objectTimeTreeElements : memory.KChunk[]) => {
                                            if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                                selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                callback(new Array());
                                                return;
                                            }
                                            var tempObjectChunkKeys: Float64Array = new Float64Array(nbObjs * 3);
                                            for (var i: number = 0; i < nbObjs; i++) {
                                                var closestTime: number = (<memory.chunk.KLongTree>objectTimeTreeElements[i]).previousOrEqual(flat[i * 3 + 1]);
                                                if (closestTime != KConfig.NULL_LONG) {
                                                    tempObjectChunkKeys[i * 3] = tempObjectTimeTreeKeys[i * 3];
                                                    tempObjectChunkKeys[i * 3 + 1] = closestTime;
                                                    tempObjectChunkKeys[i * 3 + 2] = flat[i * 3 + 2];
                                                } else {
                                                    java.lang.System.arraycopy(KContentKey.NULL_KEY, 0, tempObjectChunkKeys, (i * 3), 3);
                                                }
                                            }
                                            selfPointer.getOrLoadAndMarkAll(tempObjectChunkKeys,  (theObjectChunks : memory.KChunk[]) => {
                                                if (theObjectChunks == null || theObjectChunks.length == 0) {
                                                    selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                                    selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(new Array());
                                                } else {
                                                    var finalResult: KObject[] = new Array();
                                                    for (var h: number = 0; h < theObjectChunks.length; h++) {
                                                        if (theObjectChunks[h] != null) {
                                                            finalResult[h] = (<abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(flat[h * 3], flat[h * 3 + 1], flat[h * 3 + 2], selfPointer._manager.model().metaModel().metaClass((<memory.chunk.KObjectChunk>theObjectChunks[h]).metaClassIndex()), tempObjectTimeTreeKeys[h * 3], tempObjectChunkKeys[h * 3 + 1]);
                                                        } else {
                                                            finalResult[h] = null;
                                                        }
                                                    }
                                                    selfPointer._spaceManager.registerAll(finalResult);
                                                    callback(finalResult);
                                                }
                                            });
                                        });
                                    });
                                }
                            });
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    };
                }

                public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: KCallback<KObject[]>): scheduler.KTask {
                    var selfPointer: memory.resolver.impl.DistortedTimeResolver = this;
                    return  () => {
                        try {
                            selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : memory.KChunk) => {
                                if (theGlobalUniverseOrderElement != null) {
                                    selfPointer.getOrLoadAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, uuid,  (theObjectUniverseOrderElement : memory.KChunk) => {
                                        if (theObjectUniverseOrderElement == null) {
                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(null);
                                        } else {
                                            var closestUniverses: Float64Array = new Float64Array(times.length);
                                            var closestUnikUniverse: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                            var nbUniverseToload: number = 0;
                                            for (var i: number = 0; i < times.length; i++) {
                                                closestUniverses[i] = memory.resolver.impl.DistortedTimeResolver.resolve_universe(<memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <memory.chunk.KLongLongMap>theObjectUniverseOrderElement, times[i], universe);
                                                if (!closestUnikUniverse.contains(closestUniverses[i])) {
                                                    closestUnikUniverse.put(closestUniverses[i], nbUniverseToload);
                                                    nbUniverseToload++;
                                                }
                                            }
                                            var toLoadUniverseKeys: Float64Array = new Float64Array(nbUniverseToload * 3);
                                            closestUnikUniverse.each( (key : number, value : number) => {
                                                var currentIndex: number = <number>(value * 3);
                                                toLoadUniverseKeys[currentIndex] = value;
                                                toLoadUniverseKeys[currentIndex + 1] = KConfig.NULL_LONG;
                                                toLoadUniverseKeys[currentIndex + 2] = uuid;
                                            });
                                            selfPointer.getOrLoadAndMarkAll(toLoadUniverseKeys,  (objectTimeTreeElements : memory.KChunk[]) => {
                                                if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(null);
                                                } else {
                                                    var closestTimes: Float64Array = new Float64Array(times.length);
                                                    var closestUnikTimes: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                                    var reverseTimeUniverse: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                                    var nbTimesToload: number = 0;
                                                    for (var i: number = 0; i < times.length; i++) {
                                                        var alignedIndexOfUniverse: number = <number>closestUnikUniverse.get(closestUniverses[i]);
                                                        closestTimes[i] = (<memory.chunk.KLongTree>objectTimeTreeElements[alignedIndexOfUniverse]).previousOrEqual(times[i]);
                                                        if (!closestUnikTimes.contains(closestTimes[i])) {
                                                            closestUnikTimes.put(closestTimes[i], nbTimesToload);
                                                            reverseTimeUniverse.put(closestTimes[i], closestUniverses[i]);
                                                            nbTimesToload++;
                                                        }
                                                    }
                                                    var toLoadTimesKeys: Float64Array = new Float64Array(nbTimesToload * 3);
                                                    closestUnikTimes.each( (key : number, value : number) => {
                                                        var currentIndex: number = <number>(value * 3);
                                                        toLoadTimesKeys[currentIndex] = reverseTimeUniverse.get(key);
                                                        toLoadTimesKeys[currentIndex + 1] = key;
                                                        toLoadTimesKeys[currentIndex + 2] = uuid;
                                                    });
                                                    selfPointer.getOrLoadAndMarkAll(toLoadTimesKeys,  (objectChunks : memory.KChunk[]) => {
                                                        if (objectChunks == null || objectChunks.length == 0) {
                                                            selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                            callback(null);
                                                        } else {
                                                            var result: KObject[] = new Array();
                                                            for (var i: number = 0; i < times.length; i++) {
                                                                var resolvedUniverse: number = closestUniverses[i];
                                                                var resolvedTime: number = closestTimes[i];
                                                                var indexChunks: number = <number>closestUnikTimes.get(closestTimes[i]);
                                                                if (indexChunks != -1 && resolvedUniverse != KConfig.NULL_LONG && resolvedTime != KConfig.NULL_LONG) {
                                                                    result[i] = (<abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, times[i], uuid, selfPointer._manager.model().metaModel().metaClass((<memory.chunk.KObjectChunk>objectChunks[indexChunks]).metaClassIndex()), resolvedUniverse, resolvedTime);
                                                                } else {
                                                                    result[i] = null;
                                                                }
                                                            }
                                                            selfPointer._spaceManager.registerAll(result);
                                                            callback(result);
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
                                }
                            });
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    };
                }

                public preciseChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk {
                    return this.internal_chunk(universe, time, uuid, false, metaClass, previousResolution);
                }

                public closestChunk(universe: number, time: number, uuid: number, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk {
                    return this.internal_chunk(universe, time, uuid, true, metaClass, previousResolution);
                }

                private internal_chunk(universe: number, requestedTime: number, uuid: number, useClosest: boolean, metaClass: meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): memory.chunk.KObjectChunk {
                    var time: number = requestedTime;
                    if (metaClass.temporalResolution() != 1) {
                        time = time - (time % metaClass.temporalResolution());
                    }
                    var currentEntry: memory.chunk.KObjectChunk = <memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                    if (currentEntry != null) {
                        var previous: Float64Array;
                        var current: Float64Array;
                        var diff: boolean = false;
                        do {
                            previous = previousResolution.get();
                            if (previous[abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                                current = new Float64Array([universe, time]);
                                diff = true;
                            } else {
                                current = previous;
                            }
                        } while (!previousResolution.compareAndSet(previous, current))
                        if (diff) {
                            this._spaceManager.unmark(previous[abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                        } else {
                            this._spaceManager.unmarkMemoryElement(currentEntry);
                        }
                        return currentEntry;
                    }
                    var objectUniverseTree: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>this._spaceManager.getAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, uuid);
                    if (objectUniverseTree == null) {
                        return null;
                    }
                    var globalUniverseTree: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>this._spaceManager.getAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG);
                    if (globalUniverseTree == null) {
                        this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                        return null;
                    }
                    var resolvedUniverse: number = memory.resolver.impl.DistortedTimeResolver.resolve_universe(globalUniverseTree, objectUniverseTree, time, universe);
                    var timeTree: memory.chunk.KLongTree = <memory.chunk.KLongTree>this._spaceManager.getAndMark(resolvedUniverse, KConfig.NULL_LONG, uuid);
                    if (timeTree == null) {
                        this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                        this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                        return null;
                    }
                    var resolvedTime: number = timeTree.previousOrEqual(time);
                    if (resolvedTime != KConfig.NULL_LONG) {
                        var needTimeCopy: boolean = !useClosest && (resolvedTime != time);
                        var needUniverseCopy: boolean = !useClosest && (resolvedUniverse != universe);
                        currentEntry = <memory.chunk.KObjectChunk>this._spaceManager.getAndMark(resolvedUniverse, resolvedTime, uuid);
                        if (currentEntry == null) {
                            console.error("DePhasing problem, null chunk unexpected");;
                            this._spaceManager.unmarkMemoryElement(timeTree);
                            this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                            this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                            return null;
                        }
                        if (!needTimeCopy && !needUniverseCopy) {
                            var previous: Float64Array;
                            var current: Float64Array;
                            var diff: boolean = false;
                            do {
                                previous = previousResolution.get();
                                if (previous[abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != resolvedUniverse || previous[abs.AbstractKObject.TIME_PREVIOUS_INDEX] != resolvedTime) {
                                    current = new Float64Array([resolvedUniverse, resolvedTime]);
                                    diff = true;
                                } else {
                                    current = previous;
                                }
                            } while (!previousResolution.compareAndSet(previous, current))
                            if (diff) {
                                this._spaceManager.unmark(previous[abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                            } else {
                                this._spaceManager.unmarkMemoryElement(currentEntry);
                            }
                            this._spaceManager.unmarkMemoryElement(timeTree);
                            this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                            this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                            return currentEntry;
                        } else {
                            var previous: Float64Array;
                            var current: Float64Array;
                            var diff: boolean = false;
                            do {
                                previous = previousResolution.get();
                                if (previous[abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                                    current = new Float64Array([universe, time]);
                                    diff = true;
                                } else {
                                    current = previous;
                                }
                            } while (!previousResolution.compareAndSet(previous, current))
                            if (diff) {
                                var clonedChunk: memory.chunk.KObjectChunk = this._spaceManager.cloneAndMark(currentEntry, universe, time, uuid, this._manager.model().metaModel());
                                if (currentEntry.counter() > 2) {
                                    currentEntry.addDependency(universe, time, uuid);
                                    this._spaceManager.markMemoryElement(clonedChunk);
                                }
                                if (!needUniverseCopy) {
                                    timeTree.insertKey(time);
                                } else {
                                    var newTemporalTree: memory.chunk.KLongTree = <memory.chunk.KLongTree>this._spaceManager.createAndMark(universe, KConfig.NULL_LONG, uuid, memory.space.KChunkTypes.LONG_TREE);
                                    newTemporalTree.insertKey(time);
                                    this._spaceManager.unmarkMemoryElement(timeTree);
                                    objectUniverseTree.put(universe, time);
                                }
                                this._spaceManager.unmarkMemoryElement(currentEntry);
                                this._spaceManager.unmarkMemoryElement(currentEntry);
                                this._spaceManager.unmarkMemoryElement(timeTree);
                                this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                return clonedChunk;
                            } else {
                                console.error("Should not be here !!!!");;
                                this._spaceManager.unmarkMemoryElement(timeTree);
                                this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                var waitingChunk: memory.chunk.KObjectChunk = <memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                                var i: number = 0;
                                while (waitingChunk == null && i < KConfig.CAS_MAX_TRY){
                                    waitingChunk = <memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                                    i++;
                                }
                                if (waitingChunk == null) {
                                    throw new Error("CAS synchronisation problem!");
                                } else {
                                    this._spaceManager.unmarkMemoryElement(currentEntry);
                                    return waitingChunk;
                                }
                            }
                        }
                    } else {
                        this._spaceManager.unmarkMemoryElement(timeTree);
                        this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                        this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                        return null;
                    }
                }

                public indexObject(obj: KObject): void {
                    var metaClassIndex: number = obj.metaClass().index();
                    var chunkType: number = memory.space.KChunkTypes.OBJECT_CHUNK;
                    if (metaClassIndex == meta.impl.MetaClassIndex.INSTANCE.index()) {
                        chunkType = memory.space.KChunkTypes.OBJECT_CHUNK_INDEX;
                    }
                    var cacheEntry: memory.chunk.KObjectChunk = <memory.chunk.KObjectChunk>this._spaceManager.createAndMark(obj.universe(), obj.now(), obj.uuid(), chunkType);
                    cacheEntry.init(null, this._manager.model().metaModel(), metaClassIndex);
                    cacheEntry.setFlags(memory.KChunkFlags.DIRTY_BIT, 0);
                    cacheEntry.space().declareDirty(cacheEntry);
                    var timeTree: memory.chunk.KLongTree = <memory.chunk.KLongTree>this._spaceManager.createAndMark(obj.universe(), KConfig.NULL_LONG, obj.uuid(), memory.space.KChunkTypes.LONG_TREE);
                    timeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                    timeTree.insertKey(obj.now());
                    var universeTree: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>this._spaceManager.createAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, obj.uuid(), memory.space.KChunkTypes.LONG_LONG_MAP);
                    universeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                    universeTree.put(obj.universe(), obj.now());
                    this._spaceManager.register(obj);
                }

                public getOrLoadAndMark(universe: number, time: number, uuid: number, callback: KCallback<memory.KChunk>): void {
                    if (universe == KContentKey.NULL_KEY[0] && time == KContentKey.NULL_KEY[1] && uuid == KContentKey.NULL_KEY[2]) {
                        callback(null);
                        return;
                    }
                    var cached: memory.KChunk = this._spaceManager.getAndMark(universe, time, uuid);
                    if (cached != null) {
                        callback(cached);
                    } else {
                        this.load(new Float64Array([universe, time, uuid]),  (loadedElements : memory.KChunk[]) => {
                            callback(loadedElements[0]);
                        });
                    }
                }

                public getOrLoadAndMarkAll(keys: Float64Array, callback: KCallback<memory.KChunk[]>): void {
                    var nbKeys: number = keys.length / DistortedTimeResolver.KEYS_SIZE;
                    var toLoadIndexes: boolean[] = new Array();
                    var nbElem: number = 0;
                    var result: memory.KChunk[] = new Array();
                    for (var i: number = 0; i < nbKeys; i++) {
                        if (keys[i * DistortedTimeResolver.KEYS_SIZE] == KContentKey.NULL_KEY[0] && keys[i * DistortedTimeResolver.KEYS_SIZE + 1] == KContentKey.NULL_KEY[1] && keys[i * DistortedTimeResolver.KEYS_SIZE + 2] == KContentKey.NULL_KEY[2]) {
                            toLoadIndexes[i] = false;
                            result[i] = null;
                        } else {
                            result[i] = this._spaceManager.getAndMark(keys[i * DistortedTimeResolver.KEYS_SIZE], keys[i * DistortedTimeResolver.KEYS_SIZE + 1], keys[i * DistortedTimeResolver.KEYS_SIZE + 2]);
                            if (result[i] == null) {
                                toLoadIndexes[i] = true;
                                nbElem++;
                            } else {
                                toLoadIndexes[i] = false;
                            }
                        }
                    }
                    if (nbElem == 0) {
                        callback(result);
                    } else {
                        var keysToLoad: Float64Array = new Float64Array(nbElem * 3);
                        var lastInsertedIndex: number = 0;
                        for (var i: number = 0; i < nbKeys; i++) {
                            if (toLoadIndexes[i]) {
                                keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE];
                                lastInsertedIndex++;
                                keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE + 1];
                                lastInsertedIndex++;
                                keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE + 2];
                                lastInsertedIndex++;
                            }
                        }
                        this.load(keysToLoad,  (loadedElements : memory.KChunk[]) => {
                            var currentIndexToMerge: number = 0;
                            for (var i: number = 0; i < nbKeys; i++) {
                                if (toLoadIndexes[i]) {
                                    result[i] = loadedElements[currentIndexToMerge];
                                    currentIndexToMerge++;
                                }
                            }
                            callback(result);
                        });
                    }
                }

                public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: KCallback<Float64Array>): void {
                    var keys: Float64Array = new Float64Array([KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG, KConfig.NULL_LONG, currentUuid]);
                    this.getOrLoadAndMarkAll(keys,  (kMemoryChunks : memory.KChunk[]) => {
                        if (kMemoryChunks == null || kMemoryChunks.length == 0) {
                            callback(new Float64Array(0));
                            return;
                        }
                        var collectedUniverse: Float64Array = memory.resolver.impl.DistortedTimeResolver.universeSelectByRange(<memory.chunk.KLongLongMap>kMemoryChunks[0], <memory.chunk.KLongLongMap>kMemoryChunks[1], startTime, endTime, currentUniverse);
                        var nbKeys: number = collectedUniverse.length * 3;
                        var timeTreeKeys: Float64Array = new Float64Array(nbKeys);
                        for (var i: number = 0; i < collectedUniverse.length; i++) {
                            timeTreeKeys[i * 3] = collectedUniverse[i];
                            timeTreeKeys[i * 3 + 1] = KConfig.NULL_LONG;
                            timeTreeKeys[i * 3 + 2] = currentUuid;
                        }
                        var objUniverse: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>kMemoryChunks[1];
                        this.getOrLoadAndMarkAll(timeTreeKeys,  (timeTrees : memory.KChunk[]) => {
                            if (timeTrees == null || timeTrees.length == 0) {
                                this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                                callback(new Float64Array(0));
                                return;
                            }
                            var collector: memory.chunk.impl.ArrayLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                            var previousDivergenceTime: number = endTime;
                            for (var i: number = 0; i < collectedUniverse.length; i++) {
                                var timeTree: memory.chunk.KLongTree = <memory.chunk.KLongTree>timeTrees[i];
                                if (timeTree != null) {
                                    var currentDivergenceTime: number = objUniverse.get(collectedUniverse[i]);
                                    currentDivergenceTime = currentDivergenceTime > startTime ? currentDivergenceTime : startTime;
                                    var finalPreviousDivergenceTime: number = previousDivergenceTime;
                                    timeTree.range(currentDivergenceTime, previousDivergenceTime,  (t : number) => {
                                        if (collector.size() == 0) {
                                            collector.put(collector.size(), t);
                                        } else {
                                            if (t != finalPreviousDivergenceTime) {
                                                collector.put(collector.size(), t);
                                            }
                                        }
                                    });
                                    previousDivergenceTime = currentDivergenceTime;
                                }
                            }
                            var orderedTime: Float64Array = new Float64Array(collector.size());
                            for (var i: number = 0; i < collector.size(); i++) {
                                orderedTime[i] = collector.get(i);
                            }
                            this._spaceManager.unmarkAllMemoryElements(timeTrees);
                            this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                            callback(orderedTime);
                        });
                    });
                }

                public static resolve_universe(globalTree: memory.chunk.KLongLongMap, objUniverseTree: memory.chunk.KLongLongMap, timeToResolve: number, originUniverseId: number): number {
                    if (globalTree == null || objUniverseTree == null) {
                        return originUniverseId;
                    }
                    var currentUniverse: number = originUniverseId;
                    var previousUniverse: number = KConfig.NULL_LONG;
                    var divergenceTime: number = objUniverseTree.get(currentUniverse);
                    while (currentUniverse != previousUniverse){
                        if (divergenceTime != KConfig.NULL_LONG && divergenceTime <= timeToResolve) {
                            return currentUniverse;
                        }
                        previousUniverse = currentUniverse;
                        currentUniverse = globalTree.get(currentUniverse);
                        divergenceTime = objUniverseTree.get(currentUniverse);
                    }
                    return originUniverseId;
                }

                public static universeSelectByRange(globalTree: memory.chunk.KLongLongMap, objUniverseTree: memory.chunk.KLongLongMap, rangeMin: number, rangeMax: number, originUniverseId: number): Float64Array {
                    var collected: memory.chunk.KLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                    var currentUniverse: number = originUniverseId;
                    var previousUniverse: number = KConfig.NULL_LONG;
                    var divergenceTime: number = objUniverseTree.get(currentUniverse);
                    while (currentUniverse != previousUniverse){
                        if (divergenceTime != KConfig.NULL_LONG) {
                            if (divergenceTime <= rangeMin) {
                                collected.put(collected.size(), currentUniverse);
                                break;
                            } else {
                                if (divergenceTime <= rangeMax) {
                                    collected.put(collected.size(), currentUniverse);
                                }
                            }
                        }
                        previousUniverse = currentUniverse;
                        currentUniverse = globalTree.get(currentUniverse);
                        divergenceTime = objUniverseTree.get(currentUniverse);
                    }
                    var trimmed: Float64Array = new Float64Array(collected.size());
                    for (var i: number = 0; i < collected.size(); i++) {
                        trimmed[<number>i] = collected.get(i);
                    }
                    return trimmed;
                }

                private load(keys: Float64Array, callback: KCallback<memory.KChunk[]>): void {
                    this._manager.cdn().get(keys,  (payloads : string[]) => {
                        var results: memory.KChunk[] = new Array();
                        for (var i: number = 0; i < payloads.length; i++) {
                            var loopUniverse: number = keys[i * 3];
                            var loopTime: number = keys[i * 3 + 1];
                            var loopUuid: number = keys[i * 3 + 2];
                            var elemType: number;
                            if (loopUniverse == KConfig.NULL_LONG) {
                                elemType = memory.space.KChunkTypes.LONG_LONG_MAP;
                            } else {
                                if (loopTime == KConfig.NULL_LONG) {
                                    elemType = memory.space.KChunkTypes.LONG_TREE;
                                } else {
                                    if (payloads[i] == null || payloads[i].length < 1) {
                                        elemType = memory.space.KChunkTypes.OBJECT_CHUNK;
                                    } else {
                                        var flag: string = payloads[i].charAt(0);
                                        if (flag == '#') {
                                            elemType = memory.space.KChunkTypes.OBJECT_CHUNK_INDEX;
                                        } else {
                                            elemType = memory.space.KChunkTypes.OBJECT_CHUNK;
                                        }
                                    }
                                }
                            }
                            results[i] = this._spaceManager.createAndMark(loopUniverse, loopTime, loopUuid, elemType);
                            var classIndex: number = -1;
                            if (loopUniverse != KConfig.NULL_LONG && loopTime != KConfig.NULL_LONG && loopUuid != KConfig.NULL_LONG) {
                                var alreadyLoadedOrder: memory.chunk.KLongLongMap = <memory.chunk.KLongLongMap>this._spaceManager.getAndMark(KConfig.NULL_LONG, KConfig.NULL_LONG, loopUuid);
                                if (alreadyLoadedOrder != null) {
                                    classIndex = alreadyLoadedOrder.metaClassIndex();
                                    this._spaceManager.unmarkMemoryElement(alreadyLoadedOrder);
                                }
                            }
                            results[i].init(payloads[i], this._manager.model().metaModel(), classIndex);
                        }
                        callback(results);
                    });
                }

                public getRelatedKeysResultSize(): number {
                    return 4;
                }

                public getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void {
                    result[0] = universe;
                    result[1] = time;
                    result[2] = uuid;
                    result[3] = universe;
                    result[4] = KConfig.NULL_LONG;
                    result[5] = uuid;
                    result[6] = KConfig.NULL_LONG;
                    result[7] = KConfig.NULL_LONG;
                    result[8] = uuid;
                    result[9] = KConfig.NULL_LONG;
                    result[10] = KConfig.NULL_LONG;
                    result[11] = KConfig.NULL_LONG;
                }

            }

        }
    }
    export namespace space {
        export interface KChunkIterator {

            hasNext(): boolean;

            next(): Float64Array;

            size(): number;

        }

        export interface KChunkSpace {

            get(universe: number, time: number, obj: number): memory.KChunk;

            create(universe: number, time: number, obj: number, type: number): memory.KChunk;

            clone(previousElement: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;

            clear(metaModel: meta.KMetaModel): void;

            free(metaModel: meta.KMetaModel): void;

            remove(universe: number, time: number, obj: number, metaModel: meta.KMetaModel): void;

            size(): number;

            detachDirties(): memory.space.KChunkIterator;

            declareDirty(dirtyChunk: memory.KChunk): void;

            printDebug(p_metaModel: meta.KMetaModel): void;

        }

        export interface KChunkSpaceManager {

            getAndMark(universe: number, time: number, obj: number): memory.KChunk;

            unmark(universe: number, time: number, obj: number): void;

            createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk;

            unmarkMemoryElement(element: memory.KChunk): void;

            markMemoryElement(element: memory.KChunk): void;

            unmarkAllMemoryElements(elements: memory.KChunk[]): void;

            cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk;

            clear(): void;

            register(object: KObject): void;

            registerAll(objects: KObject[]): void;

            setResolver(resolver: memory.resolver.KResolver): void;

        }

        export class KChunkTypes {

            public static OBJECT_CHUNK: number = 0;
            public static OBJECT_CHUNK_INDEX: number = 1;
            public static LONG_TREE: number = 2;
            public static LONG_LONG_MAP: number = 3;
        }

        export namespace impl {
            export class AbstractCountingChunkSpaceManager implements memory.space.KChunkSpaceManager {

                public _space: memory.space.KChunkSpace;
                public _metaModel: meta.KMetaModel;
                constructor(p_storage: memory.space.KChunkSpace) {
                    this._space = p_storage;
                }

                public getAndMark(universe: number, time: number, obj: number): memory.KChunk {
                    var resolvedElement: memory.KChunk = this._space.get(universe, time, obj);
                    if (resolvedElement != null && (resolvedElement.getFlags() & memory.KChunkFlags.REMOVED_BIT) != memory.KChunkFlags.REMOVED_BIT) {
                        resolvedElement.inc();
                    }
                    return resolvedElement;
                }

                public unmark(universe: number, time: number, obj: number): void {
                    var resolvedElement: memory.KChunk = this._space.get(universe, time, obj);
                    if (resolvedElement != null) {
                        var newCount: number = resolvedElement.dec();
                        if (newCount <= 0) {
                            this.cleanDependenciesAndPotentiallyRemoveChunk(resolvedElement);
                        }
                    }
                }

                public createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk {
                    var newCreatedElement: memory.KChunk = this._space.create(universe, time, obj, type);
                    if (newCreatedElement != null) {
                        newCreatedElement.inc();
                    }
                    return newCreatedElement;
                }

                public unmarkMemoryElement(element: memory.KChunk): void {
                    var newCount: number = element.dec();
                    if (newCount <= 0) {
                        this.cleanDependenciesAndPotentiallyRemoveChunk(element);
                    }
                }

                public markMemoryElement(element: memory.KChunk): void {
                    element.inc();
                }

                public unmarkAllMemoryElements(elements: memory.KChunk[]): void {
                    for (var i: number = 0; i < elements.length; i++) {
                        var loopChunk: memory.KChunk = elements[i];
                        var newCount: number = elements[i].dec();
                        if (newCount <= 0) {
                            this.cleanDependenciesAndPotentiallyRemoveChunk(loopChunk);
                        }
                    }
                }

                private cleanDependenciesAndPotentiallyRemoveChunk(toRemoveChunk: memory.KChunk): void {
                    var dependencies: Float64Array = toRemoveChunk.dependencies();
                    if (dependencies != null && dependencies.length > 0) {
                        for (var i: number = 0; i < dependencies.length; i = i + 3) {
                            this.unmark(dependencies[i], dependencies[i + 1], dependencies[i + 2]);
                        }
                    }
                    if ((toRemoveChunk.getFlags() & memory.KChunkFlags.DIRTY_BIT) != memory.KChunkFlags.DIRTY_BIT) {
                        toRemoveChunk.setFlags(memory.KChunkFlags.REMOVED_BIT, 0);
                        this._space.remove(toRemoveChunk.universe(), toRemoveChunk.time(), toRemoveChunk.obj(), this._metaModel);
                    }
                }

                public cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk {
                    var newCreatedElement: memory.chunk.KObjectChunk = this._space.clone(previous, newUniverse, newTime, obj, metaModel);
                    newCreatedElement.inc();
                    return newCreatedElement;
                }

                public clear(): void {
                }

                public register(object: KObject): void {
                    throw "Abstract method";
                }

                public registerAll(objects: KObject[]): void {
                    throw "Abstract method";
                }

                public setResolver(resolver: memory.resolver.KResolver): void {
                    throw "Abstract method";
                }

            }

            export class ChunkIterator implements memory.space.KChunkIterator {

                private _dirties: Float64Array;
                private _origin: memory.space.KChunkSpace;
                private currentIndex: number = 0;
                private maxIndex: number = 0;
                private tempKeys: Float64Array;
                constructor(p_dirties: Float64Array, p_origin: memory.space.KChunkSpace) {
                    this._dirties = p_dirties;
                    this._origin = p_origin;
                    this.maxIndex = p_dirties.length / 3;
                    this.tempKeys = new Float64Array(3);
                }

                public hasNext(): boolean {
                    return this.currentIndex < this.maxIndex;
                }

                public next(): Float64Array {
                    if (this.currentIndex < this.maxIndex) {
                        this.tempKeys[0] = this._dirties[this.currentIndex * 3];
                        this.tempKeys[1] = this._dirties[this.currentIndex * 3 + 1];
                        this.tempKeys[2] = this._dirties[this.currentIndex * 3 + 2];
                    }
                    this.currentIndex++;
                    return this.tempKeys;
                }

                public size(): number {
                    return this.maxIndex;
                }

            }

            export class HeapChunkSpace implements memory.space.KChunkSpace {

                private static LOAD_FACTOR: number = (<number>75 / <number>100);
                private _state: java.util.concurrent.atomic.AtomicReference<memory.space.impl.HeapChunkSpace.InternalState>;
                private _dirtyState: java.util.concurrent.atomic.AtomicReference<memory.space.impl.HeapChunkSpace.InternalDirtyState>;
                constructor() {
                    this._dirtyState = new java.util.concurrent.atomic.AtomicReference<memory.space.impl.HeapChunkSpace.InternalDirtyState>();
                    this._state = new java.util.concurrent.atomic.AtomicReference<memory.space.impl.HeapChunkSpace.InternalState>();
                    this._dirtyState.set(new memory.space.impl.HeapChunkSpace.InternalDirtyState());
                    var initialCapacity: number = KConfig.CACHE_INIT_SIZE;
                    var newstate: memory.space.impl.HeapChunkSpace.InternalState = new memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array());
                    for (var i: number = 0; i < initialCapacity; i++) {
                        newstate.elementNext[i] = -1;
                        newstate.elementHash.set(i, -1);
                    }
                    newstate._threshold = <number>(newstate.elementDataSize * HeapChunkSpace.LOAD_FACTOR);
                    this._state.set(newstate);
                }

                public get(universe: number, time: number, obj: number): memory.KChunk {
                    var internalState: memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                    if (internalState.elementDataSize == 0) {
                        return null;
                    }
                    var index: number = ((<number>(universe ^ time ^ obj)) & 0x7FFFFFFF) % internalState.elementDataSize;
                    var m: number = internalState.elementHash.get(index);
                    while (m != -1){
                        if (universe == internalState.elementK3[(m * 3)] && time == internalState.elementK3[((m * 3) + 1)] && obj == internalState.elementK3[((m * 3) + 2)]) {
                            return internalState.values[m];
                        } else {
                            m = internalState.elementNext[m];
                        }
                    }
                    return null;
                }

                public create(universe: number, time: number, obj: number, type: number): memory.KChunk {
                    var newElement: memory.KChunk = this.internal_createElement(universe, time, obj, type);
                    return this.internal_put(universe, time, obj, newElement);
                }

                public clone(previousElement: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk {
                    return <memory.chunk.KObjectChunk>this.internal_put(newUniverse, newTime, newObj, previousElement.clone(newUniverse, newTime, newObj, metaModel));
                }

                private internal_createElement(p_universe: number, p_time: number, p_obj: number, type: number): memory.KChunk {
                    switch (type) {
                        case memory.space.KChunkTypes.OBJECT_CHUNK:
                            return new memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this);
                        case memory.space.KChunkTypes.LONG_LONG_MAP:
                            return new memory.chunk.impl.ArrayLongLongMap(p_universe, p_time, p_obj, this);
                        case memory.space.KChunkTypes.LONG_TREE:
                            return new memory.chunk.impl.ArrayLongTree(p_universe, p_time, p_obj, this);
                        case memory.space.KChunkTypes.OBJECT_CHUNK_INDEX:
                            return new memory.chunk.impl.HeapObjectIndexChunk(p_universe, p_time, p_obj, this);
                        default:
                            return null;
                    }
                }

                private internal_put(universe: number, time: number, p_obj: number, payload: memory.KChunk): memory.KChunk {
                    var currentState: memory.space.impl.HeapChunkSpace.InternalState;
                    var nextState: memory.space.impl.HeapChunkSpace.InternalState;
                    var result: memory.KChunk;
                    var nbTry: number = 0;
                    do {
                        currentState = this._state.get();
                        var entry: number = -1;
                        var index: number = -1;
                        var hash: number = <number>(universe ^ time ^ p_obj);
                        if (currentState.elementDataSize != 0) {
                            index = (hash & 0x7FFFFFFF) % currentState.elementDataSize;
                            entry = this.findNonNullKeyEntry(universe, time, p_obj, index, currentState);
                        }
                        if (entry == -1) {
                            var nextValueIndex: number = currentState._valuesIndex.getAndIncrement();
                            if (nextValueIndex > currentState._threshold) {
                                return this.complex_insert(universe, time, p_obj, payload, hash, nextValueIndex);
                            } else {
                                nextState = currentState;
                            }
                            nextState.elementK3[(nextValueIndex * 3)] = universe;
                            nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                            nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                            nextState.values[nextValueIndex] = payload;
                            nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                            nextState._elementCount.incrementAndGet();
                            result = payload;
                        } else {
                            nextState = currentState;
                            result = nextState.values[entry];
                        }
                        nbTry++;
                        if (nbTry == KConfig.CAS_MAX_TRY) {
                            throw new Error("CompareAndSwap error, failed to converge");
                        }
                    } while (!this._state.compareAndSet(currentState, nextState))
                    return result;
                }

                private complex_insert(universe: number, time: number, p_obj: number, payload: memory.KChunk, prehash: number, nextValueIndex: number): memory.KChunk {
                    var currentState: memory.space.impl.HeapChunkSpace.InternalState;
                    var nextState: memory.space.impl.HeapChunkSpace.InternalState;
                    do {
                        currentState = this._state.get();
                        if (nextValueIndex > currentState._threshold) {
                            nextState = this.rehashCapacity(currentState);
                        } else {
                            nextState = currentState;
                        }
                        var index: number = (prehash & 0x7FFFFFFF) % nextState.elementDataSize;
                        nextState.elementK3[(nextValueIndex * 3)] = universe;
                        nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                        nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                        nextState.values[nextValueIndex] = payload;
                        nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                        nextState._elementCount.incrementAndGet();
                    } while (!this._state.compareAndSet(currentState, nextState))
                    return payload;
                }

                private rehashCapacity(previousState: memory.space.impl.HeapChunkSpace.InternalState): memory.space.impl.HeapChunkSpace.InternalState {
                    var length: number = (previousState.elementDataSize == 0 ? 1 : previousState.elementDataSize << 1);
                    var newElementKV: Float64Array = new Float64Array(length * 3);
                    var newValues: memory.KChunk[] = new Array();
                    var previousIsSparse: boolean = previousState.sparse;
                    if (!previousIsSparse) {
                        java.lang.System.arraycopy(previousState.elementK3, 0, newElementKV, 0, previousState.elementDataSize * 3);
                        java.lang.System.arraycopy(previousState.values, 0, newValues, 0, previousState.elementDataSize);
                    }
                    var newElementNext: Int32Array = new Int32Array(length);
                    var newElementHash: Int32Array = new Int32Array(length);
                    for (var i: number = 0; i < length; i++) {
                        newElementNext[i] = -1;
                        newElementHash[i] = -1;
                    }
                    var currentIndex: number = 0;
                    for (var i: number = 0; i < previousState.elementDataSize; i++) {
                        if (previousState.values[i] != null) {
                            var hash: number = <number>(previousState.elementK3[(i * 3)] ^ previousState.elementK3[(i * 3) + 1] ^ previousState.elementK3[(i * 3) + 2]);
                            var index: number = (hash & 0x7FFFFFFF) % length;
                            newElementNext[i] = newElementHash[index];
                            newElementHash[index] = i;
                            if (previousIsSparse) {
                                newValues[currentIndex] = previousState.values[i];
                                newElementKV[(currentIndex * 3)] = previousState.elementK3[(i * 3)];
                                newElementKV[(currentIndex * 3) + 1] = previousState.elementK3[(i * 3) + 1];
                                newElementKV[(currentIndex * 3) + 2] = previousState.elementK3[(i * 3) + 2];
                                currentIndex++;
                            }
                        }
                    }
                    var newState: memory.space.impl.HeapChunkSpace.InternalState = new memory.space.impl.HeapChunkSpace.InternalState(length, newElementKV, newElementNext, newElementHash, newValues);
                    newState._threshold = <number>(length * HeapChunkSpace.LOAD_FACTOR);
                    newState._valuesIndex.set(previousState._valuesIndex.get());
                    if (previousIsSparse) {
                        newState._elementCount.set(currentIndex);
                        newState._valuesIndex.set(currentIndex);
                    } else {
                        newState._elementCount.set(previousState._elementCount.get());
                        newState._valuesIndex.set(previousState._valuesIndex.get());
                    }
                    return newState;
                }

                public findNonNullKeyEntry(universe: number, time: number, obj: number, index: number, internalState: memory.space.impl.HeapChunkSpace.InternalState): number {
                    var m: number = internalState.elementHash.get(index);
                    while (m >= 0){
                        if (universe == internalState.elementK3[m * 3] && time == internalState.elementK3[(m * 3) + 1] && obj == internalState.elementK3[(m * 3) + 2]) {
                            return m;
                        }
                        m = internalState.elementNext[m];
                    }
                    return -1;
                }

                public detachDirties(): memory.space.KChunkIterator {
                    var detachedState: memory.space.impl.HeapChunkSpace.InternalDirtyState = this._dirtyState.getAndSet(new memory.space.impl.HeapChunkSpace.InternalDirtyState());
                    var maxIndex: number = detachedState._dirtyIndex.get();
                    var shrinked: Float64Array = new Float64Array(maxIndex * 3);
                    java.lang.System.arraycopy(detachedState._dirtyList, 0, shrinked, 0, maxIndex * 3);
                    return new memory.space.impl.ChunkIterator(shrinked, this);
                }

                public declareDirty(dirtyChunk: memory.KChunk): void {
                    var nbTry: number = 0;
                    var current: memory.space.impl.HeapChunkSpace.InternalDirtyState;
                    do {
                        current = this._dirtyState.get();
                        current.declareDirty(dirtyChunk.universe(), dirtyChunk.time(), dirtyChunk.obj());
                        nbTry++;
                        if (nbTry == KConfig.CAS_MAX_TRY) {
                            throw new Error("CompareAndSwap error, failed to converge");
                        }
                    } while (!this._dirtyState.compareAndSet(current, current))
                }

                public remove(universe: number, time: number, obj: number, p_metaModel: meta.KMetaModel): void {
                    var previousState: memory.space.impl.HeapChunkSpace.InternalState;
                    var nbTry: number = 0;
                    do {
                        previousState = this._state.get();
                        var hash: number = <number>(universe ^ time ^ obj);
                        var index: number = (hash & 0x7FFFFFFF) % previousState.elementDataSize;
                        if (previousState.elementDataSize == 0) {
                            return;
                        }
                        var m: number = previousState.elementHash.get(index);
                        var last: number = -1;
                        while (m >= 0){
                            if (universe == previousState.elementK3[m * 3] && time == previousState.elementK3[(m * 3) + 1] && obj == previousState.elementK3[(m * 3) + 2]) {
                                break;
                            }
                            last = m;
                            m = previousState.elementNext[m];
                        }
                        if (m == -1) {
                            return;
                        }
                        if (last == -1) {
                            var previousNext: number = previousState.elementNext[m];
                            if (!previousState.elementHash.compareAndSet(index, m, previousNext)) {
                            }
                        } else {
                            previousState.elementNext[last] = previousState.elementNext[m];
                        }
                        previousState.elementNext[m] = -1;
                        var previousValue: memory.KChunk = previousState.values[m];
                        previousState.values[m] = null;
                        if (previousValue != null) {
                            previousValue.free(p_metaModel);
                        }
                        previousState._elementCount.decrementAndGet();
                        nbTry++;
                        if (nbTry == KConfig.CAS_MAX_TRY) {
                            throw new Error("CompareAndSwap error, failed to converge");
                        }
                    } while (!this._state.compareAndSet(previousState, previousState))
                }

                public clear(metaModel: meta.KMetaModel): void {
                    var previousState: memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                    if (previousState._elementCount.get() > 0) {
                        for (var i: number = 0; i < previousState.elementDataSize; i++) {
                            if (previousState.values[i] != null) {
                                previousState.values[i].free(metaModel);
                            }
                        }
                        var initialCapacity: number = KConfig.CACHE_INIT_SIZE;
                        var newstate: memory.space.impl.HeapChunkSpace.InternalState = new memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array());
                        for (var i: number = 0; i < initialCapacity; i++) {
                            newstate.elementNext[i] = -1;
                            newstate.elementHash.set(i, -1);
                        }
                        newstate._elementCount.set(0);
                        newstate._valuesIndex.set(0);
                        newstate._threshold = <number>(newstate.elementDataSize * HeapChunkSpace.LOAD_FACTOR);
                        this._state.set(newstate);
                    }
                }

                public free(metaModel: meta.KMetaModel): void {
                    var internalState: memory.space.impl.HeapChunkSpace.InternalState = this._state.getAndSet(null);
                    for (var i: number = 0; i < internalState.elementDataSize; i++) {
                        if (internalState.values[i] != null) {
                            internalState.values[i].free(metaModel);
                        }
                    }
                    internalState._elementCount.set(0);
                    internalState._valuesIndex.set(0);
                    internalState._threshold = 0;
                }

                public printDebug(p_metaModel: meta.KMetaModel): void {
                    try {
                        var state: memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                        for (var i: number = 0; i < state.values.length; i++) {
                            var loopChunk: memory.KChunk = state.values[i];
                            if (loopChunk != null) {
                                var content: string = loopChunk.serialize(p_metaModel);
                                console.log(state.elementK3[i * 3] + "," + state.elementK3[i * 3 + 1] + "," + state.elementK3[i * 3 + 2] + "=>" + loopChunk.type() + "(count:" + loopChunk.counter() + ",flag:" + loopChunk.getFlags() + ")" + "==>" + content);;
                            }
                        }
                    } catch ($ex$) {
                        if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);;
                        } else {
                            throw $ex$;
                        }
                    }
                }

                public size(): number {
                    return this._state.get()._elementCount.get();
                }

            }

            export namespace HeapChunkSpace {
                export class InternalState {

                    public sparse: boolean = false;
                    public elementDataSize: number;
                    public elementK3: Float64Array;
                    public elementNext: Int32Array;
                    public elementHash: java.util.concurrent.atomic.AtomicIntegerArray;
                    public values: memory.KChunk[];
                    public _elementCount: java.util.concurrent.atomic.AtomicInteger;
                    public _valuesIndex: java.util.concurrent.atomic.AtomicInteger;
                    public _threshold: number;
                    constructor(p_elementDataSize: number, p_elementKE: Float64Array, p_elementNext: Int32Array, p_elementHash: Int32Array, p_values: memory.KChunk[]) {
                        this.elementDataSize = p_elementDataSize;
                        this.elementK3 = p_elementKE;
                        this.elementNext = p_elementNext;
                        this.elementHash = new java.util.concurrent.atomic.AtomicIntegerArray(p_elementHash);
                        this.values = p_values;
                        this._elementCount = new java.util.concurrent.atomic.AtomicInteger(0);
                        this._valuesIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                    }

                }


                export class InternalDirtyState {

                    public _dirtyList: Float64Array;
                    public _dirtyIndex: java.util.concurrent.atomic.AtomicInteger;
                    constructor() {
                        this._dirtyList = new Float64Array(KConfig.CACHE_INIT_SIZE * 3);
                        this._dirtyIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                    }

                    public declareDirty(universe: number, time: number, obj: number): void {
                        var nextIndex: number = this._dirtyIndex.getAndIncrement() * 3;
                        if (nextIndex + 2 < this._dirtyList.length) {
                            this._dirtyList[nextIndex] = universe;
                            this._dirtyList[nextIndex + 1] = time;
                            this._dirtyList[nextIndex + 2] = obj;
                        } else {
                            this.reallocate(nextIndex);
                            this._dirtyList[nextIndex] = universe;
                            this._dirtyList[nextIndex + 1] = time;
                            this._dirtyList[nextIndex + 2] = obj;
                        }
                    }

                    private reallocate(wantedIndex: number): void {
                        if (wantedIndex + 2 >= this._dirtyList.length) {
                            var newlength: number = wantedIndex << 1;
                            var previousList: Float64Array = this._dirtyList;
                            this._dirtyList = new Float64Array(newlength);
                            java.lang.System.arraycopy(previousList, 0, this._dirtyList, 0, wantedIndex);
                        }
                    }

                }


            }
            export class NoopChunkSpaceManager implements memory.space.KChunkSpaceManager {

                private _space: memory.space.KChunkSpace;
                constructor(p_space: memory.space.KChunkSpace) {
                    this._space = p_space;
                }

                public getAndMark(universe: number, time: number, obj: number): memory.KChunk {
                    return this._space.get(universe, time, obj);
                }

                public unmark(universe: number, time: number, obj: number): void {
                }

                public createAndMark(universe: number, time: number, obj: number, type: number): memory.KChunk {
                    return this._space.create(universe, time, obj, type);
                }

                public unmarkMemoryElement(element: memory.KChunk): void {
                }

                public markMemoryElement(element: memory.KChunk): void {
                }

                public unmarkAllMemoryElements(elements: memory.KChunk[]): void {
                }

                public cloneAndMark(previous: memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: meta.KMetaModel): memory.chunk.KObjectChunk {
                    return this._space.clone(previous, newUniverse, newTime, obj, metaModel);
                }

                public clear(): void {
                }

                public register(object: KObject): void {
                }

                public registerAll(objects: KObject[]): void {
                }

                public setResolver(resolver: memory.resolver.KResolver): void {
                }

            }

        }
    }
    export namespace strategy {
        export interface KMemoryStrategy {

            newSpace(): memory.space.KChunkSpace;

            newSpaceManager(space: memory.space.KChunkSpace, scheduler: scheduler.KScheduler): memory.space.KChunkSpaceManager;

        }

        export namespace impl {
            export class HeapMemoryStrategy implements memory.strategy.KMemoryStrategy {

                public newSpace(): memory.space.KChunkSpace {
                    return new memory.space.impl.HeapChunkSpace();
                }

                public newSpaceManager(p_space: memory.space.KChunkSpace, p_scheduler: scheduler.KScheduler): memory.space.KChunkSpaceManager {
                    return new memory.space.impl.NoopChunkSpaceManager(p_space);
                }

            }

        }
    }
}
export namespace message {
    export interface KMessage {

        id(): number;

        setID(val: number): void;

        type(): number;

        setType(val: number): void;

        operationName(): string;

        setOperationName(val: string): void;

        className(): string;

        setClassName(val: string): void;

        keys(): Float64Array;

        setKeys(val: Float64Array): void;

        values(): string[];

        setValues(val: string[]): void;

        values2(): string[];

        setValues2(val: string[]): void;

        peer(): string;

        setPeer(val: string): void;

        save(): string;

    }

    export namespace impl {
        export class Message implements message.KMessage {

            private static TYPE_INDEX: number = 0;
            private static ID_INDEX: number = 1;
            private static OPERATION_INDEX: number = 2;
            private static CLASS_INDEX: number = 3;
            private static PEER_INDEX: number = 4;
            private static KEYS_INDEX: number = 5;
            private static VALUES_INDEX: number = 6;
            private static VALUES2_INDEX: number = 7;
            private static KEYS_NAME: string[] = ['T', 'I', 'O', 'C', 'P', 'K', 'V', 'W'];
            public static EVENTS_TYPE: number = 0;
            public static GET_REQ_TYPE: number = 1;
            public static GET_RES_TYPE: number = 2;
            public static PUT_REQ_TYPE: number = 3;
            public static PUT_RES_TYPE: number = 4;
            public static OPERATION_CALL_TYPE: number = 5;
            public static OPERATION_RESULT_TYPE: number = 6;
            public static ATOMIC_GET_INC_REQUEST_TYPE: number = 7;
            public static ATOMIC_GET_INC_RESULT_TYPE: number = 8;
            public static OPERATION_MAPPING: number = 9;
            private static NB_ELEM: number = 8;
            private internal: any[] = new Array();
            public id(): number {
                return <number>this.internal[Message.ID_INDEX];
            }

            public setID(val: number): void {
                this.internal[Message.ID_INDEX] = val;
            }

            public type(): number {
                return <number>this.internal[Message.TYPE_INDEX];
            }

            public setType(val: number): void {
                this.internal[Message.TYPE_INDEX] = val;
            }

            public operationName(): string {
                return <string>this.internal[Message.OPERATION_INDEX];
            }

            public setOperationName(val: string): void {
                this.internal[Message.OPERATION_INDEX] = val;
            }

            public className(): string {
                return <string>this.internal[Message.CLASS_INDEX];
            }

            public setClassName(val: string): void {
                this.internal[Message.CLASS_INDEX] = val;
            }

            public keys(): Float64Array {
                return <Float64Array>this.internal[Message.KEYS_INDEX];
            }

            public setKeys(val: Float64Array): void {
                this.internal[Message.KEYS_INDEX] = val;
            }

            public values(): string[] {
                return <string[]>this.internal[Message.VALUES_INDEX];
            }

            public setValues(val: string[]): void {
                this.internal[Message.VALUES_INDEX] = val;
            }

            public values2(): string[] {
                return <string[]>this.internal[Message.VALUES2_INDEX];
            }

            public setValues2(val: string[]): void {
                this.internal[Message.VALUES2_INDEX] = val;
            }

            public peer(): string {
                return <string>this.internal[Message.PEER_INDEX];
            }

            public setPeer(val: string): void {
                this.internal[Message.PEER_INDEX] = val;
            }

            public save(): string {
                var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                var isFirst: boolean = true;
                for (var i: number = 0; i < Message.NB_ELEM; i++) {
                    if (this.internal[i] != null) {
                        if (!isFirst) {
                            buffer.append(KConfig.ELEM_SEP);
                        }
                        isFirst = false;
                        buffer.append(Message.KEYS_NAME[i]);
                        buffer.append(KConfig.VAL_SEP);
                        switch (i) {
                            case 0:
                                util.Base64.encodeIntToBuffer(<number>this.internal[i], buffer);
                                break;
                            case 1:
                                util.Base64.encodeIntToBuffer(<number>this.internal[i], buffer);
                                break;
                            case 2:
                                util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                                break;
                            case 3:
                                util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                                break;
                            case 4:
                                util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                                break;
                            case 5:
                                var lkeys: Float64Array = <Float64Array>this.internal[i];
                                util.Base64.encodeIntToBuffer(lkeys.length, buffer);
                                for (var j: number = 0; j < lkeys.length; j++) {
                                    buffer.append(KConfig.VAL_SEP);
                                    util.Base64.encodeLongToBuffer(lkeys[j], buffer);
                                }
                                break;
                            case 6:
                                var lvalues: string[] = <string[]>this.internal[i];
                                util.Base64.encodeIntToBuffer(lvalues.length, buffer);
                                for (var j: number = 0; j < lvalues.length; j++) {
                                    buffer.append(KConfig.VAL_SEP);
                                    if (lvalues[j] != null) {
                                        util.Base64.encodeStringToBuffer(lvalues[j], buffer);
                                    }
                                }
                                break;
                            case 7:
                                var lvalues2: string[] = <string[]>this.internal[i];
                                util.Base64.encodeIntToBuffer(lvalues2.length, buffer);
                                for (var j: number = 0; j < lvalues2.length; j++) {
                                    buffer.append(KConfig.VAL_SEP);
                                    if (lvalues2[j] != null) {
                                        util.Base64.encodeStringToBuffer(lvalues2[j], buffer);
                                    }
                                }
                                break;
                        }
                    }
                }
                return buffer.toString();
            }

            public static load(payload: string): message.KMessage {
                var msg: message.impl.Message = new message.impl.Message();
                if (payload == null) {
                    return null;
                }
                var i: number = 0;
                var readElemIndex: number = -1;
                var previousValStart: number = -1;
                var longArray: Float64Array = null;
                var stringArray: string[] = null;
                var currentArrayIndex: number = -1;
                var payloadSize: number = payload.length;
                while (i < payloadSize){
                    if (payload.charAt(i) == KConfig.ELEM_SEP) {
                        if (readElemIndex != -1) {
                            if (readElemIndex < 2) {
                                msg.internal[readElemIndex] = util.Base64.decodeToIntWithBounds(payload, previousValStart, i);
                            } else {
                                if (readElemIndex < 5) {
                                    msg.internal[readElemIndex] = util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                                } else {
                                    if (readElemIndex == 5 && longArray != null) {
                                        longArray[currentArrayIndex] = util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                                        msg.internal[readElemIndex] = longArray;
                                        longArray = null;
                                    } else {
                                        if (stringArray != null) {
                                            stringArray[currentArrayIndex] = util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                                            msg.internal[readElemIndex] = stringArray;
                                            stringArray = null;
                                        }
                                    }
                                }
                            }
                        }
                        previousValStart = -1;
                        readElemIndex = -1;
                    } else {
                        if (payload.charAt(i) == KConfig.VAL_SEP) {
                            if (readElemIndex == -1) {
                                var pastType: string = payload.charAt(i - 1);
                                for (var h: number = 0; h < Message.NB_ELEM; h++) {
                                    if (pastType == Message.KEYS_NAME[h]) {
                                        readElemIndex = h;
                                    }
                                }
                            } else {
                                if (readElemIndex > 5) {
                                    if (stringArray == null) {
                                        stringArray = new Array();
                                        currentArrayIndex = 0;
                                    } else {
                                        stringArray[currentArrayIndex] = util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                                        currentArrayIndex++;
                                    }
                                } else {
                                    if (longArray == null) {
                                        longArray = new Float64Array(util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                                        currentArrayIndex = 0;
                                    } else {
                                        longArray[currentArrayIndex] = util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                                        currentArrayIndex++;
                                    }
                                }
                            }
                            previousValStart = i + 1;
                        }
                    }
                    i++;
                }
                if (readElemIndex != -1) {
                    if (readElemIndex < 2) {
                        msg.internal[readElemIndex] = util.Base64.decodeToInt(payload.substring(previousValStart, i));
                    } else {
                        if (readElemIndex < 5) {
                            msg.internal[readElemIndex] = util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                        } else {
                            if (readElemIndex == 5 && longArray != null) {
                                longArray[currentArrayIndex] = util.Base64.decodeToLong(payload.substring(previousValStart, i));
                                msg.internal[readElemIndex] = longArray;
                            } else {
                                if (stringArray != null) {
                                    stringArray[currentArrayIndex] = util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                                    msg.internal[readElemIndex] = stringArray;
                                }
                            }
                        }
                    }
                }
                return msg;
            }

        }

    }
}
export namespace meta {
    export interface KLiteral extends KMeta {}

    export interface KMeta {

        index(): number;

        metaName(): string;

        metaType(): MetaType;

    }

    export interface KMetaAttribute extends KMeta {

        key(): boolean;

        attributeTypeId(): number;

        strategy(): extrapolation.Extrapolation;

        precision(): number;

        setExtrapolation(extrapolation: extrapolation.Extrapolation): void;

        setPrecision(precision: number): void;

        setKey(key: boolean): void;

    }

    export interface KMetaClass extends KMeta {

        metaElements(): KMeta[];

        meta(index: number): KMeta;

        metaByName(name: string): KMeta;

        metaParents(): Int32Array;

        attribute(name: string): KMetaAttribute;

        reference(name: string): KMetaRelation;

        operation(name: string): KMetaOperation;

        addAttribute(attributeName: string, p_type: KType): KMetaAttribute;

        addRelation(relationName: string, metaClass: KMetaClass, oppositeName: string): KMetaRelation;

        addDependency(dependencyName: string, referredMetaClassIndex: number): KMetaDependency;

        addInput(dependencyName: string, extractor: string): KMetaInferInput;

        addOutput(name: string, metaClass: KType): KMetaInferOutput;

        addOperation(operationName: string): KMetaOperation;

        inferAlg(): infer.KInferAlg;

        dependencies(): KMetaDependencies;

        inputs(): KMetaInferInput[];

        outputs(): KMetaInferOutput[];

        temporalResolution(): number;

        setTemporalResolution(tempo: number): void;

        addParent(parentMetaClass: KMeta): void;

    }

    export interface KMetaDependencies extends KMeta {

        origin(): KMetaClass;

        allDependencies(): KMetaDependency[];

        dependencyByName(dependencyName: string): KMetaDependency;

        addDependency(dependencyName: string, p_referredMetaClassIndex: number): KMetaDependency;

    }

    export interface KMetaDependency extends KMeta {

        referredMetaClassIndex(): number;

    }

    export interface KMetaEnum extends KType, KMeta {

        literals(): KLiteral[];

        literalByName(name: string): KLiteral;

        literal(index: number): KLiteral;

        addLiteral(name: string): KLiteral;

    }

    export interface KMetaInferInput extends KMeta {

        extractorQuery(): string;

        extractor(): traversal.KTraversal;

    }

    export interface KMetaInferOutput extends KMeta {

        attributeTypeId(): number;

    }

    export interface KMetaModel extends KMeta {

        metaClasses(): KMetaClass[];

        metaClassByName(name: string): KMetaClass;

        metaClass(index: number): KMetaClass;

        addMetaClass(metaClassName: string): KMetaClass;

        addInferMetaClass(metaClassName: string, inferAlg: infer.KInferAlg): KMetaClass;

        metaTypes(): KMetaEnum[];

        metaTypeByName(name: string): KMetaEnum;

        addMetaEnum(enumName: string): KMetaEnum;

        createModel(manager: memory.manager.internal.KInternalDataManager): KModel<any>;

    }

    export interface KMetaOperation extends KMeta {

        originMetaClassIndex(): number;

        paramTypes(): Int32Array;

        paramMultiplicities(): boolean[];

        returnType(): number;

        returnTypeIsArray(): boolean;

        addParam(type: KType, isArray: boolean): void;

        setReturnType(type: KType, isArray: boolean): void;

    }

    export interface KMetaRelation extends KMeta {

        originMetaClassIndex(): number;

        referredMetaClassIndex(): number;

        oppositeName(): string;

        visible(): boolean;

        maxBound(): number;

        setMaxBound(bound: number): void;

    }

    export class KPrimitiveTypes {

        public static BOOL_ID: number = -1;
        public static STRING_ID: number = -2;
        public static LONG_ID: number = -3;
        public static INT_ID: number = -4;
        public static DOUBLE_ID: number = -5;
        public static CONTINUOUS_ID: number = -6;
        public static BOOL: KType = new abs.AbstractDataType("BOOL", KPrimitiveTypes.BOOL_ID);
        public static STRING: KType = new abs.AbstractDataType("STRING", KPrimitiveTypes.STRING_ID);
        public static LONG: KType = new abs.AbstractDataType("LONG", KPrimitiveTypes.LONG_ID);
        public static INT: KType = new abs.AbstractDataType("INT", KPrimitiveTypes.INT_ID);
        public static DOUBLE: KType = new abs.AbstractDataType("DOUBLE", KPrimitiveTypes.DOUBLE_ID);
        public static CONTINUOUS: KType = new abs.AbstractDataType("CONTINUOUS", KPrimitiveTypes.CONTINUOUS_ID);
        public static isEnum(attributeTypeId: number): boolean {
            return attributeTypeId >= 0;
        }

    }

    export class MetaType {

        public static ATTRIBUTE: MetaType = new MetaType();
        public static RELATION: MetaType = new MetaType();
        public static DEPENDENCY: MetaType = new MetaType();
        public static DEPENDENCIES: MetaType = new MetaType();
        public static INPUT: MetaType = new MetaType();
        public static OUTPUT: MetaType = new MetaType();
        public static OPERATION: MetaType = new MetaType();
        public static CLASS: MetaType = new MetaType();
        public static MODEL: MetaType = new MetaType();
        public static ENUM: MetaType = new MetaType();
        public static LITERAL: MetaType = new MetaType();
        public equals(other: any): boolean {
            return this == other;
        }
        public static _MetaTypeVALUES : MetaType[] = [
            MetaType.ATTRIBUTE
            ,MetaType.RELATION
            ,MetaType.DEPENDENCY
            ,MetaType.DEPENDENCIES
            ,MetaType.INPUT
            ,MetaType.OUTPUT
            ,MetaType.OPERATION
            ,MetaType.CLASS
            ,MetaType.MODEL
            ,MetaType.ENUM
            ,MetaType.LITERAL
        ];
        public static values():MetaType[]{
            return MetaType._MetaTypeVALUES;
        }
    }

    export namespace impl {
        export class GenericModel extends abs.AbstractKModel<any> {

            private _p_metaModel: KMetaModel;
            constructor(mm: KMetaModel, p_manager: memory.manager.internal.KInternalDataManager) {
                super(p_manager);
                this._p_metaModel = mm;
            }

            public metaModel(): KMetaModel {
                return this._p_metaModel;
            }

            public internalCreateUniverse(universe: number): KUniverse<any, any> {
                return new impl.GenericUniverse(universe, this._manager);
            }

            public internalCreateObject(universe: number, time: number, uuid: number, clazz: KMetaClass, previousUniverse: number, previousTime: number): KObject {
                if (clazz.index() == impl.MetaClassIndex.INSTANCE.index()) {
                    return new impl.GenericObjectIndex(universe, time, uuid, this._manager, previousUniverse, previousTime);
                } else {
                    if (clazz.inferAlg() != null) {
                        return new impl.GenericObjectInfer(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                    } else {
                        return new impl.GenericObject(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                    }
                }
            }

        }

        export class GenericObject extends abs.AbstractKObject {

            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
            }

        }

        export class GenericObjectIndex extends abs.AbstractKObjectIndex {

            constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                super(p_universe, p_time, p_uuid, p_manager, currentUniverse, currentTime);
            }

        }

        export class GenericObjectInfer extends abs.AbstractKObjectInfer {

            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: KMetaClass, p_manager: memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
            }

        }

        export class GenericUniverse extends abs.AbstractKUniverse<any, any> {

            constructor(p_key: number, p_manager: memory.manager.internal.KInternalDataManager) {
                super(p_key, p_manager);
            }

            public internal_create(timePoint: number): KView {
                return new impl.GenericView(this._universe, timePoint, this._manager);
            }

        }

        export class GenericView extends abs.AbstractKView {

            constructor(p_universe: number, _time: number, p_manager: memory.manager.internal.KInternalDataManager) {
                super(p_universe, _time, p_manager);
            }

        }

        export class MetaAttribute implements KMetaAttribute {

            private _name: string;
            private _index: number;
            public _precision: number;
            private _key: boolean;
            private _attributeTypeId: number;
            private _extrapolation: extrapolation.Extrapolation;
            public attributeTypeId(): number {
                return this._attributeTypeId;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.ATTRIBUTE;
            }

            public precision(): number {
                return this._precision;
            }

            public key(): boolean {
                return this._key;
            }

            public strategy(): extrapolation.Extrapolation {
                return this._extrapolation;
            }

            public setExtrapolation(extrapolation: extrapolation.Extrapolation): void {
                this._extrapolation = extrapolation;
            }

            public setPrecision(p_precision: number): void {
                this._precision = p_precision;
            }

            public setKey(p_key: boolean): void {
                this._key = p_key;
            }

            constructor(p_name: string, p_index: number, p_precision: number, p_key: boolean, p_attributeTypeId: number, p_extrapolation: extrapolation.Extrapolation) {
                this._name = p_name;
                this._index = p_index;
                this._precision = p_precision;
                this._key = p_key;
                this._attributeTypeId = p_attributeTypeId;
                this._extrapolation = p_extrapolation;
                if (this._extrapolation == null) {
                    this._extrapolation = extrapolation.impl.DiscreteExtrapolation.instance();
                }
            }

        }

        export class MetaClass implements KMetaClass {

            private _name: string;
            private _index: number;
            private _meta: KMeta[];
            private _indexes: memory.chunk.KStringMap<number> = null;
            private _alg: infer.KInferAlg;
            private _cachedInputs: KMetaInferInput[] = null;
            private _cachedOutputs: KMetaInferOutput[] = null;
            private _parents: Int32Array = null;
            private _temporalResolution: number = 1;
            constructor(p_name: string, p_index: number, p_alg: infer.KInferAlg, p_parents: Int32Array) {
                this._name = p_name;
                this._index = p_index;
                this._meta = new Array();
                this._alg = p_alg;
                this._parents = p_parents;
                this._indexes = new memory.chunk.impl.ArrayStringMap<number>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                if (this._alg != null) {
                    this.internal_add_meta(new impl.MetaDependencies(this._meta.length, this));
                }
            }

            public init(p_metaElements: KMeta[]): void {
                this._indexes.clear();
                this._meta = p_metaElements;
                for (var i: number = 0; i < this._meta.length; i++) {
                    this._indexes.put(p_metaElements[i].metaName(), p_metaElements[i].index());
                }
                this.clearCached();
            }

            public metaByName(name: string): KMeta {
                if (this._indexes != null) {
                    var resolvedIndex: number = this._indexes.get(name);
                    if (resolvedIndex != null) {
                        return this._meta[resolvedIndex];
                    }
                }
                return null;
            }

            public metaParents(): Int32Array {
                return this._parents;
            }

            public attribute(name: string): KMetaAttribute {
                var resolved: KMeta = this.metaByName(name);
                if (resolved != null && resolved.metaType() == MetaType.ATTRIBUTE) {
                    return <meta.KMetaAttribute>resolved;
                }
                return null;
            }

            public reference(name: string): KMetaRelation {
                var resolved: KMeta = this.metaByName(name);
                if (resolved != null && resolved.metaType() == MetaType.RELATION) {
                    return <meta.KMetaRelation>resolved;
                }
                return null;
            }

            public operation(name: string): KMetaOperation {
                var resolved: KMeta = this.metaByName(name);
                if (resolved != null && resolved.metaType() == MetaType.OPERATION) {
                    return <meta.KMetaOperation>resolved;
                }
                return null;
            }

            public metaElements(): KMeta[] {
                return this._meta;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.CLASS;
            }

            public meta(index: number): KMeta {
                if (index >= 0 && index < this._meta.length) {
                    return this._meta[index];
                } else {
                    return null;
                }
            }

            public addAttribute(attributeName: string, p_type: KType): KMetaAttribute {
                return this.internal_addatt(attributeName, p_type);
            }

            private internal_addatt(attributeName: string, p_type: KType): KMetaAttribute {
                var precisionCleaned: number = -1;
                var e: extrapolation.Extrapolation;
                if (p_type.id() == KPrimitiveTypes.CONTINUOUS_ID) {
                    e = extrapolation.impl.PolynomialExtrapolation.instance();
                    precisionCleaned = 0.1;
                } else {
                    e = extrapolation.impl.DiscreteExtrapolation.instance();
                }
                var tempAttribute: KMetaAttribute = new impl.MetaAttribute(attributeName, this._meta.length, precisionCleaned, false, p_type.id(), e);
                this.internal_add_meta(tempAttribute);
                return tempAttribute;
            }

            public addRelation(relationName: string, p_metaClass: KMetaClass, oppositeName: string): KMetaRelation {
                return this.internal_addref(relationName, p_metaClass, oppositeName);
            }

            private internal_addref(referenceName: string, p_metaClass: KMetaClass, oppositeName: string): KMetaRelation {
                var tempOrigin: KMetaClass = this;
                var opName: string = oppositeName;
                if (opName == null) {
                    opName = "op_" + referenceName;
                    (<meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, false);
                } else {
                    (<meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, true);
                }
                var tempReference: impl.MetaRelation = new impl.MetaRelation(referenceName, this._meta.length, true, p_metaClass.index(), opName, tempOrigin.index(), -1);
                this.internal_add_meta(tempReference);
                return tempReference;
            }

            private getOrCreate(p_name: string, p_oppositeName: string, p_oppositeClass: KMetaClass, p_visible: boolean): KMetaRelation {
                var previous: KMetaRelation = this.reference(p_name);
                if (previous != null) {
                    return previous;
                }
                var tempOrigin: KMetaClass = this;
                var tempReference: KMetaRelation = new impl.MetaRelation(p_name, this._meta.length, p_visible, p_oppositeClass.index(), p_oppositeName, tempOrigin.index(), -1);
                this.internal_add_meta(tempReference);
                return tempReference;
            }

            public addOperation(operationName: string): KMetaOperation {
                var tempOrigin: KMetaClass = this;
                var tempOperation: impl.MetaOperation = new impl.MetaOperation(operationName, this._meta.length, tempOrigin.index(), new Int32Array([]), -1, [], false);
                this.internal_add_meta(tempOperation);
                return tempOperation;
            }

            public inferAlg(): infer.KInferAlg {
                return this._alg;
            }

            public addDependency(dependencyName: string, referredMetaClassIndex: number): KMetaDependency {
                var currentDeps: KMetaDependencies = this.dependencies();
                if (currentDeps != null) {
                    return currentDeps.addDependency(dependencyName, referredMetaClassIndex);
                }
                return null;
            }

            public addInput(p_name: string, p_extractor: string): KMetaInferInput {
                var newInput: KMetaInferInput = new impl.MetaInferInput(p_name, this._meta.length, p_extractor);
                this.internal_add_meta_noindex(newInput);
                return newInput;
            }

            public addOutput(p_name: string, p_type: KType): KMetaInferOutput {
                var newOutput: KMetaInferOutput = new impl.MetaInferOutput(p_name, this._meta.length, p_type.id());
                this.internal_add_meta(newOutput);
                return newOutput;
            }

            public dependencies(): KMetaDependencies {
                return <meta.KMetaDependencies>this.metaByName(meta.impl.MetaDependencies.DEPENDENCIES_NAME);
            }

            public inputs(): KMetaInferInput[] {
                if (this._cachedInputs == null) {
                    this.cacheInputs();
                }
                return this._cachedInputs;
            }

            private cacheInputs(): void {
                var nb: number = 0;
                for (var i: number = 0; i < this._meta.length; i++) {
                    if (this._meta[i].metaType().equals(meta.MetaType.INPUT)) {
                        nb++;
                    }
                }
                this._cachedInputs = new Array();
                nb = 0;
                for (var i: number = 0; i < this._meta.length; i++) {
                    if (this._meta[i].metaType().equals(meta.MetaType.INPUT)) {
                        this._cachedInputs[nb] = <meta.KMetaInferInput>this._meta[i];
                        nb++;
                    }
                }
            }

            public outputs(): KMetaInferOutput[] {
                if (this._cachedOutputs == null) {
                    this.cacheOuputs();
                }
                return this._cachedOutputs;
            }

            public temporalResolution(): number {
                return this._temporalResolution;
            }

            public setTemporalResolution(p_tempo: number): void {
                this._temporalResolution = p_tempo;
            }

            private cacheOuputs(): void {
                var nb: number = 0;
                for (var i: number = 0; i < this._meta.length; i++) {
                    if (this._meta[i].metaType().equals(meta.MetaType.OUTPUT)) {
                        nb++;
                    }
                }
                this._cachedOutputs = new Array();
                nb = 0;
                for (var i: number = 0; i < this._meta.length; i++) {
                    if (this._meta[i].metaType().equals(meta.MetaType.OUTPUT)) {
                        this._cachedOutputs[nb] = <meta.KMetaInferOutput>this._meta[i];
                        nb++;
                    }
                }
            }

            private clearCached(): void {
                this._cachedOutputs = null;
                this._cachedInputs = null;
            }

            private internal_add_meta(p_new_meta: KMeta): void {
                this.clearCached();
                this._meta[p_new_meta.index()] = p_new_meta;
                this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }

            private internal_add_meta_noindex(p_new_meta: KMeta): void {
                this.clearCached();
                this._meta[p_new_meta.index()] = p_new_meta;
            }

            public addParent(parentMetaClass: KMeta): void {
                var newParents: Int32Array = new Int32Array(this._parents.length + 1);
                java.lang.System.arraycopy(this._parents, 0, newParents, 0, this._parents.length);
                newParents[this._parents.length] = parentMetaClass.index();
                this._parents = newParents;
            }

        }

        export class MetaClassIndex {

            public static INSTANCE: KMetaClass = new impl.MetaClass("index", -3, null, new Int32Array([]));
        }

        export class MetaDependencies implements KMetaDependencies {

            private _origin: KMetaClass;
            private _dependencies: KMetaDependency[];
            public static DEPENDENCIES_NAME: string = "allDependencies";
            private _index: number;
            private _indexes: memory.chunk.KStringMap<number> = null;
            constructor(p_index: number, p_origin: KMetaClass) {
                this._index = p_index;
                this._origin = p_origin;
                this._dependencies = new Array();
                this._indexes = new memory.chunk.impl.ArrayStringMap<number>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
            }

            public origin(): KMetaClass {
                return this._origin;
            }

            public allDependencies(): KMetaDependency[] {
                return this._dependencies;
            }

            public dependencyByName(dependencyName: string): KMetaDependency {
                var foundedIndex: number = this._indexes.get(dependencyName);
                if (foundedIndex != null) {
                    return this._dependencies[foundedIndex];
                } else {
                    return null;
                }
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return MetaDependencies.DEPENDENCIES_NAME;
            }

            public metaType(): MetaType {
                return MetaType.DEPENDENCIES;
            }

            public addDependency(p_dependencyName: string, p_referredMetaClassIndex: number): KMetaDependency {
                var newDependency: KMetaDependency = new impl.MetaDependency(p_dependencyName, this._dependencies.length, this, p_referredMetaClassIndex);
                this.internal_add_dep(newDependency);
                return newDependency;
            }

            private internal_add_dep(p_new_meta: KMetaDependency): void {
                this._dependencies[p_new_meta.index()] = p_new_meta;
                this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }

        }

        export class MetaDependency implements KMetaDependency {

            private _name: string;
            private _index: number;
            private _referredMetaClassIndex: number;
            public referredMetaClassIndex(): number {
                return this._referredMetaClassIndex;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.DEPENDENCY;
            }

            constructor(p_name: string, p_index: number, p_origin: KMetaDependencies, p_referredMetaClassIndex: number) {
                this._name = p_name;
                this._index = p_index;
                this._referredMetaClassIndex = p_referredMetaClassIndex;
            }

        }

        export class MetaEnum implements KMetaEnum {

            private _name: string;
            private _index: number;
            private _literals: KLiteral[];
            private _indexes: memory.chunk.KStringMap<number> = null;
            constructor(p_name: string, p_index: number) {
                this._name = p_name;
                this._index = p_index;
                this._literals = new Array();
                this._indexes = new memory.chunk.impl.ArrayStringMap<number>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
            }

            public init(lits: KLiteral[]): void {
                this._literals = lits;
                for (var i: number = 0; i < lits.length; i++) {
                    this._indexes.put(lits[i].metaName(), lits[i].index());
                }
            }

            public literals(): KLiteral[] {
                return this._literals;
            }

            public literalByName(p_name: string): KLiteral {
                if (this._indexes != null) {
                    var resolvedIndex: number = this._indexes.get(p_name);
                    if (resolvedIndex != null) {
                        return this._literals[resolvedIndex];
                    }
                }
                return null;
            }

            public literal(p_index: number): KLiteral {
                return this._literals[p_index];
            }

            public addLiteral(p_name: string): KLiteral {
                var newLiteral: impl.MetaLiteral = new impl.MetaLiteral(p_name, this._literals.length, this._name);
                this.internal_add_meta(newLiteral);
                return newLiteral;
            }

            public name(): string {
                return this._name;
            }

            public id(): number {
                return this._index;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.ENUM;
            }

            private internal_add_meta(p_new_meta: KLiteral): void {
                this._literals[p_new_meta.index()] = p_new_meta;
                this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }

        }

        export class MetaInferInput implements KMetaInferInput {

            private _name: string;
            private _index: number;
            private _extractor: string;
            private _cachedTraversal: traversal.KTraversal;
            constructor(p_name: string, p_index: number, p_extractor: string) {
                this._name = p_name;
                this._index = p_index;
                this._extractor = p_extractor;
            }

            public extractorQuery(): string {
                return this._extractor;
            }

            public extractor(): traversal.KTraversal {
                if (this._cachedTraversal != null) {
                    return this._cachedTraversal;
                } else {
                    return this.cacheTraversal();
                }
            }

            private cacheTraversal(): traversal.KTraversal {
                this._cachedTraversal = traversal.query.impl.QueryEngine.getINSTANCE().buildTraversal(this._extractor);
                return this._cachedTraversal;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.INPUT;
            }

        }

        export class MetaInferOutput implements KMetaInferOutput {

            private _name: string;
            private _index: number;
            private _type: number;
            constructor(p_name: string, p_index: number, p_type: number) {
                this._name = p_name;
                this._index = p_index;
                this._type = p_type;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.OUTPUT;
            }

            public attributeTypeId(): number {
                return this._type;
            }

        }

        export class MetaLiteral implements KLiteral {

            private _name: string;
            private _index: number;
            private _className: string;
            constructor(p_name: string, p_index: number, p_className: string) {
                this._name = p_name;
                this._index = p_index;
                this._className = p_className;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.LITERAL;
            }

            public toString(): string {
                return "KLiteral@" + this._className + "." + this._name;
            }

        }

        export class MetaModel implements KMetaModel {

            private _name: string;
            private _index: number;
            private _metaClasses: KMetaClass[];
            private _metaClasses_indexes: memory.chunk.KStringMap<number> = null;
            private _metaTypes: KMetaEnum[];
            private _metaTypes_indexes: memory.chunk.KStringMap<number> = null;
            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.MODEL;
            }

            constructor(p_name: string) {
                this._name = p_name;
                this._index = 0;
                this._metaClasses = new Array();
                this._metaTypes = new Array();
                this._metaClasses_indexes = new memory.chunk.impl.ArrayStringMap<number>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                this._metaTypes_indexes = new memory.chunk.impl.ArrayStringMap<number>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
            }

            public init(p_metaClasses: KMetaClass[], p_metaEnums: KMetaEnum[]): void {
                this._metaClasses_indexes.clear();
                this._metaTypes_indexes.clear();
                this._metaClasses = p_metaClasses;
                this._metaTypes = p_metaEnums;
                for (var i: number = 0; i < this._metaClasses.length; i++) {
                    this._metaClasses_indexes.put(p_metaClasses[i].metaName(), p_metaClasses[i].index());
                }
                for (var i: number = 0; i < this._metaTypes.length; i++) {
                    this._metaTypes_indexes.put(p_metaEnums[i].metaName(), p_metaEnums[i].index());
                }
            }

            public metaClasses(): KMetaClass[] {
                return this._metaClasses;
            }

            public metaClassByName(name: string): KMetaClass {
                if (this._metaClasses_indexes == null) {
                    return null;
                }
                var resolved: number = this._metaClasses_indexes.get(name);
                if (resolved == null) {
                    if (util.PrimitiveHelper.equals(name, impl.MetaClassIndex.INSTANCE.metaName())) {
                        return impl.MetaClassIndex.INSTANCE;
                    } else {
                        return null;
                    }
                } else {
                    return this._metaClasses[resolved];
                }
            }

            public metaClass(index: number): KMetaClass {
                if (index == impl.MetaClassIndex.INSTANCE.index()) {
                    return impl.MetaClassIndex.INSTANCE;
                }
                if (index >= 0 && index < this._metaClasses.length) {
                    return this._metaClasses[index];
                }
                return null;
            }

            public addMetaClass(metaClassName: string): KMetaClass {
                return this.internal_addmetaclass(metaClassName, null);
            }

            public addInferMetaClass(metaClassName: string, inferAlg: infer.KInferAlg): KMetaClass {
                return this.internal_addmetaclass(metaClassName, inferAlg);
            }

            public metaTypes(): KMetaEnum[] {
                return this._metaTypes;
            }

            public metaTypeByName(p_name: string): KMetaEnum {
                if (this._metaTypes == null) {
                    return null;
                }
                var resolved: number = this._metaTypes_indexes.get(p_name);
                if (resolved == null) {
                    return null;
                } else {
                    return this._metaTypes[resolved];
                }
            }

            public addMetaEnum(enumName: string): KMetaEnum {
                var newEnumType: KMetaEnum = new impl.MetaEnum(enumName, this._metaTypes.length);
                this.internal_add_type(newEnumType);
                return newEnumType;
            }

            private internal_addmetaclass(metaClassName: string, alg: infer.KInferAlg): KMetaClass {
                if (this._metaClasses_indexes.contains(metaClassName)) {
                    return this.metaClassByName(metaClassName);
                } else {
                    if (this._metaClasses == null) {
                        this._metaClasses = new Array();
                        this._metaClasses[0] = new impl.MetaClass(metaClassName, 0, alg, new Int32Array([]));
                        this._metaClasses_indexes.put(metaClassName, this._metaClasses[0].index());
                        return this._metaClasses[0];
                    } else {
                        var newMetaClass: KMetaClass = new impl.MetaClass(metaClassName, this._metaClasses.length, alg, new Int32Array([]));
                        this.internal_add_meta_class(newMetaClass);
                        return newMetaClass;
                    }
                }
            }

            private internal_add_meta_class(p_newMetaClass: KMetaClass): void {
                this._metaClasses[p_newMetaClass.index()] = p_newMetaClass;
                this._metaClasses_indexes.put(p_newMetaClass.metaName(), p_newMetaClass.index());
            }

            private internal_add_type(p_newType: KMetaEnum): void {
                this._metaTypes[p_newType.index()] = p_newType;
                this._metaTypes_indexes.put(p_newType.metaName(), p_newType.index());
            }

            public createModel(p_manager: memory.manager.internal.KInternalDataManager): KModel<any> {
                return new impl.GenericModel(this, p_manager);
            }

        }

        export class MetaOperation implements KMetaOperation {

            private _name: string;
            private _index: number;
            private _originMetaClassIndex: number;
            private _paramTypes: Int32Array = null;
            private _paramIsArray: boolean[] = null;
            private _returnType: number;
            private _returnIsArray: boolean = false;
            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.OPERATION;
            }

            public originMetaClassIndex(): number {
                return this._originMetaClassIndex;
            }

            public paramTypes(): Int32Array {
                return this._paramTypes;
            }

            public paramMultiplicities(): boolean[] {
                return this._paramIsArray;
            }

            public returnType(): number {
                return this._returnType;
            }

            public returnTypeIsArray(): boolean {
                return this._returnIsArray;
            }

            constructor(p_name: string, p_index: number, p_originMetaClassIndex: number, p_paramTypes: Int32Array, p_returnType: number, p_paramIsArray: boolean[], p_returnIsArray: boolean) {
                this._name = p_name;
                this._index = p_index;
                this._originMetaClassIndex = p_originMetaClassIndex;
                this._paramTypes = p_paramTypes;
                this._returnType = p_returnType;
                this._paramIsArray = p_paramIsArray;
                this._returnIsArray = p_returnIsArray;
            }

            public addParam(type: KType, isArray: boolean): void {
                var newParam: Int32Array = new Int32Array(this._paramTypes.length + 1);
                var newParamIsArray: boolean[] = new Array();
                java.lang.System.arraycopy(this._paramTypes, 0, newParam, 0, this._paramTypes.length);
                java.lang.System.arraycopy(this._paramIsArray, 0, newParamIsArray, 0, this._paramIsArray.length);
                newParam[this._paramTypes.length] = type.id();
                newParamIsArray[this._paramIsArray.length] = isArray;
                this._paramTypes = newParam;
                this._paramIsArray = newParamIsArray;
            }

            public setReturnType(type: KType, isArray: boolean): void {
                this._returnType = type.id();
                this._returnIsArray = isArray;
            }

        }

        export class MetaRelation implements KMetaRelation {

            private _name: string;
            private _index: number;
            private _visible: boolean;
            private _referredMetaClassIndex: number;
            private _op_name: string;
            private _originMetaClassIndex: number;
            private _maxBound: number = -1;
            public referredMetaClassIndex(): number {
                return this._referredMetaClassIndex;
            }

            public oppositeName(): string {
                return this._op_name;
            }

            public originMetaClassIndex(): number {
                return this._originMetaClassIndex;
            }

            public index(): number {
                return this._index;
            }

            public metaName(): string {
                return this._name;
            }

            public metaType(): MetaType {
                return MetaType.RELATION;
            }

            public visible(): boolean {
                return this._visible;
            }

            public maxBound(): number {
                return this._maxBound;
            }

            public setMaxBound(p_maxBound: number): void {
                this._maxBound = p_maxBound;
            }

            constructor(p_name: string, p_index: number, p_visible: boolean, p_referredMetaClassIndex: number, op_name: string, p_originMetaClassIndex: number, p_maxBound: number) {
                this._name = p_name;
                this._index = p_index;
                this._visible = p_visible;
                this._referredMetaClassIndex = p_referredMetaClassIndex;
                this._op_name = op_name;
                this._originMetaClassIndex = p_originMetaClassIndex;
                this._maxBound = p_maxBound;
            }

        }

    }
}
export namespace operation {
    export interface KOperationManager {

        register(operation: meta.KMetaOperation, callback: KOperation<any, any>): void;

        invoke(source: KObject, operation: meta.KMetaOperation, param: any[], strategy: operation.KOperationStrategy, callback: KCallback<any>): void;

        dispatch(message: message.KMessage): void;

        mappings(): string[];

    }

    export interface KOperationStrategy {

        (cdn: cdn.KContentDeliveryDriver, metaOperation: meta.KMetaOperation, source: KObject, param: any[], manager: operation.KOperationManager, callback: KCallback<any>, additionalClassNames: string[]): void;

    }

    export class OperationStrategies {

        public static ONLY_ONE: operation.KOperationStrategy =  (cdn : cdn.KContentDeliveryDriver, metaOperation : meta.KMetaOperation, source : KObject, param : any[], manager : operation.KOperationManager, callback : KCallback<any>, additionalClassNames : string[]) => {
            var operationCall: message.KMessage = new message.impl.Message();
            operationCall.setType(message.impl.Message.OPERATION_CALL_TYPE);
            operationCall.setKeys(new Float64Array([source.universe(), source.now(), source.uuid()]));
            operationCall.setClassName(source.metaClass().metaName());
            operationCall.setOperationName(metaOperation.metaName());
            operationCall.setValues(operation.OperationStrategies.serializeParam(metaOperation, param));
            operationCall.setValues2(additionalClassNames);
            cdn.sendToPeer(null, operationCall,  (message : message.KMessage) => {
                if (message.values() != null) {
                    callback(operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, message.values()[0]));
                } else {
                    callback(operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, null));
                }
            });
        };
        public static serialize(type: number, elem: any, isArray: boolean): string {
            if (isArray) {
                var elements: any[] = <any[]>elem;
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                for (var i: number = 0; i < elements.length; i++) {
                    if (i != 0) {
                        builder.append(KConfig.KEY_SEP);
                    }
                    builder.append(operation.OperationStrategies.serialize(type, elements[i], false));
                }
                return builder.toString();
            } else {
                switch (type) {
                    case meta.KPrimitiveTypes.BOOL_ID:
                        if (<boolean>elem) {
                            return "1";
                        } else {
                            return "0";
                        }
                    case meta.KPrimitiveTypes.STRING_ID:
                        return format.json.JsonString.encode(elem.toString());
                    case meta.KPrimitiveTypes.DOUBLE_ID:
                        return util.Base64.encodeDouble(<number>elem);
                    case meta.KPrimitiveTypes.INT_ID:
                        return util.Base64.encodeInt(<number>elem);
                    case meta.KPrimitiveTypes.LONG_ID:
                        return util.Base64.encodeLong(<number>elem);
                    default:
                        return util.Base64.encodeInt((<meta.KLiteral>elem).index());
                }
            }
        }

        public static serializeParam(metaOperation: meta.KMetaOperation, param: any[]): string[] {
            var paramTypes: Int32Array = metaOperation.paramTypes();
            var paramIsArray: boolean[] = metaOperation.paramMultiplicities();
            var stringParams: string[] = new Array();
            for (var i: number = 0; i < paramTypes.length; i++) {
                stringParams[i] = operation.OperationStrategies.serialize(paramTypes[i], param[i], paramIsArray[i]);
            }
            return stringParams;
        }

        public static serializeReturn(metaOperation: meta.KMetaOperation, result: any): string {
            return operation.OperationStrategies.serialize(metaOperation.returnType(), result, metaOperation.returnTypeIsArray());
        }

        public static unserialize(metaModel: meta.KMetaModel, type: number, payload: string, isArray: boolean): any {
            if (isArray) {
                var params: java.util.List<string> = new java.util.ArrayList<string>();
                var i: number = 0;
                var previous: number = 0;
                while (i < payload.length){
                    if (payload.charAt(i) == KConfig.KEY_SEP) {
                        if (i != previous) {
                            params.add(payload.substring(previous, i));
                        }
                        previous = i + 1;
                    }
                    i++;
                }
                if (i != previous) {
                    params.add(payload.substring(previous, i));
                }
                var result: any[];
                switch (type) {
                    case meta.KPrimitiveTypes.BOOL_ID:
                        result = new Array();
                        break;
                    case meta.KPrimitiveTypes.STRING_ID:
                        result = new Array();
                        break;
                    case meta.KPrimitiveTypes.DOUBLE_ID:
                        result = new Array();
                        break;
                    case meta.KPrimitiveTypes.INT_ID:
                        result = new Array();
                        break;
                    case meta.KPrimitiveTypes.LONG_ID:
                        result = new Array();
                        break;
                    default:
                        result = new Array();
                }
                for (var j: number = 0; j < params.size(); j++) {
                    result[j] = operation.OperationStrategies.unserialize(metaModel, type, params.get(j), false);
                }
                return result;
            } else {
                switch (type) {
                    case meta.KPrimitiveTypes.BOOL_ID:
                        return util.PrimitiveHelper.equals(payload, "1");
                    case meta.KPrimitiveTypes.STRING_ID:
                        return format.json.JsonString.unescape(payload);
                    case meta.KPrimitiveTypes.DOUBLE_ID:
                        return util.Base64.decodeToDouble(payload);
                    case meta.KPrimitiveTypes.INT_ID:
                        return util.Base64.decodeToInt(payload);
                    case meta.KPrimitiveTypes.LONG_ID:
                        return util.Base64.decodeToLong(payload);
                    default:
                        var literalIndex: number = util.Base64.decodeToInt(payload);
                        return metaModel.metaTypes()[type].literal(literalIndex);
                }
            }
        }

        public static unserializeReturn(metaModel: meta.KMetaModel, metaOperation: meta.KMetaOperation, resultString: string): any {
            if (resultString != null) {
                return operation.OperationStrategies.unserialize(metaModel, metaOperation.returnType(), resultString, metaOperation.returnTypeIsArray());
            } else {
                return null;
            }
        }

        public static unserializeParam(metaModel: meta.KMetaModel, metaOperation: meta.KMetaOperation, param: string[]): any[] {
            var paramTypes: Int32Array = metaOperation.paramTypes();
            var paramMultiplicities: boolean[] = metaOperation.paramMultiplicities();
            var objParam: any[] = new Array();
            for (var i: number = 0; i < paramTypes.length; i++) {
                objParam[i] = operation.OperationStrategies.unserialize(metaModel, paramTypes[i], param[i], paramMultiplicities[i]);
            }
            return objParam;
        }

        public static NAMED_PEER(peerName: string): operation.KOperationStrategy {
            return  (cdn : cdn.KContentDeliveryDriver, metaOperation : meta.KMetaOperation, source : KObject, param : any[], manager : operation.KOperationManager, callback : KCallback<any>, additionalClassNames : string[]) => {
                var operationCall: message.KMessage = new message.impl.Message();
                operationCall.setType(message.impl.Message.OPERATION_CALL_TYPE);
                operationCall.setKeys(new Float64Array([source.universe(), source.now(), source.uuid()]));
                operationCall.setClassName(source.metaClass().metaName());
                operationCall.setOperationName(metaOperation.metaName());
                operationCall.setValues(operation.OperationStrategies.serializeParam(metaOperation, param));
                operationCall.setValues2(additionalClassNames);
                cdn.sendToPeer(peerName, operationCall,  (message : message.KMessage) => {
                    if (message.values() != null) {
                        callback(operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, message.values()[0]));
                    } else {
                        callback(operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, null));
                    }
                });
            };
        }

    }

    export namespace impl {
        export class HashOperationManager implements operation.KOperationManager {

            private staticOperations: memory.chunk.KIntMap<memory.chunk.KIntMap<KOperation<any, any>>>;
            private _manager: memory.manager.internal.KInternalDataManager;
            constructor(p_manager: memory.manager.internal.KInternalDataManager) {
                this.staticOperations = new memory.chunk.impl.ArrayIntMap<memory.chunk.KIntMap<KOperation<any, any>>>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                this._manager = p_manager;
            }

            public register(operation: meta.KMetaOperation, callback: KOperation<any, any>): void {
                var clazzOperations: memory.chunk.KIntMap<KOperation<any, any>> = this.staticOperations.get(operation.originMetaClassIndex());
                if (clazzOperations == null) {
                    clazzOperations = new memory.chunk.impl.ArrayIntMap<KOperation<any, any>>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                    this.staticOperations.put(operation.originMetaClassIndex(), clazzOperations);
                }
                clazzOperations.put(operation.index(), callback);
            }

            public invoke(source: KObject, operation: meta.KMetaOperation, param: any[], strategy: operation.KOperationStrategy, callback: KCallback<any>): void {
                if (operation == null) {
                    throw new Error("Operation must be defined to invoke an operation");
                }
                var paramTypes: Int32Array = operation.paramTypes();
                if (paramTypes.length != 0) {
                    if (paramTypes.length != param.length) {
                        throw new Error("Bad Number of arguments for method " + operation.metaName());
                    }
                }
                var clazzOperations: memory.chunk.KIntMap<KOperation<any, any>> = this.staticOperations.get(operation.originMetaClassIndex());
                var resolved: KOperation<any, any> = null;
                if (clazzOperations != null) {
                    resolved = clazzOperations.get(operation.index());
                }
                if (resolved != null) {
                    resolved(source, param, callback);
                } else {
                    var mc: meta.KMetaClass = source.metaClass();
                    var mm: meta.KMetaModel = source.manager().model().metaModel();
                    var parentClasses: java.util.ArrayList<string> = null;
                    parentClasses = new java.util.ArrayList<string>();
                    while (resolved == null && mc != null && mc.metaParents().length > 0){
                        var metaParents: Int32Array = mc.metaParents();
                        var foundParent: number = -1;
                        var i: number = 0;
                        var loopMetaClass: meta.KMetaClass = null;
                        var loopMetaOperation: meta.KMetaOperation = null;
                        while (i < metaParents.length && foundParent == -1){
                            loopMetaClass = mm.metaClass(metaParents[i]);
                            loopMetaOperation = loopMetaClass.operation(operation.metaName());
                            if (loopMetaOperation != null) {
                                foundParent = i;
                            }
                            i++;
                        }
                        if (foundParent == -1) {
                            mc = null;
                        } else {
                            parentClasses.add(loopMetaClass.metaName());
                            mc = loopMetaClass;
                            clazzOperations = this.staticOperations.get(loopMetaOperation.originMetaClassIndex());
                            resolved = clazzOperations.get(loopMetaOperation.index());
                        }
                    }
                    if (resolved != null) {
                        resolved(source, param, callback);
                    } else {
                        var flatted: string[] = parentClasses.toArray(new Array());
                        strategy(this._manager.cdn(), operation, source, param, this, callback, flatted);
                    }
                }
            }

            public dispatch(m: message.KMessage): void {
                if (m.type() == message.impl.Message.OPERATION_CALL_TYPE) {
                    var sourceKey: Float64Array = m.keys();
                    var mc: meta.KMetaClass = this._manager.model().metaModel().metaClassByName(m.className());
                    var mo: meta.KMetaOperation = mc.operation(m.operationName());
                    var clazzOperations: memory.chunk.KIntMap<KOperation<any, any>> = this.staticOperations.get(mc.index());
                    var resolved: KOperation<any, any> = null;
                    if (clazzOperations != null) {
                        resolved = clazzOperations.get(mo.index());
                    }
                    if (resolved != null) {
                        var finalResolved: KOperation<any, any> = resolved;
                        this._manager.lookup(sourceKey[0], sourceKey[1], sourceKey[2],  (kObject : KObject) => {
                            if (kObject != null) {
                                finalResolved(kObject, operation.OperationStrategies.unserializeParam(this._manager.model().metaModel(), mo, m.values()),  (operationResult : any) => {
                                    if (m.id() != null) {
                                        var operationResultMessage: message.KMessage = new message.impl.Message();
                                        operationResultMessage.setPeer(m.peer());
                                        operationResultMessage.setID(m.id());
                                        operationResultMessage.setType(message.impl.Message.OPERATION_RESULT_TYPE);
                                        operationResultMessage.setValues([operation.OperationStrategies.serializeReturn(mo, operationResult)]);
                                        this._manager.cdn().sendToPeer(m.peer(), operationResultMessage, null);
                                    }
                                });
                            } else {
                                if (m.id() != null) {
                                    var operationResultMessage: message.KMessage = new message.impl.Message();
                                    operationResultMessage.setID(m.id());
                                    operationResultMessage.setPeer(m.peer());
                                    operationResultMessage.setType(message.impl.Message.OPERATION_RESULT_TYPE);
                                    operationResultMessage.setValues(null);
                                    this._manager.cdn().sendToPeer(m.peer(), operationResultMessage, null);
                                }
                            }
                        });
                    } else {
                        if (m.id() != null) {
                            var operationResultMessage: message.KMessage = new message.impl.Message();
                            operationResultMessage.setID(m.id());
                            operationResultMessage.setPeer(m.peer());
                            operationResultMessage.setType(message.impl.Message.OPERATION_RESULT_TYPE);
                            operationResultMessage.setValues(null);
                            this._manager.cdn().sendToPeer(m.peer(), operationResultMessage, null);
                        }
                    }
                }
            }

            public mappings(): string[] {
                var mappings: java.util.ArrayList<string> = new java.util.ArrayList<string>();
                this.staticOperations.each( (key : number, value : memory.chunk.KIntMap<KOperation<any, any>>) => {
                    if (value != null) {
                        var metaClass: meta.KMetaClass = this._manager.model().metaModel().metaClass(key);
                        var metaClassName: string = metaClass.metaName();
                        value.each( (key : number, value : KOperation<any, any>) => {
                            var metaOperation: meta.KMetaOperation = <meta.KMetaOperation>metaClass.meta(key);
                            mappings.add(metaClassName);
                            mappings.add(metaOperation.metaName());
                        });
                    }
                });
                return mappings.toArray(new Array());
            }

        }

    }
}
export namespace scheduler {
    export interface KScheduler {

        dispatch(task: scheduler.KTask): void;

        start(): void;

        stop(): void;

    }

    export interface KTask {

        (): void;

    }

    export namespace impl {
        export class AsyncScheduler implements scheduler.KScheduler, java.lang.Runnable {

            dispatch = function(task:scheduler.KTask){
                setTimeout(task,0);
            }
            start = function(){
                //NNOP
            }
            stop = function(){
                //NOOP
            }
            run = function(){
                //NOOP
            }
        }

        export class DirectScheduler implements scheduler.KScheduler {

            public dispatch(task: scheduler.KTask): void {
                task();
            }

            public start(): void {
            }

            public stop(): void {
            }

        }

    }
}
export namespace traversal {
    export interface KTraversal {

        traverse(metaReference: meta.KMetaRelation): traversal.KTraversal;

        traverseQuery(metaReferenceQuery: string): traversal.KTraversal;

        attributeQuery(attributeQuery: string): traversal.KTraversal;

        withAttribute(attribute: meta.KMetaAttribute, expectedValue: any): traversal.KTraversal;

        withoutAttribute(attribute: meta.KMetaAttribute, expectedValue: any): traversal.KTraversal;

        filter(filter: traversal.KTraversalFilter): traversal.KTraversal;

        then(cb: KCallback<KObject[]>): void;

        eval(expression: string, callback: KCallback<any[]>): void;

        map(attribute: meta.KMetaAttribute, cb: KCallback<any[]>): void;

        collect(metaReference: meta.KMetaRelation, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;

        traverseTime(timeOffset: number, steps: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;

        traverseUniverse(universeOffset: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal;

        traverseIndex(indexName: string, attributes: string): traversal.KTraversal;

        exec(origins: KObject[], view: KView, callback: KCallback<any[]>): void;

    }

    export interface KTraversalAction {

        chain(next: traversal.KTraversalAction): void;

        execute(context: traversal.KTraversalActionContext): void;

    }

    export interface KTraversalActionContext {

        inputObjects(): KObject[];

        setInputObjects(newSet: KObject[]): void;

        finalCallback(): KCallback<any[]>;

        baseView(): KView;

    }

    export interface KTraversalFilter {

        (obj: KObject): boolean;

    }

    export namespace impl {
        export class Traversal implements traversal.KTraversal {

            private static TERMINATED_MESSAGE: string = "Traversal is terminated by the call of done method, please create another promise";
            private _initObjs: KObject[];
            private _initAction: traversal.KTraversalAction;
            private _lastAction: traversal.KTraversalAction;
            private _terminated: boolean = false;
            constructor(p_roots: KObject[]) {
                this._initObjs = p_roots;
            }

            private internal_chain_action(p_action: traversal.KTraversalAction): traversal.KTraversal {
                if (this._terminated) {
                    throw new Error(Traversal.TERMINATED_MESSAGE);
                }
                if (this._initAction == null) {
                    this._initAction = p_action;
                }
                if (this._lastAction != null) {
                    this._lastAction.chain(p_action);
                }
                this._lastAction = p_action;
                return this;
            }

            public traverse(p_metaReference: meta.KMetaRelation): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.TraverseAction(p_metaReference));
            }

            public traverseQuery(p_metaReferenceQuery: string): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.TraverseQueryAction(p_metaReferenceQuery));
            }

            public withAttribute(p_attribute: meta.KMetaAttribute, p_expectedValue: any): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.FilterAttributeAction(p_attribute, p_expectedValue));
            }

            public withoutAttribute(p_attribute: meta.KMetaAttribute, p_expectedValue: any): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.FilterNotAttributeAction(p_attribute, p_expectedValue));
            }

            public attributeQuery(p_attributeQuery: string): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.FilterAttributeQueryAction(p_attributeQuery));
            }

            public filter(p_filter: traversal.KTraversalFilter): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.FilterAction(p_filter));
            }

            public collect(metaReference: meta.KMetaRelation, continueCondition: traversal.KTraversalFilter): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.DeepCollectAction(metaReference, continueCondition));
            }

            public traverseIndex(p_indexName: string, p_attributes: string): traversal.KTraversal {
                return this.internal_chain_action(new traversal.impl.actions.TraverseIndexAction(p_indexName, p_attributes));
            }

            public traverseTime(timeOffset: number, steps: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal {
                throw new Error("Not Implemented Yet!");
            }

            public traverseUniverse(universeOffset: number, continueCondition: traversal.KTraversalFilter): traversal.KTraversal {
                throw new Error("Not Implemented Yet!");
            }

            public then(cb: KCallback<KObject[]>): void {
                if (this._initObjs != null) {
                    this._initAction.execute(new traversal.impl.TraversalContext(this._initObjs, null,  (objects : any[]) => {
                        cb(<KObject[]>objects);
                    }));
                }
            }

            public eval(p_expression: string, callback: KCallback<any[]>): void {
                this.internal_chain_action(new traversal.impl.actions.MathExpressionAction(p_expression));
                this._terminated = true;
                if (this._initObjs != null) {
                    this._initAction.execute(new traversal.impl.TraversalContext(this._initObjs, null, callback));
                }
            }

            public map(attribute: meta.KMetaAttribute, cb: KCallback<any[]>): void {
                this.internal_chain_action(new traversal.impl.actions.MapAction(attribute));
                this._terminated = true;
                if (this._initObjs != null) {
                    this._initAction.execute(new traversal.impl.TraversalContext(this._initObjs, null, cb));
                }
            }

            public exec(origins: KObject[], review: KView, callback: KCallback<any[]>): void {
                if (this._initObjs == null) {
                    this._initAction.execute(new traversal.impl.TraversalContext(origins, review, callback));
                }
            }

        }

        export class TraversalContext implements traversal.KTraversalActionContext {

            private _inputs: KObject[];
            private _view: KView;
            private _finalCallback: KCallback<any[]>;
            constructor(p_inputs: KObject[], p_view: KView, p_finalCallback: KCallback<any[]>) {
                this._inputs = p_inputs;
                this._view = p_view;
                this._finalCallback = p_finalCallback;
            }

            public inputObjects(): KObject[] {
                return this._inputs;
            }

            public setInputObjects(p_newSet: KObject[]): void {
                this._inputs = p_newSet;
            }

            public baseView(): KView {
                return this._view;
            }

            public finalCallback(): KCallback<any[]> {
                return this._finalCallback;
            }

        }

        export namespace actions {
            export class DeepCollectAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _reference: meta.KMetaRelation;
                private _continueCondition: traversal.KTraversalFilter;
                private _alreadyPassed: memory.chunk.impl.ArrayLongMap<KObject> = null;
                private _finalElements: memory.chunk.impl.ArrayLongMap<KObject> = null;
                constructor(p_reference: meta.KMetaRelation, p_continueCondition: traversal.KTraversalFilter) {
                    this._reference = p_reference;
                    this._continueCondition = p_continueCondition;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        this._alreadyPassed = new memory.chunk.impl.ArrayLongMap<KObject>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                        this._finalElements = new memory.chunk.impl.ArrayLongMap<KObject>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                        var filtered_inputs: KObject[] = new Array();
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            if (this._continueCondition == null || this._continueCondition(context.inputObjects()[i])) {
                                filtered_inputs[i] = context.inputObjects()[i];
                                this._alreadyPassed.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                            }
                        }
                        var iterationCallbacks: KCallback<KObject[]>[] = new Array();
                        iterationCallbacks[0] =  (traversed : KObject[]) => {
                            var filtered_inputs2: KObject[] = new Array();
                            var nbSize: number = 0;
                            for (var i: number = 0; i < traversed.length; i++) {
                                if ((this._continueCondition == null || this._continueCondition(traversed[i])) && !this._alreadyPassed.contains(traversed[i].uuid())) {
                                    filtered_inputs2[i] = traversed[i];
                                    this._alreadyPassed.put(traversed[i].uuid(), traversed[i]);
                                    this._finalElements.put(traversed[i].uuid(), traversed[i]);
                                    nbSize++;
                                }
                            }
                            if (nbSize > 0) {
                                this.executeStep(filtered_inputs2, iterationCallbacks[0]);
                            } else {
                                var trimmed: KObject[] = new Array();
                                var nbInserted: Int32Array = new Int32Array([0]);
                                this._finalElements.each( (key : number, value : KObject) => {
                                    trimmed[nbInserted[0]] = value;
                                    nbInserted[0]++;
                                });
                                if (this._next == null) {
                                    context.finalCallback()(trimmed);
                                } else {
                                    context.setInputObjects(trimmed);
                                    this._next.execute(context);
                                }
                            }
                        };
                        this.executeStep(filtered_inputs, iterationCallbacks[0]);
                    }
                }

                private executeStep(p_inputStep: KObject[], private_callback: KCallback<KObject[]>): void {
                    var currentObject: abs.AbstractKObject = null;
                    var nextIds: memory.chunk.KLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                    for (var i: number = 0; i < p_inputStep.length; i++) {
                        if (p_inputStep[i] != null) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>p_inputStep[i];
                                currentObject = loopObj;
                                var raw: memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                if (raw != null) {
                                    if (this._reference == null) {
                                        var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                        for (var j: number = 0; j < metaElements.length; j++) {
                                            if (metaElements[j] != null && metaElements[j].metaType() == meta.MetaType.RELATION) {
                                                var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                                                if (resolved != null) {
                                                    for (var k: number = 0; k < resolved.length; k++) {
                                                        nextIds.put(resolved[k], resolved[k]);
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        var translatedRef: meta.KMetaRelation = loopObj.internal_transpose_ref(this._reference);
                                        if (translatedRef != null) {
                                            var resolved: Float64Array = raw.getLongArray(translatedRef.index(), loopObj.metaClass());
                                            if (resolved != null) {
                                                for (var j: number = 0; j < resolved.length; j++) {
                                                    nextIds.put(resolved[j], resolved[j]);
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                    }
                    var trimmed: Float64Array = new Float64Array(nextIds.size());
                    var inserted: Int32Array = new Int32Array([0]);
                    nextIds.each( (key : number, value : number) => {
                        trimmed[inserted[0]] = key;
                        inserted[0]++;
                    });
                    currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed,  (kObjects : KObject[]) => {
                        private_callback(kObjects);
                    });
                }

            }

            export class FilterAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _filter: traversal.KTraversalFilter;
                constructor(p_filter: traversal.KTraversalFilter) {
                    this._filter = p_filter;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    var selectedIndex: boolean[] = new Array();
                    var selected: number = 0;
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        try {
                            if (this._filter(context.inputObjects()[i])) {
                                selectedIndex[i] = true;
                                selected++;
                            }
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                            } else {
                                throw $ex$;
                            }
                        }
                    }
                    var nextStepElement: KObject[] = new Array();
                    var inserted: number = 0;
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        if (selectedIndex[i]) {
                            nextStepElement[inserted] = context.inputObjects()[i];
                            inserted++;
                        }
                    }
                    if (this._next == null) {
                        context.finalCallback()(nextStepElement);
                    } else {
                        context.setInputObjects(nextStepElement);
                        this._next.execute(context);
                    }
                }

            }

            export class FilterAttributeAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _attribute: meta.KMetaAttribute;
                private _expectedValue: any;
                constructor(p_attribute: meta.KMetaAttribute, p_expectedValue: any) {
                    this._attribute = p_attribute;
                    this._expectedValue = p_expectedValue;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        var selectedIndexes: boolean[] = new Array();
                        var nbSelected: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[i];
                                var raw: memory.chunk.KObjectChunk = (loopObj)._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                if (raw != null) {
                                    if (this._attribute == null) {
                                        if (this._expectedValue == null) {
                                            selectedIndexes[i] = true;
                                            nbSelected++;
                                        } else {
                                            var addToNext: boolean = false;
                                            var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                            for (var j: number = 0; j < metaElements.length; j++) {
                                                if (metaElements[j] instanceof meta.impl.MetaAttribute) {
                                                    var resolved: any = raw.getPrimitiveType(metaElements[j].index(), loopObj.metaClass());
                                                    if (resolved == null) {
                                                        if (util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                            addToNext = true;
                                                        }
                                                    } else {
                                                        if (util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                            addToNext = true;
                                                        } else {
                                                            if (util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                addToNext = true;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (addToNext) {
                                                selectedIndexes[i] = true;
                                                nbSelected++;
                                            }
                                        }
                                    } else {
                                        var translatedAtt: meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                                        if (translatedAtt != null) {
                                            var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                                            if (this._expectedValue == null) {
                                                if (resolved == null) {
                                                    selectedIndexes[i] = true;
                                                    nbSelected++;
                                                }
                                            } else {
                                                if (resolved == null) {
                                                    if (util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                        selectedIndexes[i] = true;
                                                        nbSelected++;
                                                    }
                                                } else {
                                                    if (util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                        selectedIndexes[i] = true;
                                                        nbSelected++;
                                                    } else {
                                                        if (util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                            selectedIndexes[i] = true;
                                                            nbSelected++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    console.error("WARN: Empty KObject " + loopObj.uuid());;
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        var nextStepElement: KObject[] = new Array();
                        var inserted: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            if (selectedIndexes[i]) {
                                nextStepElement[inserted] = context.inputObjects()[i];
                                inserted++;
                            }
                        }
                        if (this._next == null) {
                            context.finalCallback()(nextStepElement);
                        } else {
                            context.setInputObjects(nextStepElement);
                            this._next.execute(context);
                        }
                    }
                }

            }

            export class FilterAttributeQueryAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _attributeQuery: string;
                constructor(p_attributeQuery: string) {
                    this._attributeQuery = p_attributeQuery;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        var selectedIndexes: boolean[] = new Array();
                        var nbSelected: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[i];
                                if (this._attributeQuery == null) {
                                    selectedIndexes[i] = true;
                                    nbSelected++;
                                } else {
                                    var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                    var params: memory.chunk.impl.ArrayStringMap<traversal.impl.actions.FilterAttributeQueryAction.QueryParam> = this.buildParams(this._attributeQuery);
                                    var selectedForNext: boolean[] = [true];
                                    params.each( (key : string, param : traversal.impl.actions.FilterAttributeQueryAction.QueryParam) => {
                                        for (var j: number = 0; j < metaElements.length; j++) {
                                            if (metaElements[j] instanceof meta.impl.MetaAttribute) {
                                                var metaAttribute: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[j];
                                                if (util.PrimitiveHelper.matches(metaAttribute.metaName(), "^" + param.name() + "$")) {
                                                    var o_raw: any = loopObj.get(metaAttribute);
                                                    if (o_raw != null) {
                                                        if (util.PrimitiveHelper.equals(param.value(), "null")) {
                                                            if (!param.isNegative()) {
                                                                selectedForNext[0] = false;
                                                            }
                                                        } else {
                                                            if (util.PrimitiveHelper.matches(o_raw.toString(), "^" + param.value() + "$")) {
                                                                if (param.isNegative()) {
                                                                    selectedForNext[0] = false;
                                                                }
                                                            } else {
                                                                if (!param.isNegative()) {
                                                                    selectedForNext[0] = false;
                                                                }
                                                            }
                                                        }
                                                    } else {
                                                        if (util.PrimitiveHelper.equals(param.value(), "null") || util.PrimitiveHelper.equals(param.value(), "*")) {
                                                            if (param.isNegative()) {
                                                                selectedForNext[0] = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    });
                                    if (selectedForNext[0]) {
                                        selectedIndexes[i] = true;
                                        nbSelected++;
                                    }
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        var nextStepElement: KObject[] = new Array();
                        var inserted: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            if (selectedIndexes[i]) {
                                nextStepElement[inserted] = context.inputObjects()[i];
                                inserted++;
                            }
                        }
                        if (this._next == null) {
                            context.finalCallback()(nextStepElement);
                        } else {
                            context.setInputObjects(nextStepElement);
                            this._next.execute(context);
                        }
                    }
                }

                private buildParams(p_paramString: string): memory.chunk.impl.ArrayStringMap<traversal.impl.actions.FilterAttributeQueryAction.QueryParam> {
                    var params: memory.chunk.impl.ArrayStringMap<traversal.impl.actions.FilterAttributeQueryAction.QueryParam> = new memory.chunk.impl.ArrayStringMap<traversal.impl.actions.FilterAttributeQueryAction.QueryParam>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                    var iParam: number = 0;
                    var lastStart: number = iParam;
                    while (iParam < p_paramString.length){
                        if (p_paramString.charAt(iParam) == ',') {
                            var p: string = p_paramString.substring(lastStart, iParam).trim();
                            if (!util.PrimitiveHelper.equals(p, "") && !util.PrimitiveHelper.equals(p, "*")) {
                                if (util.PrimitiveHelper.endsWith(p, "=")) {
                                    p = p + "*";
                                }
                                var pArray: string[] = p.split("=");
                                var pObject: traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                                if (pArray.length > 1) {
                                    var paramKey: string = pArray[0].trim();
                                    var negative: boolean = util.PrimitiveHelper.endsWith(paramKey, "!");
                                    pObject = new traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                                    params.put(pObject.name(), pObject);
                                }
                            }
                            lastStart = iParam + 1;
                        }
                        iParam = iParam + 1;
                    }
                    var lastParam: string = p_paramString.substring(lastStart, iParam).trim();
                    if (!util.PrimitiveHelper.equals(lastParam, "") && !util.PrimitiveHelper.equals(lastParam, "*")) {
                        if (util.PrimitiveHelper.endsWith(lastParam, "=")) {
                            lastParam = lastParam + "*";
                        }
                        var pArray: string[] = lastParam.split("=");
                        var pObject: traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                        if (pArray.length > 1) {
                            var paramKey: string = pArray[0].trim();
                            var negative: boolean = util.PrimitiveHelper.endsWith(paramKey, "!");
                            pObject = new traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                            params.put(pObject.name(), pObject);
                        }
                    }
                    return params;
                }

            }

            export namespace FilterAttributeQueryAction {
                export class QueryParam {

                    private _name: string;
                    private _value: string;
                    private _negative: boolean;
                    constructor(p_name: string, p_value: string, p_negative: boolean) {
                        this._name = p_name;
                        this._value = p_value;
                        this._negative = p_negative;
                    }

                    public name(): string {
                        return this._name;
                    }

                    public value(): string {
                        return this._value;
                    }

                    public isNegative(): boolean {
                        return this._negative;
                    }

                }


            }
            export class FilterNotAttributeAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _attribute: meta.KMetaAttribute;
                private _expectedValue: any;
                constructor(p_attribute: meta.KMetaAttribute, p_expectedValue: any) {
                    this._attribute = p_attribute;
                    this._expectedValue = p_expectedValue;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        var selectedIndexes: boolean[] = new Array();
                        var nbSelected: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[i];
                                var raw: memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                if (raw != null) {
                                    if (this._attribute == null) {
                                        if (this._expectedValue == null) {
                                            selectedIndexes[i] = true;
                                            nbSelected++;
                                        } else {
                                            var addToNext: boolean = true;
                                            var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                            for (var j: number = 0; j < metaElements.length; j++) {
                                                if (metaElements[j] instanceof meta.impl.MetaAttribute) {
                                                    var ref: meta.KMetaAttribute = <meta.KMetaAttribute>metaElements[j];
                                                    var resolved: any = raw.getPrimitiveType(ref.index(), loopObj.metaClass());
                                                    if (resolved == null) {
                                                        if (util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                            addToNext = false;
                                                        }
                                                    } else {
                                                        if (util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                            addToNext = false;
                                                        } else {
                                                            if (util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                addToNext = false;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            if (addToNext) {
                                                selectedIndexes[i] = true;
                                                nbSelected++;
                                            }
                                        }
                                    } else {
                                        var translatedAtt: meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                                        if (translatedAtt != null) {
                                            var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                                            if (this._expectedValue == null) {
                                                if (resolved != null) {
                                                    selectedIndexes[i] = true;
                                                    nbSelected++;
                                                }
                                            } else {
                                                if (resolved == null) {
                                                    if (!util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                        selectedIndexes[i] = true;
                                                        nbSelected++;
                                                    }
                                                } else {
                                                    if (util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                    } else {
                                                        if (util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                        } else {
                                                            selectedIndexes[i] = true;
                                                            nbSelected++;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    console.error("WARN: Empty KObject " + loopObj.uuid());;
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        var nextStepElement: KObject[] = new Array();
                        var inserted: number = 0;
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            if (selectedIndexes[i]) {
                                nextStepElement[inserted] = context.inputObjects()[i];
                                inserted++;
                            }
                        }
                        if (this._next == null) {
                            context.finalCallback()(nextStepElement);
                        } else {
                            context.setInputObjects(nextStepElement);
                            this._next.execute(context);
                        }
                    }
                }

            }

            export class MapAction implements traversal.KTraversalAction {

                private _attribute: meta.KMetaAttribute;
                constructor(p_attribute: meta.KMetaAttribute) {
                    this._attribute = p_attribute;
                }

                public chain(next: traversal.KTraversalAction): void {
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    var selected: any[] = new Array();
                    var nbElem: number = 0;
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        if (context.inputObjects()[i] != null) {
                            var resolved: any = context.inputObjects()[i].get(this._attribute);
                            if (resolved != null) {
                                selected[i] = resolved;
                                nbElem++;
                            }
                        }
                    }
                    var trimmed: any[] = new Array();
                    var nbInserted: number = 0;
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        if (selected[i] != null) {
                            trimmed[nbInserted] = selected[i];
                            nbInserted++;
                        }
                    }
                    if (context.finalCallback() != null) {
                        context.finalCallback()(trimmed);
                    }
                }

            }

            export class MathExpressionAction implements traversal.KTraversalAction {

                private _expression: string;
                private _engine: util.maths.expression.KMathExpressionEngine;
                constructor(p_expression: string) {
                    this._expression = p_expression;
                    this._engine = new util.maths.expression.impl.MathExpressionEngine();
                    this._engine.parse(p_expression);
                }

                public chain(next: traversal.KTraversalAction): void {
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    var selected: any[] = new Array();
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        if (context.inputObjects()[i] != null) {
                            selected[i] = this._engine.eval(context.inputObjects()[i]);
                        }
                    }
                    if (context.finalCallback() != null) {
                        context.finalCallback()(selected);
                    }
                }

            }

            export class RemoveDuplicateAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    var elems: memory.chunk.impl.ArrayLongMap<any> = new memory.chunk.impl.ArrayLongMap<any>(context.inputObjects().length, KConfig.CACHE_LOAD_FACTOR);
                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                        elems.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                    }
                    var trimmed: KObject[] = new Array();
                    var nbInserted: Int32Array = new Int32Array([0]);
                    elems.each( (key : number, value : KObject) => {
                        trimmed[nbInserted[0]] = value;
                        nbInserted[0]++;
                    });
                    if (this._next == null) {
                        context.finalCallback()(trimmed);
                    } else {
                        context.setInputObjects(trimmed);
                        this._next.execute(context);
                    }
                }

            }

            export class TraverseAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _reference: meta.KMetaRelation;
                constructor(p_reference: meta.KMetaRelation) {
                    this._reference = p_reference;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        var currentObject: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[0];
                        var nextIds: memory.chunk.KLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[i];
                                var raw: memory.chunk.KObjectChunk = currentObject._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                if (raw != null) {
                                    if (this._reference == null) {
                                        var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                        for (var j: number = 0; j < metaElements.length; j++) {
                                            if (metaElements[j] != null && metaElements[j].metaType() == meta.MetaType.RELATION) {
                                                var ref: meta.KMetaRelation = <meta.KMetaRelation>metaElements[j];
                                                var resolved: Float64Array = raw.getLongArray(ref.index(), currentObject.metaClass());
                                                if (resolved != null) {
                                                    for (var k: number = 0; k < resolved.length; k++) {
                                                        nextIds.put(resolved[k], resolved[k]);
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        var translatedRef: meta.KMetaRelation = loopObj.internal_transpose_ref(this._reference);
                                        if (translatedRef != null) {
                                            var resolved: Float64Array = raw.getLongArray(translatedRef.index(), currentObject.metaClass());
                                            if (resolved != null) {
                                                for (var j: number = 0; j < resolved.length; j++) {
                                                    nextIds.put(resolved[j], resolved[j]);
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        var trimmed: Float64Array = new Float64Array(nextIds.size());
                        var inserted: Int32Array = new Int32Array([0]);
                        nextIds.each( (key : number, value : number) => {
                            trimmed[inserted[0]] = key;
                            inserted[0]++;
                        });
                        currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed,  (kObjects : KObject[]) => {
                            if (this._next == null) {
                                context.finalCallback()(kObjects);
                            } else {
                                context.setInputObjects(kObjects);
                                this._next.execute(context);
                            }
                        });
                    }
                }

            }

            export class TraverseIndexAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _indexName: string;
                private _attributes: string;
                constructor(p_indexName: string, p_attributes: string) {
                    this._indexName = p_indexName;
                    this._attributes = p_attributes;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    var originView: KView = context.baseView();
                    if (originView != null) {
                        if (this._attributes == null && this._indexName != null) {
                            originView.model().indexByName(originView.universe(), originView.now(), this._indexName,  (index : KObjectIndex) => {
                                if (index == null) {
                                    if (this._next == null) {
                                        context.finalCallback()(new Array());
                                    } else {
                                        context.setInputObjects(new Array());
                                        this._next.execute(context);
                                    }
                                } else {
                                    originView.model().lookupAllObjects(originView.universe(), originView.now(), index.values(),  (selectedElems : KObject[]) => {
                                        if (this._next == null) {
                                            context.finalCallback()(selectedElems);
                                        } else {
                                            context.setInputObjects(selectedElems);
                                            this._next.execute(context);
                                        }
                                    });
                                }
                            });
                        } else {
                            originView.model().findByName(this._indexName, originView.universe(), originView.now(), this._attributes,  (indexedObject : KObject) => {
                                var selectedElems: KObject[];
                                if (indexedObject == null) {
                                    selectedElems = new Array();
                                } else {
                                    selectedElems = new Array();
                                    selectedElems[0] = indexedObject;
                                }
                                if (this._next == null) {
                                    context.finalCallback()(selectedElems);
                                } else {
                                    context.setInputObjects(selectedElems);
                                    this._next.execute(context);
                                }
                            });
                        }
                    } else {
                        throw new Error("Not implemented yet!");
                    }
                }

            }

            export class TraverseQueryAction implements traversal.KTraversalAction {

                private SEP: string = ",";
                private _next: traversal.KTraversalAction;
                private _referenceQuery: string;
                constructor(p_referenceQuery: string) {
                    this._referenceQuery = p_referenceQuery;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    if (context.inputObjects() == null || context.inputObjects().length == 0) {
                        if (this._next != null) {
                            this._next.execute(context);
                        } else {
                            context.finalCallback()(context.inputObjects());
                        }
                    } else {
                        var currentFirstObject: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[0];
                        var nextIds: memory.chunk.KLongLongMap = new memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                        for (var i: number = 0; i < context.inputObjects().length; i++) {
                            try {
                                var loopObj: abs.AbstractKObject = <abs.AbstractKObject>context.inputObjects()[i];
                                var raw: memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                var metaElements: meta.KMeta[] = loopObj.metaClass().metaElements();
                                if (raw != null) {
                                    if (this._referenceQuery == null) {
                                        for (var j: number = 0; j < metaElements.length; j++) {
                                            if (metaElements[j] != null && metaElements[j].metaType() == meta.MetaType.RELATION) {
                                                var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                                                if (resolved != null) {
                                                    for (var k: number = 0; k < resolved.length; k++) {
                                                        var idResolved: number = resolved[k];
                                                        nextIds.put(idResolved, idResolved);
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        var queries: string[] = this._referenceQuery.split(this.SEP);
                                        for (var k: number = 0; k < queries.length; k++) {
                                            queries[k] = queries[k].replace("*", ".*");
                                        }
                                        for (var h: number = 0; h < metaElements.length; h++) {
                                            if (metaElements[h] != null && metaElements[h].metaType() == meta.MetaType.RELATION) {
                                                var metaReference: meta.KMetaRelation = <meta.KMetaRelation>metaElements[h];
                                                var selected: boolean = false;
                                                for (var k: number = 0; k < queries.length; k++) {
                                                    if (queries[k] != null && util.PrimitiveHelper.startsWith(queries[k].trim(), "<<")) {
                                                        if (util.PrimitiveHelper.matches(metaReference.oppositeName(), queries[k].trim().substring(2))) {
                                                            selected = true;
                                                            break;
                                                        }
                                                    } else {
                                                        if (util.PrimitiveHelper.matches(metaReference.metaName(), "^" + queries[k] + "$")) {
                                                            selected = true;
                                                            break;
                                                        }
                                                    }
                                                }
                                                if (selected) {
                                                    var resolved: Float64Array = raw.getLongArray(metaElements[h].index(), loopObj.metaClass());
                                                    if (resolved != null) {
                                                        for (var j: number = 0; j < resolved.length; j++) {
                                                            nextIds.put(resolved[j], resolved[j]);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        var trimmed: Float64Array = new Float64Array(nextIds.size());
                        var inserted: Int32Array = new Int32Array([0]);
                        nextIds.each( (key : number, value : number) => {
                            trimmed[inserted[0]] = key;
                            inserted[0]++;
                        });
                        currentFirstObject._manager.lookupAllObjects(currentFirstObject.universe(), currentFirstObject.now(), trimmed,  (nextStepElement : KObject[]) => {
                            if (this._next == null) {
                                context.finalCallback()(nextStepElement);
                            } else {
                                context.setInputObjects(nextStepElement);
                                this._next.execute(context);
                            }
                        });
                    }
                }

            }

            export class TraverseTimeAction implements traversal.KTraversalAction {

                private _next: traversal.KTraversalAction;
                private _timeOffset: number;
                private _steps: number;
                private _continueContition: traversal.KTraversalFilter;
                constructor(p_timeOffset: number, p_steps: number, p_continueCondition: traversal.KTraversalFilter) {
                    this._timeOffset = p_timeOffset;
                    this._steps = p_steps;
                    this._continueContition = p_continueCondition;
                }

                public chain(p_next: traversal.KTraversalAction): void {
                    this._next = p_next;
                }

                public execute(context: traversal.KTraversalActionContext): void {
                    throw new Error("Not implemented Yet!");
                }

            }

        }
    }
    export namespace query {
        export interface KQueryEngine {

            eval(query: string, origins: KObject[], view: KView, callback: KCallback<any[]>): void;

            buildTraversal(query: string): traversal.KTraversal;

        }

        export namespace impl {
            export class QueryEngine implements traversal.query.KQueryEngine {

                private static INSTANCE: traversal.query.KQueryEngine = null;
                public static OPEN_BRACKET: string = '[';
                public static CLOSE_BRACKET: string = ']';
                public static PIPE_SEP: string = '|';
                public static VAL_SEP: string = "=";
                public static VALS_SEP: string = ',';
                public static getINSTANCE(): traversal.query.KQueryEngine {
                    if (QueryEngine.INSTANCE == null) {
                        QueryEngine.INSTANCE = new traversal.query.impl.QueryEngine();
                    }
                    return QueryEngine.INSTANCE;
                }

                public eval(query: string, origins: KObject[], p_view: KView, callback: KCallback<any[]>): void {
                    if (callback != null) {
                        this.buildTraversal(query).exec(origins, p_view, callback);
                    }
                }

                public buildTraversal(query: string): traversal.KTraversal {
                    if (query == null || query.length == 0) {
                        return null;
                    } else {
                        var t: traversal.KTraversal = new traversal.impl.Traversal(null);
                        var i: number = 0;
                        var escaped: boolean = false;
                        var previousKQueryStart: number = 0;
                        var previousKQueryNameEnd: number = -1;
                        var previousKQueryAttributesEnd: number = -1;
                        var previousKQueryAttributesStart: number = 0;
                        var endEval: boolean = false;
                        while (i < query.length && !endEval){
                            var notLastElem: boolean = (i + 1) != query.length;
                            if (escaped && notLastElem) {
                                escaped = false;
                            } else {
                                var currentChar: string = query.charAt(i);
                                if (currentChar == QueryEngine.CLOSE_BRACKET && notLastElem) {
                                    previousKQueryAttributesEnd = i;
                                } else {
                                    if (currentChar == '\\' && notLastElem) {
                                        escaped = true;
                                    } else {
                                        if (currentChar == QueryEngine.OPEN_BRACKET && notLastElem) {
                                            previousKQueryNameEnd = i;
                                            previousKQueryAttributesStart = i + 1;
                                        } else {
                                            if (currentChar == QueryEngine.PIPE_SEP || !notLastElem) {
                                                var relationName: string;
                                                var atts: string = null;
                                                if (previousKQueryNameEnd == -1) {
                                                    if (notLastElem) {
                                                        previousKQueryNameEnd = i;
                                                    } else {
                                                        previousKQueryNameEnd = i + 1;
                                                    }
                                                } else {
                                                    if (previousKQueryAttributesStart != -1) {
                                                        if (previousKQueryAttributesEnd == -1) {
                                                            if (notLastElem || currentChar == QueryEngine.PIPE_SEP || currentChar == QueryEngine.CLOSE_BRACKET) {
                                                                previousKQueryAttributesEnd = i;
                                                            } else {
                                                                previousKQueryAttributesEnd = i + 1;
                                                            }
                                                        }
                                                        atts = query.substring(previousKQueryAttributesStart, previousKQueryAttributesEnd);
                                                        if (atts.length == 0) {
                                                            atts = null;
                                                        }
                                                    }
                                                }
                                                relationName = query.substring(previousKQueryStart, previousKQueryNameEnd).trim();
                                                if (util.PrimitiveHelper.startsWith(relationName, "@")) {
                                                    t = t.traverseIndex(relationName.substring(1), atts);
                                                } else {
                                                    if (util.PrimitiveHelper.startsWith(relationName, "=")) {
                                                        t.eval(relationName.substring(1), null);
                                                        endEval = true;
                                                    } else {
                                                        if (util.PrimitiveHelper.startsWith(relationName, ">>")) {
                                                            t = t.traverseQuery(relationName.substring(2));
                                                            if (atts != null) {
                                                                t = t.attributeQuery(atts);
                                                            }
                                                        } else {
                                                            if (util.PrimitiveHelper.startsWith(relationName, "<<")) {
                                                                t = t.traverseQuery(relationName);
                                                                if (atts != null) {
                                                                    t = t.attributeQuery(atts);
                                                                }
                                                            } else {
                                                                t = t.traverseQuery(relationName);
                                                                if (atts != null) {
                                                                    t = t.attributeQuery(atts);
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                previousKQueryStart = i + 1;
                                                previousKQueryNameEnd = -1;
                                                previousKQueryAttributesEnd = -1;
                                                previousKQueryAttributesStart = -1;
                                            }
                                        }
                                    }
                                }
                            }
                            i = i + 1;
                        }
                        return t;
                    }
                }

            }

        }
    }
    export namespace visitor {
        export interface KModelAttributeVisitor {

            (metaAttribute: meta.KMetaAttribute, value: any): void;

        }

        export interface KModelVisitor {

            (elem: KObject): traversal.visitor.KVisitResult;

        }

        export class KVisitResult {

            public static CONTINUE: KVisitResult = new KVisitResult();
            public static SKIP: KVisitResult = new KVisitResult();
            public static STOP: KVisitResult = new KVisitResult();
            public equals(other: any): boolean {
                return this == other;
            }
            public static _KVisitResultVALUES : KVisitResult[] = [
                KVisitResult.CONTINUE
                ,KVisitResult.SKIP
                ,KVisitResult.STOP
            ];
            public static values():KVisitResult[]{
                return KVisitResult._KVisitResultVALUES;
            }
        }

    }
}
export namespace util {
    export class Base64 {

        private static encodeArray = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];
        private static decodeArray = {"A":0, "B":1, "C":2, "D":3, "E":4, "F":5, "G":6, "H":7, "I":8, "J":9, "K":10, "L":11, "M":12, "N":13, "O":14, "P":15, "Q":16, "R":17, "S":18, "T":19, "U":20, "V":21, "W":22, "X":23, "Y":24, "Z":25, "a":26, "b":27, "c":28, "d":29, "e":30, "f":31, "g":32, "h":33, "i":34, "j":35, "k":36, "l":37, "m":38, "n":39, "o":40, "p":41, "q":42, "r":43, "s":44, "t":45, "u":46, "v":47, "w":48, "x":49, "y":50, "z":51, "0":52, "1":53, "2":54, "3":55, "4":56, "5":57, "6":58, "7":59, "8":60, "9":61, "+":62, "/":63};
        private static powTwo = {0:1,1:2,2:4,3:8,4:16,5:32,6:64,7:128,8:256,9:512,10:1024,11:2048,12:4096,13:8192,14:16384,15:32768,16:65536,17:131072,18:262144,19:524288,20:1048576,21:2097152,22:4194304,23:8388608,24:16777216,25:33554432,26:67108864,27:134217728,28:268435456,29:536870912,30:1073741824,31:2147483648,32:4294967296,33:8589934592,34:17179869184,35:34359738368,36:68719476736,37:137438953472,38:274877906944,39:549755813888,40:1099511627776,41:2199023255552,42:4398046511104,43:8796093022208,44:17592186044416,45:35184372088832,46:70368744177664,47:140737488355328,48:281474976710656,49:562949953421312,50:1125899906842624,51:2251799813685248,52:4503599627370496,53:9007199254740992};
        public static encodeLong(l:number) {
            var result = "";
            var tmp = l;
            if(l < 0) {
                tmp = -tmp;
            }
            for (var i = 47; i >= 5; i -= 6) {
                if (!(result === "" && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
                    result += Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F];
                }
            }
            result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
            return result;
        }
        public static encodeLongToBuffer(l:number, buffer:java.lang.StringBuilder) {
            var empty=true;
            var tmp = l;
            if(l < 0) {
                tmp = -tmp;
            }
            for (var i = 47; i >= 5; i -= 6) {
                if (!(empty && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
                    empty = false;
                    buffer.append(Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F]);
                }
            }
            buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
        }
        public static encodeInt(l:number) {
            var result = "";
            var tmp = l;
            if(l < 0) {
                tmp = -tmp;
            }
            for (var i = 29; i >= 5; i -= 6) {
                if (!(result === "" && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
                    result += Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F];
                }
            }
            result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
            return result;
        }
        public static encodeIntToBuffer(l:number, buffer:java.lang.StringBuilder) {
            var empty=true;
            var tmp = l;
            if(l < 0) {
                tmp = -tmp;
            }
            for (var i = 29; i >= 5; i -= 6) {
                if (!(empty && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
                    empty = false;
                    buffer.append(Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F]);
                }
            }
            buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
        }
        public static decodeToLong(s) {
            return Base64.decodeToLongWithBounds(s, 0, s.length);
        }
        public static decodeToLongWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
            var result = 0;
            result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
            for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
                result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Base64.powTwo[(6 * i)-1];
            }
            if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
                result = -result;
            }
            return result;
        }
        public static decodeToInt(s) {
            return Base64.decodeToIntWithBounds(s, 0, s.length);
        }
        public static decodeToIntWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
            var result = 0;
            result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
            for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
                result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Base64.powTwo[(6 * i)-1];
            }
            if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
                result = -result;
            }
            return result;
        }
        public static encodeDouble(d : number) {
            var result = "";
            var floatArr = new Float64Array(1);
            var bytes = new Uint8Array(floatArr.buffer);
            floatArr[0] = d;
            var exponent = (((bytes[7] & 0x7f) * 16) | (bytes[6] / 16)) - 0x3ff;
            var signAndExp = (((bytes[7] / 128) & 0x1) * 2048) + (exponent + 1023);
            //encode sign + exp
            result += Base64.encodeArray[(signAndExp / 64) & 0x3F];
            result += Base64.encodeArray[signAndExp & 0x3F];
            result += Base64.encodeArray[bytes[6] & 0x0F];
            result += Base64.encodeArray[(bytes[5] / 4) & 0x3F];
            result += Base64.encodeArray[((bytes[5] & 0x3) * 16) | (bytes[4] / 16)];
            result += Base64.encodeArray[((bytes[4] & 0x0F) * 4) | (bytes[3] / 64)];
            result += Base64.encodeArray[(bytes[3] & 0x3F)];
            result += Base64.encodeArray[(bytes[2] / 4) & 0x3F];
            result += Base64.encodeArray[((bytes[2] & 0x3) * 16) | (bytes[1] / 16)];
            result += Base64.encodeArray[((bytes[1] & 0x0F) * 4) | (bytes[0] / 64)];
            result += Base64.encodeArray[(bytes[0] & 0x3F)];
            var i = result.length-1;
            while(i >= 3 && result.charAt(i) == 'A') {
                i--;
            }
            return result.substr(0,i+1);
        }
        public static encodeDoubleToBuffer(d : number, buffer : java.lang.StringBuilder) {
            var result = "";
            var floatArr = new Float64Array(1);
            var bytes = new Uint8Array(floatArr.buffer);
            floatArr[0] = d;
            var exponent = (((bytes[7] & 0x7f) * 16) | bytes[6] / 16) - 0x3ff;
            var signAndExp = (((bytes[7] / 128 ) & 0x1) * 2048) + (exponent + 1023);
            //encode sign + exp
            result += Base64.encodeArray[(signAndExp / 64) & 0x3F];
            result += Base64.encodeArray[signAndExp & 0x3F];
            result += Base64.encodeArray[bytes[6] & 0x0F];
            result += Base64.encodeArray[(bytes[5] / 4) & 0x3F];
            result += Base64.encodeArray[((bytes[5] & 0x3) * 16) | (bytes[4] / 16)];
            result += Base64.encodeArray[((bytes[4] & 0x0F) * 4) | (bytes[3] / 64)];
            result += Base64.encodeArray[(bytes[3] & 0x3F)];
            result += Base64.encodeArray[(bytes[2] / 4) & 0x3F];
            result += Base64.encodeArray[((bytes[2] & 0x3) * 16) | (bytes[1] / 16)];
            result += Base64.encodeArray[((bytes[1] & 0x0F) * 4) | (bytes[0] / 64)];
            result += Base64.encodeArray[(bytes[0] & 0x3F)];
            var i = result.length-1;
            while(i >= 3 && result.charAt(i) == 'A') {
                i--;
            }
            buffer.append(result.substr(0,i+1));
        }
        public static decodeToDouble(s:string) {
            return Base64.decodeToDoubleWithBounds(s, 0, s.length);
        }
        public static decodeToDoubleWithBounds(s : string, offsetBegin : number, offsetEnd : number) {
            var signAndExp = ((Base64.decodeArray[s.charAt(offsetBegin)] & 0xFF) * 64) + (Base64.decodeArray[s.charAt(offsetBegin + 1)] & 0xFF);
            var sign = ((signAndExp & 0x800) != 0 ? -1 : 1);
            var exp = signAndExp & 0x7FF;
            //Mantisse
            var mantissaBits = 0;
            for (var i = 2; i < (offsetEnd - offsetBegin); i++) {
                mantissaBits += (Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF) * Base64.powTwo[48 - (6 * (i-2))];
            }
            return (exp != 0) ? sign * Math.pow(2, exp - 1023) * (1 + (mantissaBits / Math.pow(2, 52))) : sign * Math.pow(2, -1022) * (0 + (mantissaBits / Math.pow(2, 52)));
        }
        public static encodeBoolArray(boolArr : Array<boolean>) {
            var result = "";
            var tmpVal = 0;
            for (var i = 0; i < boolArr.length; i++) {
                tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Base64.powTwo[i % 6]);
                if (i % 6 == 5 || i == (boolArr.length - 1)) {
                    result += Base64.encodeArray[tmpVal];
                    tmpVal = 0;
                }
            }
            return result;
        }
        public static encodeBoolArrayToBuffer(boolArr : Array<boolean>, buffer : java.lang.StringBuilder) {
            var tmpVal = 0;
            for (var i = 0; i < boolArr.length; i++) {
                tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Base64.powTwo[i % 6]);
                if (i % 6 == 5 || i == boolArr.length - 1) {
                    buffer.append(Base64.encodeArray[tmpVal]);
                    tmpVal = 0;
                }
            }
        }
        public static decodeBoolArray(s : string, arraySize : number) {
            return Base64.decodeToBoolArrayWithBounds(s, 0, s.length, arraySize);
        }
        public static decodeToBoolArrayWithBounds(s : string, offsetBegin : number, offsetEnd : number, arraySize : number) {
            var resultTmp = [];
            for (var i = 0; i < (offsetEnd - offsetBegin); i++) {
                var bitarray = Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF;
                for (var bit_i = 0; bit_i < 6; bit_i++) {
                    if ((6 * i) + bit_i < arraySize) {
                        resultTmp[(6 * i) + bit_i] = (bitarray & (1 * Base64.powTwo[bit_i])) != 0;
                    } else {
                        break;
                    }
                }
            }
            return resultTmp;
        }


        public static encodeString(s : string) {
            var result = "";
            var sLength = s.length;
            var currentSourceChar;
            var currentEncodedChar = 0;
            var freeBitsInCurrentChar = 6;

            for(var charIdx = 0; charIdx < sLength; charIdx++) {
                currentSourceChar = s.charCodeAt(charIdx);
                if(freeBitsInCurrentChar == 6) {
                    result += Base64.encodeArray[(currentSourceChar / 4) & 0x3F];
                    currentEncodedChar = (currentSourceChar & 0x3) * 16;
                    freeBitsInCurrentChar = 4;
                } else if(freeBitsInCurrentChar == 4) {
                    result += Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 16) & 0xF)) & 0x3F];
                    currentEncodedChar = (currentSourceChar & 0xF) * 4;
                    freeBitsInCurrentChar = 2;
                } else if(freeBitsInCurrentChar == 2) {
                    result += Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 64) & 0x3)) & 0x3F];
                    result += Base64.encodeArray[currentSourceChar & 0x3F];
                    freeBitsInCurrentChar = 6;
                }
            }

            if(freeBitsInCurrentChar != 6) {
                result += Base64.encodeArray[currentEncodedChar];
            }
            return result;
        }
        public static encodeStringToBuffer(s : string, buffer : java.lang.StringBuilder) {
            var sLength = s.length;
            var currentSourceChar;
            var currentEncodedChar = 0;
            var freeBitsInCurrentChar = 6;

            for(var charIdx = 0; charIdx < sLength; charIdx++) {
                currentSourceChar = s.charCodeAt(charIdx);
                if(freeBitsInCurrentChar == 6) {
                    buffer.append(Base64.encodeArray[(currentSourceChar / 4) & 0x3F]);
                    currentEncodedChar = (currentSourceChar & 0x3) * 16;
                    freeBitsInCurrentChar = 4;
                } else if(freeBitsInCurrentChar == 4) {
                    buffer.append(Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 16) & 0xF)) & 0x3F]);
                    currentEncodedChar = (currentSourceChar & 0xF) * 4;
                    freeBitsInCurrentChar = 2;
                } else if(freeBitsInCurrentChar == 2) {
                    buffer.append(Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 64) & 0x3)) & 0x3F]);
                    buffer.append(Base64.encodeArray[currentSourceChar & 0x3F]);
                    freeBitsInCurrentChar = 6;
                }
            }

            if(freeBitsInCurrentChar != 6) {
                buffer.append(Base64.encodeArray[currentEncodedChar]);
            }
        }
        public static decodeString(s : string) {
            return Base64.decodeToStringWithBounds(s, 0, s.length);
        }
        public static decodeToStringWithBounds(s : string, offsetBegin : number, offsetEnd : number) {
            var result = "";
            var currentSourceChar;
            var currentDecodedChar = 0;
            var freeBitsInCurrentChar = 8;

            for(var charIdx = offsetBegin; charIdx < offsetEnd; charIdx++) {
                currentSourceChar = Base64.decodeArray[s.charAt(charIdx)];
                if(freeBitsInCurrentChar == 8) {
                    currentDecodedChar = currentSourceChar * 4;
                    freeBitsInCurrentChar = 2;
                } else if(freeBitsInCurrentChar == 2) {
                    result += String.fromCharCode(currentDecodedChar | (currentSourceChar / 16));
                    currentDecodedChar = (currentSourceChar & 0xF) * 16;
                    freeBitsInCurrentChar = 4;
                } else if(freeBitsInCurrentChar == 4) {
                    result += String.fromCharCode(currentDecodedChar | (currentSourceChar / 4));
                    currentDecodedChar = (currentSourceChar & 0x3) * 64;
                    freeBitsInCurrentChar = 6;
                } else if(freeBitsInCurrentChar == 6) {
                    result += String.fromCharCode(currentDecodedChar | currentSourceChar);
                    freeBitsInCurrentChar = 8;
                }
            }
            return result;
        }
    }

    export class Checker {

        public static isDefined(param: any): boolean {
            return param != undefined && param != null;
        }

    }

    export class PrimitiveHelper {

        public static startsWith(src: string, prefix: string): boolean {
            return src.slice(0, prefix.length) == prefix
        }

        public static endsWith(src: string, prefix: string): boolean {
            return src.slice(-prefix.length) == prefix;
        }

        public static matches(src: string, regex: string): boolean {
            if (regex == null) { return false; } else { var m = src.match(regex); return m != null && m.length > 0; }
        }

        public static equals(src: string, other: string): boolean {
            return src === other
        }

        public static parseInt(val: string): number {
            return parseInt(val);
        }

        public static parseLong(val: string): number {
            return +val;
        }

        public static parseDouble(val: string): number {
            return parseFloat(val);
        }

        public static parseShort(val: string): number {
            return +val;
        }

        public static parseBoolean(val: string): boolean {
            return val === "true";
        }

        public static SHORT_MIN_VALUE(): number {
            return -0x8000;
        }

        public static SHORT_MAX_VALUE(): number {
            return 0x7FFF;
        }

        public static isNaN(val: number): boolean {
            return isNaN(val);
        }

        public static DOUBLE_MIN_VALUE(): number {
            return Number.MIN_VALUE;
        }

        public static DOUBLE_MAX_VALUE(): number {
            return Number.MAX_VALUE;
        }

        public static stringHash(target: string): number {
            var hash = 0;
            if (target.length == 0) return hash;
            for (var i = 0; i < target.length; i++) {
                var charC = target.charCodeAt(i);
                hash = ((hash << 5) - hash) + charC;
                hash = hash & hash; // Convert to 32bit integer
            }
            return hash;
        }

    }

    export namespace maths {
        export class Correlations {

            public static pearson(x: Float64Array, y: Float64Array): number {
                var meanX: number = 0.0, meanY: number = 0.0;
                for (var i: number = 0; i < x.length; i++) {
                    meanX += x[i];
                    meanY += y[i];
                }
                meanX /= x.length;
                meanY /= x.length;
                var sumXY: number = 0.0;
                var sumX2: number = 0.0;
                var sumY2: number = 0.0;
                for (var i: number = 0; i < x.length; i++) {
                    sumXY += ((x[i] - meanX) * (y[i] - meanY));
                    sumX2 += (x[i] - meanX) * (x[i] - meanX);
                    sumY2 += (y[i] - meanY) * (y[i] - meanY);
                }
                return (sumXY / (Math.sqrt(sumX2) * Math.sqrt(sumY2)));
            }

        }

        export class Distribution {

            public static inverseNormalCDF(q: number): number {
                var b: Float64Array = new Float64Array([1.570796288, 0.03706987906, -0.8364353589e-3, -0.2250947176e-3, 0.6841218299e-5, 0.5824238515e-5, -0.104527497e-5, 0.8360937017e-7, -0.3231081277e-8, 0.3657763036e-10, 0.6936233982e-12]);
                if (q < 0.0 || 1.0 < q || q == 0.5) {
                    return 0.0;
                }
                var w1: number = q;
                if (q > 0.5) {
                    w1 = 1.0 - q;
                }
                var w3: number = -Math.log(4.0 * w1 * (1.0 - w1));
                w1 = b[0];
                for (var i: number = 1; i < 11; i++) {
                    w1 += b[i] * Math.pow(w3, i);
                }
                return q > 0.5 ? Math.sqrt(w1 * w3) : -Math.sqrt(w1 * w3);
            }

            public static gaussian(features: Float64Array, means: Float64Array, variances: Float64Array): number {
                var dim: number = features.length;
                var p: number = 1;
                for (var i: number = 0; i < dim; i++) {
                    p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
                }
                return p;
            }

            public static gaussianArray(features: util.maths.structure.KArray2D, row: number, means: Float64Array, variances: Float64Array): number {
                var dim: number = features.columns();
                var p: number = 1;
                for (var i: number = 0; i < dim; i++) {
                    p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features.get(row, i) - means[i]) * (features.get(row, i) - means[i])) / (2 * variances[i]));
                }
                return p;
            }

            public static parallelGaussian(features: Float64Array, means: Float64Array, variances: Float64Array): Float64Array {
                var dim: number = features.length;
                var p: Float64Array = new Float64Array(dim);
                for (var i: number = 0; i < dim; i++) {
                    p[i] = (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
                }
                return p;
            }

            public static gaussianOneFeature(feature: number, mean: number, variance: number): number {
                return (1 / Math.sqrt(2 * Math.PI * variance)) * Math.exp(-((feature - mean) * (feature - mean)) / (2 * variance));
            }

        }

        export class PolynomialFit {

            public A: util.maths.matrix.DenseMatrix64F;
            public coef: util.maths.matrix.DenseMatrix64F;
            public y: util.maths.matrix.DenseMatrix64F;
            public solver: util.maths.matrix.solvers.AdjLinearSolverQr;
            constructor(degree: number) {
                this.coef = new util.maths.matrix.DenseMatrix64F(degree + 1, 1);
                this.A = new util.maths.matrix.DenseMatrix64F(1, degree + 1);
                this.y = new util.maths.matrix.DenseMatrix64F(1, 1);
                this.solver = new util.maths.matrix.solvers.AdjLinearSolverQr();
            }

            public getCoef(): Float64Array {
                return this.coef.data;
            }

            public fit(samplePoints: Float64Array, observations: Float64Array): void {
                this.y.reshapeBoolean(observations.length, 1, false);
                java.lang.System.arraycopy(observations, 0, this.y.data, 0, observations.length);
                this.A.reshapeBoolean(this.y.numRows, this.coef.numRows, false);
                for (var i: number = 0; i < observations.length; i++) {
                    var obs: number = 1;
                    for (var j: number = 0; j < this.coef.numRows; j++) {
                        this.A.cset(i, j, obs);
                        obs *= samplePoints[i];
                    }
                }
                this.solver.setA(this.A);
                this.solver.solve(this.y, this.coef);
            }

            public static extrapolate(time: number, weights: Float64Array): number {
                var result: number = 0;
                var power: number = 1;
                for (var j: number = 0; j < weights.length; j++) {
                    result += weights[j] * power;
                    power = power * time;
                }
                return result;
            }

        }

        export class Ranking {

            public static wilsonRank(positive: number, negative: number, confidence: number): number {
                var n: number = positive + negative;
                if (n == 0) {
                    return 0.0;
                }
                var z: number = util.maths.Distribution.inverseNormalCDF(1.0 - confidence / 2.0);
                var p_hat: number = (1.0 * positive) / n;
                return (p_hat + z * z / (2.0 * n) - z * Math.sqrt((p_hat * (1.0 - p_hat) + z * z / (4.0 * n)) / n)) / (1.0 + z * z / n);
            }

        }

        export class Statistic {

            public static calcHistogram(data: Float64Array, dataratings: Float64Array, numBins: number): void {
                var result: Int32Array = new Int32Array(numBins);
                var max: number;
                var min: number;
                min = data[0];
                max = data[0];
                for (var i: number = 0; i < data.length; i++) {
                    if (data[i] < min) {
                        min = data[i];
                    }
                    if (data[i] > max) {
                        max = data[i];
                    }
                }
                var binSize: number = (max - min) / numBins;
                for (var i: number = 0; i < data.length; i++) {
                    var bin: number = <number>((data[i] - min) / binSize);
                    result[bin]++;
                }
            }

        }

        export class StringDistance {

            public static levenshtein(s0: string, s1: string): number {
                var len0: number = s0.length + 1;
                var len1: number = s1.length + 1;
                var cost: Int32Array = new Int32Array(len0);
                var newcost: Int32Array = new Int32Array(len0);
                for (var i: number = 0; i < len0; i++) {
                    cost[i] = i;
                }
                for (var j: number = 1; j < len1; j++) {
                    newcost[0] = j;
                    for (var i: number = 1; i < len0; i++) {
                        var match: number = (s0.charAt(i - 1) == s1.charAt(j - 1)) ? 0 : 1;
                        var cost_replace: number = cost[i - 1] + match;
                        var cost_insert: number = cost[i] + 1;
                        var cost_delete: number = newcost[i - 1] + 1;
                        newcost[i] = Math.min(Math.min(cost_insert, cost_delete), cost_replace);
                    }
                    var swap: Int32Array = cost;
                    cost = newcost;
                    newcost = swap;
                }
                return cost[len0 - 1];
            }

        }

        export namespace expression {
            export interface KMathExpressionEngine {

                parse(p_expression: string): util.maths.expression.KMathExpressionEngine;

                setVarResolver(resolver: util.maths.expression.KMathVariableResolver): void;

                eval(context: KObject): number;

            }

            export interface KMathVariableResolver {

                (potentialVarName: string): number;

            }

            export namespace impl {
                export class MathDoubleToken implements util.maths.expression.impl.MathToken {

                    private _content: number;
                    public type(): number {
                        return 2;
                    }

                    constructor(_content: number) {
                        this._content = _content;
                    }

                    public content(): number {
                        return this._content;
                    }

                    public type2(): number {
                        return 0;
                    }

                }

                export class MathEntities {

                    private static INSTANCE: util.maths.expression.impl.MathEntities = null;
                    public operators: memory.chunk.KStringMap<util.maths.expression.impl.MathOperation>;
                    public functions: memory.chunk.KStringMap<util.maths.expression.impl.MathFunction>;
                    public static getINSTANCE(): util.maths.expression.impl.MathEntities {
                        if (MathEntities.INSTANCE == null) {
                            MathEntities.INSTANCE = new util.maths.expression.impl.MathEntities();
                        }
                        return MathEntities.INSTANCE;
                    }

                    constructor() {
                        this.operators = new memory.chunk.impl.ArrayStringMap<util.maths.expression.impl.MathOperation>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                        this.operators.put("+", new util.maths.expression.impl.MathOperation("+", 20, true));
                        this.operators.put("-", new util.maths.expression.impl.MathOperation("-", 20, true));
                        this.operators.put("*", new util.maths.expression.impl.MathOperation("*", 30, true));
                        this.operators.put("/", new util.maths.expression.impl.MathOperation("/", 30, true));
                        this.operators.put("%", new util.maths.expression.impl.MathOperation("%", 30, true));
                        this.operators.put("^", new util.maths.expression.impl.MathOperation("^", 40, false));
                        this.operators.put("&&", new util.maths.expression.impl.MathOperation("&&", 4, false));
                        this.operators.put("||", new util.maths.expression.impl.MathOperation("||", 2, false));
                        this.operators.put(">", new util.maths.expression.impl.MathOperation(">", 10, false));
                        this.operators.put(">=", new util.maths.expression.impl.MathOperation(">=", 10, false));
                        this.operators.put("<", new util.maths.expression.impl.MathOperation("<", 10, false));
                        this.operators.put("<=", new util.maths.expression.impl.MathOperation("<=", 10, false));
                        this.operators.put("==", new util.maths.expression.impl.MathOperation("==", 7, false));
                        this.operators.put("!=", new util.maths.expression.impl.MathOperation("!=", 7, false));
                        this.functions = new memory.chunk.impl.ArrayStringMap<util.maths.expression.impl.MathFunction>(KConfig.CACHE_INIT_SIZE, KConfig.CACHE_LOAD_FACTOR);
                        this.functions.put("NOT", new util.maths.expression.impl.MathFunction("NOT", 1));
                        this.functions.put("IF", new util.maths.expression.impl.MathFunction("IF", 3));
                        this.functions.put("RAND", new util.maths.expression.impl.MathFunction("RAND", 0));
                        this.functions.put("SIN", new util.maths.expression.impl.MathFunction("SIN", 1));
                        this.functions.put("COS", new util.maths.expression.impl.MathFunction("COS", 1));
                        this.functions.put("TAN", new util.maths.expression.impl.MathFunction("TAN", 1));
                        this.functions.put("ASIN", new util.maths.expression.impl.MathFunction("ASIN", 1));
                        this.functions.put("ACOS", new util.maths.expression.impl.MathFunction("ACOS", 1));
                        this.functions.put("ATAN", new util.maths.expression.impl.MathFunction("ATAN", 1));
                        this.functions.put("MAX", new util.maths.expression.impl.MathFunction("MAX", 2));
                        this.functions.put("MIN", new util.maths.expression.impl.MathFunction("MIN", 2));
                        this.functions.put("ABS", new util.maths.expression.impl.MathFunction("ABS", 1));
                        this.functions.put("LOG", new util.maths.expression.impl.MathFunction("LOG", 1));
                        this.functions.put("ROUND", new util.maths.expression.impl.MathFunction("ROUND", 2));
                        this.functions.put("FLOOR", new util.maths.expression.impl.MathFunction("FLOOR", 1));
                        this.functions.put("CEILING", new util.maths.expression.impl.MathFunction("CEILING", 1));
                        this.functions.put("SQRT", new util.maths.expression.impl.MathFunction("SQRT", 1));
                        this.functions.put("SECONDS", new util.maths.expression.impl.MathFunction("SECONDS", 1));
                        this.functions.put("MINUTES", new util.maths.expression.impl.MathFunction("MINUTES", 1));
                        this.functions.put("HOURS", new util.maths.expression.impl.MathFunction("HOURS", 1));
                        this.functions.put("DAY", new util.maths.expression.impl.MathFunction("DAY", 1));
                        this.functions.put("MONTH", new util.maths.expression.impl.MathFunction("MONTH", 1));
                        this.functions.put("YEAR", new util.maths.expression.impl.MathFunction("YEAR", 1));
                        this.functions.put("DAYOFWEEK", new util.maths.expression.impl.MathFunction("DAYOFWEEK", 1));
                    }

                }

                export class MathExpressionEngine implements util.maths.expression.KMathExpressionEngine {

                    private varResolver: util.maths.expression.KMathVariableResolver;
                    public static decimalSeparator: string = '.';
                    public static minusSign: string = '-';
                    private _cacheAST: util.maths.expression.impl.MathToken[] = null;
                    constructor() {
                        var vars: java.util.HashMap<string, number> = new java.util.HashMap<string, number>();
                        vars.put("PI", Math.PI);
                        vars.put("TRUE", 1.0);
                        vars.put("FALSE", 0.0);
                        this.varResolver =  (potentialVarName : string) => {
                            return vars.get(potentialVarName);
                        };
                    }

                    public static isNumber(st: string): boolean {
                        return !isNaN(+st);
                    }

                    public static isDigit(c: string): boolean {
                        var cc = c.charCodeAt(0);
                        if ( cc >= 0x30 && cc <= 0x39 ){
                            return true ;
                        }
                        return false ;
                    }

                    public static isLetter(c: string): boolean {
                        var cc = c.charCodeAt(0);
                        if ( ( cc >= 0x41 && cc <= 0x5A ) || ( cc >= 0x61 && cc <= 0x7A ) ){
                            return true ;
                        }
                        return false ;
                    }

                    public static isWhitespace(c: string): boolean {
                        var cc = c.charCodeAt(0);
                        if ( ( cc >= 0x0009 && cc <= 0x000D ) || ( cc == 0x0020 ) || ( cc == 0x0085 ) || ( cc == 0x00A0 ) ){
                            return true ;
                        }
                        return false ;
                    }

                    private shuntingYard(expression: string): java.util.List<string> {
                        var outputQueue: java.util.List<string> = new java.util.ArrayList<string>();
                        var stack: java.util.Stack<string> = new java.util.Stack<string>();
                        var tokenizer: util.maths.expression.impl.MathExpressionTokenizer = new util.maths.expression.impl.MathExpressionTokenizer(expression);
                        var lastFunction: string = null;
                        var previousToken: string = null;
                        while (tokenizer.hasNext()){
                            var token: string = tokenizer.next();
                            if (util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                                stack.push(token);
                                lastFunction = token;
                            } else {
                                if (util.PrimitiveHelper.equals(",", token)) {
                                    while (!stack.isEmpty() && !util.PrimitiveHelper.equals("(", stack.peek())){
                                        outputQueue.add(stack.pop());
                                    }
                                    if (stack.isEmpty()) {
                                        throw new Error("Parse error for function '" + lastFunction + "'");
                                    }
                                } else {
                                    if (util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                                        var o1: util.maths.expression.impl.MathOperation = util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token);
                                        var token2: string = stack.isEmpty() ? null : stack.peek();
                                        while (util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token2) && ((o1.isLeftAssoc() && o1.getPrecedence() <= util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()) || (o1.getPrecedence() < util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()))){
                                            outputQueue.add(stack.pop());
                                            token2 = stack.isEmpty() ? null : stack.peek();
                                        }
                                        stack.push(token);
                                    } else {
                                        if (util.PrimitiveHelper.equals("(", token)) {
                                            if (previousToken != null) {
                                                if (util.maths.expression.impl.MathExpressionEngine.isNumber(previousToken)) {
                                                    throw new Error("Missing operator at character position " + tokenizer.getPos());
                                                }
                                            }
                                            stack.push(token);
                                        } else {
                                            if (util.PrimitiveHelper.equals(")", token)) {
                                                while (!stack.isEmpty() && !util.PrimitiveHelper.equals("(", stack.peek())){
                                                    outputQueue.add(stack.pop());
                                                }
                                                if (stack.isEmpty()) {
                                                    throw new Error("Mismatched parentheses");
                                                }
                                                stack.pop();
                                                if (!stack.isEmpty() && util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(stack.peek().toUpperCase())) {
                                                    outputQueue.add(stack.pop());
                                                }
                                            } else {
                                                outputQueue.add(token);
                                            }
                                        }
                                    }
                                }
                            }
                            previousToken = token;
                        }
                        while (!stack.isEmpty()){
                            var element: string = stack.pop();
                            if (util.PrimitiveHelper.equals("(", element) || util.PrimitiveHelper.equals(")", element)) {
                                throw new Error("Mismatched parentheses");
                            }
                            outputQueue.add(element);
                        }
                        return outputQueue;
                    }

                    public eval(context: KObject): number {
                        if (this._cacheAST == null) {
                            throw new Error("Call parse before");
                        }
                        var stack: java.util.Stack<number> = new java.util.Stack<number>();
                        for (var ii: number = 0; ii < this._cacheAST.length; ii++) {
                            var mathToken: util.maths.expression.impl.MathToken = this._cacheAST[ii];
                            switch (mathToken.type()) {
                                case 0:
                                    var v1: number = stack.pop();
                                    var v2: number = stack.pop();
                                    var castedOp: util.maths.expression.impl.MathOperation = <util.maths.expression.impl.MathOperation>mathToken;
                                    stack.push(castedOp.eval(v2, v1));
                                    break;
                                case 1:
                                    var castedFunction: util.maths.expression.impl.MathFunction = <util.maths.expression.impl.MathFunction>mathToken;
                                    var p: Float64Array = new Float64Array(castedFunction.getNumParams());
                                    for (var i: number = castedFunction.getNumParams() - 1; i >= 0; i--) {
                                        p[i] = stack.pop();
                                    }
                                    stack.push(castedFunction.eval(p));
                                    break;
                                case 2:
                                    var castedDouble: util.maths.expression.impl.MathDoubleToken = <util.maths.expression.impl.MathDoubleToken>mathToken;
                                    stack.push(castedDouble.content());
                                    break;
                                case 3:
                                    var castedFreeToken: util.maths.expression.impl.MathFreeToken = <util.maths.expression.impl.MathFreeToken>mathToken;
                                    if (this.varResolver(castedFreeToken.content()) != null) {
                                        stack.push(this.varResolver(castedFreeToken.content()));
                                    } else {
                                        if (context != null) {
                                            if (util.PrimitiveHelper.equals("TIME", castedFreeToken.content())) {
                                                stack.push(<number>context.now());
                                            } else {
                                                var resolved: any = context.getByName(castedFreeToken.content());
                                                if (resolved != null) {
                                                    if (resolved instanceof meta.impl.MetaLiteral) {
                                                        stack.push(<number>(<meta.impl.MetaLiteral>resolved).index());
                                                    } else {
                                                        var valueString: string = resolved.toString();
                                                        if (util.PrimitiveHelper.equals(valueString, "true")) {
                                                            stack.push(1.0);
                                                        } else {
                                                            if (util.PrimitiveHelper.equals(valueString, "false")) {
                                                                stack.push(0.0);
                                                            } else {
                                                                try {
                                                                    stack.push(util.PrimitiveHelper.parseDouble(resolved.toString()));
                                                                } catch ($ex$) {
                                                                    if ($ex$ instanceof Error) {
                                                                        var e: Error = <Error>$ex$;
                                                                    } else {
                                                                        throw $ex$;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    throw new Error("Unknow variable for name " + castedFreeToken.content());
                                                }
                                            }
                                        } else {
                                            throw new Error("Unknow variable for name " + castedFreeToken.content());
                                        }
                                    }
                                    break;
                            }
                        }
                        var result: number = stack.pop();
                        if (result == null) {
                            return 0;
                        } else {
                            return result;
                        }
                    }

                    public buildAST(rpn: java.util.List<string>): util.maths.expression.impl.MathToken[] {
                        var result: util.maths.expression.impl.MathToken[] = new Array();
                        for (var ii: number = 0; ii < rpn.size(); ii++) {
                            var token: string = rpn.get(ii);
                            if (util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                                result[ii] = util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token);
                            } else {
                                if (util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                                    result[ii] = util.maths.expression.impl.MathEntities.getINSTANCE().functions.get(token.toUpperCase());
                                } else {
                                    if (token.length > 0 && util.maths.expression.impl.MathExpressionEngine.isLetter(token.charAt(0))) {
                                        result[ii] = new util.maths.expression.impl.MathFreeToken(token);
                                    } else {
                                        try {
                                            var parsed: number = util.PrimitiveHelper.parseDouble(token);
                                            result[ii] = new util.maths.expression.impl.MathDoubleToken(parsed);
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                result[ii] = new util.maths.expression.impl.MathFreeToken(token);
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return result;
                    }

                    public parse(p_expression: string): util.maths.expression.KMathExpressionEngine {
                        var rpn: java.util.List<string> = this.shuntingYard(p_expression);
                        this._cacheAST = this.buildAST(rpn);
                        return this;
                    }

                    public setVarResolver(p_resolver: util.maths.expression.KMathVariableResolver): void {
                        this.varResolver = p_resolver;
                    }

                }

                export class MathExpressionTokenizer {

                    private pos: number = 0;
                    private input: string;
                    private previousToken: string;
                    constructor(input: string) {
                        this.input = input.trim();
                    }

                    public hasNext(): boolean {
                        return (this.pos < this.input.length);
                    }

                    private peekNextChar(): string {
                        if (this.pos < (this.input.length - 1)) {
                            return this.input.charAt(this.pos + 1);
                        } else {
                            return '\0';
                        }
                    }

                    public next(): string {
                        var token: java.lang.StringBuilder = new java.lang.StringBuilder();
                        if (this.pos >= this.input.length) {
                            return this.previousToken = null;
                        }
                        var ch: string = this.input.charAt(this.pos);
                        while (util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && this.pos < this.input.length){
                            ch = this.input.charAt(++this.pos);
                        }
                        if (util.maths.expression.impl.MathExpressionEngine.isDigit(ch)) {
                            while ((util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || ch == util.maths.expression.impl.MathExpressionEngine.decimalSeparator) && (this.pos < this.input.length)){
                                token.append(this.input.charAt(this.pos++));
                                ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                            }
                        } else {
                            if (ch == util.maths.expression.impl.MathExpressionEngine.minusSign && util.maths.expression.impl.MathExpressionEngine.isDigit(this.peekNextChar()) && (util.PrimitiveHelper.equals("(", this.previousToken) || util.PrimitiveHelper.equals(",", this.previousToken) || this.previousToken == null || util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(this.previousToken))) {
                                token.append(util.maths.expression.impl.MathExpressionEngine.minusSign);
                                this.pos++;
                                token.append(this.next());
                            } else {
                                if (util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || (ch == '_')) {
                                    while ((util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || (ch == '_')) && (this.pos < this.input.length)){
                                        token.append(this.input.charAt(this.pos++));
                                        ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                                    }
                                } else {
                                    if (ch == '(' || ch == ')' || ch == ',') {
                                        token.append(ch);
                                        this.pos++;
                                    } else {
                                        while (!util.maths.expression.impl.MathExpressionEngine.isLetter(ch) && !util.maths.expression.impl.MathExpressionEngine.isDigit(ch) && ch != '_' && !util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && ch != '(' && ch != ')' && ch != ',' && (this.pos < this.input.length)){
                                            token.append(this.input.charAt(this.pos));
                                            this.pos++;
                                            ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                                            if (ch == util.maths.expression.impl.MathExpressionEngine.minusSign) {
                                                break;
                                            }
                                        }
                                        if (!util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token.toString())) {
                                            throw new Error("Unknown operator '" + token + "' at position " + (this.pos - token.length + 1));
                                        }
                                    }
                                }
                            }
                        }
                        return this.previousToken = token.toString();
                    }

                    public getPos(): number {
                        return this.pos;
                    }

                }

                export class MathFreeToken implements util.maths.expression.impl.MathToken {

                    private _content: string;
                    constructor(content: string) {
                        this._content = content;
                    }

                    public content(): string {
                        return this._content;
                    }

                    public type(): number {
                        return 3;
                    }

                    public type2(): number {
                        return 0;
                    }

                }

                export class MathFunction implements util.maths.expression.impl.MathToken {

                    private name: string;
                    private numParams: number;
                    constructor(name: string, numParams: number) {
                        this.name = name.toUpperCase();
                        this.numParams = numParams;
                    }

                    public getName(): string {
                        return this.name;
                    }

                    public getNumParams(): number {
                        return this.numParams;
                    }

                    public eval(p: Float64Array): number {
                        if (util.PrimitiveHelper.equals(this.name, "NOT")) {
                            return (p[0] == 0) ? 1 : 0;
                        } else {
                            if (util.PrimitiveHelper.equals(this.name, "IF")) {
                                return !(p[0] == 0) ? p[1] : p[2];
                            } else {
                                if (util.PrimitiveHelper.equals(this.name, "RAND")) {
                                    return Math.random();
                                } else {
                                    if (util.PrimitiveHelper.equals(this.name, "SIN")) {
                                        return Math.sin(p[0]);
                                    } else {
                                        if (util.PrimitiveHelper.equals(this.name, "COS")) {
                                            return Math.cos(p[0]);
                                        } else {
                                            if (util.PrimitiveHelper.equals(this.name, "TAN")) {
                                                return Math.tan(p[0]);
                                            } else {
                                                if (util.PrimitiveHelper.equals(this.name, "ASIN")) {
                                                    return Math.asin(p[0]);
                                                } else {
                                                    if (util.PrimitiveHelper.equals(this.name, "ACOS")) {
                                                        return Math.acos(p[0]);
                                                    } else {
                                                        if (util.PrimitiveHelper.equals(this.name, "ATAN")) {
                                                            return Math.atan(p[0]);
                                                        } else {
                                                            if (util.PrimitiveHelper.equals(this.name, "MAX")) {
                                                                return p[0] > p[1] ? p[0] : p[1];
                                                            } else {
                                                                if (util.PrimitiveHelper.equals(this.name, "MIN")) {
                                                                    return p[0] < p[1] ? p[0] : p[1];
                                                                } else {
                                                                    if (util.PrimitiveHelper.equals(this.name, "ABS")) {
                                                                        return Math.abs(p[0]);
                                                                    } else {
                                                                        if (util.PrimitiveHelper.equals(this.name, "LOG")) {
                                                                            return Math.log(p[0]);
                                                                        } else {
                                                                            if (util.PrimitiveHelper.equals(this.name, "ROUND")) {
                                                                                var factor: number = <number>Math.pow(10, p[1]);
                                                                                var value: number = p[0] * factor;
                                                                                var tmp: number = Math.round(value);
                                                                                return <number>tmp / factor;
                                                                            } else {
                                                                                if (util.PrimitiveHelper.equals(this.name, "FLOOR")) {
                                                                                    return Math.floor(p[0]);
                                                                                } else {
                                                                                    if (util.PrimitiveHelper.equals(this.name, "CEILING")) {
                                                                                        return Math.ceil(p[0]);
                                                                                    } else {
                                                                                        if (util.PrimitiveHelper.equals(this.name, "SQRT")) {
                                                                                            return Math.sqrt(p[0]);
                                                                                        } else {
                                                                                            if (util.PrimitiveHelper.equals(this.name, "SECONDS")) {
                                                                                                return this.date_to_seconds(p[0]);
                                                                                            } else {
                                                                                                if (util.PrimitiveHelper.equals(this.name, "MINUTES")) {
                                                                                                    return this.date_to_minutes(p[0]);
                                                                                                } else {
                                                                                                    if (util.PrimitiveHelper.equals(this.name, "HOURS")) {
                                                                                                        return this.date_to_hours(p[0]);
                                                                                                    } else {
                                                                                                        if (util.PrimitiveHelper.equals(this.name, "DAY")) {
                                                                                                            return this.date_to_days(p[0]);
                                                                                                        } else {
                                                                                                            if (util.PrimitiveHelper.equals(this.name, "MONTH")) {
                                                                                                                return this.date_to_months(p[0]);
                                                                                                            } else {
                                                                                                                if (util.PrimitiveHelper.equals(this.name, "YEAR")) {
                                                                                                                    return this.date_to_year(p[0]);
                                                                                                                } else {
                                                                                                                    if (util.PrimitiveHelper.equals(this.name, "DAYOFWEEK")) {
                                                                                                                        return this.date_to_dayofweek(p[0]);
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return 0;
                    }

                    private date_to_seconds(value: number): number {
                        var date = new Date(value);
                        return date.getSeconds();
                    }

                    private date_to_minutes(value: number): number {
                        var date = new Date(value);
                        return date.getMinutes();
                    }

                    private date_to_hours(value: number): number {
                        var date = new Date(value);
                        return date.getHours();
                    }

                    private date_to_days(value: number): number {
                        var date = new Date(value);
                        return date.getDate();
                    }

                    private date_to_months(value: number): number {
                        var date = new Date(value);
                        return date.getMonth();
                    }

                    private date_to_year(value: number): number {
                        var date = new Date(value);
                        return date.getFullYear();
                    }

                    private date_to_dayofweek(value: number): number {
                        var date = new Date(value);
                        return date.getDay();
                    }

                    public type(): number {
                        return 1;
                    }

                    public type2(): number {
                        return 0;
                    }

                }

                export class MathOperation implements util.maths.expression.impl.MathToken {

                    private oper: string;
                    private precedence: number;
                    private leftAssoc: boolean;
                    constructor(oper: string, precedence: number, leftAssoc: boolean) {
                        this.oper = oper;
                        this.precedence = precedence;
                        this.leftAssoc = leftAssoc;
                    }

                    public getOper(): string {
                        return this.oper;
                    }

                    public getPrecedence(): number {
                        return this.precedence;
                    }

                    public isLeftAssoc(): boolean {
                        return this.leftAssoc;
                    }

                    public eval(v1: number, v2: number): number {
                        if (util.PrimitiveHelper.equals(this.oper, "+")) {
                            return v1 + v2;
                        } else {
                            if (util.PrimitiveHelper.equals(this.oper, "-")) {
                                return v1 - v2;
                            } else {
                                if (util.PrimitiveHelper.equals(this.oper, "*")) {
                                    return v1 * v2;
                                } else {
                                    if (util.PrimitiveHelper.equals(this.oper, "/")) {
                                        return v1 / v2;
                                    } else {
                                        if (util.PrimitiveHelper.equals(this.oper, "%")) {
                                            return v1 % v2;
                                        } else {
                                            if (util.PrimitiveHelper.equals(this.oper, "^")) {
                                                return Math.pow(v1, v2);
                                            } else {
                                                if (util.PrimitiveHelper.equals(this.oper, "&&")) {
                                                    var b1: boolean = !(v1 == 0);
                                                    var b2: boolean = !(v2 == 0);
                                                    return b1 && b2 ? 1 : 0;
                                                } else {
                                                    if (util.PrimitiveHelper.equals(this.oper, "||")) {
                                                        var b1: boolean = !(v1 == 0);
                                                        var b2: boolean = !(v2 == 0);
                                                        return b1 || b2 ? 1 : 0;
                                                    } else {
                                                        if (util.PrimitiveHelper.equals(this.oper, ">")) {
                                                            return v1 > v2 ? 1 : 0;
                                                        } else {
                                                            if (util.PrimitiveHelper.equals(this.oper, ">=")) {
                                                                return v1 >= v2 ? 1 : 0;
                                                            } else {
                                                                if (util.PrimitiveHelper.equals(this.oper, "<")) {
                                                                    return v1 < v2 ? 1 : 0;
                                                                } else {
                                                                    if (util.PrimitiveHelper.equals(this.oper, "<=")) {
                                                                        return v1 <= v2 ? 1 : 0;
                                                                    } else {
                                                                        if (util.PrimitiveHelper.equals(this.oper, "==")) {
                                                                            return v1 == v2 ? 1 : 0;
                                                                        } else {
                                                                            if (util.PrimitiveHelper.equals(this.oper, "!=")) {
                                                                                return v1 != v2 ? 1 : 0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return 0;
                    }

                    public type(): number {
                        return 0;
                    }

                    public type2(): number {
                        return 0;
                    }

                }

                export interface MathToken {

                    type(): number;

                    type2(): number;

                }

            }
        }
        export namespace matrix {
            export class CommonOps {

                public static BLOCK_WIDTH: number = 60;
                public static TRANSPOSE_SWITCH: number = 375;
                public static MULT_COLUMN_SWITCH: number = 15;
                public static EPS: number = Math.pow(2, -52);
                public static mult(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (b.numCols == 1) {
                        util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                    } else {
                        if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                            util.maths.matrix.MatrixMatrixMult.mult_reorder(a, b, c);
                        } else {
                            util.maths.matrix.MatrixMatrixMult.mult_small(a, b, c);
                        }
                    }
                }

                public static memset(data: Float64Array, val: number): void {
                    for (var i: number = 0; i < data.length; i++) {
                        data[i] = val;
                    }
                }

                public static multAddalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                        util.maths.matrix.MatrixMatrixMult.multAdd_reorderalpha(alpha, a, b, c);
                    } else {
                        util.maths.matrix.MatrixMatrixMult.multAdd_smallalpha(alpha, a, b, c);
                    }
                }

                public static multAlphaBetaTransA(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F, beta: number): void {
                    c.scale(beta);
                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                        util.maths.matrix.MatrixMatrixMult.multAlphaTransA_reorder(alpha, a, b, c);
                    } else {
                        util.maths.matrix.MatrixMatrixMult.multAlphaTransA_small(alpha, a, b, c);
                    }
                }

                public static multTransA(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (b.numCols == 1) {
                        if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                            util.maths.matrix.MatrixVectorMult.multTransA_reorder(a, b, c);
                        } else {
                            util.maths.matrix.MatrixVectorMult.multTransA_small(a, b, c);
                        }
                    } else {
                        if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                            util.maths.matrix.MatrixMatrixMult.multTransA_reorder(a, b, c);
                        } else {
                            util.maths.matrix.MatrixMatrixMult.multTransA_small(a, b, c);
                        }
                    }
                }

                public static multTransB(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (b.numRows == 1) {
                        util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                    } else {
                        util.maths.matrix.MatrixMatrixMult.multTransB(a, b, c);
                    }
                }

                public static subvector(A: util.maths.matrix.DenseMatrix64F, rowA: number, colA: number, length: number, row: boolean, offsetV: number, v: util.maths.matrix.DenseMatrix64F): void {
                    if (row) {
                        for (var i: number = 0; i < length; i++) {
                            v.setValueAtIndex(offsetV + i, A.get(rowA, colA + i));
                        }
                    } else {
                        for (var i: number = 0; i < length; i++) {
                            v.setValueAtIndex(offsetV + i, A.get(rowA + i, colA));
                        }
                    }
                }

                public static abs(matrix: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    for (var i: number = 0; i < matrix.numRows(); i++) {
                        for (var j: number = 0; j < matrix.numCols(); j++) {
                            matrix.setValue2D(i, j, Math.abs(matrix.getValue2D(i, j)));
                        }
                    }
                    return matrix;
                }

                public static trace(a: util.maths.matrix.DenseMatrix64F): number {
                    var N: number = Math.min(a.numRows, a.numCols);
                    var sum: number = 0;
                    var index: number = 0;
                    for (var i: number = 0; i < N; i++) {
                        sum += a.getValueAtIndex(index);
                        index += 1 + a.numCols;
                    }
                    return sum;
                }

                public static transposeMatrix(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                    if (A_tran == null) {
                        A_tran = new util.maths.matrix.DenseMatrix64F(A.numCols, A.numRows);
                    } else {
                        if (A.numRows != A_tran.numCols || A.numCols != A_tran.numRows) {
                            throw new Error("Incompatible matrix dimensions");
                        }
                    }
                    if (A.numRows > CommonOps.TRANSPOSE_SWITCH && A.numCols > CommonOps.TRANSPOSE_SWITCH) {
                        util.maths.matrix.TransposeAlgs.block(A, A_tran, CommonOps.BLOCK_WIDTH);
                    } else {
                        util.maths.matrix.TransposeAlgs.standard(A, A_tran);
                    }
                    return A_tran;
                }

                public static transpose(mat: util.maths.matrix.DenseMatrix64F): void {
                    if (mat.numCols == mat.numRows) {
                        util.maths.matrix.TransposeAlgs.square(mat);
                    } else {
                        var b: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(mat.numCols, mat.numRows);
                        util.maths.matrix.CommonOps.transposeMatrix(mat, b);
                        mat.setMatrix(b);
                    }
                }

                public static det(mat: util.maths.matrix.DenseMatrix64F): number {
                    var numCol: number = mat.getNumCols();
                    var numRow: number = mat.getNumRows();
                    if (numCol != numRow) {
                        throw new Error("Must be a square matrix.");
                    } else {
                        if (numCol <= 1) {
                            return mat.getValueAtIndex(0);
                        } else {
                            var alg: util.maths.matrix.solvers.LUDecompositionAlt_D64 = new util.maths.matrix.solvers.LUDecompositionAlt_D64();
                            if (!alg.decompose(mat)) {
                                return 0.0;
                            }
                            return alg.computeDeterminant();
                        }
                    }
                }

                public static invert(mat: util.maths.matrix.DenseMatrix64F, result: util.maths.matrix.DenseMatrix64F): boolean {
                    var alg: util.maths.matrix.solvers.LUDecompositionAlt_D64 = new util.maths.matrix.solvers.LUDecompositionAlt_D64();
                    var solver: util.maths.matrix.solvers.LinearSolverLu_D64 = new util.maths.matrix.solvers.LinearSolverLu_D64(alg);
                    if (solver.modifiesA()) {
                        mat = mat.copy();
                    }
                    if (!solver.setA(mat)) {
                        return false;
                    }
                    solver.invert(result);
                    return true;
                }

                public static copyMatrix(matA: util.maths.structure.KArray2D, ejmlmatA: util.maths.matrix.SimpleMatrix): void {
                    for (var i: number = 0; i < matA.rows(); i++) {
                        for (var j: number = 0; j < matA.columns(); j++) {
                            ejmlmatA.setValue2D(i, j, matA.get(i, j));
                        }
                    }
                }

                public static copyMatrixDense(matA: util.maths.structure.impl.NativeArray2D, ejmlmatA: util.maths.matrix.DenseMatrix64F): void {
                    for (var i: number = 0; i < matA.rows(); i++) {
                        for (var j: number = 0; j < matA.columns(); j++) {
                            ejmlmatA.set(i, j, matA.get(i, j));
                        }
                    }
                }

                public static extractImpl(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcX0: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number, numRows: number, numCols: number): void {
                    for (var y: number = 0; y < numRows; y++) {
                        var indexSrc: number = src.getIndex(y + srcY0, srcX0);
                        var indexDst: number = dst.getIndex(y + dstY0, dstX0);
                        java.lang.System.arraycopy(src.data, indexSrc, dst.data, indexDst, numCols);
                    }
                }

                public static extractInsert(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                    var w: number = srcX1 - srcX0;
                    var h: number = srcY1 - srcY0;
                    util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
                }

                public static insert(src: util.maths.matrix.DenseMatrix64F, dest: util.maths.matrix.DenseMatrix64F, destY0: number, destX0: number): void {
                    util.maths.matrix.CommonOps.extractInsert(src, 0, src.getNumRows(), 0, src.getNumCols(), dest, destY0, destX0);
                }

                public static extract4Int(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number): util.maths.matrix.DenseMatrix64F {
                    if (srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.numRows) {
                        throw new Error("srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.getNumRows");
                    }
                    if (srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.numCols) {
                        throw new Error("srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.getNumCols");
                    }
                    var w: number = srcX1 - srcX0;
                    var h: number = srcY1 - srcY0;
                    var dst: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(h, w);
                    util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, 0, 0, h, w);
                    return dst;
                }

                public static columnsToVector(A: util.maths.matrix.DenseMatrix64F, v: util.maths.matrix.DenseMatrix64F[]): util.maths.matrix.DenseMatrix64F[] {
                    var ret: util.maths.matrix.DenseMatrix64F[];
                    if (v == null || v.length < A.numCols) {
                        ret = new Array();
                    } else {
                        ret = v;
                    }
                    for (var i: number = 0; i < ret.length; i++) {
                        if (ret[i] == null) {
                            ret[i] = new util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                        } else {
                            ret[i].reshapeBoolean(A.numRows, 1, false);
                        }
                        var u: util.maths.matrix.DenseMatrix64F = ret[i];
                        for (var j: number = 0; j < A.numRows; j++) {
                            u.set(j, 0, A.get(j, i));
                        }
                    }
                    return ret;
                }

                public static rowsToVector(A: util.maths.matrix.DenseMatrix64F, v: util.maths.matrix.DenseMatrix64F[]): util.maths.matrix.DenseMatrix64F[] {
                    var ret: util.maths.matrix.DenseMatrix64F[];
                    if (v == null || v.length < A.numRows) {
                        ret = new Array();
                    } else {
                        ret = v;
                    }
                    for (var i: number = 0; i < ret.length; i++) {
                        if (ret[i] == null) {
                            ret[i] = new util.maths.matrix.DenseMatrix64F(A.numCols, 1);
                        } else {
                            ret[i].reshapeBoolean(A.numCols, 1, false);
                        }
                        var u: util.maths.matrix.DenseMatrix64F = ret[i];
                        for (var j: number = 0; j < A.numCols; j++) {
                            u.set(j, 0, A.get(i, j));
                        }
                    }
                    return ret;
                }

                public static setIdentity(mat: util.maths.matrix.DenseMatrix64F): void {
                    var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                    java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                    var index: number = 0;
                    for (var i: number = 0; i < width; i++) {
                        mat.data[index] = 1;
                        index += mat.numCols + 1;
                    }
                }

                public static identity1D(width: number): util.maths.matrix.DenseMatrix64F {
                    var ret: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(width, width);
                    for (var i: number = 0; i < width; i++) {
                        ret.set(i, i, 1.0);
                    }
                    return ret;
                }

                public static identity(numRows: number, numCols: number): util.maths.matrix.DenseMatrix64F {
                    var ret: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                    var small: number = numRows < numCols ? numRows : numCols;
                    for (var i: number = 0; i < small; i++) {
                        ret.set(i, i, 1.0);
                    }
                    return ret;
                }

                public static diag(diagEl: Float64Array): util.maths.matrix.DenseMatrix64F {
                    return util.maths.matrix.CommonOps.diagMatrix(null, diagEl.length, diagEl);
                }

                public static diagMatrix(ret: util.maths.matrix.DenseMatrix64F, width: number, diagEl: Float64Array): util.maths.matrix.DenseMatrix64F {
                    if (ret == null) {
                        ret = new util.maths.matrix.DenseMatrix64F(width, width);
                    } else {
                        util.maths.matrix.CommonOps.fill(ret, 0);
                    }
                    for (var i: number = 0; i < width; i++) {
                        ret.set(i, i, diagEl[i]);
                    }
                    return ret;
                }

                public static kron(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    var numColsC: number = A.numCols * B.numCols;
                    var numRowsC: number = A.numRows * B.numRows;
                    for (var i: number = 0; i < A.numRows; i++) {
                        for (var j: number = 0; j < A.numCols; j++) {
                            var a: number = A.get(i, j);
                            for (var rowB: number = 0; rowB < B.numRows; rowB++) {
                                for (var colB: number = 0; colB < B.numCols; colB++) {
                                    var val: number = a * B.get(rowB, colB);
                                    C.set(i * B.numRows + rowB, j * B.numCols + colB, val);
                                }
                            }
                        }
                    }
                }

                public static extractDiag(src: util.maths.matrix.DenseMatrix64F, dst: util.maths.matrix.DenseMatrix64F): void {
                    var N: number = Math.min(src.numRows, src.numCols);
                    if (!util.maths.matrix.MatrixFeatures.isVector(dst)) {
                        throw new Error("Expected a vector for dst.");
                    }
                    for (var i: number = 0; i < N; i++) {
                        dst.setValueAtIndex(i, src.get(i, i));
                    }
                }

                public static extractRow(a: util.maths.matrix.DenseMatrix64F, row: number, out: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                    if (out == null) {
                        out = new util.maths.matrix.DenseMatrix64F(1, a.numCols);
                    }
                    java.lang.System.arraycopy(a.data, a.getIndex(row, 0), out.data, 0, a.numCols);
                    return out;
                }

                public static extractColumn(a: util.maths.matrix.DenseMatrix64F, column: number, out: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                    if (out == null) {
                        out = new util.maths.matrix.DenseMatrix64F(a.numRows, 1);
                    }
                    var index: number = column;
                    for (var i: number = 0; i < a.numRows; i++) {
                        out.data[i] = a.data[index];
                        index += a.numCols;
                    }
                    return out;
                }

                public static elementMax(a: util.maths.matrix.DenseMatrix64F): number {
                    var size: number = a.getNumElements();
                    var max: number = a.getValueAtIndex(0);
                    for (var i: number = 1; i < size; i++) {
                        var val: number = a.getValueAtIndex(i);
                        if (val >= max) {
                            max = val;
                        }
                    }
                    return max;
                }

                public static elementMaxAbs(a: util.maths.matrix.DenseMatrix64F): number {
                    var size: number = a.getNumElements();
                    var max: number = 0;
                    for (var i: number = 0; i < size; i++) {
                        var val: number = Math.abs(a.getValueAtIndex(i));
                        if (val > max) {
                            max = val;
                        }
                    }
                    return max;
                }

                public static elementMult(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        c.setValueAtIndex(i, a.getValueAtIndex(i) * b.getValueAtIndex(i));
                    }
                }

                public static elementSum(mat: util.maths.matrix.DenseMatrix64F): number {
                    var total: number = 0;
                    var size: number = mat.getNumElements();
                    for (var i: number = 0; i < size; i++) {
                        total += mat.getValueAtIndex(i);
                    }
                    return total;
                }

                public static addEquals(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F): void {
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        a.plus(i, b.getValueAtIndex(i));
                    }
                }

                public static addEqualsbeta(a: util.maths.matrix.DenseMatrix64F, beta: number, b: util.maths.matrix.DenseMatrix64F): void {
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        a.plus(i, beta * b.getValueAtIndex(i));
                    }
                }

                public static add(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        c.setValueAtIndex(i, a.getValueAtIndex(i) + b.getValueAtIndex(i));
                    }
                }

                public static subtract3mat(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        c.data[i] = a.data[i] - b.data[i];
                    }
                }

                public static scale(alpha: number, a: util.maths.matrix.DenseMatrix64F): void {
                    var size: number = a.getNumElements();
                    for (var i: number = 0; i < size; i++) {
                        a.data[i] *= alpha;
                    }
                }

                public static changeSign(a: util.maths.matrix.DenseMatrix64F): void {
                    var size: number = a.getNumElements();
                    for (var i: number = 0; i < size; i++) {
                        a.data[i] = -a.data[i];
                    }
                }

                public static fill(a: util.maths.matrix.DenseMatrix64F, value: number): void {
                    java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
                }

                public static normalizeF(A: util.maths.matrix.DenseMatrix64F): void {
                    var val: number = util.maths.matrix.CommonOps.normF(A);
                    if (val == 0) {
                        return;
                    }
                    var size: number = A.getNumElements();
                    for (var i: number = 0; i < size; i++) {
                        A.div(i, val);
                    }
                }

                public static normF(a: util.maths.matrix.DenseMatrix64F): number {
                    var total: number = 0;
                    var scale: number = util.maths.matrix.CommonOps.elementMaxAbs(a);
                    if (scale == 0.0) {
                        return 0.0;
                    }
                    var size: number = a.getNumElements();
                    for (var i: number = 0; i < size; i++) {
                        var val: number = a.getValueAtIndex(i) / scale;
                        total += val * val;
                    }
                    return scale * Math.sqrt(total);
                }

                public static extract6M(src: util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                    var w: number = srcX1 - srcX0;
                    var h: number = srcY1 - srcY0;
                    util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
                }

                public static multAlphaBeta(alpha: number, matrix: util.maths.matrix.DenseMatrix64F, matrix1: util.maths.matrix.DenseMatrix64F, matrix2: util.maths.matrix.DenseMatrix64F, beta: number): void {
                    matrix2.scale(beta);
                    util.maths.matrix.CommonOps.multAddalpha(alpha, matrix, matrix1, matrix2);
                }

            }

            export class Complex64F {

                public real: number;
                public imaginary: number;
                constructor() {
                }

                public getReal(): number {
                    return this.real;
                }

                public getMagnitude(): number {
                    return Math.sqrt(this.real * this.real + this.imaginary * this.imaginary);
                }

                public getMagnitude2(): number {
                    return this.real * this.real + this.imaginary * this.imaginary;
                }

                public setReal(real: number): void {
                    this.real = real;
                }

                public setValues(real: number, imaginary: number): void {
                    this.real = real;
                    this.imaginary = imaginary;
                }

                public isReal(): boolean {
                    return this.imaginary == 0.0;
                }

                public toString(): string {
                    if (this.imaginary == 0) {
                        return "" + this.real;
                    } else {
                        return this.real + " " + this.imaginary + "i";
                    }
                }

                public times(a: util.maths.matrix.Complex64F): util.maths.matrix.Complex64F {
                    var ret: util.maths.matrix.Complex64F = new util.maths.matrix.Complex64F();
                    util.maths.matrix.ComplexMath64F.multiply(this, a, ret);
                    return ret;
                }

            }

            export class ComplexMath64F {

                public static conj(input: util.maths.matrix.Complex64F, conj: util.maths.matrix.Complex64F): void {
                    conj.real = input.real;
                    conj.imaginary = -input.imaginary;
                }

                public static plus(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void {
                    result.real = a.real + b.real;
                    result.imaginary = a.imaginary + b.imaginary;
                }

                public static minus(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void {
                    result.real = a.real - b.real;
                    result.imaginary = a.imaginary - b.imaginary;
                }

                public static multiply(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void {
                    result.real = a.real * b.real - a.imaginary * b.imaginary;
                    result.imaginary = a.real * b.imaginary + a.imaginary * b.real;
                }

                public static divide(a: util.maths.matrix.Complex64F, b: util.maths.matrix.Complex64F, result: util.maths.matrix.Complex64F): void {
                    var norm: number = b.getMagnitude2();
                    result.real = (a.real * b.real + a.imaginary * b.imaginary) / norm;
                    result.imaginary = (a.imaginary * b.real - a.real * b.imaginary) / norm;
                }

                public static root(a: util.maths.matrix.Complex64F, N: number, k: number, result: util.maths.matrix.Complex64F): void {
                    var r: number = a.getMagnitude();
                    var theta: number = Math.atan2(a.imaginary, a.real);
                    r = Math.pow(r, 1.0 / N);
                    theta = (theta + 2.0 * k * Math.PI) / N;
                    result.real = r * Math.cos(theta);
                    result.imaginary = r * Math.sin(theta);
                }

                public static sqrt(input: util.maths.matrix.Complex64F, root: util.maths.matrix.Complex64F): void {
                    var r: number = input.getMagnitude();
                    var a: number = input.real;
                    root.real = Math.sqrt((r + a) / 2.0);
                    root.imaginary = Math.sqrt((r - a) / 2.0);
                    if (input.imaginary < 0) {
                        root.imaginary = -root.imaginary;
                    }
                }

            }

            export class DenseMatrix64F {

                public numRows: number;
                public numCols: number;
                public data: Float64Array;
                public static MULT_COLUMN_SWITCH: number = 15;
                constructor(numRows: number, numCols: number) {
                    this.data = new Float64Array(numRows * numCols);
                    this.numRows = numRows;
                    this.numCols = numCols;
                    for (var i: number = 0; i < numCols * numRows; i++) {
                        this.data[i] = 0;
                    }
                }

                public constructorDenseMatrix(orig: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                    var result: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(orig.numRows, orig.numCols);
                    java.lang.System.arraycopy(orig.data, 0, result.data, 0, orig.getNumElements());
                    return result;
                }

                public static setIdentity(mat: util.maths.matrix.DenseMatrix64F): void {
                    var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                    java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                    var index: number = 0;
                    for (var i: number = 0; i < width; i++) {
                        mat.data[index] = 1;
                        index += mat.numCols + 1;
                    }
                }

                public static widentity(width: number): util.maths.matrix.DenseMatrix64F {
                    var ret: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(width, width);
                    for (var i: number = 0; i < width; i++) {
                        ret.cset(i, i, 1.0);
                    }
                    return ret;
                }

                public static identity(numRows: number, numCols: number): util.maths.matrix.DenseMatrix64F {
                    var ret: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                    var small: number = numRows < numCols ? numRows : numCols;
                    for (var i: number = 0; i < small; i++) {
                        ret.cset(i, i, 1.0);
                    }
                    return ret;
                }

                public zero(): void {
                    java.util.Arrays.fill(this.data, 0, this.getNumElements(), 0.0);
                }

                public copy(): util.maths.matrix.DenseMatrix64F {
                    return this.constructorDenseMatrix(this);
                }

                public static fill(a: util.maths.matrix.DenseMatrix64F, value: number): void {
                    java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
                }

                public reshapeBoolean(numRows: number, numCols: number, saveValues: boolean): void {
                    if (this.data.length < numRows * numCols) {
                        var d: Float64Array = new Float64Array(numRows * numCols);
                        if (saveValues) {
                            java.lang.System.arraycopy(this.data, 0, d, 0, this.getNumElements());
                        }
                        this.data = d;
                    }
                    this.numRows = numRows;
                    this.numCols = numCols;
                }

                public cset(row: number, col: number, value: number): void {
                    this.data[row * this.numCols + col] = value;
                }

                public add(row: number, col: number, value: number): void {
                    this.data[row * this.numCols + col] += value;
                }

                public plus(index: number, val: number): number {
                    return this.data[index] += val;
                }

                public scale(value: number): util.maths.matrix.DenseMatrix64F {
                    for (var i: number = 0; i < this.data.length; i++) {
                        this.data[i] *= value;
                    }
                    return this;
                }

                public minus(index: number, val: number): number {
                    return this.data[index] -= val;
                }

                public times(index: number, val: number): number {
                    return this.data[index] *= val;
                }

                public div(index: number, val: number): number {
                    return this.data[index] /= val;
                }

                public reshape(numRows: number, numCols: number): void {
                    this.reshapeBoolean(numRows, numCols, false);
                }

                public getNumRows(): number {
                    return this.numRows;
                }

                public getNumCols(): number {
                    return this.numCols;
                }

                public getData(): Float64Array {
                    return this.data;
                }

                public get(row: number, col: number): number {
                    return this.data[row * this.numCols + col];
                }

                public getNumElements(): number {
                    return this.numRows * this.numCols;
                }

                public getIndex(row: number, col: number): number {
                    return row * this.numCols + col;
                }

                public getValueAtIndex(index: number): number {
                    return this.data[index];
                }

                public setValueAtIndex(index: number, val: number): number {
                    return this.data[index] = val;
                }

                public setNumRows(numRows: number): void {
                    this.numRows = numRows;
                }

                public setNumCols(numCols: number): void {
                    this.numCols = numCols;
                }

                public setData(data: Float64Array): void {
                    this.data = data;
                }

                public setMatrix(b: util.maths.matrix.DenseMatrix64F): void {
                    this.reshape(b.numRows, b.numCols);
                    var dataLength: number = b.getNumElements();
                    java.lang.System.arraycopy(b.data, 0, this.data, 0, dataLength);
                }

                public set(row: number, col: number, value: number): void {
                    this.data[row * this.numCols + col] = value;
                }

            }

            export class MatrixFeatures {

                public static isVector(mat: util.maths.matrix.DenseMatrix64F): boolean {
                    return (mat.getNumCols() == 1 || mat.getNumRows() == 1);
                }

                public static isSymmetricDouble(m: util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                    if (m.numCols != m.numRows) {
                        return false;
                    }
                    var max: number = util.maths.matrix.CommonOps.elementMaxAbs(m);
                    for (var i: number = 0; i < m.numRows; i++) {
                        for (var j: number = 0; j < i; j++) {
                            var a: number = m.get(i, j) / max;
                            var b: number = m.get(j, i) / max;
                            var diff: number = Math.abs(a - b);
                            if (!(diff <= tol)) {
                                return false;
                            }
                        }
                    }
                    return true;
                }

                public static isIdentical(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                    if (a.numRows != b.numRows || a.numCols != b.numCols) {
                        return false;
                    }
                    if (tol < 0) {
                        throw new Error("Tolerance must be greater than or equal to zero.");
                    }
                    var length: number = a.getNumElements();
                    for (var i: number = 0; i < length; i++) {
                        var valA: number = a.getValueAtIndex(i);
                        var valB: number = b.getValueAtIndex(i);
                        var diff: number = Math.abs(valA - valB);
                        if (tol >= diff) {
                            continue;
                        }
                        return false;
                    }
                    return true;
                }

            }

            export class MatrixMatrixMult {

                public static multTransA_smallMV(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    for (var i: number = 0; i < A.numCols; i++) {
                        var total: number = 0.0;
                        var indexA: number = i;
                        for (var j: number = 0; j < A.numRows; j++) {
                            total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                            indexA += A.numCols;
                        }
                        C.setValueAtIndex(cIndex++, total);
                    }
                }

                public static multTransA_reorderMV(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    if (A.numRows == 0) {
                        util.maths.matrix.DenseMatrix64F.fill(C, 0);
                        return;
                    }
                    var B_val: number = B.getValueAtIndex(0);
                    for (var i: number = 0; i < A.numCols; i++) {
                        C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                    }
                    var indexA: number = A.numCols;
                    for (var i: number = 1; i < A.numRows; i++) {
                        B_val = B.getValueAtIndex(i);
                        for (var j: number = 0; j < A.numCols; j++) {
                            C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                        }
                    }
                }

                public static multTransA_reorderMM(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (a.numCols == 0 || a.numRows == 0) {
                        util.maths.matrix.DenseMatrix64F.fill(c, 0);
                        return;
                    }
                    var valA: number;
                    for (var i: number = 0; i < a.numCols; i++) {
                        var indexC_start: number = i * c.numCols;
                        valA = a.getValueAtIndex(i);
                        var indexB: number = 0;
                        var end: number = indexB + b.numCols;
                        var indexC: number = indexC_start;
                        while (indexB < end){
                            c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                        }
                        for (var k: number = 1; k < a.numRows; k++) {
                            valA = a.get(k, i);
                            end = indexB + b.numCols;
                            indexC = indexC_start;
                            while (indexB < end){
                                c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                            }
                        }
                    }
                }

                public static multTransA_smallMM(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    for (var i: number = 0; i < a.numCols; i++) {
                        for (var j: number = 0; j < b.numCols; j++) {
                            var indexA: number = i;
                            var indexB: number = j;
                            var end: number = indexB + b.numRows * b.numCols;
                            var total: number = 0;
                            for (; indexB < end; indexB += b.numCols) {
                                total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                indexA += a.numCols;
                            }
                            c.setValueAtIndex(cIndex++, total);
                        }
                    }
                }

                public static multTransA(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (b.numCols == 1) {
                        if (a.numCols >= util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                            util.maths.matrix.MatrixMatrixMult.multTransA_reorderMV(a, b, c);
                        } else {
                            util.maths.matrix.MatrixMatrixMult.multTransA_smallMV(a, b, c);
                        }
                    } else {
                        if (a.numCols >= util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH || b.numCols >= util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                            util.maths.matrix.MatrixMatrixMult.multTransA_reorderMM(a, b, c);
                        } else {
                            util.maths.matrix.MatrixMatrixMult.multTransA_smallMM(a, b, c);
                        }
                    }
                }

                public static mult_reorder(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (a.numCols == 0 || a.numRows == 0) {
                        util.maths.matrix.CommonOps.fill(c, 0);
                        return;
                    }
                    var valA: number;
                    var indexCbase: number = 0;
                    var endOfKLoop: number = b.numRows * b.numCols;
                    for (var i: number = 0; i < a.numRows; i++) {
                        var indexA: number = i * a.numCols;
                        var indexB: number = 0;
                        var indexC: number = indexCbase;
                        var end: number = indexB + b.numCols;
                        valA = a.getValueAtIndex(indexA++);
                        while (indexB < end){
                            c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                        }
                        while (indexB != endOfKLoop){
                            indexC = indexCbase;
                            end = indexB + b.numCols;
                            valA = a.getValueAtIndex(indexA++);
                            while (indexB < end){
                                c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                            }
                        }
                        indexCbase += c.numCols;
                    }
                }

                public static mult_small(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var aIndexStart: number = 0;
                    var cIndex: number = 0;
                    for (var i: number = 0; i < a.numRows; i++) {
                        for (var j: number = 0; j < b.numCols; j++) {
                            var total: number = 0;
                            var indexA: number = aIndexStart;
                            var indexB: number = j;
                            var end: number = indexA + b.numRows;
                            while (indexA < end){
                                total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                indexB += b.numCols;
                            }
                            c.setValueAtIndex(cIndex++, total);
                        }
                        aIndexStart += a.numCols;
                    }
                }

                public static multTransA_reorder(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (a.numCols == 0 || a.numRows == 0) {
                        util.maths.matrix.CommonOps.fill(c, 0);
                        return;
                    }
                    var valA: number;
                    for (var i: number = 0; i < a.numCols; i++) {
                        var indexC_start: number = i * c.numCols;
                        valA = a.getValueAtIndex(i);
                        var indexB: number = 0;
                        var end: number = indexB + b.numCols;
                        var indexC: number = indexC_start;
                        while (indexB < end){
                            c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                        }
                        for (var k: number = 1; k < a.numRows; k++) {
                            valA = a.get(k, i);
                            end = indexB + b.numCols;
                            indexC = indexC_start;
                            while (indexB < end){
                                c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                            }
                        }
                    }
                }

                public static multTransA_small(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    for (var i: number = 0; i < a.numCols; i++) {
                        for (var j: number = 0; j < b.numCols; j++) {
                            var indexA: number = i;
                            var indexB: number = j;
                            var end: number = indexB + b.numRows * b.numCols;
                            var total: number = 0.0;
                            for (; indexB < end; indexB += b.numCols) {
                                total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                indexA += a.numCols;
                            }
                            c.setValueAtIndex(cIndex++, total);
                        }
                    }
                }

                public static multTransB(a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    var aIndexStart: number = 0;
                    for (var xA: number = 0; xA < a.numRows; xA++) {
                        var end: number = aIndexStart + b.numCols;
                        var indexB: number = 0;
                        for (var xB: number = 0; xB < b.numRows; xB++) {
                            var indexA: number = aIndexStart;
                            var total: number = 0;
                            while (indexA < end){
                                total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                            }
                            c.setValueAtIndex(cIndex++, total);
                        }
                        aIndexStart += a.numCols;
                    }
                }

                public static multAlphaTransA_reorder(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (a.numCols == 0 || a.numRows == 0) {
                        util.maths.matrix.CommonOps.fill(c, 0);
                        return;
                    }
                    var valA: number;
                    for (var i: number = 0; i < a.numCols; i++) {
                        var indexC_start: number = i * c.numCols;
                        valA = alpha * a.getValueAtIndex(i);
                        var indexB: number = 0;
                        var end: number = indexB + b.numCols;
                        var indexC: number = indexC_start;
                        while (indexB < end){
                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                        }
                        for (var k: number = 1; k < a.numRows; k++) {
                            valA = alpha * a.get(k, i);
                            end = indexB + b.numCols;
                            indexC = indexC_start;
                            while (indexB < end){
                                c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                            }
                        }
                    }
                }

                public static multAlphaTransA_small(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    for (var i: number = 0; i < a.numCols; i++) {
                        for (var j: number = 0; j < b.numCols; j++) {
                            var indexA: number = i;
                            var indexB: number = j;
                            var end: number = indexB + b.numRows * b.numCols;
                            var total: number = 0;
                            for (; indexB < end; indexB += b.numCols) {
                                total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                indexA += a.numCols;
                            }
                            c.plus(cIndex++, alpha * total);
                        }
                    }
                }

                public static multAdd_reorderalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    if (a.numCols == 0 || a.numRows == 0) {
                        return;
                    }
                    var valA: number;
                    var indexCbase: number = 0;
                    var endOfKLoop: number = b.numRows * b.numCols;
                    for (var i: number = 0; i < a.numRows; i++) {
                        var indexA: number = i * a.numCols;
                        var indexB: number = 0;
                        var indexC: number = indexCbase;
                        var end: number = indexB + b.numCols;
                        valA = alpha * a.getValueAtIndex(indexA++);
                        while (indexB < end){
                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                        }
                        while (indexB != endOfKLoop){
                            indexC = indexCbase;
                            end = indexB + b.numCols;
                            valA = alpha * a.getValueAtIndex(indexA++);
                            while (indexB < end){
                                c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                            }
                        }
                        indexCbase += c.numCols;
                    }
                }

                public static multAdd_smallalpha(alpha: number, a: util.maths.matrix.DenseMatrix64F, b: util.maths.matrix.DenseMatrix64F, c: util.maths.matrix.DenseMatrix64F): void {
                    var aIndexStart: number = 0;
                    var cIndex: number = 0;
                    for (var i: number = 0; i < a.numRows; i++) {
                        for (var j: number = 0; j < b.numCols; j++) {
                            var total: number = 0;
                            var indexA: number = aIndexStart;
                            var indexB: number = j;
                            var end: number = indexA + b.numRows;
                            while (indexA < end){
                                total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                indexB += b.numCols;
                            }
                            c.plus(cIndex++, alpha * total);
                        }
                        aIndexStart += a.numCols;
                    }
                }

            }

            export class MatrixVectorMult {

                public static mult(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    if (A.numCols == 0) {
                        util.maths.matrix.CommonOps.fill(C, 0);
                        return;
                    }
                    var indexA: number = 0;
                    var cIndex: number = 0;
                    var b0: number = B.getValueAtIndex(0);
                    for (var i: number = 0; i < A.numRows; i++) {
                        var total: number = A.getValueAtIndex(indexA++) * b0;
                        for (var j: number = 1; j < A.numCols; j++) {
                            total += A.getValueAtIndex(indexA++) * B.getValueAtIndex(j);
                        }
                        C.setValueAtIndex(cIndex++, total);
                    }
                }

                public static multTransA_small(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    var cIndex: number = 0;
                    for (var i: number = 0; i < A.numCols; i++) {
                        var total: number = 0;
                        var indexA: number = i;
                        for (var j: number = 0; j < A.numRows; j++) {
                            total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                            indexA += A.numCols;
                        }
                        C.setValueAtIndex(cIndex++, total);
                    }
                }

                public static multTransA_reorder(A: util.maths.matrix.DenseMatrix64F, B: util.maths.matrix.DenseMatrix64F, C: util.maths.matrix.DenseMatrix64F): void {
                    if (A.numRows == 0) {
                        util.maths.matrix.CommonOps.fill(C, 0);
                        return;
                    }
                    var B_val: number = B.getValueAtIndex(0);
                    for (var i: number = 0; i < A.numCols; i++) {
                        C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                    }
                    var indexA: number = A.numCols;
                    for (var i: number = 1; i < A.numRows; i++) {
                        B_val = B.getValueAtIndex(i);
                        for (var j: number = 0; j < A.numCols; j++) {
                            C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                        }
                    }
                }

            }

            export class SimpleMatrix {

                public mat: util.maths.matrix.DenseMatrix64F;
                public getMatrix(): util.maths.matrix.DenseMatrix64F {
                    return this.mat;
                }

                public setValue2D(row: number, col: number, value: number): void {
                    this.mat.set(row, col, value);
                }

                public setValue1D(index: number, value: number): void {
                    this.mat.setValueAtIndex(index, value);
                }

                public getValue2D(row: number, col: number): number {
                    return this.mat.get(row, col);
                }

                public getValue1D(index: number): number {
                    return this.mat.data[index];
                }

                public getIndex(row: number, col: number): number {
                    return row * this.mat.numCols + col;
                }

                public mult(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, b.getMatrix().numCols);
                    util.maths.matrix.CommonOps.mult(this.mat, b.getMatrix(), ret.getMatrix());
                    return ret;
                }

                public scale(val: number): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.copy();
                    util.maths.matrix.CommonOps.scale(val, ret.getMatrix());
                    return ret;
                }

                public plus(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.copy();
                    util.maths.matrix.CommonOps.addEquals(ret.getMatrix(), b.getMatrix());
                    return ret;
                }

                public copy(): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                    ret.getMatrix().setMatrix(this.getMatrix());
                    return ret;
                }

                public numRows(): number {
                    return this.mat.numRows;
                }

                public numCols(): number {
                    return this.mat.numCols;
                }

                public getNumElements(): number {
                    return this.mat.getNumElements();
                }

                public extractDiag(): util.maths.matrix.SimpleMatrix {
                    var N: number = Math.min(this.mat.numCols, this.mat.numRows);
                    var diag: util.maths.matrix.SimpleMatrix = this.createMatrix(N, 1);
                    util.maths.matrix.CommonOps.extractDiag(this.mat, diag.getMatrix());
                    return diag;
                }

                public isIdentical(a: util.maths.matrix.SimpleMatrix, tol: number): boolean {
                    return util.maths.matrix.MatrixFeatures.isIdentical(this.mat, a.getMatrix(), tol);
                }

                public trace(): number {
                    return util.maths.matrix.CommonOps.trace(this.mat);
                }

                public elementMaxAbs(): number {
                    return util.maths.matrix.CommonOps.elementMaxAbs(this.mat);
                }

                public elementSum(): number {
                    return util.maths.matrix.CommonOps.elementSum(this.mat);
                }

                public elementMult(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    var c: util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                    util.maths.matrix.CommonOps.elementMult(this.mat, b.getMatrix(), c.getMatrix());
                    return c;
                }

                public isInBounds(row: number, col: number): boolean {
                    return row >= 0 && col >= 0 && row < this.mat.numRows && col < this.mat.numCols;
                }

                public printDimensions(): void {
                    console.log("[rows = " + this.numRows() + " , cols = " + this.numCols() + " ]");;
                }

                public transpose(): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numCols, this.mat.numRows);
                    util.maths.matrix.CommonOps.transposeMatrix(this.mat, ret.getMatrix());
                    return ret;
                }

                constructor(numRows: number, numCols: number) {
                    this.mat = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                }

                public static wrap(internalMat: util.maths.matrix.DenseMatrix64F): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = new util.maths.matrix.SimpleMatrix(internalMat.numRows, internalMat.numCols);
                    ret.mat = internalMat;
                    return ret;
                }

                public static identity(width: number): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = new util.maths.matrix.SimpleMatrix(width, width);
                    util.maths.matrix.CommonOps.setIdentity(ret.mat);
                    return ret;
                }

                public minus(b: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.copy();
                    util.maths.matrix.CommonOps.subtract3mat(this.getMatrix(), b.getMatrix(), ret.getMatrix());
                    return ret;
                }

                public invert(): util.maths.matrix.SimpleMatrix {
                    var ret: util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                    util.maths.matrix.CommonOps.invert(this.mat, ret.getMatrix());
                    return ret;
                }

                public determinant(): number {
                    var ret: number = util.maths.matrix.CommonOps.det(this.mat);
                    return ret;
                }

                public createMatrix(numRows: number, numCols: number): util.maths.matrix.SimpleMatrix {
                    var sm: util.maths.matrix.SimpleMatrix = new util.maths.matrix.SimpleMatrix(numRows, numCols);
                    return sm;
                }

                public extractVector(extractRow: boolean, element: number): util.maths.matrix.SimpleMatrix {
                    var length: number = extractRow ? this.mat.numCols : this.mat.numRows;
                    var ret: util.maths.matrix.SimpleMatrix = extractRow ? this.createMatrix(1, length) : this.createMatrix(length, 1);
                    if (extractRow) {
                        util.maths.matrix.CommonOps.subvector(this.mat, element, 0, length, true, 0, ret.getMatrix());
                    } else {
                        util.maths.matrix.CommonOps.subvector(this.mat, 0, element, length, false, 0, ret.getMatrix());
                    }
                    return ret;
                }

                public eig(): util.maths.matrix.solvers.SimpleEVD<any> {
                    return new util.maths.matrix.solvers.SimpleEVD<any>(this.mat);
                }

                public svd(compact: boolean): util.maths.matrix.solvers.SimpleSVD<any> {
                    return new util.maths.matrix.solvers.SimpleSVD<any>(this.mat, compact);
                }

                public combine(insertRow: number, insertCol: number, B: util.maths.matrix.SimpleMatrix): util.maths.matrix.SimpleMatrix {
                    var maxRow: number = insertRow + B.numRows();
                    var maxCol: number = insertCol + B.numCols();
                    var ret: util.maths.matrix.SimpleMatrix;
                    if (maxRow > this.mat.numRows || maxCol > this.mat.numCols) {
                        var M: number = Math.max(maxRow, this.mat.numRows);
                        var N: number = Math.max(maxCol, this.mat.numCols);
                        ret = this.createMatrix(M, N);
                        ret.insertIntoThis(0, 0, this);
                    } else {
                        ret = this.copy();
                    }
                    ret.insertIntoThis(insertRow, insertCol, B);
                    return ret;
                }

                public insertIntoThis(insertRow: number, insertCol: number, B: util.maths.matrix.SimpleMatrix): void {
                    util.maths.matrix.CommonOps.insert(B.getMatrix(), this.mat, insertRow, insertCol);
                }

            }

            export class TransposeAlgs {

                public static square(mat: util.maths.matrix.DenseMatrix64F): void {
                    var index: number = 1;
                    var indexEnd: number = mat.numCols;
                    for (var i: number = 0; i < mat.numRows; i++) {
                        var indexOther: number = (i + 1) * mat.numCols + i;
                        for (; index < indexEnd; index++) {
                            var val: number = mat.data[index];
                            mat.data[index] = mat.data[indexOther];
                            mat.data[indexOther] = val;
                            indexOther += mat.numCols;
                        }
                        index += i + 2;
                        indexEnd += mat.numCols;
                    }
                }

                public static block(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F, blockLength: number): void {
                    for (var i: number = 0; i < A.numRows; i += blockLength) {
                        var blockHeight: number = Math.min(blockLength, A.numRows - i);
                        var indexSrc: number = i * A.numCols;
                        var indexDst: number = i;
                        for (var j: number = 0; j < A.numCols; j += blockLength) {
                            var blockWidth: number = Math.min(blockLength, A.numCols - j);
                            var indexSrcEnd: number = indexSrc + blockWidth;
                            for (; indexSrc < indexSrcEnd; indexSrc++) {
                                var rowSrc: number = indexSrc;
                                var rowDst: number = indexDst;
                                var end: number = rowDst + blockHeight;
                                for (; rowDst < end; rowSrc += A.numCols) {
                                    A_tran.data[rowDst++] = A.data[rowSrc];
                                }
                                indexDst += A_tran.numCols;
                            }
                        }
                    }
                }

                public static standard(A: util.maths.matrix.DenseMatrix64F, A_tran: util.maths.matrix.DenseMatrix64F): void {
                    var index: number = 0;
                    for (var i: number = 0; i < A_tran.numRows; i++) {
                        var index2: number = i;
                        var end: number = index + A_tran.numCols;
                        while (index < end){
                            A_tran.data[index++] = A.data[index2];
                            index2 += A.numCols;
                        }
                    }
                }

            }

            export namespace solvers {
                export class AdjLinearSolverQr {

                    public numRows: number;
                    public numCols: number;
                    private decomposer: util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64;
                    public maxRows: number = -1;
                    public maxCols: number = -1;
                    public Q: util.maths.matrix.DenseMatrix64F;
                    public R: util.maths.matrix.DenseMatrix64F;
                    private Y: util.maths.matrix.DenseMatrix64F;
                    private Z: util.maths.matrix.DenseMatrix64F;
                    public setA(A: util.maths.matrix.DenseMatrix64F): boolean {
                        if (A.numRows > this.maxRows || A.numCols > this.maxCols) {
                            this.setMaxSize(A.numRows, A.numCols);
                        }
                        this.numRows = A.numRows;
                        this.numCols = A.numCols;
                        if (!this.decomposer.decompose(A)) {
                            return false;
                        }
                        this.Q.reshapeBoolean(this.numRows, this.numRows, false);
                        this.R.reshapeBoolean(this.numRows, this.numCols, false);
                        this.decomposer.getQ(this.Q, false);
                        this.decomposer.getR(this.R, false);
                        return true;
                    }

                    private solveU(U: Float64Array, b: Float64Array, n: number): void {
                        for (var i: number = n - 1; i >= 0; i--) {
                            var sum: number = b[i];
                            var indexU: number = i * n + i + 1;
                            for (var j: number = i + 1; j < n; j++) {
                                sum -= U[indexU++] * b[j];
                            }
                            b[i] = sum / U[i * n + i];
                        }
                    }

                    public solve(B: util.maths.matrix.DenseMatrix64F, X: util.maths.matrix.DenseMatrix64F): void {
                        var BnumCols: number = B.numCols;
                        this.Y.reshapeBoolean(this.numRows, 1, false);
                        this.Z.reshapeBoolean(this.numRows, 1, false);
                        for (var colB: number = 0; colB < BnumCols; colB++) {
                            for (var i: number = 0; i < this.numRows; i++) {
                                this.Y.data[i] = B.get(i, colB);
                            }
                            util.maths.matrix.MatrixMatrixMult.multTransA(this.Q, this.Y, this.Z);
                            this.solveU(this.R.data, this.Z.data, this.numCols);
                            for (var i: number = 0; i < this.numCols; i++) {
                                X.cset(i, colB, this.Z.data[i]);
                            }
                        }
                    }

                    constructor() {
                        this.decomposer = new util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64();
                    }

                    public setMaxSize(maxRows: number, maxCols: number): void {
                        maxRows += 5;
                        this.maxRows = maxRows;
                        this.maxCols = maxCols;
                        this.Q = new util.maths.matrix.DenseMatrix64F(maxRows, maxRows);
                        this.R = new util.maths.matrix.DenseMatrix64F(maxRows, maxCols);
                        this.Y = new util.maths.matrix.DenseMatrix64F(maxRows, 1);
                        this.Z = new util.maths.matrix.DenseMatrix64F(maxRows, 1);
                    }

                }

                export class LUDecompositionAlt_D64 {

                    public LU: util.maths.matrix.DenseMatrix64F;
                    public maxWidth: number = -1;
                    public m: number;
                    public n: number;
                    public dataLU: Float64Array;
                    public vv: Float64Array;
                    public indx: Int32Array;
                    public pivot: Int32Array;
                    public pivsign: number;
                    public setExpectedMaxSize(numRows: number, numCols: number): void {
                        this.LU = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                        this.dataLU = this.LU.data;
                        this.maxWidth = Math.max(numRows, numCols);
                        this.vv = new Float64Array(this.maxWidth);
                        this.indx = new Int32Array(this.maxWidth);
                        this.pivot = new Int32Array(this.maxWidth);
                        for (var i: number = 0; i < this.maxWidth; i++) {
                            this.vv[i] = 0;
                            this.indx[i] = 0;
                            this.pivot[i] = 0;
                        }
                    }

                    public getLU(): util.maths.matrix.DenseMatrix64F {
                        return this.LU;
                    }

                    public getIndx(): Int32Array {
                        return this.indx;
                    }

                    public getPivot(): Int32Array {
                        return this.pivot;
                    }

                    public getLower(lower: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                        var numRows: number = this.LU.numRows;
                        var numCols: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                        if (lower == null) {
                            lower = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                        } else {
                            util.maths.matrix.CommonOps.fill(lower, 0);
                        }
                        for (var i: number = 0; i < numCols; i++) {
                            lower.set(i, i, 1.0);
                            for (var j: number = 0; j < i; j++) {
                                lower.set(i, j, this.LU.get(i, j));
                            }
                        }
                        if (numRows > numCols) {
                            for (var i: number = numCols; i < numRows; i++) {
                                for (var j: number = 0; j < numCols; j++) {
                                    lower.set(i, j, this.LU.get(i, j));
                                }
                            }
                        }
                        return lower;
                    }

                    public getUpper(upper: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                        var numRows: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                        var numCols: number = this.LU.numCols;
                        if (upper == null) {
                            upper = new util.maths.matrix.DenseMatrix64F(numRows, numCols);
                        } else {
                            util.maths.matrix.CommonOps.fill(upper, 0);
                        }
                        for (var i: number = 0; i < numRows; i++) {
                            for (var j: number = i; j < numCols; j++) {
                                upper.set(i, j, this.LU.get(i, j));
                            }
                        }
                        return upper;
                    }

                    public decomposeCommonInit(a: util.maths.matrix.DenseMatrix64F): void {
                        if (a.numRows > this.maxWidth || a.numCols > this.maxWidth) {
                            this.setExpectedMaxSize(a.numRows, a.numCols);
                        }
                        this.m = a.numRows;
                        this.n = a.numCols;
                        this.LU.setMatrix(a);
                        for (var i: number = 0; i < this.m; i++) {
                            this.pivot[i] = i;
                        }
                        this.pivsign = 1;
                    }

                    public _solveVectorInternal(vv: Float64Array): void {
                        var ii: number = 0;
                        for (var i: number = 0; i < this.n; i++) {
                            var ip: number = this.indx[i];
                            var sum: number = vv[ip];
                            vv[ip] = vv[i];
                            if (ii != 0) {
                                var index: number = i * this.n + ii - 1;
                                for (var j: number = ii - 1; j < i; j++) {
                                    sum -= this.dataLU[index++] * vv[j];
                                }
                            } else {
                                if (sum != 0.0) {
                                    ii = i + 1;
                                }
                            }
                            vv[i] = sum;
                        }
                        util.maths.matrix.solvers.TriangularSolver.solveU2arr(this.dataLU, vv, this.n);
                    }

                    public _getVV(): Float64Array {
                        return this.vv;
                    }

                    public computeDeterminant(): number {
                        var ret: number = this.pivsign;
                        var total: number = this.m * this.n;
                        for (var i: number = 0; i < total; i += this.n + 1) {
                            ret *= this.dataLU[i];
                        }
                        return ret;
                    }

                    public decompose(a: util.maths.matrix.DenseMatrix64F): boolean {
                        this.decomposeCommonInit(a);
                        var LUcolj: Float64Array = this.vv;
                        for (var j: number = 0; j < this.n; j++) {
                            for (var i: number = 0; i < this.m; i++) {
                                LUcolj[i] = this.dataLU[i * this.n + j];
                            }
                            for (var i: number = 0; i < this.m; i++) {
                                var rowIndex: number = i * this.n;
                                var kmax: number = i < j ? i : j;
                                var s: number = 0.0;
                                for (var k: number = 0; k < kmax; k++) {
                                    s += this.dataLU[rowIndex + k] * LUcolj[k];
                                }
                                this.dataLU[rowIndex + j] = LUcolj[i] -= s;
                            }
                            var p: number = j;
                            var max: number = Math.abs(LUcolj[p]);
                            for (var i: number = j + 1; i < this.m; i++) {
                                var v: number = Math.abs(LUcolj[i]);
                                if (v > max) {
                                    p = i;
                                    max = v;
                                }
                            }
                            if (p != j) {
                                var rowP: number = p * this.n;
                                var rowJ: number = j * this.n;
                                var endP: number = rowP + this.n;
                                for (rowP = p * this.n; rowP < endP; rowP++) {
                                    var t: number = this.dataLU[rowP];
                                    this.dataLU[rowP] = this.dataLU[rowJ];
                                    this.dataLU[rowJ] = t;
                                    rowJ++;
                                }
                                var k: number = this.pivot[p];
                                this.pivot[p] = this.pivot[j];
                                this.pivot[j] = k;
                                this.pivsign = -this.pivsign;
                            }
                            this.indx[j] = p;
                            if (j < this.m) {
                                var lujj: number = this.dataLU[j * this.n + j];
                                if (lujj != 0) {
                                    for (var i: number = j + 1; i < this.m; i++) {
                                        this.dataLU[i * this.n + j] /= lujj;
                                    }
                                }
                            }
                        }
                        return true;
                    }

                }

                export class LinearSolverLu_D64 {

                    public A: util.maths.matrix.DenseMatrix64F;
                    public numRows: number;
                    public numCols: number;
                    public decomp: util.maths.matrix.solvers.LUDecompositionAlt_D64;
                    public doImprove: boolean = false;
                    public getA(): util.maths.matrix.DenseMatrix64F {
                        return this.A;
                    }

                    public _setA(A: util.maths.matrix.DenseMatrix64F): void {
                        this.A = A;
                        this.numRows = A.numRows;
                        this.numCols = A.numCols;
                    }

                    constructor(decomp: util.maths.matrix.solvers.LUDecompositionAlt_D64) {
                        this.decomp = decomp;
                    }

                    public setA(A: util.maths.matrix.DenseMatrix64F): boolean {
                        this._setA(A);
                        return this.decomp.decompose(A);
                    }

                    public invert(A_inv: util.maths.matrix.DenseMatrix64F): void {
                        var vv: Float64Array = this.decomp._getVV();
                        var LU: util.maths.matrix.DenseMatrix64F = this.decomp.getLU();
                        var n: number = this.A.numCols;
                        var dataInv: Float64Array = A_inv.data;
                        for (var j: number = 0; j < n; j++) {
                            for (var i: number = 0; i < n; i++) {
                                if (i == j) {
                                    vv[i] = 1;
                                } else {
                                    vv[i] = 0;
                                }
                            }
                            this.decomp._solveVectorInternal(vv);
                            var index: number = j;
                            for (var i: number = 0; i < n; i++) {
                                dataInv[index] = vv[i];
                                index += n;
                            }
                        }
                    }

                    public improveSol(b: util.maths.matrix.DenseMatrix64F, x: util.maths.matrix.DenseMatrix64F): void {
                        var dataA: Float64Array = this.A.data;
                        var dataB: Float64Array = b.data;
                        var dataX: Float64Array = x.data;
                        var nc: number = b.numCols;
                        var n: number = b.numCols;
                        var vv: Float64Array = this.decomp._getVV();
                        for (var k: number = 0; k < nc; k++) {
                            for (var i: number = 0; i < n; i++) {
                                var sdp: number = -dataB[i * nc + k];
                                for (var j: number = 0; j < n; j++) {
                                    sdp += dataA[i * n + j] * dataX[j * nc + k];
                                }
                                vv[i] = sdp;
                            }
                            this.decomp._solveVectorInternal(vv);
                            for (var i: number = 0; i < n; i++) {
                                dataX[i * nc + k] -= vv[i];
                            }
                        }
                    }

                    public modifiesA(): boolean {
                        return false;
                    }

                    public modifiesB(): boolean {
                        return false;
                    }

                    public solve(b: util.maths.matrix.DenseMatrix64F, x: util.maths.matrix.DenseMatrix64F): void {
                        var numCols: number = b.numCols;
                        var dataB: Float64Array = b.data;
                        var dataX: Float64Array = x.data;
                        var vv: Float64Array = this.decomp._getVV();
                        for (var j: number = 0; j < numCols; j++) {
                            var index: number = j;
                            for (var i: number = 0; i < this.numCols; i++) {
                                vv[i] = dataB[index];
                                index += numCols;
                            }
                            this.decomp._solveVectorInternal(vv);
                            index = j;
                            for (var i: number = 0; i < this.numCols; i++) {
                                dataX[index] = vv[i];
                                index += numCols;
                            }
                        }
                        if (this.doImprove) {
                            this.improveSol(b, x);
                        }
                    }

                }

                export class SimpleEVD<T extends util.maths.matrix.SimpleMatrix> {

                    private eig: util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition;
                    public mat: util.maths.matrix.DenseMatrix64F;
                    constructor(mat: util.maths.matrix.DenseMatrix64F) {
                        this.mat = mat;
                        this.eig = new util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition(mat.numCols, true, 1e-8);
                        if (!this.eig.decompose(mat)) {
                            throw new Error("Eigenvalue Decomposition failed");
                        }
                    }

                    public getNumberOfEigenvalues(): number {
                        return this.eig.getNumberOfEigenvalues();
                    }

                    public getEigenvalue(index: number): util.maths.matrix.Complex64F {
                        return this.eig.getEigenvalue(index);
                    }

                    public getEigenVector(index: number): T {
                        return <T>util.maths.matrix.SimpleMatrix.wrap(this.eig.getEigenVector(index));
                    }

                    public getEVD(): util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition {
                        return this.eig;
                    }

                    public getIndexMax(): number {
                        var indexMax: number = 0;
                        var max: number = this.getEigenvalue(0).getMagnitude2();
                        var N: number = this.getNumberOfEigenvalues();
                        for (var i: number = 1; i < N; i++) {
                            var m: number = this.getEigenvalue(i).getMagnitude2();
                            if (m > max) {
                                max = m;
                                indexMax = i;
                            }
                        }
                        return indexMax;
                    }

                    public getIndexMin(): number {
                        var indexMin: number = 0;
                        var min: number = this.getEigenvalue(0).getMagnitude2();
                        var N: number = this.getNumberOfEigenvalues();
                        for (var i: number = 1; i < N; i++) {
                            var m: number = this.getEigenvalue(i).getMagnitude2();
                            if (m < min) {
                                min = m;
                                indexMin = i;
                            }
                        }
                        return indexMin;
                    }

                }

                export class SimpleSVD<T extends util.maths.matrix.SimpleMatrix> {

                    private svd: util.maths.matrix.solvers.SvdImplicitQrDecompose_D64;
                    private U: T;
                    private W: T;
                    private V: T;
                    private mat: util.maths.matrix.DenseMatrix64F;
                    public tol: number;
                    private static swapRowOrCol(M: util.maths.matrix.DenseMatrix64F, tran: boolean, i: number, bigIndex: number): void {
                        var tmp: number;
                        if (tran) {
                            for (var col: number = 0; col < M.numCols; col++) {
                                tmp = M.get(i, col);
                                M.set(i, col, M.get(bigIndex, col));
                                M.set(bigIndex, col, tmp);
                            }
                        } else {
                            for (var row: number = 0; row < M.numRows; row++) {
                                tmp = M.get(row, i);
                                M.set(row, i, M.get(row, bigIndex));
                                M.set(row, bigIndex, tmp);
                            }
                        }
                    }

                    public static singularThreshold(svd: util.maths.matrix.solvers.SvdImplicitQrDecompose_D64): number {
                        var largest: number = 0;
                        var w: Float64Array = svd.getSingularValues();
                        var N: number = svd.numberOfSingularValues();
                        for (var j: number = 0; j < N; j++) {
                            if (w[j] > largest) {
                                largest = w[j];
                            }
                        }
                        var M: number = Math.max(svd.getNumCols(), svd.getNumRows());
                        return M * largest * util.maths.matrix.CommonOps.EPS;
                    }

                    public static descendingOrder(U: util.maths.matrix.DenseMatrix64F, tranU: boolean, W: util.maths.matrix.DenseMatrix64F, V: util.maths.matrix.DenseMatrix64F, tranV: boolean): void {
                        var numSingular: number = Math.min(W.numRows, W.numCols);
                        for (var i: number = 0; i < numSingular; i++) {
                            var bigValue: number = -1;
                            var bigIndex: number = -1;
                            for (var j: number = i; j < numSingular; j++) {
                                var v: number = W.get(j, j);
                                if (v > bigValue) {
                                    bigValue = v;
                                    bigIndex = j;
                                }
                            }
                            if (bigIndex == i) {
                                continue;
                            }
                            if (bigIndex == -1) {
                                break;
                            }
                            var tmp: number = W.get(i, i);
                            W.set(i, i, bigValue);
                            W.set(bigIndex, bigIndex, tmp);
                            if (V != null) {
                                util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(V, tranV, i, bigIndex);
                            }
                            if (U != null) {
                                util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(U, tranU, i, bigIndex);
                            }
                        }
                    }

                    constructor(mat: util.maths.matrix.DenseMatrix64F, compact: boolean) {
                        this.mat = mat;
                        this.svd = new util.maths.matrix.solvers.SvdImplicitQrDecompose_D64(compact, true, true, false);
                        if (!this.svd.decompose(mat)) {
                            throw new Error("Decomposition failed");
                        }
                        this.U = <T>util.maths.matrix.SimpleMatrix.wrap(this.svd.getU(null, false));
                        this.W = <T>util.maths.matrix.SimpleMatrix.wrap(this.svd.getW(null));
                        this.V = <T>util.maths.matrix.SimpleMatrix.wrap(this.svd.getV(null, false));
                        util.maths.matrix.solvers.SimpleSVD.descendingOrder(this.U.getMatrix(), false, this.W.getMatrix(), this.V.getMatrix(), false);
                        this.tol = util.maths.matrix.solvers.SimpleSVD.singularThreshold(this.svd);
                    }

                    public getU(): T {
                        return this.U;
                    }

                    public getW(): T {
                        return this.W;
                    }

                    public getV(): T {
                        return this.V;
                    }

                }

                export class SvdImplicitQrAlgorithm {

                    public rand: java.util.Random = new java.util.Random();
                    public Ut: util.maths.matrix.DenseMatrix64F;
                    public Vt: util.maths.matrix.DenseMatrix64F;
                    public totalSteps: number;
                    public maxValue: number;
                    public N: number;
                    public eigenSmall: util.maths.matrix.solvers.decomposition.EigenvalueSmall = new util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                    public numExceptional: number;
                    public nextExceptional: number;
                    public diag: Float64Array;
                    public off: Float64Array;
                    public bulge: number;
                    public x1: number;
                    public x2: number;
                    public steps: number;
                    public splits: Int32Array;
                    public numSplits: number;
                    private exceptionalThresh: number = 15;
                    private maxIterations: number = this.exceptionalThresh * 100;
                    public followScript: boolean;
                    private static giveUpOnKnown: number = 10;
                    private values: Float64Array;
                    private fastValues: boolean = false;
                    private findingZeros: boolean;
                    public c: number;
                    public s: number;
                    constructor() {
                    }

                    public getUt(): util.maths.matrix.DenseMatrix64F {
                        return this.Ut;
                    }

                    public setUt(ut: util.maths.matrix.DenseMatrix64F): void {
                        this.Ut = ut;
                    }

                    public getVt(): util.maths.matrix.DenseMatrix64F {
                        return this.Vt;
                    }

                    public setVt(vt: util.maths.matrix.DenseMatrix64F): void {
                        this.Vt = vt;
                    }

                    public setMatrix(numRows: number, numCols: number, diag: Float64Array, off: Float64Array): void {
                        this.initParam(numRows, numCols);
                        this.diag = diag;
                        this.off = off;
                        this.maxValue = Math.abs(diag[0]);
                        for (var i: number = 1; i < this.N; i++) {
                            var a: number = Math.abs(diag[i]);
                            var b: number = Math.abs(off[i - 1]);
                            if (a > this.maxValue) {
                                this.maxValue = Math.abs(a);
                            }
                            if (b > this.maxValue) {
                                this.maxValue = Math.abs(b);
                            }
                        }
                    }

                    public swapDiag(diag: Float64Array): Float64Array {
                        var ret: Float64Array = this.diag;
                        this.diag = diag;
                        return ret;
                    }

                    public swapOff(off: Float64Array): Float64Array {
                        var ret: Float64Array = this.off;
                        this.off = off;
                        return ret;
                    }

                    public setMaxValue(maxValue: number): void {
                        this.maxValue = maxValue;
                    }

                    public initParam(M: number, N: number): void {
                        if (N > M) {
                            throw new Error("Must be a square or tall matrix");
                        }
                        this.N = N;
                        if (this.splits == null || this.splits.length < N) {
                            this.splits = new Int32Array(N);
                        }
                        this.x1 = 0;
                        this.x2 = this.N - 1;
                        this.steps = 0;
                        this.totalSteps = 0;
                        this.numSplits = 0;
                        this.numExceptional = 0;
                        this.nextExceptional = this.exceptionalThresh;
                    }

                    public process(): boolean {
                        this.followScript = false;
                        this.findingZeros = true;
                        return this._process();
                    }

                    public processValues(values: Float64Array): boolean {
                        this.followScript = true;
                        this.values = values;
                        this.findingZeros = false;
                        return this._process();
                    }

                    public _process(): boolean {
                        if (this.maxValue == 0) {
                            return true;
                        }
                        while (this.x2 >= 0){
                            if (this.steps > this.maxIterations) {
                                return false;
                            }
                            if (this.x1 == this.x2) {
                                this.resetSteps();
                                if (!this.nextSplit()) {
                                    break;
                                }
                            } else {
                                if (this.fastValues && this.x2 - this.x1 == 1) {
                                    this.resetSteps();
                                    this.eigenBB_2x2(this.x1);
                                    this.setSubmatrix(this.x2, this.x2);
                                } else {
                                    if (this.steps >= this.nextExceptional) {
                                        this.exceptionShift();
                                    } else {
                                        if (!this.checkForAndHandleZeros()) {
                                            if (this.followScript) {
                                                this.performScriptedStep();
                                            } else {
                                                this.performDynamicStep();
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        return true;
                    }

                    private performDynamicStep(): void {
                        if (this.findingZeros) {
                            if (this.steps > 6) {
                                this.findingZeros = false;
                            } else {
                                var scale: number = this.computeBulgeScale();
                                this.performImplicitSingleStep(scale, 0, false);
                            }
                        } else {
                            var scale: number = this.computeBulgeScale();
                            var lambda: number = this.selectWilkinsonShift(scale);
                            this.performImplicitSingleStep(scale, lambda, false);
                        }
                    }

                    private performScriptedStep(): void {
                        var scale: number = this.computeBulgeScale();
                        if (this.steps > SvdImplicitQrAlgorithm.giveUpOnKnown) {
                            this.followScript = false;
                        } else {
                            var s: number = this.values[this.x2] / scale;
                            this.performImplicitSingleStep(scale, s * s, false);
                        }
                    }

                    public incrementSteps(): void {
                        this.steps++;
                        this.totalSteps++;
                    }

                    public isOffZero(i: number): boolean {
                        var bottom: number = Math.abs(this.diag[i]) + Math.abs(this.diag[i + 1]);
                        return Math.abs(this.off[i]) <= bottom * util.maths.matrix.CommonOps.EPS;
                    }

                    public isDiagonalZero(i: number): boolean {
                        var bottom: number = Math.abs(this.diag[i + 1]) + Math.abs(this.off[i]);
                        return Math.abs(this.diag[i]) <= bottom * util.maths.matrix.CommonOps.EPS;
                    }

                    public resetSteps(): void {
                        this.steps = 0;
                        this.nextExceptional = this.exceptionalThresh;
                        this.numExceptional = 0;
                    }

                    public nextSplit(): boolean {
                        if (this.numSplits == 0) {
                            return false;
                        }
                        this.x2 = this.splits[--this.numSplits];
                        if (this.numSplits > 0) {
                            this.x1 = this.splits[this.numSplits - 1] + 1;
                        } else {
                            this.x1 = 0;
                        }
                        return true;
                    }

                    public performImplicitSingleStep(scale: number, lambda: number, byAngle: boolean): void {
                        this.createBulge(this.x1, lambda, scale, byAngle);
                        for (var i: number = this.x1; i < this.x2 - 1 && this.bulge != 0.0; i++) {
                            this.removeBulgeLeft(i, true);
                            if (this.bulge == 0) {
                                break;
                            }
                            this.removeBulgeRight(i);
                        }
                        if (this.bulge != 0) {
                            this.removeBulgeLeft(this.x2 - 1, false);
                        }
                        this.incrementSteps();
                    }

                    public updateRotator(Q: util.maths.matrix.DenseMatrix64F, m: number, n: number, c: number, s: number): void {
                        var rowA: number = m * Q.numCols;
                        var rowB: number = n * Q.numCols;
                        var endA: number = rowA + Q.numCols;
                        for (; rowA != endA; rowA++) {
                            var a: number = Q.getValueAtIndex(rowA);
                            var b: number = Q.getValueAtIndex(rowB);
                            Q.setValueAtIndex(rowA, c * a + s * b);
                            Q.setValueAtIndex(rowB, -s * a + c * b);
                            rowB++;
                        }
                    }

                    private computeBulgeScale(): number {
                        var b11: number = this.diag[this.x1];
                        var b12: number = this.off[this.x1];
                        return Math.max(Math.abs(b11), Math.abs(b12));
                    }

                    public createBulge(x1: number, p: number, scale: number, byAngle: boolean): void {
                        var b11: number = this.diag[x1];
                        var b12: number = this.off[x1];
                        var b22: number = this.diag[x1 + 1];
                        if (byAngle) {
                            this.c = Math.cos(p);
                            this.s = Math.sin(p);
                        } else {
                            var u1: number = (b11 / scale) * (b11 / scale) - p;
                            var u2: number = (b12 / scale) * (b11 / scale);
                            var gamma: number = Math.sqrt(u1 * u1 + u2 * u2);
                            this.c = u1 / gamma;
                            this.s = u2 / gamma;
                        }
                        this.diag[x1] = b11 * this.c + b12 * this.s;
                        this.off[x1] = b12 * this.c - b11 * this.s;
                        this.diag[x1 + 1] = b22 * this.c;
                        this.bulge = b22 * this.s;
                        if (this.Vt != null) {
                            this.updateRotator(this.Vt, x1, x1 + 1, this.c, this.s);
                        }
                    }

                    public computeRotator(rise: number, run: number): void {
                        if (Math.abs(rise) < Math.abs(run)) {
                            var k: number = rise / run;
                            var bottom: number = Math.sqrt(1.0 + k * k);
                            this.s = 1.0 / bottom;
                            this.c = k / bottom;
                        } else {
                            var t: number = run / rise;
                            var bottom: number = Math.sqrt(1.0 + t * t);
                            this.c = 1.0 / bottom;
                            this.s = t / bottom;
                        }
                    }

                    public removeBulgeLeft(x1: number, notLast: boolean): void {
                        var b11: number = this.diag[x1];
                        var b12: number = this.off[x1];
                        var b22: number = this.diag[x1 + 1];
                        this.computeRotator(b11, this.bulge);
                        this.diag[x1] = this.c * b11 + this.s * this.bulge;
                        this.off[x1] = this.c * b12 + this.s * b22;
                        this.diag[x1 + 1] = this.c * b22 - this.s * b12;
                        if (notLast) {
                            var b23: number = this.off[x1 + 1];
                            this.bulge = this.s * b23;
                            this.off[x1 + 1] = this.c * b23;
                        }
                        if (this.Ut != null) {
                            this.updateRotator(this.Ut, x1, x1 + 1, this.c, this.s);
                        }
                    }

                    public removeBulgeRight(x1: number): void {
                        var b12: number = this.off[x1];
                        var b22: number = this.diag[x1 + 1];
                        var b23: number = this.off[x1 + 1];
                        this.computeRotator(b12, this.bulge);
                        this.off[x1] = b12 * this.c + this.bulge * this.s;
                        this.diag[x1 + 1] = b22 * this.c + b23 * this.s;
                        this.off[x1 + 1] = -b22 * this.s + b23 * this.c;
                        var b33: number = this.diag[x1 + 2];
                        this.diag[x1 + 2] = b33 * this.c;
                        this.bulge = b33 * this.s;
                        if (this.Vt != null) {
                            this.updateRotator(this.Vt, x1 + 1, x1 + 2, this.c, this.s);
                        }
                    }

                    public setSubmatrix(x1: number, x2: number): void {
                        this.x1 = x1;
                        this.x2 = x2;
                    }

                    public selectWilkinsonShift(scale: number): number {
                        var a11: number, a22: number;
                        if (this.x2 - this.x1 > 1) {
                            var d1: number = this.diag[this.x2 - 1] / scale;
                            var o1: number = this.off[this.x2 - 2] / scale;
                            var d2: number = this.diag[this.x2] / scale;
                            var o2: number = this.off[this.x2 - 1] / scale;
                            a11 = o1 * o1 + d1 * d1;
                            a22 = o2 * o2 + d2 * d2;
                            this.eigenSmall.symm2x2_fast(a11, o2 * d1, a22);
                        } else {
                            var a: number = this.diag[this.x2 - 1] / scale;
                            var b: number = this.off[this.x2 - 1] / scale;
                            var c: number = this.diag[this.x2] / scale;
                            a11 = a * a;
                            a22 = b * b + c * c;
                            this.eigenSmall.symm2x2_fast(a11, a * b, a22);
                        }
                        var diff0: number = Math.abs(this.eigenSmall.value0.real - a22);
                        var diff1: number = Math.abs(this.eigenSmall.value1.real - a22);
                        return diff0 < diff1 ? this.eigenSmall.value0.real : this.eigenSmall.value1.real;
                    }

                    public static signum(d: number): number {
                        if (d < 0) {
                            return -1.0;
                        }
                        if (d > 0) {
                            return 1.0;
                        }
                        return 0.0;
                    }

                    public eigenBB_2x2(x1: number): void {
                        var b11: number = this.diag[x1];
                        var b12: number = this.off[x1];
                        var b22: number = this.diag[x1 + 1];
                        var absA: number = Math.abs(b11);
                        var absB: number = Math.abs(b12);
                        var absC: number = Math.abs(b22);
                        var scale: number = absA > absB ? absA : absB;
                        if (absC > scale) {
                            scale = absC;
                        }
                        if (scale == 0) {
                            return;
                        }
                        b11 /= scale;
                        b12 /= scale;
                        b22 /= scale;
                        this.eigenSmall.symm2x2_fast(b11 * b11, b11 * b12, b12 * b12 + b22 * b22);
                        this.off[x1] = 0;
                        this.diag[x1] = scale * Math.sqrt(this.eigenSmall.value0.real);
                        var sgn: number = util.maths.matrix.solvers.SvdImplicitQrAlgorithm.signum(this.eigenSmall.value1.real);
                        this.diag[x1 + 1] = sgn * scale * Math.sqrt(Math.abs(this.eigenSmall.value1.real));
                    }

                    public checkForAndHandleZeros(): boolean {
                        for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                            if (this.isOffZero(i)) {
                                this.resetSteps();
                                this.splits[this.numSplits++] = i;
                                this.x1 = i + 1;
                                return true;
                            }
                        }
                        for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                            if (this.isDiagonalZero(i)) {
                                this.pushRight(i);
                                this.resetSteps();
                                this.splits[this.numSplits++] = i;
                                this.x1 = i + 1;
                                return true;
                            }
                        }
                        return false;
                    }

                    private pushRight(row: number): void {
                        if (this.isOffZero(row)) {
                            return;
                        }
                        this.rotatorPushRight(row);
                        var end: number = this.N - 2 - row;
                        for (var i: number = 0; i < end && this.bulge != 0; i++) {
                            this.rotatorPushRight2(row, i + 2);
                        }
                    }

                    private rotatorPushRight(m: number): void {
                        var b11: number = this.off[m];
                        var b21: number = this.diag[m + 1];
                        this.computeRotator(b21, -b11);
                        this.off[m] = 0;
                        this.diag[m + 1] = b21 * this.c - b11 * this.s;
                        if (m + 2 < this.N) {
                            var b22: number = this.off[m + 1];
                            this.off[m + 1] = b22 * this.c;
                            this.bulge = b22 * this.s;
                        } else {
                            this.bulge = 0;
                        }
                        if (this.Ut != null) {
                            this.updateRotator(this.Ut, m, m + 1, this.c, this.s);
                        }
                    }

                    private rotatorPushRight2(m: number, offset: number): void {
                        var b11: number = this.bulge;
                        var b12: number = this.diag[m + offset];
                        this.computeRotator(b12, -b11);
                        this.diag[m + offset] = b12 * this.c - b11 * this.s;
                        if (m + offset < this.N - 1) {
                            var b22: number = this.off[m + offset];
                            this.off[m + offset] = b22 * this.c;
                            this.bulge = b22 * this.s;
                        }
                        if (this.Ut != null) {
                            this.updateRotator(this.Ut, m, m + offset, this.c, this.s);
                        }
                    }

                    public exceptionShift(): void {
                        this.numExceptional++;
                        var mag: number = 0.05 * this.numExceptional;
                        if (mag > 1.0) {
                            mag = 1.0;
                        }
                        var angle: number = 2.0 * Math.PI * (this.rand.nextDouble() - 0.5) * mag;
                        this.performImplicitSingleStep(0, angle, true);
                        this.nextExceptional = this.steps + this.exceptionalThresh;
                    }

                    public getNumberOfSingularValues(): number {
                        return this.N;
                    }

                    public getSingularValue(index: number): number {
                        return this.diag[index];
                    }

                    public setFastValues(b: boolean): void {
                        this.fastValues = b;
                    }

                    public getSingularValues(): Float64Array {
                        return this.diag;
                    }

                    public getDiag(): Float64Array {
                        return this.diag;
                    }

                    public getOff(): Float64Array {
                        return this.off;
                    }

                    public getMaxValue(): number {
                        return this.maxValue;
                    }

                }

                export class SvdImplicitQrDecompose_D64 {

                    private numRows: number;
                    private numCols: number;
                    private numRowsT: number;
                    private numColsT: number;
                    private canUseTallBidiagonal: boolean;
                    private bidiag: util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F>;
                    private qralg: util.maths.matrix.solvers.SvdImplicitQrAlgorithm = new util.maths.matrix.solvers.SvdImplicitQrAlgorithm();
                    public diag: Float64Array;
                    public off: Float64Array;
                    private Ut: util.maths.matrix.DenseMatrix64F;
                    private Vt: util.maths.matrix.DenseMatrix64F;
                    private singularValues: Float64Array;
                    private numSingular: number;
                    private compact: boolean;
                    private computeU: boolean;
                    private computeV: boolean;
                    private prefComputeU: boolean;
                    private prefComputeV: boolean;
                    private transposed: boolean;
                    private A_mod: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(1, 1);
                    constructor(compact: boolean, computeU: boolean, computeV: boolean, canUseTallBidiagonal: boolean) {
                        this.compact = compact;
                        this.prefComputeU = computeU;
                        this.prefComputeV = computeV;
                        this.canUseTallBidiagonal = canUseTallBidiagonal;
                    }

                    public getSingularValues(): Float64Array {
                        return this.singularValues;
                    }

                    public numberOfSingularValues(): number {
                        return this.numSingular;
                    }

                    public isCompact(): boolean {
                        return this.compact;
                    }

                    public getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean): util.maths.matrix.DenseMatrix64F {
                        if (!this.prefComputeU) {
                            throw new Error("As requested U was not computed.");
                        }
                        if (transpose) {
                            if (U == null) {
                                return this.Ut;
                            } else {
                                if (U.numRows != this.Ut.numRows || U.numCols != this.Ut.numCols) {
                                    throw new Error("Unexpected shape of U");
                                }
                            }
                            U.setMatrix(this.Ut);
                        } else {
                            if (U == null) {
                                U = new util.maths.matrix.DenseMatrix64F(this.Ut.numCols, this.Ut.numRows);
                            } else {
                                if (U.numRows != this.Ut.numCols || U.numCols != this.Ut.numRows) {
                                    throw new Error("Unexpected shape of U");
                                }
                            }
                            util.maths.matrix.CommonOps.transposeMatrix(this.Ut, U);
                        }
                        return U;
                    }

                    public getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean): util.maths.matrix.DenseMatrix64F {
                        if (!this.prefComputeV) {
                            throw new Error("As requested V was not computed.");
                        }
                        if (transpose) {
                            if (V == null) {
                                return this.Vt;
                            } else {
                                if (V.numRows != this.Vt.numRows || V.numCols != this.Vt.numCols) {
                                    throw new Error("Unexpected shape of V");
                                }
                            }
                            V.setMatrix(this.Vt);
                        } else {
                            if (V == null) {
                                V = new util.maths.matrix.DenseMatrix64F(this.Vt.numCols, this.Vt.numRows);
                            } else {
                                if (V.numRows != this.Vt.numCols || V.numCols != this.Vt.numRows) {
                                    throw new Error("Unexpected shape of V");
                                }
                            }
                            util.maths.matrix.CommonOps.transposeMatrix(this.Vt, V);
                        }
                        return V;
                    }

                    public getW(W: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                        var m: number = this.compact ? this.numSingular : this.numRows;
                        var n: number = this.compact ? this.numSingular : this.numCols;
                        if (W == null) {
                            W = new util.maths.matrix.DenseMatrix64F(m, n);
                        } else {
                            W.reshapeBoolean(m, n, false);
                            W.zero();
                        }
                        for (var i: number = 0; i < this.numSingular; i++) {
                            W.set(i, i, this.singularValues[i]);
                        }
                        return W;
                    }

                    public decompose(orig: util.maths.matrix.DenseMatrix64F): boolean {
                        if (!this.setup(orig)) {
                            return false;
                        }
                        if (this.bidiagonalization(orig)) {
                            return false;
                        }
                        if (this.computeUWV()) {
                            return false;
                        }
                        this.makeSingularPositive();
                        this.undoTranspose();
                        return true;
                    }

                    public inputModified(): boolean {
                        return false;
                    }

                    private bidiagonalization(orig: util.maths.matrix.DenseMatrix64F): boolean {
                        if (this.transposed) {
                            this.A_mod.reshapeBoolean(orig.numCols, orig.numRows, false);
                            util.maths.matrix.CommonOps.transposeMatrix(orig, this.A_mod);
                        } else {
                            this.A_mod.reshapeBoolean(orig.numRows, orig.numCols, false);
                            this.A_mod.setMatrix(orig);
                        }
                        return !this.bidiag.decompose(this.A_mod);
                    }

                    private undoTranspose(): void {
                        if (this.transposed) {
                            var temp: util.maths.matrix.DenseMatrix64F = this.Vt;
                            this.Vt = this.Ut;
                            this.Ut = temp;
                        }
                    }

                    private computeUWV(): boolean {
                        this.bidiag.getDiagonal(this.diag, this.off);
                        this.qralg.setMatrix(this.numRowsT, this.numColsT, this.diag, this.off);
                        if (this.computeU) {
                            this.Ut = this.bidiag.getU(this.Ut, true, this.compact);
                        }
                        if (this.computeV) {
                            this.Vt = this.bidiag.getV(this.Vt, true, this.compact);
                        }
                        this.qralg.setFastValues(false);
                        if (this.computeU) {
                            this.qralg.setUt(this.Ut);
                        } else {
                            this.qralg.setUt(null);
                        }
                        if (this.computeV) {
                            this.qralg.setVt(this.Vt);
                        } else {
                            this.qralg.setVt(null);
                        }
                        var ret: boolean = !this.qralg.process();
                        return ret;
                    }

                    private setup(orig: util.maths.matrix.DenseMatrix64F): boolean {
                        this.transposed = orig.numCols > orig.numRows;
                        if (this.transposed) {
                            this.computeU = this.prefComputeV;
                            this.computeV = this.prefComputeU;
                            this.numRowsT = orig.numCols;
                            this.numColsT = orig.numRows;
                        } else {
                            this.computeU = this.prefComputeU;
                            this.computeV = this.prefComputeV;
                            this.numRowsT = orig.numRows;
                            this.numColsT = orig.numCols;
                        }
                        this.numRows = orig.numRows;
                        this.numCols = orig.numCols;
                        if (this.numRows == 0 || this.numCols == 0) {
                            return false;
                        }
                        if (this.diag == null || this.diag.length < this.numColsT) {
                            this.diag = new Float64Array(this.numColsT);
                            this.off = new Float64Array(this.numColsT - 1);
                        }
                        if (this.canUseTallBidiagonal && this.numRows > this.numCols * 2 && !this.computeU) {
                            if (this.bidiag == null || !(this.bidiag instanceof util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64)) {
                                this.bidiag = new util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64();
                            }
                        } else {
                            if (this.bidiag == null || !(this.bidiag instanceof util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64)) {
                                this.bidiag = new util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                            }
                        }
                        return true;
                    }

                    private makeSingularPositive(): void {
                        this.numSingular = this.qralg.getNumberOfSingularValues();
                        this.singularValues = this.qralg.getSingularValues();
                        for (var i: number = 0; i < this.numSingular; i++) {
                            var val: number = this.qralg.getSingularValue(i);
                            if (val < 0) {
                                this.singularValues[i] = 0.0 - val;
                                if (this.computeU) {
                                    var start: number = i * this.Ut.numCols;
                                    var stop: number = start + this.Ut.numCols;
                                    for (var j: number = start; j < stop; j++) {
                                        this.Ut.setValueAtIndex(j, 0.0 - this.Ut.getValueAtIndex(j));
                                    }
                                }
                            } else {
                                this.singularValues[i] = val;
                            }
                        }
                    }

                    public getNumRows(): number {
                        return this.numRows;
                    }

                    public getNumCols(): number {
                        return this.numCols;
                    }

                }

                export class TriangularSolver {

                    public static solveU2arr(U: Float64Array, b: Float64Array, n: number): void {
                        for (var i: number = n - 1; i >= 0; i--) {
                            var sum: number = b[i];
                            var indexU: number = i * n + i + 1;
                            for (var j: number = i + 1; j < n; j++) {
                                sum -= U[indexU++] * b[j];
                            }
                            b[i] = sum / U[i * n + i];
                        }
                    }

                    public static solveU(U: Float64Array, b: Float64Array, sideLength: number, minRow: number, maxRow: number): void {
                        for (var i: number = maxRow - 1; i >= minRow; i--) {
                            var sum: number = b[i];
                            var indexU: number = i * sideLength + i + 1;
                            for (var j: number = i + 1; j < maxRow; j++) {
                                sum -= U[indexU++] * b[j];
                            }
                            b[i] = sum / U[i * sideLength + i];
                        }
                    }

                }

                export namespace decomposition {
                    export interface BidiagonalDecomposition<T extends util.maths.matrix.DenseMatrix64F> {

                        getB(B: T, compact: boolean): T;

                        getU(U: T, transpose: boolean, compact: boolean): T;

                        getV(V: T, transpose: boolean, compact: boolean): T;

                        getDiagonal(diag: Float64Array, off: Float64Array): void;

                        decompose(orig: T): boolean;

                        inputModified(): boolean;

                    }

                    export class BidiagonalDecompositionRow_D64 implements util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F> {

                        private UBV: util.maths.matrix.DenseMatrix64F;
                        private m: number;
                        private n: number;
                        private min: number;
                        private gammasU: Float64Array;
                        private gammasV: Float64Array;
                        private b: Float64Array;
                        private u: Float64Array;
                        constructor(numElements: number) {
                            this.UBV = new util.maths.matrix.DenseMatrix64F(numElements, 1);
                            this.gammasU = new Float64Array(numElements);
                            this.gammasV = new Float64Array(numElements);
                            this.b = new Float64Array(numElements);
                            this.u = new Float64Array(numElements);
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            this.init(A);
                            return this._decompose();
                        }

                        public init(A: util.maths.matrix.DenseMatrix64F): void {
                            this.UBV = A;
                            this.m = this.UBV.numRows;
                            this.n = this.UBV.numCols;
                            this.min = Math.min(this.m, this.n);
                            var max: number = Math.max(this.m, this.n);
                            if (this.b.length < max + 1) {
                                this.b = new Float64Array(max + 1);
                                this.u = new Float64Array(max + 1);
                            }
                            if (this.gammasU.length < this.m) {
                                this.gammasU = new Float64Array(this.m);
                            }
                            if (this.gammasV.length < this.n) {
                                this.gammasV = new Float64Array(this.n);
                            }
                        }

                        public getUBV(): util.maths.matrix.DenseMatrix64F {
                            return this.UBV;
                        }

                        public getDiagonal(diag: Float64Array, off: Float64Array): void {
                            diag[0] = this.UBV.getValueAtIndex(0);
                            for (var i: number = 1; i < this.n; i++) {
                                diag[i] = this.UBV.get(i, i);
                                off[i - 1] = this.UBV.get(i - 1, i);
                            }
                        }

                        public getB(B: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            B = util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                            B.set(0, 0, this.UBV.get(0, 0));
                            for (var i: number = 1; i < this.min; i++) {
                                B.set(i, i, this.UBV.get(i, i));
                                B.set(i - 1, i, this.UBV.get(i - 1, i));
                            }
                            if (this.n > this.m) {
                                B.set(this.min - 1, this.min, this.UBV.get(this.min - 1, this.min));
                            }
                            return B;
                        }

                        public static handleB(B: util.maths.matrix.DenseMatrix64F, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F {
                            var w: number = n > m ? min + 1 : min;
                            if (compact) {
                                if (B == null) {
                                    B = new util.maths.matrix.DenseMatrix64F(min, w);
                                } else {
                                    B.reshapeBoolean(min, w, false);
                                    B.zero();
                                }
                            } else {
                                if (B == null) {
                                    B = new util.maths.matrix.DenseMatrix64F(m, n);
                                } else {
                                    B.reshapeBoolean(m, n, false);
                                    B.zero();
                                }
                            }
                            return B;
                        }

                        public getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            U = util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, transpose, compact, this.m, this.n, this.min);
                            util.maths.matrix.CommonOps.setIdentity(U);
                            for (var i: number = 0; i < this.m; i++) {
                                this.u[i] = 0;
                            }
                            for (var j: number = this.min - 1; j >= 0; j--) {
                                this.u[j] = 1;
                                for (var i: number = j + 1; i < this.m; i++) {
                                    this.u[i] = this.UBV.get(i, j);
                                }
                                if (transpose) {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(U, this.u, this.gammasU[j], j, j, this.m);
                                } else {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(U, this.u, this.gammasU[j], j, j, this.m, this.b);
                                }
                            }
                            return U;
                        }

                        public static handleU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F {
                            if (compact) {
                                if (transpose) {
                                    if (U == null) {
                                        U = new util.maths.matrix.DenseMatrix64F(min, m);
                                    } else {
                                        U.reshapeBoolean(min, m, false);
                                    }
                                } else {
                                    if (U == null) {
                                        U = new util.maths.matrix.DenseMatrix64F(m, min);
                                    } else {
                                        U.reshapeBoolean(m, min, false);
                                    }
                                }
                            } else {
                                if (U == null) {
                                    U = new util.maths.matrix.DenseMatrix64F(m, m);
                                } else {
                                    U.reshapeBoolean(m, m, false);
                                }
                            }
                            return U;
                        }

                        public getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            V = util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleV(V, transpose, compact, this.m, this.n, this.min);
                            util.maths.matrix.CommonOps.setIdentity(V);
                            for (var j: number = this.min - 1; j >= 0; j--) {
                                this.u[j + 1] = 1;
                                for (var i: number = j + 2; i < this.n; i++) {
                                    this.u[i] = this.UBV.get(j, i);
                                }
                                if (transpose) {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(V, this.u, this.gammasV[j], j + 1, j + 1, this.n);
                                } else {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(V, this.u, this.gammasV[j], j + 1, j + 1, this.n, this.b);
                                }
                            }
                            return V;
                        }

                        public static handleV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): util.maths.matrix.DenseMatrix64F {
                            var w: number = n > m ? min + 1 : min;
                            if (compact) {
                                if (transpose) {
                                    if (V == null) {
                                        V = new util.maths.matrix.DenseMatrix64F(w, n);
                                    } else {
                                        V.reshapeBoolean(w, n, false);
                                    }
                                } else {
                                    if (V == null) {
                                        V = new util.maths.matrix.DenseMatrix64F(n, w);
                                    } else {
                                        V.reshapeBoolean(n, w, false);
                                    }
                                }
                            } else {
                                if (V == null) {
                                    V = new util.maths.matrix.DenseMatrix64F(n, n);
                                } else {
                                    V.reshapeBoolean(n, n, false);
                                }
                            }
                            return V;
                        }

                        private _decompose(): boolean {
                            for (var k: number = 0; k < this.min; k++) {
                                this.computeU(k);
                                this.computeV(k);
                            }
                            return true;
                        }

                        public computeU(k: number): void {
                            var b: Float64Array = this.UBV.data;
                            var max: number = 0;
                            for (var i: number = k; i < this.m; i++) {
                                var val: number = this.u[i] = b[i * this.n + k];
                                val = Math.abs(val);
                                if (val > max) {
                                    max = val;
                                }
                            }
                            if (max > 0) {
                                var tau: number = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4arg(k, this.m, this.u, max);
                                var nu: number = this.u[k] + tau;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Bcol(k + 1, this.m, this.n, this.u, b, k, nu);
                                this.u[k] = 1.0;
                                var gamma: number = nu / tau;
                                this.gammasU[k] = gamma;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.UBV, this.u, gamma, k + 1, k, this.m, this.b);
                                b[k * this.n + k] = -tau * max;
                            } else {
                                this.gammasU[k] = 0;
                            }
                        }

                        public computeV(k: number): void {
                            var b: Float64Array = this.UBV.data;
                            var row: number = k * this.n;
                            var max: number = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMax(b, row + k + 1, this.n - k - 1);
                            if (max > 0) {
                                var tau: number = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k + 1, this.n, b, row, max);
                                var nu: number = b[row + k + 1] + tau;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Brow(k + 2, this.n, this.u, b, row, nu);
                                this.u[k + 1] = 1.0;
                                var gamma: number = nu / tau;
                                this.gammasV[k] = gamma;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.UBV, this.u, gamma, k + 1, k + 1, this.n);
                                b[row + k + 1] = -tau * max;
                            } else {
                                this.gammasV[k] = 0;
                            }
                        }

                        public getGammasU(): Float64Array {
                            return this.gammasU;
                        }

                        public getGammasV(): Float64Array {
                            return this.gammasV;
                        }

                        public inputModified(): boolean {
                            return true;
                        }

                    }

                    export class BidiagonalDecompositionTall_D64 implements util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F> {

                        public decompQRP: util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64 = new util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64();
                        public decompBi: util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<util.maths.matrix.DenseMatrix64F> = new util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                        public B: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(1, 1);
                        public m: number;
                        public n: number;
                        public min: number;
                        public getDiagonal(diag: Float64Array, off: Float64Array): void {
                            diag[0] = this.B.getValueAtIndex(0);
                            for (var i: number = 1; i < this.n; i++) {
                                diag[i] = this.B.get(i, i);
                                off[i - 1] = this.B.get(i - 1, i);
                            }
                        }

                        public getB(B: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            B = util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                            B.set(0, 0, this.B.get(0, 0));
                            for (var i: number = 1; i < this.min; i++) {
                                B.set(i, i, this.B.get(i, i));
                                B.set(i - 1, i, this.B.get(i - 1, i));
                            }
                            if (this.n > this.m) {
                                B.set(this.min - 1, this.min, this.B.get(this.min - 1, this.min));
                            }
                            return B;
                        }

                        public getU(U: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            U = util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, false, compact, this.m, this.n, this.min);
                            if (compact) {
                                var Q1: util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(null, true);
                                var U1: util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                                util.maths.matrix.CommonOps.mult(Q1, U1, U);
                            } else {
                                var Q: util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(U, false);
                                var U1: util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                                var Q1: util.maths.matrix.DenseMatrix64F = util.maths.matrix.CommonOps.extract4Int(Q, 0, Q.numRows, 0, this.min);
                                var tmp: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(Q1.numRows, U1.numCols);
                                util.maths.matrix.CommonOps.mult(Q1, U1, tmp);
                                util.maths.matrix.CommonOps.insert(tmp, Q, 0, 0);
                            }
                            if (transpose) {
                                util.maths.matrix.CommonOps.transpose(U);
                            }
                            return U;
                        }

                        public getV(V: util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            return this.decompBi.getV(V, transpose, compact);
                        }

                        public decompose(orig: util.maths.matrix.DenseMatrix64F): boolean {
                            if (!this.decompQRP.decompose(orig)) {
                                return false;
                            }
                            this.m = orig.numRows;
                            this.n = orig.numCols;
                            this.min = Math.min(this.m, this.n);
                            this.B.reshapeBoolean(this.min, this.n, false);
                            this.decompQRP.getR(this.B, true);
                            var result: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(this.min, this.n);
                            var P: util.maths.matrix.DenseMatrix64F = this.decompQRP.getPivotMatrix(null);
                            util.maths.matrix.CommonOps.multTransB(this.B, P, result);
                            this.B.setMatrix(result);
                            return this.decompBi.decompose(this.B);
                        }

                        public inputModified(): boolean {
                            return this.decompQRP.inputModified();
                        }

                    }

                    export class EigenvalueSmall {

                        public value0: util.maths.matrix.Complex64F = new util.maths.matrix.Complex64F();
                        public value1: util.maths.matrix.Complex64F = new util.maths.matrix.Complex64F();
                        public value2x2(a11: number, a12: number, a21: number, a22: number): void {
                            var c: number, s: number;
                            if (a12 + a21 == 0) {
                                c = s = 1.0 / Math.sqrt(2);
                            } else {
                                var aa: number = (a11 - a22);
                                var bb: number = (a12 + a21);
                                var t_hat: number = aa / bb;
                                var t: number = t_hat / (1.0 + Math.sqrt(1.0 + t_hat * t_hat));
                                c = 1.0 / Math.sqrt(1.0 + t * t);
                                s = c * t;
                            }
                            var c2: number = c * c;
                            var s2: number = s * s;
                            var cs: number = c * s;
                            var b11: number = c2 * a11 + s2 * a22 - cs * (a12 + a21);
                            var b12: number = c2 * a12 - s2 * a21 + cs * (a11 - a22);
                            var b21: number = c2 * a21 - s2 * a12 + cs * (a11 - a22);
                            if (b21 * b12 >= 0) {
                                if (b12 == 0) {
                                    c = 0;
                                    s = 1;
                                } else {
                                    s = Math.sqrt(b21 / (b12 + b21));
                                    c = Math.sqrt(b12 / (b12 + b21));
                                }
                                cs = c * s;
                                a11 = b11 - cs * (b12 + b21);
                                a22 = b11 + cs * (b12 + b21);
                                this.value0.real = a11;
                                this.value1.real = a22;
                                this.value0.imaginary = this.value1.imaginary = 0;
                            } else {
                                this.value0.real = this.value1.real = b11;
                                this.value0.imaginary = Math.sqrt(-b21 * b12);
                                this.value1.imaginary = -this.value0.imaginary;
                            }
                        }

                        public value2x2_fast(a11: number, a12: number, a21: number, a22: number): void {
                            var left: number = (a11 + a22) / 2.0;
                            var inside: number = 4.0 * a12 * a21 + (a11 - a22) * (a11 - a22);
                            if (inside < 0) {
                                this.value0.real = this.value1.real = left;
                                this.value0.imaginary = Math.sqrt(-inside) / 2.0;
                                this.value1.imaginary = -this.value0.imaginary;
                            } else {
                                var right: number = Math.sqrt(inside) / 2.0;
                                this.value0.real = (left + right);
                                this.value1.real = (left - right);
                                this.value0.imaginary = this.value1.imaginary = 0.0;
                            }
                        }

                        public symm2x2_fast(a11: number, a12: number, a22: number): void {
                            var left: number = (a11 + a22) * 0.5;
                            var b: number = (a11 - a22) * 0.5;
                            var right: number = Math.sqrt(b * b + a12 * a12);
                            this.value0.real = left + right;
                            this.value1.real = left - right;
                        }

                    }

                    export class HessenbergSimilarDecomposition_D64 {

                        private QH: util.maths.matrix.DenseMatrix64F;
                        private N: number;
                        private gammas: Float64Array;
                        private b: Float64Array;
                        private u: Float64Array;
                        constructor(initialSize: number) {
                            this.gammas = new Float64Array(initialSize);
                            this.b = new Float64Array(initialSize);
                            this.u = new Float64Array(initialSize);
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            if (A.numRows != A.numCols) {
                                throw new Error("A must be square.");
                            }
                            if (A.numRows <= 0) {
                                return false;
                            }
                            this.QH = A;
                            this.N = A.numCols;
                            if (this.b.length < this.N) {
                                this.b = new Float64Array(this.N);
                                this.gammas = new Float64Array(this.N);
                                this.u = new Float64Array(this.N);
                            }
                            return this._decompose();
                        }

                        public inputModified(): boolean {
                            return true;
                        }

                        public getQH(): util.maths.matrix.DenseMatrix64F {
                            return this.QH;
                        }

                        public getH(H: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                            if (H == null) {
                                H = new util.maths.matrix.DenseMatrix64F(this.N, this.N);
                            } else {
                                H.zero();
                            }
                            java.lang.System.arraycopy(this.QH.data, 0, H.data, 0, this.N);
                            for (var i: number = 1; i < this.N; i++) {
                                for (var j: number = i - 1; j < this.N; j++) {
                                    H.set(i, j, this.QH.get(i, j));
                                }
                            }
                            return H;
                        }

                        public getQ(Q: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                            if (Q == null) {
                                Q = new util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                for (var i: number = 0; i < this.N; i++) {
                                    Q.data[i * this.N + i] = 1;
                                }
                            } else {
                                if (this.N != Q.numRows || this.N != Q.numCols) {
                                    throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                } else {
                                    util.maths.matrix.CommonOps.setIdentity(Q);
                                }
                            }
                            for (var j: number = this.N - 2; j >= 0; j--) {
                                this.u[j + 1] = 1;
                                for (var i: number = j + 2; i < this.N; i++) {
                                    this.u[i] = this.QH.get(i, j);
                                }
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.u, this.gammas[j], j + 1, j + 1, this.N, this.b);
                            }
                            return Q;
                        }

                        private _decompose(): boolean {
                            var h: Float64Array = this.QH.data;
                            for (var k: number = 0; k < this.N - 2; k++) {
                                var max: number = 0;
                                for (var i: number = k + 1; i < this.N; i++) {
                                    var val: number = this.u[i] = h[i * this.N + k];
                                    val = Math.abs(val);
                                    if (val > max) {
                                        max = val;
                                    }
                                }
                                if (max > 0) {
                                    var tau: number = 0;
                                    for (var i: number = k + 1; i < this.N; i++) {
                                        var val: number = this.u[i] /= max;
                                        tau += val * val;
                                    }
                                    tau = Math.sqrt(tau);
                                    if (this.u[k + 1] < 0) {
                                        tau = -tau;
                                    }
                                    var nu: number = this.u[k + 1] + tau;
                                    this.u[k + 1] = 1.0;
                                    for (var i: number = k + 2; i < this.N; i++) {
                                        h[i * this.N + k] = this.u[i] /= nu;
                                    }
                                    var gamma: number = nu / tau;
                                    this.gammas[k] = gamma;
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.QH, this.u, gamma, k + 1, k + 1, this.N, this.b);
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.QH, this.u, gamma, 0, k + 1, this.N);
                                    h[(k + 1) * this.N + k] = -tau * max;
                                } else {
                                    this.gammas[k] = 0;
                                }
                            }
                            return true;
                        }

                        public getGammas(): Float64Array {
                            return this.gammas;
                        }

                    }

                    export class QRDecompositionHouseholderColumn_D64 {

                        public dataQR: util.maths.structure.KArray2D;
                        public v: Float64Array;
                        public numCols: number;
                        public numRows: number;
                        public minLength: number;
                        public gammas: Float64Array;
                        public gamma: number;
                        public tau: number;
                        public error: boolean;
                        public setExpectedMaxSize(numRows: number, numCols: number): void {
                            this.numCols = numCols;
                            this.numRows = numRows;
                            this.minLength = Math.min(numCols, numRows);
                            var maxLength: number = Math.max(numCols, numRows);
                            if (this.dataQR == null || this.dataQR.rows() < numRows || this.dataQR.columns() < numCols) {
                                this.dataQR = new util.maths.structure.impl.NativeArray2D(numRows, numCols);
                                this.v = new Float64Array(maxLength);
                                this.gammas = new Float64Array(this.minLength);
                            }
                            if (this.v.length < maxLength) {
                                this.v = new Float64Array(maxLength);
                            }
                            if (this.gammas.length < this.minLength) {
                                this.gammas = new Float64Array(this.minLength);
                            }
                        }

                        public getQ(Q: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            if (compact) {
                                if (Q == null) {
                                    Q = util.maths.matrix.DenseMatrix64F.identity(this.numRows, this.minLength);
                                } else {
                                    util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                                }
                            } else {
                                if (Q == null) {
                                    Q = util.maths.matrix.DenseMatrix64F.widentity(this.numRows);
                                } else {
                                    util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                                }
                            }
                            for (var j: number = this.minLength - 1; j >= 0; j--) {
                                var vv: number = this.dataQR.get(j, j);
                                this.dataQR.set(j, j, 1);
                                util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.rank1UpdateMultR(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                                this.dataQR.set(j, j, vv);
                            }
                            return Q;
                        }

                        public getR(R: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            if (R == null) {
                                if (compact) {
                                    R = new util.maths.matrix.DenseMatrix64F(this.minLength, this.numCols);
                                } else {
                                    R = new util.maths.matrix.DenseMatrix64F(this.numRows, this.numCols);
                                }
                            } else {
                                for (var i: number = 0; i < R.numRows; i++) {
                                    var min: number = Math.min(i, R.numCols);
                                    for (var j: number = 0; j < min; j++) {
                                        R.cset(i, j, 0);
                                    }
                                }
                            }
                            for (var j: number = 0; j < this.numCols; j++) {
                                var l: number = Math.min(j, this.numRows - 1);
                                for (var i: number = 0; i <= l; i++) {
                                    var val: number = this.dataQR.get(i, j);
                                    R.cset(i, j, val);
                                }
                            }
                            return R;
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            this.setExpectedMaxSize(A.numRows, A.numCols);
                            this.convertToColumnMajor(A);
                            this.error = false;
                            for (var j: number = 0; j < this.minLength; j++) {
                                this.householder(j);
                                this.updateA(j);
                            }
                            return !this.error;
                        }

                        public convertToColumnMajor(A: util.maths.matrix.DenseMatrix64F): void {
                            for (var x: number = 0; x < this.numCols; x++) {
                                for (var y: number = 0; y < this.numRows; y++) {
                                    this.dataQR.set(y, x, A.data[y * this.numCols + x]);
                                }
                            }
                        }

                        public householder(j: number): void {
                            var max: number = util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.findMax(this.dataQR, j, j, this.numRows - j);
                            if (max == 0.0) {
                                this.gamma = 0;
                                this.error = true;
                            } else {
                                this.tau = util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.computeTauAndDivide(j, this.numRows, this.dataQR, j, max);
                                var u_0: number = this.dataQR.get(j, j) + this.tau;
                                util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.divideElements(j + 1, this.numRows, this.dataQR, j, u_0);
                                this.gamma = u_0 / this.tau;
                                this.tau *= max;
                                this.dataQR.set(j, j, -this.tau);
                            }
                            this.gammas[j] = this.gamma;
                        }

                        public updateA(w: number): void {
                            for (var j: number = w + 1; j < this.numCols; j++) {
                                var val: number = this.dataQR.get(w, j);
                                for (var k: number = w + 1; k < this.numRows; k++) {
                                    val += this.dataQR.get(k, w) * this.dataQR.get(k, j);
                                }
                                val *= this.gamma;
                                this.dataQR.add(w, j, -val);
                                for (var i: number = w + 1; i < this.numRows; i++) {
                                    this.dataQR.add(i, j, -this.dataQR.get(i, w) * val);
                                }
                            }
                        }

                        public static findMax(u: util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                            var max: number = -1;
                            var index: number = startU;
                            var stopIndex: number = startU + length;
                            for (; index < stopIndex; index++) {
                                var val: number = u.get(index, col);
                                val = (val < 0.0) ? -val : val;
                                if (val > max) {
                                    max = val;
                                }
                            }
                            return max;
                        }

                        public static divideElements(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, u_0: number): void {
                            for (var i: number = j; i < numRows; i++) {
                                u.set(i, col, u.get(i, col) / u_0);
                            }
                        }

                        public static computeTauAndDivide(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, max: number): number {
                            var tau: number = 0;
                            for (var i: number = j; i < numRows; i++) {
                                u.set(i, col, u.get(i, col) / max);
                                var d: number = u.get(i, col);
                                tau += d * d;
                            }
                            tau = Math.sqrt(tau);
                            if (u.get(j, col) < 0) {
                                tau = -tau;
                            }
                            return tau;
                        }

                        public inputModified(): boolean {
                            return false;
                        }

                        public static rank1UpdateMultR(A: util.maths.matrix.DenseMatrix64F, u: util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                            }
                            for (var k: number = w0 + 1; k < w1; k++) {
                                var indexA: number = k * A.numCols + colA0;
                                var valU: number = u.get(k, col);
                                for (var i: number = colA0; i < A.numCols; i++) {
                                    _temp[i] += valU * A.data[indexA++];
                                }
                            }
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] *= gamma;
                            }
                            for (var i: number = w0; i < w1; i++) {
                                var valU: number = u.get(i, col);
                                var indexA: number = i * A.numCols + colA0;
                                for (var j: number = colA0; j < A.numCols; j++) {
                                    A.data[indexA++] -= valU * _temp[j];
                                }
                            }
                        }

                    }

                    export class QRxColPivDecompositionHouseholderColumn_D64 extends util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64 {

                        public pivots: Int32Array;
                        public normsCol: Float64Array;
                        public maxAbs: number;
                        public singularThreshold: number = util.maths.matrix.CommonOps.EPS;
                        public rank: number;
                        constructor() {
                            super();
                        }

                        public setSingularThreshold(threshold: number): void {
                            this.singularThreshold = threshold;
                        }

                        public setExpectedMaxSize(numRows: number, numCols: number): void {
                            super.setExpectedMaxSize(numRows, numCols);
                            if (this.pivots == null || this.pivots.length < numCols) {
                                this.pivots = new Int32Array(numCols);
                                this.normsCol = new Float64Array(numCols);
                            }
                        }

                        public getQ(Q: util.maths.matrix.DenseMatrix64F, compact: boolean): util.maths.matrix.DenseMatrix64F {
                            if (compact) {
                                if (Q == null) {
                                    Q = util.maths.matrix.CommonOps.identity(this.numRows, this.minLength);
                                } else {
                                    if (Q.numRows != this.numRows || Q.numCols != this.minLength) {
                                        throw new Error("Unexpected matrix dimension.");
                                    } else {
                                        util.maths.matrix.CommonOps.setIdentity(Q);
                                    }
                                }
                            } else {
                                if (Q == null) {
                                    Q = util.maths.matrix.CommonOps.identity1D(this.numRows);
                                } else {
                                    if (Q.numRows != this.numRows || Q.numCols != this.numRows) {
                                        throw new Error("Unexpected matrix dimension.");
                                    } else {
                                        util.maths.matrix.CommonOps.setIdentity(Q);
                                    }
                                }
                            }
                            for (var j: number = this.rank - 1; j >= 0; j--) {
                                var vv: number = this.dataQR.get(j, j);
                                this.dataQR.set(j, j, 1);
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultRArray(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                                this.dataQR.set(j, j, vv);
                            }
                            return Q;
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            this.setExpectedMaxSize(A.numRows, A.numCols);
                            this.convertToColumnMajor(A);
                            this.maxAbs = util.maths.matrix.CommonOps.elementMaxAbs(A);
                            this.setupPivotInfo();
                            for (var j: number = 0; j < this.minLength; j++) {
                                if (j > 0) {
                                    this.updateNorms(j);
                                }
                                this.swapColumns(j);
                                if (!this.householderPivot(j)) {
                                    break;
                                }
                                this.updateA(j);
                                this.rank = j + 1;
                            }
                            return true;
                        }

                        private setupPivotInfo(): void {
                            for (var col: number = 0; col < this.numCols; col++) {
                                this.pivots[col] = col;
                                var norm: number = 0;
                                for (var row: number = 0; row < this.numRows; row++) {
                                    var element: number = this.dataQR.get(row, col);
                                    norm += element * element;
                                }
                                this.normsCol[col] = norm;
                            }
                        }

                        private updateNorms(j: number): void {
                            var foundNegative: boolean = false;
                            for (var col: number = j; col < this.numCols; col++) {
                                var e: number = this.dataQR.get(j - 1, col);
                                this.normsCol[col] -= e * e;
                                if (this.normsCol[col] < 0) {
                                    foundNegative = true;
                                    break;
                                }
                            }
                            if (foundNegative) {
                                for (var col: number = j; col < this.numCols; col++) {
                                    var actual: number = 0;
                                    for (var i: number = j; i < this.numRows; i++) {
                                        var v: number = this.dataQR.get(i, col);
                                        actual += v * v;
                                    }
                                    this.normsCol[col] = actual;
                                }
                            }
                        }

                        private swapColumns(j: number): void {
                            var largestIndex: number = j;
                            var largestNorm: number = this.normsCol[j];
                            for (var col: number = j + 1; col < this.numCols; col++) {
                                var n: number = this.normsCol[col];
                                if (n > largestNorm) {
                                    largestNorm = n;
                                    largestIndex = col;
                                }
                            }
                            var val: number = 0;
                            for (var k: number = 0; k < this.dataQR.rows(); k++) {
                                val = this.dataQR.get(k, j);
                                this.dataQR.set(k, j, this.dataQR.get(k, largestIndex));
                                this.dataQR.set(k, largestIndex, val);
                            }
                            var tempN: number = this.normsCol[j];
                            this.normsCol[j] = this.normsCol[largestIndex];
                            this.normsCol[largestIndex] = tempN;
                            var tempP: number = this.pivots[j];
                            this.pivots[j] = this.pivots[largestIndex];
                            this.pivots[largestIndex] = tempP;
                        }

                        public householderPivot(j: number): boolean {
                            var max: number = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMaxArray(this.dataQR, j, j, this.numRows - j);
                            if (max <= 0) {
                                return false;
                            } else {
                                this.tau = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4argArray(j, this.numRows, this.dataQR, j, max);
                                var u_0: number = this.dataQR.get(j, j) + this.tau;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements4argArray(j + 1, this.numRows, this.dataQR, j, u_0);
                                this.gamma = u_0 / this.tau;
                                this.tau *= max;
                                this.dataQR.set(j, j, -this.tau);
                                if (Math.abs(this.tau) <= this.singularThreshold) {
                                    return false;
                                }
                            }
                            this.gammas[j] = this.gamma;
                            return true;
                        }

                        public getRank(): number {
                            return this.rank;
                        }

                        public getPivots(): Int32Array {
                            return this.pivots;
                        }

                        public getPivotMatrix(P: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                            if (P == null) {
                                P = new util.maths.matrix.DenseMatrix64F(this.numCols, this.numCols);
                            } else {
                                if (P.numRows != this.numCols) {
                                    throw new Error("Number of rows must be " + this.numCols);
                                } else {
                                    if (P.numCols != this.numCols) {
                                        throw new Error("Number of columns must be " + this.numCols);
                                    } else {
                                        P.zero();
                                    }
                                }
                            }
                            for (var i: number = 0; i < this.numCols; i++) {
                                P.set(this.pivots[i], i, 1);
                            }
                            return P;
                        }

                    }

                    export class QrHelperFunctions_D64 {

                        public static findMax(u: Float64Array, startU: number, length: number): number {
                            var max: number = -1;
                            var index: number = startU;
                            var stopIndex: number = startU + length;
                            for (; index < stopIndex; index++) {
                                var val: number = u[index];
                                val = (val < 0.0) ? -val : val;
                                if (val > max) {
                                    max = val;
                                }
                            }
                            return max;
                        }

                        public static findMaxArray(u: util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                            var max: number = -1;
                            var index: number = startU;
                            var stopIndex: number = startU + length;
                            for (; index < stopIndex; index++) {
                                var val: number = u.get(index, col);
                                val = (val < 0.0) ? -val : val;
                                if (val > max) {
                                    max = val;
                                }
                            }
                            return max;
                        }

                        public static divideElements4arg(j: number, numRows: number, u: Float64Array, u_0: number): void {
                            for (var i: number = j; i < numRows; i++) {
                                u[i] /= u_0;
                            }
                        }

                        public static divideElements4argArray(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, u_0: number): void {
                            for (var i: number = j; i < numRows; i++) {
                                u.set(i, col, u.get(i, col) / u_0);
                            }
                        }

                        public static divideElements(j: number, numRows: number, u: Float64Array, startU: number, u_0: number): void {
                            for (var i: number = j; i < numRows; i++) {
                                u[i + startU] /= u_0;
                            }
                        }

                        public static divideElements_Brow(j: number, numRows: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                            for (var i: number = j; i < numRows; i++) {
                                u[i] = b[i + startB] /= u_0;
                            }
                        }

                        public static divideElements_Bcol(j: number, numRows: number, numCols: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                            var indexB: number = j * numCols + startB;
                            for (var i: number = j; i < numRows; i++) {
                                b[indexB] = u[i] /= u_0;
                                indexB += numCols;
                            }
                        }

                        public static computeTauAndDivide(j: number, numRows: number, u: Float64Array, startU: number, max: number): number {
                            var tau: number = 0;
                            for (var i: number = j; i < numRows; i++) {
                                var d: number = u[startU + i] /= max;
                                tau += d * d;
                            }
                            tau = Math.sqrt(tau);
                            if (u[startU + j] < 0) {
                                tau = -tau;
                            }
                            return tau;
                        }

                        public static computeTauAndDivide4arg(j: number, numRows: number, u: Float64Array, max: number): number {
                            var tau: number = 0;
                            for (var i: number = j; i < numRows; i++) {
                                var d: number = u[i] /= max;
                                tau += d * d;
                            }
                            tau = Math.sqrt(tau);
                            if (u[j] < 0) {
                                tau = -tau;
                            }
                            return tau;
                        }

                        public static computeTauAndDivide4argArray(j: number, numRows: number, u: util.maths.structure.KArray2D, col: number, max: number): number {
                            var tau: number = 0;
                            for (var i: number = j; i < numRows; i++) {
                                u.set(i, col, u.get(i, col) / max);
                                var d: number = u.get(i, col);
                                tau += d * d;
                            }
                            tau = Math.sqrt(tau);
                            if (u.get(j, col) < 0) {
                                tau = -tau;
                            }
                            return tau;
                        }

                        public static rank1UpdateMultR(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] = u[w0] * A.data[w0 * A.numCols + i];
                            }
                            for (var k: number = w0 + 1; k < w1; k++) {
                                var indexA: number = k * A.numCols + colA0;
                                var valU: number = u[k];
                                for (var i: number = colA0; i < A.numCols; i++) {
                                    _temp[i] += valU * A.data[indexA++];
                                }
                            }
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] *= gamma;
                            }
                            for (var i: number = w0; i < w1; i++) {
                                var valU: number = u[i];
                                var indexA: number = i * A.numCols + colA0;
                                for (var j: number = colA0; j < A.numCols; j++) {
                                    A.data[indexA++] -= valU * _temp[j];
                                }
                            }
                        }

                        public static rank1UpdateMultRArray(A: util.maths.matrix.DenseMatrix64F, u: util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                            }
                            for (var k: number = w0 + 1; k < w1; k++) {
                                var indexA: number = k * A.numCols + colA0;
                                var valU: number = u.get(k, col);
                                for (var i: number = colA0; i < A.numCols; i++) {
                                    _temp[i] += valU * A.data[indexA++];
                                }
                            }
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] *= gamma;
                            }
                            for (var i: number = w0; i < w1; i++) {
                                var valU: number = u.get(i, col);
                                var indexA: number = i * A.numCols + colA0;
                                for (var j: number = colA0; j < A.numCols; j++) {
                                    A.data[indexA++] -= valU * _temp[j];
                                }
                            }
                        }

                        public static rank1UpdateMultR8param(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, offsetU: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] = u[w0 + offsetU] * A.data[w0 * A.numCols + i];
                            }
                            for (var k: number = w0 + 1; k < w1; k++) {
                                var indexA: number = k * A.numCols + colA0;
                                var valU: number = u[k + offsetU];
                                for (var i: number = colA0; i < A.numCols; i++) {
                                    _temp[i] += valU * A.data[indexA++];
                                }
                            }
                            for (var i: number = colA0; i < A.numCols; i++) {
                                _temp[i] *= gamma;
                            }
                            for (var i: number = w0; i < w1; i++) {
                                var valU: number = u[i + offsetU];
                                var indexA: number = i * A.numCols + colA0;
                                for (var j: number = colA0; j < A.numCols; j++) {
                                    A.data[indexA++] -= valU * _temp[j];
                                }
                            }
                        }

                        public static rank1UpdateMultL(A: util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number): void {
                            for (var i: number = colA0; i < A.numRows; i++) {
                                var startIndex: number = i * A.numCols + w0;
                                var sum: number = 0;
                                var rowIndex: number = startIndex;
                                for (var j: number = w0; j < w1; j++) {
                                    sum += A.data[rowIndex++] * u[j];
                                }
                                sum = -gamma * sum;
                                rowIndex = startIndex;
                                for (var j: number = w0; j < w1; j++) {
                                    A.data[rowIndex++] += sum * u[j];
                                }
                            }
                        }

                    }

                    export class SwitchingEigenDecomposition {

                        private tol: number;
                        public symmetricAlg: util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64;
                        public generalAlg: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64;
                        public symmetric: boolean;
                        public computeVectors: boolean;
                        public A: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(1, 1);
                        constructor(matrixSize: number, computeVectors: boolean, tol: number) {
                            var decomp: util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64 = new util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64();
                            this.symmetricAlg = new util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64(decomp, computeVectors);
                            this.generalAlg = new util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64(computeVectors);
                            this.computeVectors = computeVectors;
                            this.tol = tol;
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.symmetric ? this.symmetricAlg.getNumberOfEigenvalues() : this.generalAlg.getNumberOfEigenvalues();
                        }

                        public getEigenvalue(index: number): util.maths.matrix.Complex64F {
                            return this.symmetric ? this.symmetricAlg.getEigenvalue(index) : this.generalAlg.getEigenvalue(index);
                        }

                        public getEigenVector(index: number): util.maths.matrix.DenseMatrix64F {
                            if (!this.computeVectors) {
                                throw new Error("Configured to not compute eignevectors");
                            }
                            return this.symmetric ? this.symmetricAlg.getEigenVector(index) : this.generalAlg.getEigenVector(index);
                        }

                        public decompose(orig: util.maths.matrix.DenseMatrix64F): boolean {
                            this.A.setMatrix(orig);
                            this.symmetric = util.maths.matrix.MatrixFeatures.isSymmetricDouble(this.A, this.tol);
                            return this.symmetric ? this.symmetricAlg.decompose(this.A) : this.generalAlg.decompose(this.A);
                        }

                        public inputModified(): boolean {
                            return false;
                        }

                    }

                    export class SymmetricQRAlgorithmDecomposition_D64 {

                        private decomp: util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64;
                        private helper: util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                        private vector: util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm;
                        private computeVectorsWithValues: boolean = false;
                        private values: Float64Array;
                        private diag: Float64Array;
                        private off: Float64Array;
                        private diagSaved: Float64Array;
                        private offSaved: Float64Array;
                        private V: util.maths.matrix.DenseMatrix64F;
                        private eigenvectors: util.maths.matrix.DenseMatrix64F[];
                        public computeVectors: boolean;
                        constructor(decomp: util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64, computeVectors: boolean) {
                            this.decomp = decomp;
                            this.computeVectors = computeVectors;
                            this.helper = new util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper();
                            this.vector = new util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm(this.helper);
                        }

                        public setComputeVectorsWithValues(computeVectorsWithValues: boolean): void {
                            if (!this.computeVectors) {
                                throw new Error("Compute eigenvalues has been set to false");
                            }
                            this.computeVectorsWithValues = computeVectorsWithValues;
                        }

                        public setMaxIterations(max: number): void {
                            this.vector.setMaxIterations(max);
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.helper.getMatrixSize();
                        }

                        public getEigenvalue(index: number): util.maths.matrix.Complex64F {
                            var c: util.maths.matrix.Complex64F = new util.maths.matrix.Complex64F();
                            c.setValues(this.values[index], 0);
                            return c;
                        }

                        public getEigenVector(index: number): util.maths.matrix.DenseMatrix64F {
                            return this.eigenvectors[index];
                        }

                        public decompose(orig: util.maths.matrix.DenseMatrix64F): boolean {
                            if (orig.numCols != orig.numRows) {
                                throw new Error("Matrix must be square.");
                            }
                            if (orig.numCols <= 0) {
                                return false;
                            }
                            var N: number = orig.numRows;
                            if (!this.decomp.decompose(orig)) {
                                return false;
                            }
                            if (this.diag == null || this.diag.length < N) {
                                this.diag = new Float64Array(N);
                                this.off = new Float64Array(N - 1);
                            }
                            this.decomp.getDiagonal(this.diag, this.off);
                            this.helper.init(this.diag, this.off, N);
                            if (this.computeVectors) {
                                if (this.computeVectorsWithValues) {
                                    return this.extractTogether();
                                } else {
                                    return this.extractSeparate(N);
                                }
                            } else {
                                return this.computeEigenValues();
                            }
                        }

                        public inputModified(): boolean {
                            return this.decomp.inputModified();
                        }

                        private extractTogether(): boolean {
                            this.V = this.decomp.getQ(this.V, true);
                            this.helper.setQ(this.V);
                            this.vector.setFastEigenvalues(false);
                            if (!this.vector.process3arg(-1, null, null)) {
                                return false;
                            }
                            this.eigenvectors = util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                            this.values = this.helper.copyEigenvalues(this.values);
                            return true;
                        }

                        private extractSeparate(numCols: number): boolean {
                            if (!this.computeEigenValues()) {
                                return false;
                            }
                            this.helper.reset(numCols);
                            this.diagSaved = this.helper.swapDiag(this.diagSaved);
                            this.offSaved = this.helper.swapOff(this.offSaved);
                            this.V = this.decomp.getQ(this.V, true);
                            this.vector.setQ(this.V);
                            if (!this.vector.process(-1, null, null, this.values)) {
                                return false;
                            }
                            this.values = this.helper.copyEigenvalues(this.values);
                            this.eigenvectors = util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                            return true;
                        }

                        private computeEigenValues(): boolean {
                            this.diagSaved = this.helper.copyDiag(this.diagSaved);
                            this.offSaved = this.helper.copyOff(this.offSaved);
                            this.vector.setQ(null);
                            this.vector.setFastEigenvalues(true);
                            if (!this.vector.process3arg(-1, null, null)) {
                                return false;
                            }
                            this.values = this.helper.copyEigenvalues(this.values);
                            return true;
                        }

                    }

                    export class SymmetricQREigenHelper {

                        public rand: java.util.Random = new java.util.Random();
                        public steps: number;
                        public numExceptional: number;
                        public lastExceptional: number;
                        public eigenSmall: util.maths.matrix.solvers.decomposition.EigenvalueSmall = new util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                        public Q: util.maths.matrix.DenseMatrix64F;
                        public N: number;
                        public diag: Float64Array;
                        public off: Float64Array;
                        public x1: number;
                        public x2: number;
                        public splits: Int32Array;
                        public numSplits: number;
                        private bulge: number;
                        private c: number;
                        private s: number;
                        private c2: number;
                        private s2: number;
                        private cs: number;
                        constructor() {
                            this.splits = new Int32Array(1);
                        }

                        public setQ(q: util.maths.matrix.DenseMatrix64F): void {
                            this.Q = q;
                        }

                        public incrementSteps(): void {
                            this.steps++;
                        }

                        public init(diag: Float64Array, off: Float64Array, numCols: number): void {
                            this.reset(numCols);
                            this.diag = diag;
                            this.off = off;
                        }

                        public swapDiag(diag: Float64Array): Float64Array {
                            var ret: Float64Array = this.diag;
                            this.diag = diag;
                            return ret;
                        }

                        public swapOff(off: Float64Array): Float64Array {
                            var ret: Float64Array = this.off;
                            this.off = off;
                            return ret;
                        }

                        public reset(N: number): void {
                            this.N = N;
                            this.diag = null;
                            this.off = null;
                            if (this.splits.length < N) {
                                this.splits = new Int32Array(N);
                            }
                            this.numSplits = 0;
                            this.x1 = 0;
                            this.x2 = N - 1;
                            this.steps = this.numExceptional = this.lastExceptional = 0;
                            this.Q = null;
                        }

                        public copyDiag(ret: Float64Array): Float64Array {
                            if (ret == null || ret.length < this.N) {
                                ret = new Float64Array(this.N);
                            }
                            java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                            return ret;
                        }

                        public copyOff(ret: Float64Array): Float64Array {
                            if (ret == null || ret.length < this.N - 1) {
                                ret = new Float64Array(this.N - 1);
                            }
                            java.lang.System.arraycopy(this.off, 0, ret, 0, this.N - 1);
                            return ret;
                        }

                        public copyEigenvalues(ret: Float64Array): Float64Array {
                            if (ret == null || ret.length < this.N) {
                                ret = new Float64Array(this.N);
                            }
                            java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                            return ret;
                        }

                        public setSubmatrix(x1: number, x2: number): void {
                            this.x1 = x1;
                            this.x2 = x2;
                        }

                        public isZero(index: number): boolean {
                            var bottom: number = Math.abs(this.diag[index]) + Math.abs(this.diag[index + 1]);
                            return (Math.abs(this.off[index]) <= bottom * util.maths.matrix.CommonOps.EPS);
                        }

                        public performImplicitSingleStep(lambda: number, byAngle: boolean): void {
                            if (this.x2 - this.x1 == 1) {
                                this.createBulge2by2(this.x1, lambda, byAngle);
                            } else {
                                this.createBulge(this.x1, lambda, byAngle);
                                for (var i: number = this.x1; i < this.x2 - 2 && this.bulge != 0.0; i++) {
                                    this.removeBulge(i);
                                }
                                if (this.bulge != 0.0) {
                                    this.removeBulgeEnd(this.x2 - 2);
                                }
                            }
                        }

                        public updateQ(m: number, n: number, c: number, s: number): void {
                            var rowA: number = m * this.N;
                            var rowB: number = n * this.N;
                            var endA: number = rowA + this.N;
                            while (rowA < endA){
                                var a: number = this.Q.data[rowA];
                                var b: number = this.Q.data[rowB];
                                this.Q.data[rowA++] = c * a + s * b;
                                this.Q.data[rowB++] = -s * a + c * b;
                            }
                        }

                        public createBulge(x1: number, p: number, byAngle: boolean): void {
                            var a11: number = this.diag[x1];
                            var a22: number = this.diag[x1 + 1];
                            var a12: number = this.off[x1];
                            var a23: number = this.off[x1 + 1];
                            if (byAngle) {
                                this.c = Math.cos(p);
                                this.s = Math.sin(p);
                                this.c2 = this.c * this.c;
                                this.s2 = this.s * this.s;
                                this.cs = this.c * this.s;
                            } else {
                                this.computeRotation(a11 - p, a12);
                            }
                            this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                            this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                            this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                            this.off[x1 + 1] = this.c * a23;
                            this.bulge = this.s * a23;
                            if (this.Q != null) {
                                this.updateQ(x1, x1 + 1, this.c, this.s);
                            }
                        }

                        public createBulge2by2(x1: number, p: number, byAngle: boolean): void {
                            var a11: number = this.diag[x1];
                            var a22: number = this.diag[x1 + 1];
                            var a12: number = this.off[x1];
                            if (byAngle) {
                                this.c = Math.cos(p);
                                this.s = Math.sin(p);
                                this.c2 = this.c * this.c;
                                this.s2 = this.s * this.s;
                                this.cs = this.c * this.s;
                            } else {
                                this.computeRotation(a11 - p, a12);
                            }
                            this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                            this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                            this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                            if (this.Q != null) {
                                this.updateQ(x1, x1 + 1, this.c, this.s);
                            }
                        }

                        private computeRotation(run: number, rise: number): void {
                            if (Math.abs(rise) > Math.abs(run)) {
                                var k: number = run / rise;
                                var bottom: number = 1.0 + k * k;
                                var bottom_sq: number = Math.sqrt(bottom);
                                this.s2 = 1.0 / bottom;
                                this.c2 = k * k / bottom;
                                this.cs = k / bottom;
                                this.s = 1.0 / bottom_sq;
                                this.c = k / bottom_sq;
                            } else {
                                var t: number = rise / run;
                                var bottom: number = 1.0 + t * t;
                                var bottom_sq: number = Math.sqrt(bottom);
                                this.c2 = 1.0 / bottom;
                                this.s2 = t * t / bottom;
                                this.cs = t / bottom;
                                this.c = 1.0 / bottom_sq;
                                this.s = t / bottom_sq;
                            }
                        }

                        public removeBulge(x1: number): void {
                            var a22: number = this.diag[x1 + 1];
                            var a33: number = this.diag[x1 + 2];
                            var a12: number = this.off[x1];
                            var a23: number = this.off[x1 + 1];
                            var a34: number = this.off[x1 + 2];
                            this.computeRotation(a12, this.bulge);
                            this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                            this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                            this.off[x1] = this.c * a12 + this.s * this.bulge;
                            this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                            this.off[x1 + 2] = this.c * a34;
                            this.bulge = this.s * a34;
                            if (this.Q != null) {
                                this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                            }
                        }

                        public removeBulgeEnd(x1: number): void {
                            var a22: number = this.diag[x1 + 1];
                            var a12: number = this.off[x1];
                            var a23: number = this.off[x1 + 1];
                            var a33: number = this.diag[x1 + 2];
                            this.computeRotation(a12, this.bulge);
                            this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                            this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                            this.off[x1] = this.c * a12 + this.s * this.bulge;
                            this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                            if (this.Q != null) {
                                this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                            }
                        }

                        public eigenvalue2by2(x1: number): void {
                            var a: number = this.diag[x1];
                            var b: number = this.off[x1];
                            var c: number = this.diag[x1 + 1];
                            var absA: number = Math.abs(a);
                            var absB: number = Math.abs(b);
                            var absC: number = Math.abs(c);
                            var scale: number = absA > absB ? absA : absB;
                            if (absC > scale) {
                                scale = absC;
                            }
                            if (scale == 0) {
                                this.off[x1] = 0;
                                this.diag[x1] = 0;
                                this.diag[x1 + 1] = 0;
                                return;
                            }
                            a /= scale;
                            b /= scale;
                            c /= scale;
                            this.eigenSmall.symm2x2_fast(a, b, c);
                            this.off[x1] = 0;
                            this.diag[x1] = scale * this.eigenSmall.value0.real;
                            this.diag[x1 + 1] = scale * this.eigenSmall.value1.real;
                        }

                        public exceptionalShift(): void {
                            this.numExceptional++;
                            var mag: number = 0.05 * this.numExceptional;
                            if (mag > 1.0) {
                                mag = 1.0;
                            }
                            var theta: number = 2.0 * (this.rand.nextDouble() - 0.5) * mag;
                            this.performImplicitSingleStep(theta, true);
                            this.lastExceptional = this.steps;
                        }

                        public nextSplit(): boolean {
                            if (this.numSplits == 0) {
                                return false;
                            }
                            this.x2 = this.splits[--this.numSplits];
                            if (this.numSplits > 0) {
                                this.x1 = this.splits[this.numSplits - 1] + 1;
                            } else {
                                this.x1 = 0;
                            }
                            return true;
                        }

                        public computeShift(): number {
                            if (this.x2 - this.x1 >= 1) {
                                return this.computeWilkinsonShift();
                            } else {
                                return this.diag[this.x2];
                            }
                        }

                        public computeWilkinsonShift(): number {
                            var a: number = this.diag[this.x2 - 1];
                            var b: number = this.off[this.x2 - 1];
                            var c: number = this.diag[this.x2];
                            var absA: number = Math.abs(a);
                            var absB: number = Math.abs(b);
                            var absC: number = Math.abs(c);
                            var scale: number = absA > absB ? absA : absB;
                            if (absC > scale) {
                                scale = absC;
                            }
                            if (scale == 0) {
                                throw new Error("this should never happen");
                            }
                            a /= scale;
                            b /= scale;
                            c /= scale;
                            this.eigenSmall.symm2x2_fast(a, b, c);
                            var diff0: number = Math.abs(this.eigenSmall.value0.real - c);
                            var diff1: number = Math.abs(this.eigenSmall.value1.real - c);
                            if (diff0 < diff1) {
                                return scale * this.eigenSmall.value0.real;
                            } else {
                                return scale * this.eigenSmall.value1.real;
                            }
                        }

                        public getMatrixSize(): number {
                            return this.N;
                        }

                        public resetSteps(): void {
                            this.steps = 0;
                            this.lastExceptional = 0;
                        }

                    }

                    export class SymmetricQrAlgorithm {

                        private helper: util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                        private Q: util.maths.matrix.DenseMatrix64F;
                        private eigenvalues: Float64Array;
                        private exceptionalThresh: number = 15;
                        private maxIterations: number = this.exceptionalThresh * 15;
                        private fastEigenvalues: boolean;
                        private followingScript: boolean;
                        constructor(helper: util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper) {
                            this.helper = helper;
                        }

                        public setMaxIterations(maxIterations: number): void {
                            this.maxIterations = maxIterations;
                        }

                        public getQ(): util.maths.matrix.DenseMatrix64F {
                            return this.Q;
                        }

                        public setQ(q: util.maths.matrix.DenseMatrix64F): void {
                            this.Q = q;
                        }

                        public setFastEigenvalues(fastEigenvalues: boolean): void {
                            this.fastEigenvalues = fastEigenvalues;
                        }

                        public getEigenvalue(index: number): number {
                            return this.helper.diag[index];
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.helper.N;
                        }

                        public process(sideLength: number, diag: Float64Array, off: Float64Array, eigenvalues: Float64Array): boolean {
                            if (diag != null) {
                                this.helper.init(diag, off, sideLength);
                            }
                            if (this.Q == null) {
                                this.Q = util.maths.matrix.CommonOps.identity1D(this.helper.N);
                            }
                            this.helper.setQ(this.Q);
                            this.followingScript = true;
                            this.eigenvalues = eigenvalues;
                            this.fastEigenvalues = false;
                            return this._process();
                        }

                        public process3arg(sideLength: number, diag: Float64Array, off: Float64Array): boolean {
                            if (diag != null) {
                                this.helper.init(diag, off, sideLength);
                            }
                            this.followingScript = false;
                            this.eigenvalues = null;
                            return this._process();
                        }

                        private _process(): boolean {
                            while (this.helper.x2 >= 0){
                                if (this.helper.steps > this.maxIterations) {
                                    return false;
                                }
                                if (this.helper.x1 == this.helper.x2) {
                                    this.helper.resetSteps();
                                    if (!this.helper.nextSplit()) {
                                        break;
                                    }
                                } else {
                                    if (this.fastEigenvalues && this.helper.x2 - this.helper.x1 == 1) {
                                        this.helper.resetSteps();
                                        this.helper.eigenvalue2by2(this.helper.x1);
                                        this.helper.setSubmatrix(this.helper.x2, this.helper.x2);
                                    } else {
                                        if (this.helper.steps - this.helper.lastExceptional > this.exceptionalThresh) {
                                            this.helper.exceptionalShift();
                                        } else {
                                            this.performStep();
                                        }
                                    }
                                }
                                this.helper.incrementSteps();
                            }
                            return true;
                        }

                        public performStep(): void {
                            for (var i: number = this.helper.x2 - 1; i >= this.helper.x1; i--) {
                                if (this.helper.isZero(i)) {
                                    this.helper.splits[this.helper.numSplits++] = i;
                                    this.helper.x1 = i + 1;
                                    return;
                                }
                            }
                            var lambda: number;
                            if (this.followingScript) {
                                if (this.helper.steps > 10) {
                                    this.followingScript = false;
                                    return;
                                } else {
                                    lambda = this.eigenvalues[this.helper.x2];
                                }
                            } else {
                                lambda = this.helper.computeShift();
                            }
                            this.helper.performImplicitSingleStep(lambda, false);
                        }

                    }

                    export class TridiagonalDecompositionHouseholder_D64 {

                        private QT: util.maths.matrix.DenseMatrix64F;
                        private N: number;
                        private w: Float64Array;
                        private gammas: Float64Array;
                        private b: Float64Array;
                        constructor() {
                            this.N = 1;
                            this.w = new Float64Array(this.N);
                            this.b = new Float64Array(this.N);
                            this.gammas = new Float64Array(this.N);
                        }

                        public getQT(): util.maths.matrix.DenseMatrix64F {
                            return this.QT;
                        }

                        public getDiagonal(diag: Float64Array, off: Float64Array): void {
                            for (var i: number = 0; i < this.N; i++) {
                                diag[i] = this.QT.data[i * this.N + i];
                                if (i + 1 < this.N) {
                                    off[i] = this.QT.data[i * this.N + i + 1];
                                }
                            }
                        }

                        public getT(T: util.maths.matrix.DenseMatrix64F): util.maths.matrix.DenseMatrix64F {
                            if (T == null) {
                                T = new util.maths.matrix.DenseMatrix64F(this.N, this.N);
                            } else {
                                if (this.N != T.numRows || this.N != T.numCols) {
                                    throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                } else {
                                    T.zero();
                                }
                            }
                            T.data[0] = this.QT.data[0];
                            for (var i: number = 1; i < this.N; i++) {
                                T.set(i, i, this.QT.get(i, i));
                                var a: number = this.QT.get(i - 1, i);
                                T.set(i - 1, i, a);
                                T.set(i, i - 1, a);
                            }
                            if (this.N > 1) {
                                T.data[(this.N - 1) * this.N + this.N - 1] = this.QT.data[(this.N - 1) * this.N + this.N - 1];
                                T.data[(this.N - 1) * this.N + this.N - 2] = this.QT.data[(this.N - 2) * this.N + this.N - 1];
                            }
                            return T;
                        }

                        public getQ(Q: util.maths.matrix.DenseMatrix64F, transposed: boolean): util.maths.matrix.DenseMatrix64F {
                            if (Q == null) {
                                Q = util.maths.matrix.CommonOps.identity1D(this.N);
                            } else {
                                if (this.N != Q.numRows || this.N != Q.numCols) {
                                    throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                } else {
                                    util.maths.matrix.CommonOps.setIdentity(Q);
                                }
                            }
                            for (var i: number = 0; i < this.N; i++) {
                                this.w[i] = 0;
                            }
                            if (transposed) {
                                for (var j: number = this.N - 2; j >= 0; j--) {
                                    this.w[j + 1] = 1;
                                    for (var i: number = j + 2; i < this.N; i++) {
                                        this.w[i] = this.QT.data[j * this.N + i];
                                    }
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N);
                                }
                            } else {
                                for (var j: number = this.N - 2; j >= 0; j--) {
                                    this.w[j + 1] = 1;
                                    for (var i: number = j + 2; i < this.N; i++) {
                                        this.w[i] = this.QT.get(j, i);
                                    }
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N, this.b);
                                }
                            }
                            return Q;
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            this.init(A);
                            for (var k: number = 1; k < this.N; k++) {
                                this.similarTransform(k);
                            }
                            return true;
                        }

                        private similarTransform(k: number): void {
                            var t: Float64Array = this.QT.data;
                            var max: number = 0;
                            var rowU: number = (k - 1) * this.N;
                            for (var i: number = k; i < this.N; i++) {
                                var val: number = Math.abs(t[rowU + i]);
                                if (val > max) {
                                    max = val;
                                }
                            }
                            if (max > 0) {
                                var tau: number = util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k, this.N, t, rowU, max);
                                var nu: number = t[rowU + k] + tau;
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements(k + 1, this.N, t, rowU, nu);
                                t[rowU + k] = 1.0;
                                var gamma: number = nu / tau;
                                this.gammas[k] = gamma;
                                this.householderSymmetric(k, gamma);
                                t[rowU + k] = -tau * max;
                            } else {
                                this.gammas[k] = 0;
                            }
                        }

                        public householderSymmetric(row: number, gamma: number): void {
                            var startU: number = (row - 1) * this.N;
                            for (var i: number = row; i < this.N; i++) {
                                var total: number = 0;
                                for (var j: number = row; j < i; j++) {
                                    total += this.QT.data[j * this.N + i] * this.QT.data[startU + j];
                                }
                                for (var j: number = i; j < this.N; j++) {
                                    total += this.QT.data[i * this.N + j] * this.QT.data[startU + j];
                                }
                                this.w[i] = -gamma * total;
                            }
                            var alpha: number = 0;
                            for (var i: number = row; i < this.N; i++) {
                                alpha += this.QT.data[startU + i] * this.w[i];
                            }
                            alpha *= -0.5 * gamma;
                            for (var i: number = row; i < this.N; i++) {
                                this.w[i] += alpha * this.QT.data[startU + i];
                            }
                            for (var i: number = row; i < this.N; i++) {
                                var ww: number = this.w[i];
                                var uu: number = this.QT.data[startU + i];
                                var rowA: number = i * this.N;
                                for (var j: number = i; j < this.N; j++) {
                                    this.QT.data[rowA + j] += ww * this.QT.data[startU + j] + this.w[j] * uu;
                                }
                            }
                        }

                        public init(A: util.maths.matrix.DenseMatrix64F): void {
                            if (A.numRows != A.numCols) {
                                throw new Error("Must be square");
                            }
                            if (A.numCols != this.N) {
                                this.N = A.numCols;
                                if (this.w.length < this.N) {
                                    this.w = new Float64Array(this.N);
                                    this.gammas = new Float64Array(this.N);
                                    this.b = new Float64Array(this.N);
                                }
                            }
                            this.QT = A;
                        }

                        public inputModified(): boolean {
                            return true;
                        }

                    }

                    export class WatchedDoubleStepQRDecomposition_D64 {

                        public hessenberg: util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64;
                        public algValue: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue;
                        public algVector: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector;
                        public H: util.maths.matrix.DenseMatrix64F;
                        public computeVectors: boolean;
                        constructor(computeVectors: boolean) {
                            this.hessenberg = new util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64(10);
                            this.algValue = new util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue();
                            this.algVector = new util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector();
                            this.computeVectors = computeVectors;
                        }

                        public decompose(A: util.maths.matrix.DenseMatrix64F): boolean {
                            if (!this.hessenberg.decompose(A)) {
                                return false;
                            }
                            this.H = this.hessenberg.getH(null);
                            this.algValue.getImplicitQR().createR = false;
                            if (!this.algValue.process(this.H)) {
                                return false;
                            }
                            this.algValue.getImplicitQR().createR = true;
                            if (this.computeVectors) {
                                return this.algVector.process(this.algValue.getImplicitQR(), this.H, this.hessenberg.getQ(null));
                            } else {
                                return true;
                            }
                        }

                        public inputModified(): boolean {
                            return this.hessenberg.inputModified();
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.algValue.getEigenvalues().length;
                        }

                        public getEigenvalue(index: number): util.maths.matrix.Complex64F {
                            return this.algValue.getEigenvalues()[index];
                        }

                        public getEigenVector(index: number): util.maths.matrix.DenseMatrix64F {
                            return this.algVector.getEigenvectors()[index];
                        }

                    }

                    export class WatchedDoubleStepQREigen {

                        private rand: java.util.Random = new java.util.Random();
                        private N: number;
                        public A: util.maths.matrix.DenseMatrix64F;
                        private u: util.maths.matrix.DenseMatrix64F;
                        private gamma: number;
                        private _temp: util.maths.matrix.DenseMatrix64F;
                        public numStepsFind: Int32Array;
                        public steps: number;
                        public eigenvalues: util.maths.matrix.Complex64F[];
                        public numEigen: number;
                        private valueSmall: util.maths.matrix.solvers.decomposition.EigenvalueSmall = new util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                        private temp: Float64Array = new Float64Array(9);
                        private printHumps: boolean = false;
                        public checkHessenberg: boolean = false;
                        private checkOrthogonal: boolean = false;
                        private checkUncountable: boolean = false;
                        private useStandardEq: boolean = false;
                        private useCareful2x2: boolean = true;
                        private normalize: boolean = true;
                        public lastExceptional: number;
                        public numExceptional: number;
                        public exceptionalThreshold: number = 20;
                        public maxIterations: number = this.exceptionalThreshold * 20;
                        public createR: boolean = true;
                        public Q: util.maths.matrix.DenseMatrix64F;
                        public incrementSteps(): void {
                            this.steps++;
                        }

                        public setQ(Q: util.maths.matrix.DenseMatrix64F): void {
                            this.Q = Q;
                        }

                        private addEigenvalue(v: number): void {
                            this.numStepsFind[this.numEigen] = this.steps;
                            this.eigenvalues[this.numEigen].setValues(v, 0);
                            this.numEigen++;
                            this.steps = 0;
                            this.lastExceptional = 0;
                        }

                        private addEigenvalue2arg(v: number, i: number): void {
                            this.numStepsFind[this.numEigen] = this.steps;
                            this.eigenvalues[this.numEigen].setValues(v, i);
                            this.numEigen++;
                            this.steps = 0;
                            this.lastExceptional = 0;
                        }

                        public setChecks(hessenberg: boolean, orthogonal: boolean, uncountable: boolean): void {
                            this.checkHessenberg = hessenberg;
                            this.checkOrthogonal = orthogonal;
                            this.checkUncountable = uncountable;
                        }

                        public isZero(x1: number, x2: number): boolean {
                            var target: number = Math.abs(this.A.get(x1, x2));
                            var above: number = Math.abs(this.A.get(x1 - 1, x2));
                            var right: number = Math.abs(this.A.get(x1, x2 + 1));
                            return target <= 0.5 * util.maths.matrix.CommonOps.EPS * (above + right);
                        }

                        public setup(A: util.maths.matrix.DenseMatrix64F): void {
                            if (A.numRows != A.numCols) {
                                throw new Error("Must be square");
                            }
                            if (this.N != A.numRows) {
                                this.N = A.numRows;
                                this.A = A.copy();
                                this.u = new util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                                this._temp = new util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                                this.numStepsFind = new Int32Array(A.numRows);
                            } else {
                                this.A.setMatrix(A);
                            }
                            for (var i: number = 2; i < this.N; i++) {
                                for (var j: number = 0; j < i - 1; j++) {
                                    this.A.set(i, j, 0);
                                }
                            }
                            this.eigenvalues = new Array();
                            for (var i: number = 0; i < this.eigenvalues.length; i++) {
                                this.eigenvalues[i] = new util.maths.matrix.Complex64F();
                            }
                            this.numEigen = 0;
                            this.lastExceptional = 0;
                            this.numExceptional = 0;
                            this.steps = 0;
                        }

                        public exceptionalShift(x1: number, x2: number): void {
                            if (this.printHumps) {
                                console.log("Performing exceptional implicit double step");;
                            }
                            var val: number = Math.abs(this.A.get(x2, x2));
                            if (val == 0) {
                                val = 1;
                            }
                            this.numExceptional++;
                            var p: number = 1 - Math.pow(0.1, this.numExceptional);
                            val *= p + 2.0 * (1.0 - p) * (this.rand.nextDouble() - 0.5);
                            if (this.rand.nextBoolean()) {
                                val = -val;
                            }
                            this.performImplicitSingleStep(x1, x2, val);
                            this.lastExceptional = this.steps;
                        }

                        public implicitDoubleStep(x1: number, x2: number): void {
                            if (this.printHumps) {
                                console.log("Performing implicit double step");;
                            }
                            var z11: number = this.A.get(x2 - 1, x2 - 1);
                            var z12: number = this.A.get(x2 - 1, x2);
                            var z21: number = this.A.get(x2, x2 - 1);
                            var z22: number = this.A.get(x2, x2);
                            var a11: number = this.A.get(x1, x1);
                            var a21: number = this.A.get(x1 + 1, x1);
                            var a12: number = this.A.get(x1, x1 + 1);
                            var a22: number = this.A.get(x1 + 1, x1 + 1);
                            var a32: number = this.A.get(x1 + 2, x1 + 1);
                            if (this.normalize) {
                                this.temp[0] = a11;
                                this.temp[1] = a21;
                                this.temp[2] = a12;
                                this.temp[3] = a22;
                                this.temp[4] = a32;
                                this.temp[5] = z11;
                                this.temp[6] = z22;
                                this.temp[7] = z12;
                                this.temp[8] = z21;
                                var max: number = Math.abs(this.temp[0]);
                                for (var j: number = 1; j < this.temp.length; j++) {
                                    if (Math.abs(this.temp[j]) > max) {
                                        max = Math.abs(this.temp[j]);
                                    }
                                }
                                a11 /= max;
                                a21 /= max;
                                a12 /= max;
                                a22 /= max;
                                a32 /= max;
                                z11 /= max;
                                z22 /= max;
                                z12 /= max;
                                z21 /= max;
                            }
                            var b11: number, b21: number, b31: number;
                            if (this.useStandardEq) {
                                b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) / a21 + a12;
                                b21 = a11 + a22 - z11 - z22;
                                b31 = a32;
                            } else {
                                b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) + a12 * a21;
                                b21 = (a11 + a22 - z11 - z22) * a21;
                                b31 = a32 * a21;
                            }
                            this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                        }

                        public performImplicitDoubleStep(x1: number, x2: number, real: number, img: number): void {
                            var a11: number = this.A.get(x1, x1);
                            var a21: number = this.A.get(x1 + 1, x1);
                            var a12: number = this.A.get(x1, x1 + 1);
                            var a22: number = this.A.get(x1 + 1, x1 + 1);
                            var a32: number = this.A.get(x1 + 2, x1 + 1);
                            var p_plus_t: number = 2.0 * real;
                            var p_times_t: number = real * real + img * img;
                            var b11: number, b21: number, b31: number;
                            if (this.useStandardEq) {
                                b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) / a21 + a12;
                                b21 = a11 + a22 - p_plus_t;
                                b31 = a32;
                            } else {
                                b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) + a12 * a21;
                                b21 = (a11 + a22 - p_plus_t) * a21;
                                b31 = a32 * a21;
                            }
                            this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                        }

                        private performImplicitDoubleStep5arg(x1: number, x2: number, b11: number, b21: number, b31: number): void {
                            if (!this.bulgeDoubleStepQn6arg(x1, b11, b21, b31, 0, false)) {
                                return;
                            }
                            if (this.Q != null) {
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 3, this._temp.data);
                            }
                            for (var i: number = x1; i < x2 - 2; i++) {
                                if (this.bulgeDoubleStepQn(i) && this.Q != null) {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 4, this._temp.data);
                                }
                            }
                            if (x2 - 2 >= 0 && this.bulgeSingleStepQn(x2 - 2) && this.Q != null) {
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x2 - 1, x2 + 1, this._temp.data);
                            }
                        }

                        public performImplicitSingleStep(x1: number, x2: number, eigenvalue: number): void {
                            if (!this.createBulgeSingleStep(x1, eigenvalue)) {
                                return;
                            }
                            if (this.Q != null) {
                                util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 2, this._temp.data);
                            }
                            for (var i: number = x1; i < x2 - 1; i++) {
                                if (this.bulgeSingleStepQn(i) && this.Q != null) {
                                    util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 3, this._temp.data);
                                }
                            }
                        }

                        public createBulgeSingleStep(x1: number, eigenvalue: number): boolean {
                            var b11: number = this.A.get(x1, x1) - eigenvalue;
                            var b21: number = this.A.get(x1 + 1, x1);
                            var threshold: number = Math.abs(this.A.get(x1, x1)) * util.maths.matrix.CommonOps.EPS;
                            return this.bulgeSingleStepQn5arg(x1, b11, b21, threshold, false);
                        }

                        public bulgeDoubleStepQn(i: number): boolean {
                            var a11: number = this.A.get(i + 1, i);
                            var a21: number = this.A.get(i + 2, i);
                            var a31: number = this.A.get(i + 3, i);
                            var threshold: number = Math.abs(this.A.get(i, i)) * util.maths.matrix.CommonOps.EPS;
                            return this.bulgeDoubleStepQn6arg(i + 1, a11, a21, a31, threshold, true);
                        }

                        public bulgeDoubleStepQn6arg(i: number, a11: number, a21: number, a31: number, threshold: number, set: boolean): boolean {
                            var max: number;
                            if (this.normalize) {
                                var absA11: number = Math.abs(a11);
                                var absA21: number = Math.abs(a21);
                                var absA31: number = Math.abs(a31);
                                max = absA11 > absA21 ? absA11 : absA21;
                                if (absA31 > max) {
                                    max = absA31;
                                }
                                if (max <= threshold) {
                                    if (set) {
                                        this.A.set(i, i - 1, 0);
                                        this.A.set(i + 1, i - 1, 0);
                                        this.A.set(i + 2, i - 1, 0);
                                    }
                                    return false;
                                }
                                a11 /= max;
                                a21 /= max;
                                a31 /= max;
                            } else {
                                max = 1;
                            }
                            var tau: number = Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31);
                            if (a11 < 0) {
                                tau = -tau;
                            }
                            var div: number = a11 + tau;
                            this.u.set(i, 0, 1);
                            this.u.set(i + 1, 0, a21 / div);
                            this.u.set(i + 2, 0, a31 / div);
                            this.gamma = div / tau;
                            util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 3, this._temp.data);
                            if (set) {
                                this.A.set(i, i - 1, -max * tau);
                                this.A.set(i + 1, i - 1, 0);
                                this.A.set(i + 2, i - 1, 0);
                            }
                            util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 3);
                            return true;
                        }

                        public bulgeSingleStepQn(i: number): boolean {
                            var a11: number = this.A.get(i + 1, i);
                            var a21: number = this.A.get(i + 2, i);
                            var threshold: number = Math.abs(this.A.get(i, i)) * util.maths.matrix.CommonOps.EPS;
                            return this.bulgeSingleStepQn5arg(i + 1, a11, a21, threshold, true);
                        }

                        public bulgeSingleStepQn5arg(i: number, a11: number, a21: number, threshold: number, set: boolean): boolean {
                            var max: number;
                            if (this.normalize) {
                                max = Math.abs(a11);
                                if (max < Math.abs(a21)) {
                                    max = Math.abs(a21);
                                }
                                if (max <= threshold) {
                                    if (set) {
                                        this.A.set(i, i - 1, 0);
                                        this.A.set(i + 1, i - 1, 0);
                                    }
                                    return false;
                                }
                                a11 /= max;
                                a21 /= max;
                            } else {
                                max = 1;
                            }
                            var tau: number = Math.sqrt(a11 * a11 + a21 * a21);
                            if (a11 < 0) {
                                tau = -tau;
                            }
                            var div: number = a11 + tau;
                            this.u.set(i, 0, 1);
                            this.u.set(i + 1, 0, a21 / div);
                            this.gamma = div / tau;
                            util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 2, this._temp.data);
                            if (set) {
                                this.A.set(i, i - 1, -max * tau);
                                this.A.set(i + 1, i - 1, 0);
                            }
                            util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 2);
                            return true;
                        }

                        public eigen2by2_scale(a11: number, a12: number, a21: number, a22: number): void {
                            var abs11: number = Math.abs(a11);
                            var abs22: number = Math.abs(a22);
                            var abs12: number = Math.abs(a12);
                            var abs21: number = Math.abs(a21);
                            var max: number = abs11 > abs22 ? abs11 : abs22;
                            if (max < abs12) {
                                max = abs12;
                            }
                            if (max < abs21) {
                                max = abs21;
                            }
                            if (max == 0) {
                                this.valueSmall.value0.real = 0;
                                this.valueSmall.value0.imaginary = 0;
                                this.valueSmall.value1.real = 0;
                                this.valueSmall.value1.imaginary = 0;
                            } else {
                                a12 /= max;
                                a21 /= max;
                                a11 /= max;
                                a22 /= max;
                                if (this.useCareful2x2) {
                                    this.valueSmall.value2x2(a11, a12, a21, a22);
                                } else {
                                    this.valueSmall.value2x2_fast(a11, a12, a21, a22);
                                }
                                this.valueSmall.value0.real *= max;
                                this.valueSmall.value0.imaginary *= max;
                                this.valueSmall.value1.real *= max;
                                this.valueSmall.value1.imaginary *= max;
                            }
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.numEigen;
                        }

                        public getEigenvalues(): util.maths.matrix.Complex64F[] {
                            return this.eigenvalues;
                        }

                        public addComputedEigen2x2(x1: number, x2: number): void {
                            this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                            if (this.checkUncountable && (util.PrimitiveHelper.isNaN(this.valueSmall.value0.real) || util.PrimitiveHelper.isNaN(this.valueSmall.value1.real))) {
                                throw new Error("Uncountable");
                            }
                            this.addEigenvalue2arg(this.valueSmall.value0.real, this.valueSmall.value0.imaginary);
                            this.addEigenvalue2arg(this.valueSmall.value1.real, this.valueSmall.value1.imaginary);
                        }

                        public isReal2x2(x1: number, x2: number): boolean {
                            this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                            return this.valueSmall.value0.isReal();
                        }

                        public addEigenAt(x1: number): void {
                            this.addEigenvalue(this.A.get(x1, x1));
                        }

                        public printSteps(): void {
                            for (var i: number = 0; i < this.N; i++) {
                                console.log("Step[" + i + "] = " + this.numStepsFind[i]);;
                            }
                        }

                    }

                    export class WatchedDoubleStepQREigenvalue {

                        public implicitQR: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                        public splits: Int32Array;
                        public numSplits: number;
                        public x1: number;
                        public x2: number;
                        constructor() {
                            this.implicitQR = new util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen();
                        }

                        public setup(A: util.maths.matrix.DenseMatrix64F): void {
                            this.implicitQR.setup(A);
                            this.implicitQR.setQ(null);
                            this.splits = new Int32Array(A.numRows);
                            this.numSplits = 0;
                        }

                        public process(origA: util.maths.matrix.DenseMatrix64F): boolean {
                            this.setup(origA);
                            this.x1 = 0;
                            this.x2 = origA.numRows - 1;
                            while (this.implicitQR.numEigen < origA.numRows){
                                if (this.implicitQR.steps > this.implicitQR.maxIterations) {
                                    return false;
                                }
                                this.implicitQR.incrementSteps();
                                if (this.x2 < this.x1) {
                                    this.moveToNextSplit();
                                } else {
                                    if (this.x2 - this.x1 == 0) {
                                        this.implicitQR.addEigenAt(this.x1);
                                        this.x2--;
                                    } else {
                                        if (this.x2 - this.x1 == 1) {
                                            this.implicitQR.addComputedEigen2x2(this.x1, this.x2);
                                            this.x2 -= 2;
                                        } else {
                                            if (this.implicitQR.steps - this.implicitQR.lastExceptional > this.implicitQR.exceptionalThreshold) {
                                                if (util.PrimitiveHelper.isNaN(this.implicitQR.A.get(this.x2, this.x2))) {
                                                    return false;
                                                }
                                                this.implicitQR.exceptionalShift(this.x1, this.x2);
                                            } else {
                                                if (this.implicitQR.isZero(this.x2, this.x2 - 1)) {
                                                    this.implicitQR.addEigenAt(this.x2);
                                                    this.x2--;
                                                } else {
                                                    this.performIteration();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return true;
                        }

                        private moveToNextSplit(): void {
                            if (this.numSplits <= 0) {
                                throw new Error("bad");
                            }
                            this.x2 = this.splits[--this.numSplits];
                            if (this.numSplits > 0) {
                                this.x1 = this.splits[this.numSplits - 1] + 1;
                            } else {
                                this.x1 = 0;
                            }
                        }

                        private performIteration(): void {
                            var changed: boolean = false;
                            for (var i: number = this.x2; i > this.x1; i--) {
                                if (this.implicitQR.isZero(i, i - 1)) {
                                    this.x1 = i;
                                    this.splits[this.numSplits++] = i - 1;
                                    changed = true;
                                    break;
                                }
                            }
                            if (!changed) {
                                this.implicitQR.implicitDoubleStep(this.x1, this.x2);
                            }
                        }

                        public getNumberOfEigenvalues(): number {
                            return this.implicitQR.getNumberOfEigenvalues();
                        }

                        public getEigenvalues(): util.maths.matrix.Complex64F[] {
                            return this.implicitQR.getEigenvalues();
                        }

                        public getImplicitQR(): util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                            return this.implicitQR;
                        }

                    }

                    export class WatchedDoubleStepQREigenvector {

                        public implicit: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                        public Q: util.maths.matrix.DenseMatrix64F;
                        public eigenvectors: util.maths.matrix.DenseMatrix64F[];
                        public eigenvectorTemp: util.maths.matrix.DenseMatrix64F;
                        public solver: util.maths.matrix.solvers.LinearSolverLu_D64;
                        public origEigenvalues: util.maths.matrix.Complex64F[];
                        public N: number;
                        public splits: Int32Array;
                        public numSplits: number;
                        public x1: number;
                        public x2: number;
                        public indexVal: number;
                        public onscript: boolean;
                        public process(implicit: util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen, A: util.maths.matrix.DenseMatrix64F, Q_h: util.maths.matrix.DenseMatrix64F): boolean {
                            this.implicit = implicit;
                            if (this.N != A.numRows) {
                                this.N = A.numRows;
                                this.Q = new util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                this.splits = new Int32Array(this.N);
                                this.origEigenvalues = new Array();
                                this.eigenvectors = new Array();
                                this.eigenvectorTemp = new util.maths.matrix.DenseMatrix64F(this.N, 1);
                                this.solver = new util.maths.matrix.solvers.LinearSolverLu_D64(new util.maths.matrix.solvers.LUDecompositionAlt_D64());
                            } else {
                                this.eigenvectors = new Array();
                            }
                            java.lang.System.arraycopy(implicit.eigenvalues, 0, this.origEigenvalues, 0, this.N);
                            implicit.setup(A);
                            implicit.setQ(this.Q);
                            this.numSplits = 0;
                            this.onscript = true;
                            if (!this.findQandR()) {
                                return false;
                            }
                            return this.extractVectors(Q_h);
                        }

                        public extractVectors(Q_h: util.maths.matrix.DenseMatrix64F): boolean {
                            util.maths.matrix.CommonOps.memset(this.eigenvectorTemp.data, 0);
                            var triangular: boolean = true;
                            for (var i: number = 0; i < this.N; i++) {
                                var c: util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                                if (triangular && !c.isReal()) {
                                    triangular = false;
                                }
                                if (c.isReal() && this.eigenvectors[this.N - i - 1] == null) {
                                    this.solveEigenvectorDuplicateEigenvalue(c.real, i, triangular);
                                }
                            }
                            if (Q_h != null) {
                                var temp: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(this.N, 1);
                                for (var i: number = 0; i < this.N; i++) {
                                    var v: util.maths.matrix.DenseMatrix64F = this.eigenvectors[i];
                                    if (v != null) {
                                        util.maths.matrix.CommonOps.mult(Q_h, v, temp);
                                        this.eigenvectors[i] = temp;
                                        temp = v;
                                    }
                                }
                            }
                            return true;
                        }

                        private solveEigenvectorDuplicateEigenvalue(real: number, first: number, isTriangle: boolean): void {
                            var scale: number = Math.abs(real);
                            if (scale == 0) {
                                scale = 1;
                            }
                            this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                            this.eigenvectorTemp.zero();
                            if (first > 0) {
                                if (isTriangle) {
                                    this.solveUsingTriangle(real, first, this.eigenvectorTemp);
                                } else {
                                    this.solveWithLU(real, first, this.eigenvectorTemp);
                                }
                            }
                            this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                            for (var i: number = first; i < this.N; i++) {
                                var c: util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                                if (c.isReal() && Math.abs(c.real - real) / scale < 100.0 * util.maths.matrix.CommonOps.EPS) {
                                    this.eigenvectorTemp.data[i] = 1;
                                    var v: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(this.N, 1);
                                    util.maths.matrix.CommonOps.multTransA(this.Q, this.eigenvectorTemp, v);
                                    this.eigenvectors[this.N - i - 1] = v;
                                    util.maths.matrix.CommonOps.normalizeF(v);
                                    this.eigenvectorTemp.data[i] = 0;
                                }
                            }
                        }

                        private solveUsingTriangle(real: number, index: number, r: util.maths.matrix.DenseMatrix64F): void {
                            for (var i: number = 0; i < index; i++) {
                                this.implicit.A.add(i, i, -real);
                            }
                            util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                            util.maths.matrix.CommonOps.changeSign(r);
                            util.maths.matrix.solvers.TriangularSolver.solveU(this.implicit.A.data, r.data, this.implicit.A.numRows, 0, index);
                            for (var i: number = 0; i < index; i++) {
                                this.implicit.A.add(i, i, real);
                            }
                        }

                        private solveWithLU(real: number, index: number, r: util.maths.matrix.DenseMatrix64F): void {
                            var A: util.maths.matrix.DenseMatrix64F = new util.maths.matrix.DenseMatrix64F(index, index);
                            util.maths.matrix.CommonOps.extract6M(this.implicit.A, 0, index, 0, index, A, 0, 0);
                            for (var i: number = 0; i < index; i++) {
                                A.add(i, i, -real);
                            }
                            r.reshapeBoolean(index, 1, false);
                            util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                            util.maths.matrix.CommonOps.changeSign(r);
                            if (!this.solver.setA(A)) {
                                throw new Error("Solve failed");
                            }
                            this.solver.solve(r, r);
                        }

                        public findQandR(): boolean {
                            util.maths.matrix.CommonOps.setIdentity(this.Q);
                            this.x1 = 0;
                            this.x2 = this.N - 1;
                            this.indexVal = 0;
                            while (this.indexVal < this.N){
                                if (!this.findNextEigenvalue()) {
                                    return false;
                                }
                            }
                            return true;
                        }

                        private findNextEigenvalue(): boolean {
                            var foundEigen: boolean = false;
                            while (!foundEigen && this.implicit.steps < this.implicit.maxIterations){
                                this.implicit.incrementSteps();
                                if (this.x2 < this.x1) {
                                    this.moveToNextSplit();
                                } else {
                                    if (this.x2 - this.x1 == 0) {
                                        this.implicit.addEigenAt(this.x1);
                                        this.x2--;
                                        this.indexVal++;
                                        foundEigen = true;
                                    } else {
                                        if (this.x2 - this.x1 == 1 && !this.implicit.isReal2x2(this.x1, this.x2)) {
                                            this.implicit.addComputedEigen2x2(this.x1, this.x2);
                                            this.x2 -= 2;
                                            this.indexVal += 2;
                                            foundEigen = true;
                                        } else {
                                            if (this.implicit.steps - this.implicit.lastExceptional > this.implicit.exceptionalThreshold) {
                                                this.implicit.exceptionalShift(this.x1, this.x2);
                                                this.implicit.lastExceptional = this.implicit.steps;
                                            } else {
                                                if (this.implicit.isZero(this.x2, this.x2 - 1)) {
                                                    this.implicit.addEigenAt(this.x2);
                                                    foundEigen = true;
                                                    this.x2--;
                                                    this.indexVal++;
                                                } else {
                                                    this.checkSplitPerformImplicit();
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return foundEigen;
                        }

                        private checkSplitPerformImplicit(): void {
                            for (var i: number = this.x2; i > this.x1; i--) {
                                if (this.implicit.isZero(i, i - 1)) {
                                    this.x1 = i;
                                    this.splits[this.numSplits++] = i - 1;
                                    return;
                                }
                            }
                            if (this.onscript) {
                                if (this.implicit.steps > this.implicit.exceptionalThreshold / 2) {
                                    this.onscript = false;
                                } else {
                                    var a: util.maths.matrix.Complex64F = this.origEigenvalues[this.indexVal];
                                    if (a.isReal()) {
                                        this.implicit.performImplicitSingleStep(this.x1, this.x2, a.getReal());
                                    } else {
                                        if (this.x2 < this.N - 2) {
                                            this.implicit.performImplicitDoubleStep(this.x1, this.x2, a.real, a.imaginary);
                                        } else {
                                            this.onscript = false;
                                        }
                                    }
                                }
                            } else {
                                if (this.x2 - this.x1 >= 1 && this.x2 < this.N - 2) {
                                    this.implicit.implicitDoubleStep(this.x1, this.x2);
                                } else {
                                    this.implicit.performImplicitSingleStep(this.x1, this.x2, this.implicit.A.get(this.x2, this.x2));
                                }
                            }
                        }

                        private moveToNextSplit(): void {
                            if (this.numSplits <= 0) {
                                throw new Error("bad");
                            }
                            this.x2 = this.splits[--this.numSplits];
                            if (this.numSplits > 0) {
                                this.x1 = this.splits[this.numSplits - 1] + 1;
                            } else {
                                this.x1 = 0;
                            }
                        }

                        public getQ(): util.maths.matrix.DenseMatrix64F {
                            return this.Q;
                        }

                        public getImplicit(): util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                            return this.implicit;
                        }

                        public getEigenvectors(): util.maths.matrix.DenseMatrix64F[] {
                            return this.eigenvectors;
                        }

                        public getEigenvalues(): util.maths.matrix.Complex64F[] {
                            return this.implicit.eigenvalues;
                        }

                    }

                }
            }
        }
        export namespace structure {
            export interface KArray1D {

                size(): number;

                get(index: number): number;

                set(index: number, value: number): number;

                add(index: number, value: number): number;

                addAll(value: number): void;

                setAll(value: number): void;

                addElement(index: number, numElem: number): void;

                clone(): util.maths.structure.KArray1D;

                data(): Float64Array;

                setData(data: Float64Array): void;

            }

            export interface KArray2D {

                rows(): number;

                columns(): number;

                get(rowIndex: number, columnIndex: number): number;

                set(rowIndex: number, columnIndex: number, value: number): number;

                add(rowIndex: number, columnIndex: number, value: number): number;

                setAll(value: number): void;

                addRow(rowindex: number, numRow: number): void;

                addCol(colIndex: number, numCol: number): void;

                getAtIndex(index: number): number;

                setAtIndex(index: number, value: number): number;

                addAtIndex(index: number, value: number): number;

                clone(): util.maths.structure.KArray2D;

                data(): Float64Array;

                setData(data: Float64Array): void;

            }

            export namespace blas {
                export interface KBlas {

                    dgemm(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, m: number, n: number, k: number, alpha: number, matA: Float64Array, offsetA: number, ldA: number, matB: Float64Array, offsetB: number, ldB: number, beta: number, matC: Float64Array, offsetC: number, ldC: number): void;

                    dgetrs(transA: util.maths.structure.blas.KBlasTransposeType, dim: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void;

                    dgetri(dim: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, work: Float64Array, offsetWork: number, ldWork: number, info: Int32Array): void;

                    dgetrf(rows: number, columns: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, info: Int32Array): void;

                    dorgqr(m: number, n: number, k: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetWork: number, lWork: number, info: Int32Array): void;

                    dgeqrf(m: number, n: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetwork: number, lWork: number, info: Int32Array): void;

                    shutdown(): void;

                }

                export class KBlasDirectionType {

                    public static FORWARD: KBlasDirectionType = new KBlasDirectionType();
                    public static BACKWARD: KBlasDirectionType = new KBlasDirectionType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasDirectionTypeVALUES : KBlasDirectionType[] = [
                        KBlasDirectionType.FORWARD
                        ,KBlasDirectionType.BACKWARD
                    ];
                    public static values():KBlasDirectionType[]{
                        return KBlasDirectionType._KBlasDirectionTypeVALUES;
                    }
                }

                export class KBlasMajorType {

                    public static COLUMNWISE: KBlasMajorType = new KBlasMajorType();
                    public static ROWWISE: KBlasMajorType = new KBlasMajorType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasMajorTypeVALUES : KBlasMajorType[] = [
                        KBlasMajorType.COLUMNWISE
                        ,KBlasMajorType.ROWWISE
                    ];
                    public static values():KBlasMajorType[]{
                        return KBlasMajorType._KBlasMajorTypeVALUES;
                    }
                }

                export class KBlasOrientationType {

                    public static UPPER: KBlasOrientationType = new KBlasOrientationType();
                    public static LOWER: KBlasOrientationType = new KBlasOrientationType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasOrientationTypeVALUES : KBlasOrientationType[] = [
                        KBlasOrientationType.UPPER
                        ,KBlasOrientationType.LOWER
                    ];
                    public static values():KBlasOrientationType[]{
                        return KBlasOrientationType._KBlasOrientationTypeVALUES;
                    }
                }

                export class KBlasSideType {

                    public static LEFT: KBlasSideType = new KBlasSideType();
                    public static RIGHT: KBlasSideType = new KBlasSideType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasSideTypeVALUES : KBlasSideType[] = [
                        KBlasSideType.LEFT
                        ,KBlasSideType.RIGHT
                    ];
                    public static values():KBlasSideType[]{
                        return KBlasSideType._KBlasSideTypeVALUES;
                    }
                }

                export class KBlasTransposeType {

                    public static NOTRANSPOSE: KBlasTransposeType = new KBlasTransposeType();
                    public static TRANSPOSE: KBlasTransposeType = new KBlasTransposeType();
                    public static CONJUGATE: KBlasTransposeType = new KBlasTransposeType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasTransposeTypeVALUES : KBlasTransposeType[] = [
                        KBlasTransposeType.NOTRANSPOSE
                        ,KBlasTransposeType.TRANSPOSE
                        ,KBlasTransposeType.CONJUGATE
                    ];
                    public static values():KBlasTransposeType[]{
                        return KBlasTransposeType._KBlasTransposeTypeVALUES;
                    }
                }

                export class KBlasUnitType {

                    public static UNIT: KBlasUnitType = new KBlasUnitType();
                    public static NONUNIT: KBlasUnitType = new KBlasUnitType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _KBlasUnitTypeVALUES : KBlasUnitType[] = [
                        KBlasUnitType.UNIT
                        ,KBlasUnitType.NONUNIT
                    ];
                    public static values():KBlasUnitType[]{
                        return KBlasUnitType._KBlasUnitTypeVALUES;
                    }
                }

                export namespace impl {
                    export class JavaBlas implements util.maths.structure.blas.KBlas {

                        public dgemm(paramString1: util.maths.structure.blas.KBlasTransposeType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramInt3: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var bool1: boolean = false;
                            var bool2: boolean = false;
                            bool1 = paramString1.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                            bool2 = paramString2.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                            var i3: number;
                            var i4: number;
                            if ((paramDouble1 == 0)) {
                                if ((paramDouble2 == 0)) {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        i = 1;
                                        for (i4 = paramInt1; i4 > 0; i4--) {
                                            paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                                            i++;
                                        }
                                        k++;
                                    }
                                } else {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        i = 1;
                                        for (i4 = paramInt1; i4 > 0; i4--) {
                                            paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                            i++;
                                        }
                                        k++;
                                    }
                                }
                                return;
                            }
                            var i5: number;
                            if (bool2) {
                                if (bool1) {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        if ((paramDouble2 == 0)) {
                                            i = 1;
                                            for (i4 = paramInt1; i4 > 0; i4--) {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                                                i++;
                                            }
                                        } else {
                                            i = 1;
                                            i4 = paramInt1;
                                            for (; ; ) {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                                i++;
                                                i4--;
                                                if (i4 <= 0) {
                                                    break;
                                                }
                                            }
                                        }
                                        m = 1;
                                        for (i4 = paramInt3; i4 > 0; i4--) {
                                            if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)] != 0.0)) {
                                                d = paramDouble1 * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)];
                                                i = 1;
                                                for (i5 = paramInt1; i5 > 0; i5--) {
                                                    paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt5 + paramInt4)];
                                                    i++;
                                                }
                                            }
                                            m++;
                                        }
                                        k++;
                                    }
                                } else {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        i = 1;
                                        for (i4 = paramInt1; i4 > 0; i4--) {
                                            d = 0.0;
                                            m = 1;
                                            for (i5 = paramInt3; i5 > 0; i5--) {
                                                d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt5 + paramInt4)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)];
                                                m++;
                                            }
                                            if ((paramDouble2 == 0)) {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d);
                                            } else {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d + paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                            }
                                            i++;
                                        }
                                        k++;
                                    }
                                }
                            } else {
                                if (bool1) {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        if ((paramDouble2 == 0)) {
                                            i = 1;
                                            for (i4 = paramInt1; i4 > 0; i4--) {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                                                i++;
                                            }
                                        } else {
                                            if ((paramDouble2 != 1.0)) {
                                                i = 1;
                                                i4 = paramInt1;
                                                for (; ; ) {
                                                    paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                                    i++;
                                                    i4--;
                                                    if (i4 <= 0) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                        m = 1;
                                        for (i4 = paramInt3; i4 > 0; i4--) {
                                            if ((paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)] != 0.0)) {
                                                d = paramDouble1 * paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)];
                                                i = 1;
                                                for (i5 = paramInt1; i5 > 0; i5--) {
                                                    paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt5 + paramInt4)];
                                                    i++;
                                                }
                                            }
                                            m++;
                                        }
                                        k++;
                                    }
                                } else {
                                    k = 1;
                                    for (i3 = paramInt2; i3 > 0; i3--) {
                                        i = 1;
                                        for (i4 = paramInt1; i4 > 0; i4--) {
                                            d = 0.0;
                                            m = 1;
                                            for (i5 = paramInt3; i5 > 0; i5--) {
                                                d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt5 + paramInt4)] * paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)];
                                                m++;
                                            }
                                            if ((paramDouble2 == 0)) {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d);
                                            } else {
                                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d + paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                            }
                                            i++;
                                        }
                                        k++;
                                    }
                                }
                            }
                        }

                        public dgetri(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfInt: Int32Array, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramintW: Int32Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var i2: number = 0;
                            var i3: number = 0;
                            var i4: number = 0;
                            var i5: number = 0;
                            var i6: number = 0;
                            var i7: number = 0;
                            paramintW[0] = 0;
                            i5 = this.ilaenv(1, "DGETRI", " ", paramInt1, -1, -1, -1);
                            i4 = paramInt1 * i5;
                            paramArrayOfDouble2[paramInt5] = i4;
                            i = paramInt6 != -1 ? 0 : 1;
                            if ((paramInt1 < 0)) {
                                paramintW[0] = -1;
                            } else {
                                if ((paramInt3 < Math.max(1, paramInt1))) {
                                    paramintW[0] = -3;
                                }
                            }
                            if ((paramintW[0] != 0)) {
                                return;
                            }
                            if (i != 0) {
                                return;
                            }
                            if ((paramInt1 == 0)) {
                                return;
                            }
                            this.dtrtri(util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramArrayOfDouble1, paramInt2, paramInt3, paramintW);
                            if ((paramintW[0] > 0)) {
                                return;
                            }
                            i6 = 2;
                            i3 = paramInt1;
                            if (((i5 < paramInt1) ? 1 : 0) != 0) {
                                k = Math.max(i3 * i5, 1);
                                if ((paramInt6 < k)) {
                                    i5 = this.floorDiv(paramInt6, i3);
                                    i6 = Math.max(2, this.ilaenv(2, "DGETRI", " ", paramInt1, -1, -1, -1));
                                }
                            } else {
                                k = paramInt1;
                            }
                            var i9: number;
                            if (((i5 >= paramInt1))) {
                                m = paramInt1;
                                for (var i8: number = paramInt1; i8 > 0; i8--) {
                                    j = m + 1;
                                    for (i9 = paramInt1 - (m + 1) + 1; i9 > 0; i9--) {
                                        paramArrayOfDouble2[(j - 1 + paramInt5)] = paramArrayOfDouble1[(j - 1 + (m - 1) * paramInt3 + paramInt2)];
                                        paramArrayOfDouble1[(j - 1 + (m - 1) * paramInt3 + paramInt2)] = 0.0;
                                        j++;
                                    }
                                    if ((m < paramInt1)) {
                                        this.dgemv(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt1 - m, -1.0, paramArrayOfDouble1, (m) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble2, m + paramInt5, 1, 1.0, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, 1);
                                    }
                                    m += -1;
                                }
                            } else {
                                i7 = this.floorDiv((paramInt1 - 1), i5) * i5 + 1;
                                m = i7;
                                for (var i8: number = this.floorDiv((1 - i7 + -i5), -i5); i8 > 0; i8--) {
                                    n = Math.min(i5, paramInt1 - m + 1);
                                    i1 = m;
                                    for (i9 = n; i9 > 0; i9--) {
                                        j = i1 + 1;
                                        for (var i10: number = paramInt1 - (i1 + 1) + 1; i10 > 0; i10--) {
                                            paramArrayOfDouble2[(j + (i1 - m) * i3 - 1 + paramInt5)] = paramArrayOfDouble1[(j - 1 + (i1 - 1) * paramInt3 + paramInt2)];
                                            paramArrayOfDouble1[(j - 1 + (i1 - 1) * paramInt3 + paramInt2)] = 0.0;
                                            j++;
                                        }
                                        i1++;
                                    }
                                    if ((m + n <= paramInt1)) {
                                        this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, n, paramInt1 - m - n + 1, -1.0, paramArrayOfDouble1, (m + n - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble2, m + n - 1 + paramInt5, i3, 1.0, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, paramInt3);
                                    }
                                    this.dtrsm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, n, 1.0, paramArrayOfDouble2, m - 1 + paramInt5, i3, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, paramInt3);
                                    m += -i5;
                                }
                            }
                            m = paramInt1 - 1;
                            for (var i8: number = -1 + paramInt1; i8 > 0; i8--) {
                                i2 = paramArrayOfInt[(m - 1 + paramInt4)];
                                if ((i2 != m)) {
                                    this.dswap(paramInt1, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, 1, paramArrayOfDouble1, (i2 - 1) * paramInt3 + paramInt2, 1);
                                }
                                m += -1;
                            }
                            paramArrayOfDouble2[(paramInt5)] = k;
                        }

                        public dgetrf(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void {
                            var i: number = 0;
                            info[0] = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            info[0] = 0;
                            var localintW: Int32Array = new Int32Array(1);
                            localintW[0] = 0;
                            if ((paramInt1 < 0)) {
                                info[0] = -1;
                            } else {
                                if ((paramInt2 < 0)) {
                                    info[0] = -2;
                                } else {
                                    if ((paramInt4 < Math.max(1, paramInt1))) {
                                        info[0] = -4;
                                    }
                                }
                            }
                            if ((info[0] != 0)) {
                                return;
                            }
                            if (((paramInt2 == 0))) {
                                return;
                            }
                            m = this.ilaenv(1, "DGETRF", " ", paramInt1, paramInt2, -1, -1);
                            if (((m >= Math.min(paramInt1, paramInt2)))) {
                                this.dgetf2(paramInt1, paramInt2, paramArrayOfDouble, paramInt3, paramInt4, paramArrayOfInt, paramInt5, info);
                            } else {
                                j = 1;
                                for (var n: number = this.floorDiv((Math.min(paramInt1, paramInt2) - 1 + m), m); n > 0; n--) {
                                    k = Math.min(Math.min(paramInt1, paramInt2) - j + 1, m);
                                    this.dgetf2(paramInt1 - j + 1, k, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfInt, j - 1 + paramInt5, localintW);
                                    i = j;
                                    for (var i1: number = Math.min(paramInt1, j + k - 1) - j + 1; i1 > 0; i1--) {
                                        paramArrayOfInt[(i - 1 + paramInt5)] = (j - 1 + paramArrayOfInt[(i - 1 + paramInt5)]);
                                        i++;
                                    }
                                    this.dlaswp(j - 1, paramArrayOfDouble, paramInt3, paramInt4, j, j + k - 1, paramArrayOfInt, paramInt5, 1);
                                    if ((j + k <= paramInt2)) {
                                        this.dlaswp(paramInt2 - j - k + 1, paramArrayOfDouble, (j + k - 1) * paramInt4 + paramInt3, paramInt4, j, j + k - 1, paramArrayOfInt, paramInt5, 1);
                                        this.dtrsm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, k, paramInt2 - j - k + 1, 1.0, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4);
                                        if ((j + k <= paramInt1)) {
                                            this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1 - j - k + 1, paramInt2 - j - k + 1, k, -1.0, paramArrayOfDouble, j + k - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4, 1.0, paramArrayOfDouble, j + k - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4);
                                        }
                                    }
                                    j += m;
                                }
                            }
                        }

                        public dgetrs(trans: util.maths.structure.blas.KBlasTransposeType, nOrder: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiV: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void {
                            var bool: boolean = false;
                            info[0] = 0;
                            bool = trans.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                            if (bool) {
                                this.dlaswp(nrhs, matB, offsetB, ldB, 1, nOrder, ipiv, offsetIpiV, 1);
                                this.dtrsm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                                this.dtrsm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.NONUNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                            } else {
                                this.dtrsm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.NONUNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                                this.dtrsm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                                this.dlaswp(nrhs, matB, offsetB, ldB, 1, nOrder, ipiv, offsetIpiV, -1);
                            }
                        }

                        public dorgqr(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number, paramintW: Int32Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var localintW: Int32Array = new Int32Array(1);
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var i2: number = 0;
                            var i3: number = 0;
                            var i4: number = 0;
                            var i5: number = 0;
                            var i6: number = 0;
                            var i7: number = 0;
                            var i8: number = 0;
                            paramintW[0] = 0;
                            i6 = this.ilaenv(1, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1);
                            i5 = Math.max(1, paramInt2) * i6;
                            paramArrayOfDouble3[(paramInt7)] = i5;
                            i = paramInt8 != -1 ? 0 : 1;
                            if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if (((paramInt2 <= paramInt1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if (((paramInt3 <= paramInt2 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                        paramintW[0] = -3;
                                    } else {
                                        if ((paramInt5 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                                            paramintW[0] = -5;
                                        }
                                    }
                                }
                            }
                            if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                                return;
                            }
                            if (i != 0) {
                                return;
                            }
                            if ((paramInt2 > 0 ? 0 : 1) != 0) {
                                paramArrayOfDouble3[(paramInt7)] = 1;
                                return;
                            }
                            i7 = 2;
                            i8 = 0;
                            m = paramInt2;
                            if (((i6 >= paramInt3 ? 0 : 1) != 0 ? 1 : 0) != 0) {
                                i8 = Math.max(0, this.ilaenv(3, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1));
                                if ((i8 >= paramInt3 ? 0 : 1) != 0) {
                                    i4 = paramInt2;
                                    m = i4 * i6;
                                    if ((paramInt8 >= m ? 0 : 1) != 0) {
                                        i6 = paramInt8 / i4;
                                        i7 = Math.max(2, this.ilaenv(2, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1));
                                    }
                                }
                            }
                            var i9: number;
                            var i10: number;
                            if (((i8 >= paramInt3 ? 0 : 1) != 0 ? 1 : 0) != 0) {
                                i1 = (paramInt3 - i8 - 1) / i6 * i6;
                                i2 = Math.min(paramInt3, i1 + i6);
                                n = i2 + 1;
                                for (i9 = paramInt2 - (i2 + 1) + 1; i9 > 0; i9--) {
                                    j = 1;
                                    for (i10 = i2; i10 > 0; i10--) {
                                        paramArrayOfDouble1[(j - 1 + (n - 1) * paramInt5 + paramInt4)] = 0.0;
                                        j += 1;
                                    }
                                    n += 1;
                                }
                            } else {
                                i2 = 0;
                            }
                            if ((i2 >= paramInt2 ? 0 : 1) != 0) {
                                this.dorg2r(paramInt1 - i2, paramInt2 - i2, paramInt3 - i2, paramArrayOfDouble1, i2 + (i2) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, i2 + paramInt6, paramArrayOfDouble3, paramInt7, localintW);
                            }
                            if ((i2 <= 0 ? 0 : 1) != 0) {
                                j = i1 + 1;
                                for (i9 = (1 - (i1 + 1) + -i6) / -i6; i9 > 0; i9--) {
                                    k = Math.min(i6, paramInt3 - j + 1);
                                    if ((j + k > paramInt2 ? 0 : 1) != 0) {
                                        this.dlarft(util.maths.structure.blas.KBlasDirectionType.FORWARD, util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, j - 1 + paramInt6, paramArrayOfDouble3, paramInt7, i4);
                                        this.dlarfb(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasDirectionType.FORWARD, util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, paramInt2 - j - k + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, paramInt7, i4, paramArrayOfDouble1, j - 1 + (j + k - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, k + paramInt7, i4);
                                    }
                                    this.dorg2r(paramInt1 - j + 1, k, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, j - 1 + paramInt6, paramArrayOfDouble3, paramInt7, localintW);
                                    n = j;
                                    for (i10 = j + k - 1 - j + 1; i10 > 0; i10--) {
                                        i3 = 1;
                                        for (var i11: number = j - 1; i11 > 0; i11--) {
                                            paramArrayOfDouble1[(i3 - 1 + (n - 1) * paramInt5 + paramInt4)] = 0.0;
                                            i3 += 1;
                                        }
                                        n += 1;
                                    }
                                    j += -i6;
                                }
                            }
                            paramArrayOfDouble3[(paramInt7)] = m;
                        }

                        public dgeqrf(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number, paramintW: Int32Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var localintW: Int32Array = new Int32Array(1);
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var i2: number = 0;
                            var i3: number = 0;
                            var i4: number = 0;
                            var i5: number = 0;
                            paramintW[0] = 0;
                            i3 = this.ilaenv(1, "DGEQRF", " ", paramInt1, paramInt2, -1, -1);
                            i2 = paramInt2 * i3;
                            paramArrayOfDouble3[paramInt6] = i2;
                            i = paramInt7 != -1 ? 0 : 1;
                            if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if ((paramInt2 >= 0 ? 0 : 1) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if ((paramInt4 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                                        paramintW[0] = -4;
                                    }
                                }
                            }
                            if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                                return;
                            }
                            if (i != 0) {
                                return;
                            }
                            n = Math.min(paramInt1, paramInt2);
                            if ((n != 0 ? 0 : 1) != 0) {
                                paramArrayOfDouble3[paramInt6] = 1;
                                return;
                            }
                            i4 = 2;
                            i5 = 0;
                            m = paramInt2;
                            if (((i3 >= n ? 0 : 1) != 0 ? 1 : 0) != 0) {
                                i5 = Math.max(0, this.ilaenv(3, "DGEQRF", " ", paramInt1, paramInt2, -1, -1));
                                if ((i5 >= n ? 0 : 1) != 0) {
                                    i1 = paramInt2;
                                    m = i1 * i3;
                                    if ((paramInt7 >= m ? 0 : 1) != 0) {
                                        i3 = paramInt7 / i1;
                                        i4 = Math.max(2, this.ilaenv(2, "DGEQRF", " ", paramInt1, paramInt2, -1, -1));
                                    }
                                }
                            }
                            if (((i5 >= n ? 0 : 1) != 0 ? 1 : 0) != 0) {
                                j = 1;
                                for (var i6: number = (n - i5 - 1 + i3) / i3; i6 > 0; i6--) {
                                    k = Math.min(n - j + 1, i3);
                                    this.dgeqr2(paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, localintW);
                                    if ((j + k > paramInt2 ? 0 : 1) != 0) {
                                        this.dlarft(util.maths.structure.blas.KBlasDirectionType.FORWARD, util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, i1);
                                        this.dlarfb(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasDirectionType.FORWARD, util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, paramInt2 - j - k + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, paramInt6, i1, paramArrayOfDouble1, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, k + paramInt6, i1);
                                    }
                                    j += i3;
                                }
                            } else {
                                j = 1;
                            }
                            if ((j > n ? 0 : 1) != 0) {
                                this.dgeqr2(paramInt1 - j + 1, paramInt2 - j + 1, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, localintW);
                            }
                            paramArrayOfDouble3[(paramInt6)] = m;
                        }

                        public dorg2r(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramintW: Int32Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            paramintW[0] = 0;
                            if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if (((paramInt2 <= paramInt1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if (((paramInt3 <= paramInt2 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                        paramintW[0] = -3;
                                    } else {
                                        if ((paramInt5 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                                            paramintW[0] = -5;
                                        }
                                    }
                                }
                            }
                            if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                                return;
                            }
                            if ((paramInt2 > 0 ? 0 : 1) != 0) {
                                return;
                            }
                            j = paramInt3 + 1;
                            var n: number;
                            for (var m: number = paramInt2 - (paramInt3 + 1) + 1; m > 0; m--) {
                                k = 1;
                                for (n = paramInt1; n > 0; n--) {
                                    paramArrayOfDouble1[(k - 1 + (j - 1) * paramInt5 + paramInt4)] = 0.0;
                                    k += 1;
                                }
                                paramArrayOfDouble1[(j - 1 + (j - 1) * paramInt5 + paramInt4)] = 1.0;
                                j += 1;
                            }
                            i = paramInt3;
                            for (var m: number = (1 - paramInt3 + -1) / -1; m > 0; m--) {
                                if ((i >= paramInt2 ? 0 : 1) != 0) {
                                    paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt5 + paramInt4)] = 1.0;
                                    this.dlarf(util.maths.structure.blas.KBlasSideType.LEFT, paramInt1 - i + 1, paramInt2 - i, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt5 + paramInt4, 1, paramArrayOfDouble2[(i - 1 + paramInt6)], paramArrayOfDouble1, i - 1 + (i) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, paramInt7);
                                }
                                if ((i >= paramInt1 ? 0 : 1) != 0) {
                                    this.dscal(paramInt1 - i, -paramArrayOfDouble2[(i - 1 + paramInt6)], paramArrayOfDouble1, i + (i - 1) * paramInt5 + paramInt4, 1);
                                }
                                paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt5 + paramInt4)] = (1.0 - paramArrayOfDouble2[(i - 1 + paramInt6)]);
                                k = 1;
                                for (n = i - 1; n > 0; n--) {
                                    paramArrayOfDouble1[(k - 1 + (i - 1) * paramInt5 + paramInt4)] = 0.0;
                                    k += 1;
                                }
                                i += -1;
                            }
                        }

                        public dlarfb(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramString3: util.maths.structure.blas.KBlasDirectionType, paramString4: util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number, paramArrayOfDouble4: Float64Array, paramInt10: number, paramInt11: number): void {
                            var str: util.maths.structure.blas.KBlasTransposeType;
                            var i: number = 0;
                            var j: number = 0;
                            if (((paramInt2 > 0 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                return;
                            }
                            if (paramString2.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                str = util.maths.structure.blas.KBlasTransposeType.TRANSPOSE;
                            } else {
                                str = util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE;
                            }
                            var k: number;
                            var m: number;
                            if (paramString4.equals(util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                                if (paramString3.equals(util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                                    if (paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT)) {
                                        j = 1;
                                        for (k = paramInt3; k > 0; k--) {
                                            this.dcopy(paramInt2, paramArrayOfDouble3, j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                            j += 1;
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                        if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                            this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt3 + paramInt8, paramInt9, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, str, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                        if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                            this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt3 + (1 - 1) * paramInt9 + paramInt8, paramInt9);
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                        j = 1;
                                        for (k = paramInt3; k > 0; k--) {
                                            i = 1;
                                            for (m = paramInt2; m > 0; m--) {
                                                paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                i += 1;
                                            }
                                            j += 1;
                                        }
                                    } else {
                                        if (paramString1.equals(util.maths.structure.blas.KBlasSideType.RIGHT)) {
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                this.dcopy(paramInt1, paramArrayOfDouble3, (j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                j += 1;
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            j = 1;
                                            k = paramInt3;
                                            for (; ; ) {
                                                i = 1;
                                                for (m = paramInt1; m > 0; m--) {
                                                    paramArrayOfDouble3[(i - 1 + (j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                    i += 1;
                                                }
                                                j += 1;
                                                k--;
                                                if (k <= 0) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT)) {
                                        j = 1;
                                        for (k = paramInt3; k > 0; k--) {
                                            this.dcopy(paramInt2, paramArrayOfDouble3, paramInt1 - paramInt3 + j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                            j += 1;
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt1 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                        if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                            this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, str, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                        if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                            this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                                        }
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt1 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                        j = 1;
                                        for (k = paramInt3; k > 0; k--) {
                                            i = 1;
                                            for (m = paramInt2; m > 0; m--) {
                                                paramArrayOfDouble3[(paramInt1 - paramInt3 + j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                i += 1;
                                            }
                                            j += 1;
                                        }
                                    } else {
                                        if (paramString1.equals(util.maths.structure.blas.KBlasSideType.RIGHT)) {
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                this.dcopy(paramInt1, paramArrayOfDouble3, (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                j += 1;
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt2 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt2 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            j = 1;
                                            k = paramInt3;
                                            for (; ; ) {
                                                i = 1;
                                                for (m = paramInt1; m > 0; m--) {
                                                    paramArrayOfDouble3[(i - 1 + (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                    i += 1;
                                                }
                                                j += 1;
                                                k--;
                                                if (k <= 0) {
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (paramString4.equals(util.maths.structure.blas.KBlasMajorType.ROWWISE)) {
                                    if (paramString3.equals(util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                                        if (paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT)) {
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                this.dcopy(paramInt2, paramArrayOfDouble3, j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                j += 1;
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt3 + paramInt8, paramInt9, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, str, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt3 + (1 - 1) * paramInt9 + paramInt8, paramInt9);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                i = 1;
                                                for (m = paramInt2; m > 0; m--) {
                                                    paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                    i += 1;
                                                }
                                                j += 1;
                                            }
                                        } else {
                                            if (paramString1.equals(util.maths.structure.blas.KBlasSideType.RIGHT)) {
                                                j = 1;
                                                for (k = paramInt3; k > 0; k--) {
                                                    this.dcopy(paramInt1, paramArrayOfDouble3, (j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                    j += 1;
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                                if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                    this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                                if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                    this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9);
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                                j = 1;
                                                k = paramInt3;
                                                for (; ; ) {
                                                    i = 1;
                                                    for (m = paramInt1; m > 0; m--) {
                                                        paramArrayOfDouble3[(i - 1 + (j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                        i += 1;
                                                    }
                                                    j += 1;
                                                    k--;
                                                    if (k <= 0) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    } else {
                                        if (paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT)) {
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                this.dcopy(paramInt2, paramArrayOfDouble3, paramInt1 - paramInt3 + j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                j += 1;
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, (paramInt1 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, str, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                                                this.dgemm(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                                            }
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, (paramInt1 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                            j = 1;
                                            for (k = paramInt3; k > 0; k--) {
                                                i = 1;
                                                for (m = paramInt2; m > 0; m--) {
                                                    paramArrayOfDouble3[(paramInt1 - paramInt3 + j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                    i += 1;
                                                }
                                                j += 1;
                                            }
                                        } else {
                                            if (paramString1.equals(util.maths.structure.blas.KBlasSideType.RIGHT)) {
                                                j = 1;
                                                for (k = paramInt3; k > 0; k--) {
                                                    this.dcopy(paramInt1, paramArrayOfDouble3, (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                                    j += 1;
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, (paramInt2 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                                if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                    this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                                                if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                                    this.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                                                }
                                                this.dtrmm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, (paramInt2 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                                                j = 1;
                                                k = paramInt3;
                                                for (; ; ) {
                                                    i = 1;
                                                    for (m = paramInt1; m > 0; m--) {
                                                        paramArrayOfDouble3[(i - 1 + (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                                        i += 1;
                                                    }
                                                    j += 1;
                                                    k--;
                                                    if (k <= 0) {
                                                        break;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        public dcopy(n: number, x: Float64Array, offsetx: number, incx: number, y: Float64Array, offsety: number, incy: number): void {
                            if (n <= 0) {
                                return;
                            }
                            var indexX: number = offsetx;
                            var indexY: number = offsety;
                            for (var i: number = 0; i < n; i++) {
                                y[indexY] = x[indexX];
                                indexY += incy;
                                indexX += incx;
                            }
                        }

                        public dlarft(paramString1: util.maths.structure.blas.KBlasDirectionType, paramString2: util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number): void {
                            var i: number = 0;
                            var j: number = 0;
                            var d: number = 0.0;
                            if ((paramInt1 != 0 ? 0 : 1) != 0) {
                                return;
                            }
                            var k: number;
                            var m: number;
                            if (paramString1.equals(util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                                i = 1;
                                for (k = paramInt2; k > 0; k--) {
                                    if ((paramArrayOfDouble2[(i - 1 + paramInt5)] != 0.0 ? 0 : 1) != 0) {
                                        j = 1;
                                        for (m = i; m > 0; m--) {
                                            paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt7 + paramInt6)] = 0.0;
                                            j += 1;
                                        }
                                    } else {
                                        d = paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                        paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                                        if (paramString2.equals(util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                                            this.dgemv(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - i + 1, i - 1, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i - 1 + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, 1, 0.0, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                                        } else {
                                            this.dgemv(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, i - 1, paramInt1 - i + 1, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, (i - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, paramInt4, 0.0, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                                        }
                                        paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                                        this.dtrmv(util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.NONUNIT, i - 1, paramArrayOfDouble3, paramInt6, paramInt7, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                                        paramArrayOfDouble3[(i - 1 + (i - 1) * paramInt7 + paramInt6)] = paramArrayOfDouble2[(i - 1 + paramInt5)];
                                    }
                                    i += 1;
                                }
                            } else {
                                i = paramInt2;
                                for (k = (1 - paramInt2 + -1) / -1; k > 0; k--) {
                                    if ((paramArrayOfDouble2[(i - 1 + paramInt5)] != 0.0 ? 0 : 1) != 0) {
                                        j = i;
                                        for (m = paramInt2 - i + 1; m > 0; m--) {
                                            paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt7 + paramInt6)] = 0.0;
                                            j += 1;
                                        }
                                    } else {
                                        if ((i >= paramInt2 ? 0 : 1) != 0) {
                                            if (paramString2.equals(util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                                                d = paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                                paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                                                this.dgemv(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt2 + i, paramInt2 - i, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, (i) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble1, (i - 1) * paramInt4 + paramInt3, 1, 0.0, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                                                paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                                            } else {
                                                d = paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)];
                                                paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)] = 1.0;
                                                this.dgemv(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2 - i, paramInt1 - paramInt2 + i, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + paramInt3, paramInt4, 0.0, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                                                paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)] = d;
                                            }
                                            this.dtrmv(util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2 - i, paramArrayOfDouble3, i + (i) * paramInt7 + paramInt6, paramInt7, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                                        }
                                        paramArrayOfDouble3[(i - 1 + (i - 1) * paramInt7 + paramInt6)] = paramArrayOfDouble2[(i - 1 + paramInt5)];
                                    }
                                    i += -1;
                                }
                            }
                        }

                        public dgeqr2(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramintW: Int32Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var d: number = 0.0;
                            paramintW[0] = 0;
                            if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if ((paramInt2 >= 0 ? 0 : 1) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if ((paramInt4 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                                        paramintW[0] = -4;
                                    }
                                }
                            }
                            if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                                return;
                            }
                            j = Math.min(paramInt1, paramInt2);
                            i = 1;
                            for (var k: number = j; k > 0; k--) {
                                this.dlarfg_adapter(paramInt1 - i + 1, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, paramArrayOfDouble1, Math.min(i + 1, paramInt1) - 1 + (i - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble2, i - 1 + paramInt5);
                                if ((i >= paramInt2 ? 0 : 1) != 0) {
                                    d = paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                    paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                                    this.dlarf(util.maths.structure.blas.KBlasSideType.LEFT, paramInt1 - i + 1, paramInt2 - i, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i - 1 + (i) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, paramInt6);
                                    paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                                }
                                i += 1;
                            }
                        }

                        private dlarfg_adapter(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramArrayOfDouble2: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble3: Float64Array, paramInt5: number): void {
                            var localdoubleW1: Float64Array = new Float64Array(1);
                            localdoubleW1[0] = (paramArrayOfDouble1[paramInt2]);
                            var localdoubleW2: Float64Array = new Float64Array(1);
                            localdoubleW2[0] = (paramArrayOfDouble3[paramInt5]);
                            this.dlarfg(paramInt1, localdoubleW1, paramArrayOfDouble2, paramInt3, paramInt4, localdoubleW2);
                            paramArrayOfDouble1[paramInt2] = localdoubleW1[0];
                            paramArrayOfDouble3[paramInt5] = localdoubleW2[0];
                        }

                        public dlarf(paramString: util.maths.structure.blas.KBlasSideType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramDouble: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number): void {
                            if (paramString.equals(util.maths.structure.blas.KBlasSideType.LEFT)) {
                                if ((paramDouble == 0.0 ? 0 : 1) != 0) {
                                    this.dgemv(util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2, 1.0, paramArrayOfDouble2, paramInt5, paramInt6, paramArrayOfDouble1, paramInt3, paramInt4, 0.0, paramArrayOfDouble3, paramInt7, 1);
                                    this.dger(paramInt1, paramInt2, -paramDouble, paramArrayOfDouble1, paramInt3, paramInt4, paramArrayOfDouble3, paramInt7, 1, paramArrayOfDouble2, paramInt5, paramInt6);
                                }
                            } else {
                                if ((paramDouble == 0.0 ? 0 : 1) != 0) {
                                    this.dgemv(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2, 1.0, paramArrayOfDouble2, paramInt5, paramInt6, paramArrayOfDouble1, paramInt3, paramInt4, 0.0, paramArrayOfDouble3, paramInt7, 1);
                                    this.dger(paramInt1, paramInt2, -paramDouble, paramArrayOfDouble3, paramInt7, 1, paramArrayOfDouble1, paramInt3, paramInt4, paramArrayOfDouble2, paramInt5, paramInt6);
                                }
                            }
                        }

                        public dnrm2(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number {
                            var d1: number = 0.0;
                            var d2: number = 0.0;
                            var d3: number = 0.0;
                            var d4: number = 0.0;
                            var i: number = 0;
                            var d5: number = 0.0;
                            if (((paramInt3 >= 1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                                d2 = 0.0;
                            } else {
                                if ((paramInt1 != 1 ? 0 : 1) != 0) {
                                    d2 = Math.abs(paramArrayOfDouble[(paramInt2)]);
                                } else {
                                    d3 = 0.0;
                                    d4 = 1.0;
                                    i = 1;
                                    for (var j: number = (1 + (paramInt1 - 1) * paramInt3 - 1 + paramInt3) / paramInt3; j > 0; j--) {
                                        if ((paramArrayOfDouble[(i - 1 + paramInt2)] == 0.0 ? 0 : 1) != 0) {
                                            d1 = Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]);
                                            if ((d3 >= d1 ? 0 : 1) != 0) {
                                                d4 = 1.0 + d4 * Math.pow(d3 / d1, 2);
                                                d3 = d1;
                                            } else {
                                                d4 += Math.pow(d1 / d3, 2);
                                            }
                                        }
                                        i += paramInt3;
                                    }
                                    d2 = d3 * Math.sqrt(d4);
                                }
                            }
                            d5 = d2;
                            return d5;
                        }

                        public dlapy2(paramDouble1: number, paramDouble2: number): number {
                            var d1: number = 0.0;
                            var d2: number = 0.0;
                            var d3: number = 0.0;
                            var d4: number = 0.0;
                            var d5: number = 0.0;
                            d2 = Math.abs(paramDouble1);
                            d3 = Math.abs(paramDouble2);
                            d1 = Math.max(d2, d3);
                            d4 = Math.min(d2, d3);
                            if ((d4 != 0.0 ? 0 : 1) != 0) {
                                d5 = d1;
                            } else {
                                d5 = d1 * Math.sqrt(1.0 + Math.pow(d4 / d1, 2));
                            }
                            return d5;
                        }

                        private dsign(paramDouble1: number, paramDouble2: number): number {
                            if (paramDouble2 > 0.0) {
                                return Math.abs(paramDouble1);
                            }
                            if (paramDouble2 < 0.0) {
                                return -Math.abs(paramDouble1);
                            }
                            return 0.0;
                        }

                        public dlarfg(paramInt1: number, paramdoubleW1: Float64Array, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramdoubleW2: Float64Array): void {
                            var i: number = 0;
                            var j: number = 0;
                            var d1: number = 0.0;
                            var d2: number = 0.0;
                            var d3: number = 0.0;
                            var d4: number = 0.0;
                            if ((paramInt1 > 1 ? 0 : 1) != 0) {
                                paramdoubleW2[0] = 0.0;
                                return;
                            }
                            d4 = this.dnrm2(paramInt1 - 1, paramArrayOfDouble, paramInt2, paramInt3);
                            if ((d4 != 0.0 ? 0 : 1) != 0) {
                                paramdoubleW2[0] = 0.0;
                            } else {
                                d1 = -this.dsign(this.dlapy2(paramdoubleW1[0], d4), paramdoubleW1[0]);
                                d3 = util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                                if ((Math.abs(d1) >= d3 ? 0 : 1) != 0) {
                                    d2 = 1.0 / d3;
                                    j = 0;
                                    do {
                                        j += 1;
                                        this.dscal(paramInt1 - 1, d2, paramArrayOfDouble, paramInt2, paramInt3);
                                        d1 *= d2;
                                        paramdoubleW1[0] *= d2;
                                    } while ((Math.abs(d1) >= d3 ? 0 : 1) != 0)
                                    d4 = this.dnrm2(paramInt1 - 1, paramArrayOfDouble, paramInt2, paramInt3);
                                    d1 = -this.dsign(this.dlapy2(paramdoubleW1[0], d4), paramdoubleW1[0]);
                                    paramdoubleW2[0] = ((d1 - paramdoubleW1[0]) / d1);
                                    this.dscal(paramInt1 - 1, 1.0 / (paramdoubleW1[0] - d1), paramArrayOfDouble, paramInt2, paramInt3);
                                    paramdoubleW1[0] = d1;
                                    i = 1;
                                    for (var k: number = j; k > 0; k--) {
                                        paramdoubleW1[0] *= d3;
                                        i += 1;
                                    }
                                } else {
                                    paramdoubleW2[0] = ((d1 - paramdoubleW1[0]) / d1);
                                    this.dscal(paramInt1 - 1, 1.0 / (paramdoubleW1[0] - d1), paramArrayOfDouble, paramInt2, paramInt3);
                                    paramdoubleW1[0] = d1;
                                }
                            }
                        }

                        public shutdown(): void {
                        }

                        public dtrti2(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void {
                            var bool1: boolean = false;
                            var bool2: boolean = false;
                            var i: number = 0;
                            var d: number = 0.0;
                            paramintW[0] = 0;
                            bool2 = paramString1.equals(util.maths.structure.blas.KBlasOrientationType.UPPER);
                            bool1 = paramString2.equals(util.maths.structure.blas.KBlasUnitType.NONUNIT);
                            if ((((!bool2)) && ((!paramString1.equals(util.maths.structure.blas.KBlasOrientationType.LOWER))) ? 1 : 0) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if ((((!bool1)) && ((!paramString2.equals(util.maths.structure.blas.KBlasUnitType.UNIT))) ? 1 : 0) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if ((paramInt1 < 0)) {
                                        paramintW[0] = -3;
                                    } else {
                                        if ((paramInt3 < Math.max(1, paramInt1))) {
                                            paramintW[0] = -5;
                                        }
                                    }
                                }
                            }
                            if ((paramintW[0] != 0)) {
                                return;
                            }
                            var j: number;
                            if (bool2) {
                                i = 1;
                                for (j = paramInt1; j > 0; j--) {
                                    if (bool1) {
                                        paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)] = (1.0 / paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)]);
                                        d = -paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)];
                                    } else {
                                        d = -1.0;
                                    }
                                    this.dtrmv(util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, paramArrayOfDouble, paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, 1);
                                    this.dscal(i - 1, d, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, 1);
                                    i++;
                                }
                            } else {
                                i = paramInt1;
                                for (j = paramInt1; j > 0; j--) {
                                    if (bool1) {
                                        paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)] = (1.0 / paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)]);
                                        d = -paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)];
                                    } else {
                                        d = -1.0;
                                    }
                                    if ((i < paramInt1)) {
                                        this.dtrmv(util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i, paramArrayOfDouble, i + (i) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + (i - 1) * paramInt3 + paramInt2, 1);
                                        this.dscal(paramInt1 - i, d, paramArrayOfDouble, i + (i - 1) * paramInt3 + paramInt2, 1);
                                    }
                                    i += -1;
                                }
                            }
                        }

                        private print(paramArrayOfDouble: Float64Array, s: string): void {
                            var t: string = s + ": ";
                            for (var i: number = 0; i < paramArrayOfDouble.length; i++) {
                                t = t + paramArrayOfDouble[i] + " ";
                            }
                            console.log(t);;
                        }

                        public dtrmv(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasTransposeType, paramString3: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var bool: boolean = false;
                            bool = paramString3.equals(util.maths.structure.blas.KBlasUnitType.NONUNIT);
                            if ((paramInt5 <= 0)) {
                                i1 = 1 - (paramInt1 - 1) * paramInt5;
                            } else {
                                if ((paramInt5 != 1)) {
                                    i1 = 1;
                                }
                            }
                            var i2: number;
                            var i3: number;
                            if (paramString2.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                if (paramString1.equals(util.maths.structure.blas.KBlasOrientationType.UPPER)) {
                                    if ((paramInt5 == 1)) {
                                        m = 1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            if ((paramArrayOfDouble2[(m - 1 + paramInt4)] != 0.0)) {
                                                d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                                                i = 1;
                                                for (i3 = m - 1; i3 > 0; i3--) {
                                                    paramArrayOfDouble2[(i - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                    i++;
                                                }
                                                if (bool) {
                                                    paramArrayOfDouble2[(m - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                }
                                            }
                                            m++;
                                        }
                                    } else {
                                        n = i1;
                                        m = 1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            if ((paramArrayOfDouble2[(n - 1 + paramInt4)] != 0.0)) {
                                                d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                                                k = i1;
                                                i = 1;
                                                for (i3 = m - 1; i3 > 0; i3--) {
                                                    paramArrayOfDouble2[(k - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                    k += paramInt5;
                                                    i++;
                                                }
                                                if (bool) {
                                                    paramArrayOfDouble2[(n - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                }
                                            }
                                            n += paramInt5;
                                            m++;
                                        }
                                    }
                                } else {
                                    if ((paramInt5 == 1)) {
                                        m = paramInt1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            if ((paramArrayOfDouble2[(m - 1 + paramInt4)] != 0.0)) {
                                                d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                                                i = paramInt1;
                                                for (i3 = -(m - paramInt1); i3 > 0; i3--) {
                                                    paramArrayOfDouble2[(i - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                    i += -1;
                                                }
                                                if (bool) {
                                                    paramArrayOfDouble2[(m - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                }
                                            }
                                            m += -1;
                                        }
                                    } else {
                                        i1 += (paramInt1 - 1) * paramInt5;
                                        n = i1;
                                        m = paramInt1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            if ((paramArrayOfDouble2[(n - 1 + paramInt4)] != 0.0)) {
                                                d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                                                k = i1;
                                                i = paramInt1;
                                                for (i3 = -(m - paramInt1); i3 > 0; i3--) {
                                                    paramArrayOfDouble2[(k - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                    k -= paramInt5;
                                                    i += -1;
                                                }
                                                if (bool) {
                                                    paramArrayOfDouble2[(n - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                                }
                                            }
                                            n -= paramInt5;
                                            m += -1;
                                        }
                                    }
                                }
                            } else {
                                if (paramString1.equals(util.maths.structure.blas.KBlasOrientationType.UPPER)) {
                                    if ((paramInt5 == 1)) {
                                        m = paramInt1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                                            if (bool) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                            }
                                            i = m - 1;
                                            for (i3 = (m - 1); i3 > 0; i3--) {
                                                d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(i - 1 + paramInt4)];
                                                i += -1;
                                            }
                                            paramArrayOfDouble2[(m - 1 + paramInt4)] = d;
                                            m += -1;
                                        }
                                    } else {
                                        n = i1 + (paramInt1 - 1) * paramInt5;
                                        m = paramInt1;
                                        for (i2 = -paramInt1; i2 > 0; i2--) {
                                            d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                                            k = n;
                                            if (bool) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                            }
                                            i = m - 1;
                                            for (i3 = (m - 1); i3 > 0; i3--) {
                                                k -= paramInt5;
                                                d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(k - 1 + paramInt4)];
                                                i += -1;
                                            }
                                            paramArrayOfDouble2[(n - 1 + paramInt4)] = d;
                                            n -= paramInt5;
                                            m += -1;
                                        }
                                    }
                                } else {
                                    if ((paramInt5 == 1)) {
                                        m = 1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                                            if (bool) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                            }
                                            i = m + 1;
                                            for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                                d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(i - 1 + paramInt4)];
                                                i++;
                                            }
                                            paramArrayOfDouble2[(m - 1 + paramInt4)] = d;
                                            m++;
                                        }
                                    } else {
                                        n = i1;
                                        m = 1;
                                        for (i2 = paramInt1; i2 > 0; i2--) {
                                            d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                                            k = n;
                                            if (bool) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                                            }
                                            i = m + 1;
                                            for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                                k += paramInt5;
                                                d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(k - 1 + paramInt4)];
                                                i++;
                                            }
                                            paramArrayOfDouble2[(n - 1 + paramInt4)] = d;
                                            n += paramInt5;
                                            m++;
                                        }
                                    }
                                }
                            }
                        }

                        public dtrmm(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasOrientationType, paramString3: util.maths.structure.blas.KBlasTransposeType, paramString4: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var bool1: boolean = false;
                            var bool2: boolean = false;
                            var bool3: boolean = false;
                            bool1 = paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT);
                            if (bool1) {
                                n = paramInt1;
                            } else {
                                n = paramInt2;
                            }
                            bool2 = paramString4.equals(util.maths.structure.blas.KBlasUnitType.NONUNIT);
                            bool3 = paramString2.equals(util.maths.structure.blas.KBlasOrientationType.UPPER);
                            var i1: number;
                            var i2: number;
                            if ((paramDouble == 0)) {
                                k = 1;
                                for (i1 = paramInt2; i1 > 0; i1--) {
                                    i = 1;
                                    for (i2 = paramInt1; i2 > 0; i2--) {
                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = 0.0;
                                        i++;
                                    }
                                    k++;
                                }
                                return;
                            }
                            var i3: number;
                            if (bool1) {
                                if (paramString3.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    if (bool3) {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            m = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    i = 1;
                                                    for (i3 = m - 1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                        i++;
                                                    }
                                                    if (bool2) {
                                                        d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    }
                                                    paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                                                }
                                                m++;
                                            }
                                            k++;
                                        }
                                    } else {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            m = paramInt1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                                                    if (bool2) {
                                                        paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    }
                                                    i = m + 1;
                                                    for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                        i++;
                                                    }
                                                }
                                                m += -1;
                                            }
                                            k++;
                                        }
                                    }
                                } else {
                                    if (bool3) {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            i = paramInt1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                d = paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                if (bool2) {
                                                    d *= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                                }
                                                m = 1;
                                                for (i3 = i - 1; i3 > 0; i3--) {
                                                    d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    m++;
                                                }
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * d);
                                                i += -1;
                                            }
                                            k++;
                                        }
                                    } else {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            i = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                d = paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                if (bool2) {
                                                    d *= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                                }
                                                m = i + 1;
                                                for (i3 = paramInt1 - (i + 1) + 1; i3 > 0; i3--) {
                                                    d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    m++;
                                                }
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * d);
                                                i++;
                                            }
                                            k++;
                                        }
                                    }
                                }
                            } else {
                                if (paramString3.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    if (bool3) {
                                        k = paramInt2;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            d = paramDouble;
                                            if (bool2) {
                                                d *= paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                                            }
                                            i = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                i++;
                                            }
                                            m = 1;
                                            for (i2 = k - 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                m++;
                                            }
                                            k += -1;
                                        }
                                    } else {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            d = paramDouble;
                                            if (bool2) {
                                                d *= paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                                            }
                                            i = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                i++;
                                            }
                                            m = k + 1;
                                            for (i2 = paramInt2 - (k + 1) + 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                m++;
                                            }
                                            k++;
                                        }
                                    }
                                } else {
                                    if (bool3) {
                                        m = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            k = 1;
                                            for (i2 = m - 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                k++;
                                            }
                                            d = paramDouble;
                                            if (bool2) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                            }
                                            if ((d != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m++;
                                        }
                                    } else {
                                        m = paramInt2;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            k = m + 1;
                                            for (i2 = paramInt2 - (m + 1) + 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramDouble * paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                k++;
                                            }
                                            d = paramDouble;
                                            if (bool2) {
                                                d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                            }
                                            if ((d != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m += -1;
                                        }
                                    }
                                }
                            }
                        }

                        public dtrtri(paramString1: util.maths.structure.blas.KBlasOrientationType, paramString2: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void {
                            var bool1: boolean = false;
                            var bool2: boolean = false;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            paramintW[0] = 0;
                            bool2 = paramString1.equals(util.maths.structure.blas.KBlasOrientationType.UPPER);
                            bool1 = paramString2.equals(util.maths.structure.blas.KBlasUnitType.NONUNIT);
                            if ((((!bool2)) && ((!paramString1.equals(util.maths.structure.blas.KBlasOrientationType.LOWER))) ? 1 : 0) != 0) {
                                paramintW[0] = -1;
                            } else {
                                if ((((!bool1)) && ((!paramString2.equals(util.maths.structure.blas.KBlasUnitType.UNIT))) ? 1 : 0) != 0) {
                                    paramintW[0] = -2;
                                } else {
                                    if ((paramInt1 < 0)) {
                                        paramintW[0] = -3;
                                    } else {
                                        if ((paramInt3 < Math.max(1, paramInt1))) {
                                            paramintW[0] = -5;
                                        }
                                    }
                                }
                            }
                            if ((paramintW[0] != 0)) {
                                return;
                            }
                            if ((paramInt1 == 0)) {
                                return;
                            }
                            var n: number;
                            if (bool1) {
                                paramintW[0] = 1;
                                for (n = paramInt1; n > 0; n--) {
                                    if ((paramArrayOfDouble[(paramintW[0] - 1 + (paramintW[0] - 1) * paramInt3 + paramInt2)] == 0)) {
                                        return;
                                    }
                                    paramintW[0]++;
                                }
                                paramintW[0] = 0;
                            }
                            k = this.ilaenv(1, "DTRTRI", "", paramInt1, -1, -1, -1);
                            if (((k >= paramInt1))) {
                                this.dtrti2(paramString1, paramString2, paramInt1, paramArrayOfDouble, paramInt2, paramInt3, paramintW);
                            } else {
                                if (bool2) {
                                    i = 1;
                                    for (n = <number>this.floorDiv((paramInt1 - 1 + k), k); n > 0; n--) {
                                        j = Math.min(k, paramInt1 - i + 1);
                                        this.dtrmm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, j, 1.0, paramArrayOfDouble, paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, paramInt3);
                                        this.dtrsm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.UPPER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, j, -1.0, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, paramInt3);
                                        this.dtrti2(util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, j, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramintW);
                                        i += k;
                                    }
                                } else {
                                    m = this.floorDiv((paramInt1 - 1), k) * k + 1;
                                    i = m;
                                    for (n = this.floorDiv((1 - m + -k), -k); n > 0; n--) {
                                        j = Math.min(k, paramInt1 - i + 1);
                                        if ((i + j <= paramInt1)) {
                                            this.dtrmm(util.maths.structure.blas.KBlasSideType.LEFT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i - j + 1, j, 1.0, paramArrayOfDouble, i + j - 1 + (i + j - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + j - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3);
                                            this.dtrsm(util.maths.structure.blas.KBlasSideType.RIGHT, util.maths.structure.blas.KBlasOrientationType.LOWER, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i - j + 1, j, -1.0, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + j - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3);
                                        }
                                        this.dtrti2(util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, j, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramintW);
                                        i += -k;
                                    }
                                }
                            }
                        }

                        public dgemv(paramString: util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var i2: number = 0;
                            var i3: number = 0;
                            var i4: number = 0;
                            var i5: number = 0;
                            var i6: number = 0;
                            if (paramString.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                i5 = paramInt2;
                                i6 = paramInt1;
                            } else {
                                i5 = paramInt1;
                                i6 = paramInt2;
                            }
                            if ((paramInt6 > 0)) {
                                i3 = 1;
                            } else {
                                i3 = 1 - (i5 - 1) * paramInt6;
                            }
                            if ((paramInt8 > 0)) {
                                i4 = 1;
                            } else {
                                i4 = 1 - (i6 - 1) * paramInt8;
                            }
                            var i7: number;
                            if ((paramDouble2 != 1.0)) {
                                if ((paramInt8 == 1)) {
                                    if ((paramDouble2 == 0)) {
                                        i = 1;
                                        for (i7 = i6; i7 > 0; i7--) {
                                            paramArrayOfDouble3[(i - 1 + paramInt7)] = 0.0;
                                            i++;
                                        }
                                    } else {
                                        i = 1;
                                        for (i7 = i6; i7 > 0; i7--) {
                                            paramArrayOfDouble3[(i - 1 + paramInt7)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + paramInt7)]);
                                            i++;
                                        }
                                    }
                                } else {
                                    m = i4;
                                    if ((paramDouble2 == 0)) {
                                        i = 1;
                                        for (i7 = i6; i7 > 0; i7--) {
                                            paramArrayOfDouble3[(m - 1 + paramInt7)] = 0.0;
                                            m += paramInt8;
                                            i++;
                                        }
                                    } else {
                                        i = 1;
                                        for (i7 = i6; i7 > 0; i7--) {
                                            paramArrayOfDouble3[(m - 1 + paramInt7)] = (paramDouble2 * paramArrayOfDouble3[(m - 1 + paramInt7)]);
                                            m += paramInt8;
                                            i++;
                                        }
                                    }
                                }
                            }
                            if ((paramDouble1 == 0)) {
                                return;
                            }
                            var i8: number;
                            if (paramString.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                i1 = i3;
                                if ((paramInt8 == 1)) {
                                    n = 1;
                                    for (i7 = paramInt2; i7 > 0; i7--) {
                                        if ((paramArrayOfDouble2[(i1 - 1 + paramInt5)] != 0.0)) {
                                            d = paramDouble1 * paramArrayOfDouble2[(i1 - 1 + paramInt5)];
                                            i = 1;
                                            for (i8 = paramInt1; i8 > 0; i8--) {
                                                paramArrayOfDouble3[(i - 1 + paramInt7)] += d * paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)];
                                                i++;
                                            }
                                        }
                                        i1 += paramInt6;
                                        n++;
                                    }
                                } else {
                                    n = 1;
                                    for (i7 = paramInt2; i7 > 0; i7--) {
                                        if ((paramArrayOfDouble2[(i1 - 1 + paramInt5)] != 0.0)) {
                                            d = paramDouble1 * paramArrayOfDouble2[(i1 - 1 + paramInt5)];
                                            m = i4;
                                            i = 1;
                                            for (i8 = paramInt1; i8 > 0; i8--) {
                                                paramArrayOfDouble3[(m - 1 + paramInt7)] += d * paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)];
                                                m += paramInt8;
                                                i++;
                                            }
                                        }
                                        i1 += paramInt6;
                                        n++;
                                    }
                                }
                            } else {
                                i2 = i4;
                                if ((paramInt6 == 1)) {
                                    n = 1;
                                    for (i7 = paramInt2; i7 > 0; i7--) {
                                        d = 0.0;
                                        i = 1;
                                        for (i8 = paramInt1; i8 > 0; i8--) {
                                            d += paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + paramInt5)];
                                            i++;
                                        }
                                        paramArrayOfDouble3[(i2 - 1 + paramInt7)] += paramDouble1 * d;
                                        i2 += paramInt8;
                                        n++;
                                    }
                                } else {
                                    n = 1;
                                    for (i7 = paramInt2; i7 > 0; i7--) {
                                        d = 0.0;
                                        k = i3;
                                        i = 1;
                                        for (i8 = paramInt1; i8 > 0; i8--) {
                                            d += paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(k - 1 + paramInt5)];
                                            k += paramInt6;
                                            i++;
                                        }
                                        paramArrayOfDouble3[(i2 - 1 + paramInt7)] += paramDouble1 * d;
                                        i2 += paramInt8;
                                        n++;
                                    }
                                }
                            }
                        }

                        private ilaenv(i: number, dgetrf: string, s: string, paramInt1: number, paramInt2: number, i1: number, i2: number): number {
                            return 64;
                        }

                        public dger(paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            if ((paramInt6 > 0)) {
                                n = 1;
                            } else {
                                n = 1 - (paramInt2 - 1) * paramInt6;
                            }
                            var i2: number;
                            var i3: number;
                            if ((paramInt4 == 1)) {
                                m = 1;
                                for (i2 = paramInt2; i2 > 0; i2--) {
                                    if ((paramArrayOfDouble2[(n - 1 + paramInt5)] != 0.0)) {
                                        d = paramDouble * paramArrayOfDouble2[(n - 1 + paramInt5)];
                                        i = 1;
                                        for (i3 = paramInt1; i3 > 0; i3--) {
                                            paramArrayOfDouble3[(i - 1 + (m - 1) * paramInt8 + paramInt7)] += paramArrayOfDouble1[(i - 1 + paramInt3)] * d;
                                            i++;
                                        }
                                    }
                                    n += paramInt6;
                                    m++;
                                }
                            } else {
                                if ((paramInt4 > 0)) {
                                    i1 = 1;
                                } else {
                                    i1 = 1 - (paramInt1 - 1) * paramInt4;
                                }
                                m = 1;
                                for (i2 = paramInt2; i2 > 0; i2--) {
                                    if ((paramArrayOfDouble2[(n - 1 + paramInt5)] != 0.0)) {
                                        d = paramDouble * paramArrayOfDouble2[(n - 1 + paramInt5)];
                                        k = i1;
                                        i = 1;
                                        for (i3 = paramInt1; i3 > 0; i3--) {
                                            paramArrayOfDouble3[(i - 1 + (m - 1) * paramInt8 + paramInt7)] += paramArrayOfDouble1[(k - 1 + paramInt3)] * d;
                                            k += paramInt4;
                                            i++;
                                        }
                                    }
                                    n += paramInt6;
                                    m++;
                                }
                            }
                        }

                        public idamax(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            k = 0;
                            if (((paramInt3 <= 0))) {
                                return k;
                            }
                            k = 1;
                            if ((paramInt1 == 1)) {
                                return k;
                            }
                            var m: number;
                            if ((paramInt3 == 1)) {
                                d = Math.abs(paramArrayOfDouble[(paramInt2)]);
                                i = 2;
                                for (m = paramInt1 - 1; m > 0; m--) {
                                    if ((Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]) > d)) {
                                        k = i;
                                        d = Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]);
                                    }
                                    i++;
                                }
                            } else {
                                j = 1;
                                d = Math.abs(paramArrayOfDouble[(paramInt2)]);
                                j += paramInt3;
                                i = 2;
                                for (m = paramInt1 - 1; m > 0; m--) {
                                    if ((Math.abs(paramArrayOfDouble[(j - 1 + paramInt2)]) > d)) {
                                        k = i;
                                        d = Math.abs(paramArrayOfDouble[(j - 1 + paramInt2)]);
                                    }
                                    j += paramInt3;
                                    i++;
                                }
                            }
                            return k;
                        }

                        public dswap(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            if ((paramInt1 <= 0)) {
                                return;
                            }
                            var i1: number;
                            if (((paramInt5 == 1) ? 1 : 0) != 0) {
                                m = paramInt1 % 3;
                                if ((m != 0)) {
                                    i = 1;
                                    for (i1 = m; i1 > 0; i1--) {
                                        d = paramArrayOfDouble1[(i - 1 + paramInt2)];
                                        paramArrayOfDouble1[(i - 1 + paramInt2)] = paramArrayOfDouble2[(i - 1 + paramInt4)];
                                        paramArrayOfDouble2[(i - 1 + paramInt4)] = d;
                                        i++;
                                    }
                                    if ((paramInt1 < 3)) {
                                        return;
                                    }
                                }
                                n = m + 1;
                                i = n;
                                for (i1 = this.floorDiv((paramInt1 - n + 3), 3); i1 > 0; i1--) {
                                    d = paramArrayOfDouble1[(i - 1 + paramInt2)];
                                    paramArrayOfDouble1[(i - 1 + paramInt2)] = paramArrayOfDouble2[(i - 1 + paramInt4)];
                                    paramArrayOfDouble2[(i - 1 + paramInt4)] = d;
                                    d = paramArrayOfDouble1[(i + paramInt2)];
                                    paramArrayOfDouble1[(i + paramInt2)] = paramArrayOfDouble2[(i + paramInt4)];
                                    paramArrayOfDouble2[(i + paramInt4)] = d;
                                    d = paramArrayOfDouble1[(i + 1 + paramInt2)];
                                    paramArrayOfDouble1[(i + 1 + paramInt2)] = paramArrayOfDouble2[(i + 1 + paramInt4)];
                                    paramArrayOfDouble2[(i + 1 + paramInt4)] = d;
                                    i += 3;
                                }
                            } else {
                                j = 1;
                                k = 1;
                                if ((paramInt3 < 0)) {
                                    j = (-paramInt1 + 1) * paramInt3 + 1;
                                }
                                if ((paramInt5 < 0)) {
                                    k = (-paramInt1 + 1) * paramInt5 + 1;
                                }
                                i = 1;
                                for (i1 = paramInt1; i1 > 0; i1--) {
                                    d = paramArrayOfDouble1[(j - 1 + paramInt2)];
                                    paramArrayOfDouble1[(j - 1 + paramInt2)] = paramArrayOfDouble2[(k - 1 + paramInt4)];
                                    paramArrayOfDouble2[(k - 1 + paramInt4)] = d;
                                    j += paramInt3;
                                    k += paramInt5;
                                    i++;
                                }
                            }
                        }

                        public dscal(paramInt1: number, paramDouble: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number;
                            if ((paramInt3 == 1)) {
                                j = paramInt1 % 5;
                                if ((j != 0)) {
                                    i = 1;
                                    for (n = j; n > 0; n--) {
                                        paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                                        i++;
                                    }
                                    if ((paramInt1 < 5)) {
                                        return;
                                    }
                                }
                                k = j + 1;
                                i = k;
                                for (n = this.floorDiv((paramInt1 - k + 5), 5); n > 0; n--) {
                                    paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                                    paramArrayOfDouble[(i + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + paramInt2)]);
                                    paramArrayOfDouble[(i + 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 1 + paramInt2)]);
                                    paramArrayOfDouble[(i + 2 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 2 + paramInt2)]);
                                    paramArrayOfDouble[(i + 3 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 3 + paramInt2)]);
                                    i += 5;
                                }
                            } else {
                                m = paramInt1 * paramInt3;
                                i = 1;
                                for (n = this.floorDiv((m - 1 + paramInt3), paramInt3); n > 0; n--) {
                                    paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                                    i += paramInt3;
                                }
                            }
                        }

                        public dgetf2(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            info[0] = 0;
                            if ((paramInt1 < 0)) {
                                info[0] = -1;
                            } else {
                                if ((paramInt2 < 0)) {
                                    info[0] = -2;
                                } else {
                                    if ((paramInt4 < Math.max(1, paramInt1))) {
                                        info[0] = -4;
                                    }
                                }
                            }
                            if ((info[0] != 0)) {
                                return;
                            }
                            if (((paramInt2 == 0))) {
                                return;
                            }
                            d = util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                            j = 1;
                            for (var m: number = Math.min(paramInt1, paramInt2); m > 0; m--) {
                                k = j - 1 + this.idamax(paramInt1 - j + 1, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, 1);
                                paramArrayOfInt[(j - 1 + paramInt5)] = k;
                                if ((paramArrayOfDouble[(k - 1 + (j - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                    if ((k != j)) {
                                        this.dswap(paramInt2, paramArrayOfDouble, j - 1 + paramInt3, paramInt4, paramArrayOfDouble, k - 1 + paramInt3, paramInt4);
                                    }
                                    if ((j < paramInt1)) {
                                        if ((Math.abs(paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)]) >= d)) {
                                            this.dscal(paramInt1 - j, 1.0 / paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)], paramArrayOfDouble, j + (j - 1) * paramInt4 + paramInt3, 1);
                                        } else {
                                            i = 1;
                                            for (var n: number = paramInt1 - j; n > 0; n--) {
                                                paramArrayOfDouble[(j + i - 1 + (j - 1) * paramInt4 + paramInt3)] /= paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)];
                                                i++;
                                            }
                                        }
                                    }
                                } else {
                                    if ((info[0] == 0)) {
                                        info[0] = j;
                                    }
                                }
                                if ((j < Math.min(paramInt1, paramInt2))) {
                                    this.dger(paramInt1 - j, paramInt2 - j, -1.0, paramArrayOfDouble, j + (j - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble, j - 1 + (j) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j + (j) * paramInt4 + paramInt3, paramInt4);
                                }
                                j++;
                            }
                        }

                        public dlaswp(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramInt4: number, paramInt5: number, paramArrayOfInt: Int32Array, paramInt6: number, paramInt7: number): void {
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var i1: number = 0;
                            var i2: number = 0;
                            var i3: number = 0;
                            var i4: number = 0;
                            var i5: number = 0;
                            var d: number = 0.0;
                            if ((paramInt7 > 0)) {
                                i2 = paramInt4;
                                j = paramInt4;
                                k = paramInt5;
                                m = 1;
                            } else {
                                if ((paramInt7 < 0)) {
                                    i2 = 1 + (1 - paramInt5) * paramInt7;
                                    j = paramInt5;
                                    k = paramInt4;
                                    m = -1;
                                } else {
                                    return;
                                }
                            }
                            i5 = this.floorDiv(paramInt1, 32) * 32;
                            var i6: number;
                            var i7: number;
                            if ((i5 != 0)) {
                                i3 = 1;
                                for (i6 = this.floorDiv((i5 - 1 + 32), 32); i6 > 0; i6--) {
                                    i1 = i2;
                                    i = j;
                                    for (i7 = this.floorDiv((k - j + m), m); i7 > 0; i7--) {
                                        n = paramArrayOfInt[(i1 - 1 + paramInt6)];
                                        if ((n != i)) {
                                            i4 = i3;
                                            for (var i8: number = i3 + 31 - i3 + 1; i8 > 0; i8--) {
                                                d = paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                                                paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)] = paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                                                paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)] = d;
                                                i4++;
                                            }
                                        }
                                        i1 += paramInt7;
                                        i += m;
                                    }
                                    i3 += 32;
                                }
                            }
                            if ((i5 != paramInt1)) {
                                i5++;
                                i1 = i2;
                                i = j;
                                for (i6 = this.floorDiv((k - j + m), m); i6 > 0; i6--) {
                                    n = paramArrayOfInt[(i1 - 1 + paramInt6)];
                                    if ((n != i)) {
                                        i4 = i5;
                                        for (i7 = paramInt1 - i5 + 1; i7 > 0; i7--) {
                                            d = paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                                            paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)] = paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                                            paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)] = d;
                                            i4++;
                                        }
                                    }
                                    i1 += paramInt7;
                                    i += m;
                                }
                            }
                        }

                        public dtrsm(paramString1: util.maths.structure.blas.KBlasSideType, paramString2: util.maths.structure.blas.KBlasOrientationType, paramString3: util.maths.structure.blas.KBlasTransposeType, paramString4: util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void {
                            var d: number = 0.0;
                            var i: number = 0;
                            var j: number = 0;
                            var k: number = 0;
                            var m: number = 0;
                            var n: number = 0;
                            var bool1: boolean = false;
                            var bool2: boolean = false;
                            var bool3: boolean = false;
                            bool1 = paramString1.equals(util.maths.structure.blas.KBlasSideType.LEFT);
                            if (bool1) {
                                n = paramInt1;
                            } else {
                                n = paramInt2;
                            }
                            bool2 = paramString4.equals(util.maths.structure.blas.KBlasUnitType.NONUNIT);
                            bool3 = paramString2.equals(util.maths.structure.blas.KBlasOrientationType.UPPER);
                            var i1: number;
                            var i2: number;
                            if ((paramDouble == 0)) {
                                k = 1;
                                for (i1 = paramInt2; i1 > 0; i1--) {
                                    i = 1;
                                    for (i2 = paramInt1; i2 > 0; i2--) {
                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = 0.0;
                                        i++;
                                    }
                                    k++;
                                }
                                return;
                            }
                            var i3: number;
                            if (bool1) {
                                if (paramString3.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    if (bool3) {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m = paramInt1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                                    if (bool2) {
                                                        paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] /= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    }
                                                    i = 1;
                                                    for (i3 = m - 1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                        i++;
                                                    }
                                                }
                                                m += -1;
                                            }
                                            k++;
                                        }
                                    } else {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                                    if (bool2) {
                                                        paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] /= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    }
                                                    i = m + 1;
                                                    for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                        i++;
                                                    }
                                                }
                                                m++;
                                            }
                                            k++;
                                        }
                                    }
                                } else {
                                    if (bool3) {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            i = 1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                d = paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                m = 1;
                                                for (i3 = i - 1; i3 > 0; i3--) {
                                                    d -= paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    m++;
                                                }
                                                if (bool2) {
                                                    d /= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                                }
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                                                i++;
                                            }
                                            k++;
                                        }
                                    } else {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            i = paramInt1;
                                            for (i2 = paramInt1; i2 > 0; i2--) {
                                                d = paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                m = i + 1;
                                                for (i3 = paramInt1 - i; i3 > 0; i3--) {
                                                    d -= paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                                    m++;
                                                }
                                                if (bool2) {
                                                    d /= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                                                }
                                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                                                i += -1;
                                            }
                                            k++;
                                        }
                                    }
                                }
                            } else {
                                if (paramString3.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    if (bool3) {
                                        k = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m = 1;
                                            for (i2 = k - 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                m++;
                                            }
                                            if (bool2) {
                                                d = 1.0 / paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            k++;
                                        }
                                    } else {
                                        k = paramInt2;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m = k + 1;
                                            for (i2 = paramInt2 - (k + 1) + 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                m++;
                                            }
                                            if (bool2) {
                                                d = 1.0 / paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            k += -1;
                                        }
                                    }
                                } else {
                                    if (bool3) {
                                        m = paramInt2;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if (bool2) {
                                                d = 1.0 / paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            k = 1;
                                            for (i2 = m - 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                k++;
                                            }
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m += -1;
                                        }
                                    } else {
                                        m = 1;
                                        for (i1 = paramInt2; i1 > 0; i1--) {
                                            if (bool2) {
                                                d = 1.0 / paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            k = m + 1;
                                            for (i2 = paramInt2 - (m + 1) + 1; i2 > 0; i2--) {
                                                if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                                    d = paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                                    i = 1;
                                                    for (i3 = paramInt1; i3 > 0; i3--) {
                                                        paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                                        i++;
                                                    }
                                                }
                                                k++;
                                            }
                                            if ((paramDouble != 1.0)) {
                                                i = 1;
                                                for (i2 = paramInt1; i2 > 0; i2--) {
                                                    paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                                    i++;
                                                }
                                            }
                                            m++;
                                        }
                                    }
                                }
                            }
                        }

                        private floorDiv(x: number, y: number): number {
                            return Math.floor(x/y);
                        }

                    }

                }
            }
            export namespace impl {
                export class Array1D implements util.maths.structure.KArray1D {

                    private _size: number;
                    private _offset: number;
                    private _segmentIndex: number;
                    private _segment: memory.chunk.KObjectChunk;
                    private _metaClass: meta.KMetaClass;
                    constructor(p_size: number, p_offset: number, p_segmentIndex: number, p_segment: memory.chunk.KObjectChunk, p_metaClass: meta.KMetaClass) {
                        this._size = p_size;
                        this._offset = p_offset;
                        this._segmentIndex = p_segmentIndex;
                        this._segment = p_segment;
                        this._metaClass = p_metaClass;
                    }

                    public size(): number {
                        return this._size;
                    }

                    public get(p_index: number): number {
                        return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + p_index, this._metaClass);
                    }

                    public set(p_index: number, p_value: number): number {
                        this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + p_index, p_value, this._metaClass);
                        return p_value;
                    }

                    public add(index: number, value: number): number {
                        return this.set(index, this.get(index) + value);
                    }

                    public addAll(value: number): void {
                        for (var i: number = 0; i < this._size; i++) {
                            this.add(i, value);
                        }
                    }

                    public setAll(value: number): void {
                    }

                    public addElement(index: number, numElem: number): void {
                    }

                    public clone(): util.maths.structure.KArray1D {
                        return null;
                    }

                    public data(): Float64Array {
                        return this._segment.getDoubleArray(this._segmentIndex, this._metaClass);
                    }

                    public setData(data: Float64Array): void {
                    }

                }

                export class Array2D implements util.maths.structure.KArray2D {

                    private _nbRows: number;
                    private _nbColumns: number;
                    private _offset: number;
                    private _segmentIndex: number;
                    private _segment: memory.chunk.KObjectChunk;
                    private _metaClass: meta.KMetaClass;
                    constructor(p_nbRows: number, p_nbColumns: number, p_offset: number, p_segmentIndex: number, p_segment: memory.chunk.KObjectChunk, p_metaClass: meta.KMetaClass) {
                        this._nbRows = p_nbRows;
                        this._nbColumns = p_nbColumns;
                        this._offset = p_offset;
                        this._segment = p_segment;
                        this._segmentIndex = p_segmentIndex;
                        this._metaClass = p_metaClass;
                    }

                    public rows(): number {
                        return this._nbRows;
                    }

                    public columns(): number {
                        return this._nbColumns;
                    }

                    private getIndex(p_rowIndex: number, p_columnIndex: number): number {
                        return this._offset + p_rowIndex + (this._nbRows * p_columnIndex);
                    }

                    public get(p_rowIndex: number, p_columnIndex: number): number {
                        return this._segment.getDoubleArrayElem(this._segmentIndex, this.getIndex(p_rowIndex, p_columnIndex), this._metaClass);
                    }

                    public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                        this._segment.setDoubleArrayElem(this._segmentIndex, this.getIndex(p_rowIndex, p_columnIndex), value, this._metaClass);
                        return value;
                    }

                    public add(rowIndex: number, columnIndex: number, value: number): number {
                        return this.set(rowIndex, columnIndex, this.get(rowIndex, columnIndex) + value);
                    }

                    public setAll(value: number): void {
                        for (var i: number = 0; i < this._nbColumns * this._nbRows; i++) {
                            this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + i, value, this._metaClass);
                        }
                    }

                    public addRow(rowindex: number, numRow: number): void {
                    }

                    public addCol(colIndex: number, numCol: number): void {
                    }

                    public clone(): util.maths.structure.KArray2D {
                        var cloned: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(this._nbRows, this._nbColumns);
                        cloned.setData(this.data());
                        return cloned;
                    }

                    public data(): Float64Array {
                        return this._segment.getDoubleArray(this._segmentIndex, this._metaClass);
                    }

                    public setData(p_data: Float64Array): void {
                        for (var i: number = 0; i < p_data.length; i++) {
                            this.setAtIndex(i, p_data[i]);
                        }
                    }

                    public getAtIndex(index: number): number {
                        return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + index, this._metaClass);
                    }

                    public setAtIndex(index: number, value: number): number {
                        this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + index, value, this._metaClass);
                        return value;
                    }

                    public addAtIndex(index: number, value: number): number {
                        return this.setAtIndex(index, this.getAtIndex(index) + value);
                    }

                }

                export class NativeArray2D implements util.maths.structure.KArray2D {

                    private _nbRows: number;
                    private _nbColumns: number;
                    private _back: Float64Array;
                    constructor(p_nbRows: number, p_nbColumns: number) {
                        this._nbRows = p_nbRows;
                        this._nbColumns = p_nbColumns;
                        this._back = new Float64Array(p_nbRows * p_nbColumns);
                    }

                    private getIndex(p_rowIndex: number, p_columnIndex: number): number {
                        return p_rowIndex + (this._nbRows * p_columnIndex);
                    }

                    public rows(): number {
                        return this._nbRows;
                    }

                    public columns(): number {
                        return this._nbColumns;
                    }

                    public get(p_rowIndex: number, p_columnIndex: number): number {
                        return this._back[this.getIndex(p_rowIndex, p_columnIndex)];
                    }

                    public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                        this._back[this.getIndex(p_rowIndex, p_columnIndex)] = value;
                        return value;
                    }

                    public add(rowIndex: number, columnIndex: number, value: number): number {
                        return this.set(rowIndex, columnIndex, this.get(rowIndex, columnIndex) + value);
                    }

                    public setAll(value: number): void {
                    }

                    public addRow(rowindex: number, numRow: number): void {
                    }

                    public addCol(colIndex: number, numCol: number): void {
                    }

                    public clone(): util.maths.structure.KArray2D {
                        var newArr: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(this._nbRows, this._nbColumns);
                        java.lang.System.arraycopy(this._back, 0, newArr._back, 0, this._nbColumns * this._nbRows);
                        return newArr;
                    }

                    public data(): Float64Array {
                        return this._back;
                    }

                    public setData(data: Float64Array): void {
                        this._back = data;
                    }

                    public getAtIndex(index: number): number {
                        return this._back[index];
                    }

                    public setAtIndex(index: number, value: number): number {
                        this._back[index] = value;
                        return value;
                    }

                    public addAtIndex(index: number, value: number): number {
                        this._back[index] += value;
                        return this._back[index];
                    }

                }

            }
            export namespace matrix {
                export class MatrixOperations {

                    public static BLOCK_WIDTH: number = 60;
                    public static TRANSPOSE_SWITCH: number = 375;
                    public static leadingDimension(matA: util.maths.structure.KArray2D): number {
                        return Math.max(matA.columns(), matA.rows());
                    }

                    public static multiply(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                        var matC: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(matA.rows(), matB.columns());
                        blas.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matC.rows(), matC.columns(), matA.columns(), 1.0, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), 0.0, matC.data(), 0, matC.rows());
                        return matC;
                    }

                    public static multiplyTransposeAlpha(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, alpha: number, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                        if (util.maths.structure.matrix.MatrixOperations.testDimensionsAB(transA, transB, matA, matB)) {
                            var k: number = 0;
                            var dimC: Int32Array = new Int32Array(2);
                            if (transA.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                k = matA.columns();
                                if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    dimC[0] = matA.rows();
                                    dimC[1] = matB.columns();
                                } else {
                                    dimC[0] = matA.rows();
                                    dimC[1] = matB.rows();
                                }
                            } else {
                                k = matA.rows();
                                if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                    dimC[0] = matA.columns();
                                    dimC[1] = matB.columns();
                                } else {
                                    dimC[0] = matA.columns();
                                    dimC[1] = matB.rows();
                                }
                            }
                            var matC: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(dimC[0], dimC[1]);
                            blas.dgemm(transA, transB, matC.rows(), matC.columns(), k, alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), 0, matC.data(), 0, matC.rows());
                            return matC;
                        } else {
                            throw new Error("Dimensions mismatch between A,B and C");
                        }
                    }

                    public static multiplyAlphaBetaResult(alpha: number, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, beta: number, matC: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): void {
                        if (util.maths.structure.matrix.MatrixOperations.testDimensionsABC(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matA, matB, matC)) {
                            blas.dgemm(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matC.rows(), matC.columns(), matA.columns(), alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), beta, matC.data(), 0, matC.rows());
                        } else {
                            throw new Error("Dimensions mismatch between A,B and C");
                        }
                    }

                    public static multiplyTransposeAlphaBetaResult(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, alpha: number, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, beta: number, matC: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): void {
                        if (util.maths.structure.matrix.MatrixOperations.testDimensionsABC(transA, transB, matA, matB, matC)) {
                            var k: number;
                            if (transA.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                k = matA.columns();
                            } else {
                                k = matA.rows();
                            }
                            blas.dgemm(transA, transB, matC.rows(), matC.columns(), k, alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), beta, matC.data(), 0, matC.rows());
                        } else {
                            throw new Error("Dimensions mismatch between A,B and C");
                        }
                    }

                    public static testDimensionsABC(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, matC: util.maths.structure.KArray2D): boolean {
                        if (transA.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                            if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                return (matA.columns() == matB.rows() && matC.rows() == matA.rows() && matC.columns() == matB.columns());
                            } else {
                                return (matA.columns() == matB.columns() && matC.rows() == matA.rows() && matC.columns() == matB.rows());
                            }
                        } else {
                            if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                return (matA.rows() == matB.rows() && matC.rows() == matA.columns() && matC.columns() == matB.columns());
                            } else {
                                return (matA.rows() == matB.columns() && matC.rows() == matA.columns() && matC.columns() == matB.rows());
                            }
                        }
                    }

                    public static testDimensionsAB(transA: util.maths.structure.blas.KBlasTransposeType, transB: util.maths.structure.blas.KBlasTransposeType, matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D): boolean {
                        if (transA.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                            if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                return (matA.columns() == matB.rows());
                            } else {
                                return (matA.columns() == matB.columns());
                            }
                        } else {
                            if (transB.equals(util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                                return (matA.rows() == matB.rows());
                            } else {
                                return (matA.rows() == matB.columns());
                            }
                        }
                    }

                    public static initMatrice(matA: util.maths.structure.KArray2D, random: boolean): void {
                        var rand: java.util.Random = new java.util.Random();
                        var k: number = 0;
                        for (var j: number = 0; j < matA.columns(); j++) {
                            for (var i: number = 0; i < matA.rows(); i++) {
                                if (random) {
                                    matA.set(i, j, rand.nextDouble() * 100 - 50);
                                } else {
                                    matA.set(i, j, k);
                                }
                                k++;
                            }
                        }
                    }

                    public static random(rows: number, columns: number): util.maths.structure.KArray2D {
                        var res: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(rows, columns);
                        var rand: java.util.Random = new java.util.Random();
                        for (var i: number = 0; i < rows * columns; i++) {
                            res.setAtIndex(i, rand.nextDouble() * 100 - 50);
                        }
                        return res;
                    }

                    public static invert(mat: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                        if (mat.rows() != mat.columns()) {
                            return null;
                        }
                        var alg: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                        var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                        var A_temp: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                        java.lang.System.arraycopy(mat.data(), 0, A_temp.data(), 0, mat.columns() * mat.rows());
                        var dlu: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(A_temp.rows(), A_temp.columns());
                        if (dlu.invert(A_temp, blas)) {
                            result.setData(A_temp.data());
                            return result;
                        } else {
                            return null;
                        }
                    }

                    public static invertInPlace(mat: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): boolean {
                        if (mat.rows() != mat.columns()) {
                            return false;
                        }
                        var alg: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                        var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                        var dlu: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                        return dlu.invert(mat, blas);
                    }

                    public static scale(alpha: number, matA: util.maths.structure.KArray2D): void {
                        if (alpha == 0) {
                            matA.setAll(0);
                            return;
                        }
                        for (var i: number = 0; i < matA.rows() * matA.columns(); i++) {
                            matA.setAtIndex(i, alpha * matA.getAtIndex(i));
                        }
                    }

                    public static transpose(matA: util.maths.structure.KArray2D): util.maths.structure.KArray2D {
                        var result: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(matA.columns(), matA.rows());
                        if (matA.columns() == matA.rows()) {
                            util.maths.structure.matrix.MatrixOperations.transposeSquare(matA, result);
                        } else {
                            if (matA.columns() > MatrixOperations.TRANSPOSE_SWITCH && matA.rows() > MatrixOperations.TRANSPOSE_SWITCH) {
                                util.maths.structure.matrix.MatrixOperations.transposeBlock(matA, result);
                            } else {
                                util.maths.structure.matrix.MatrixOperations.transposeStandard(matA, result);
                            }
                        }
                        return result;
                    }

                    private static transposeSquare(matA: util.maths.structure.KArray2D, result: util.maths.structure.KArray2D): void {
                        var index: number = 1;
                        var indexEnd: number = matA.columns();
                        for (var i: number = 0; i < matA.rows(); i++) {
                            var indexOther: number = (i + 1) * matA.columns() + i;
                            var n: number = i * (matA.columns() + 1);
                            result.setAtIndex(n, matA.getAtIndex(n));
                            for (; index < indexEnd; index++) {
                                result.setAtIndex(index, matA.getAtIndex(indexOther));
                                result.setAtIndex(indexOther, matA.getAtIndex(index));
                                indexOther += matA.columns();
                            }
                            index += i + 2;
                            indexEnd += matA.columns();
                        }
                    }

                    private static transposeStandard(matA: util.maths.structure.KArray2D, result: util.maths.structure.KArray2D): void {
                        var index: number = 0;
                        for (var i: number = 0; i < result.columns(); i++) {
                            var index2: number = i;
                            var end: number = index + result.rows();
                            while (index < end){
                                result.setAtIndex(index++, matA.getAtIndex(index2));
                                index2 += matA.rows();
                            }
                        }
                    }

                    private static transposeBlock(matA: util.maths.structure.KArray2D, result: util.maths.structure.KArray2D): void {
                        for (var j: number = 0; j < matA.columns(); j += MatrixOperations.BLOCK_WIDTH) {
                            var blockWidth: number = Math.min(MatrixOperations.BLOCK_WIDTH, matA.columns() - j);
                            var indexSrc: number = j * matA.rows();
                            var indexDst: number = j;
                            for (var i: number = 0; i < matA.rows(); i += MatrixOperations.BLOCK_WIDTH) {
                                var blockHeight: number = Math.min(MatrixOperations.BLOCK_WIDTH, matA.rows() - i);
                                var indexSrcEnd: number = indexSrc + blockHeight;
                                for (; indexSrc < indexSrcEnd; indexSrc++) {
                                    var colSrc: number = indexSrc;
                                    var colDst: number = indexDst;
                                    var end: number = colDst + blockWidth;
                                    for (; colDst < end; colDst++) {
                                        result.setAtIndex(colDst, matA.getAtIndex(colSrc));
                                        colSrc += matA.rows();
                                    }
                                    indexDst += result.rows();
                                }
                            }
                        }
                    }

                    public static createIdentity(width: number): util.maths.structure.KArray2D {
                        var ret: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(width, width);
                        ret.setAll(0);
                        for (var i: number = 0; i < width; i++) {
                            ret.set(i, i, 1);
                        }
                        return ret;
                    }

                    public static solve(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D, workInPlace: boolean, transB: util.maths.structure.blas.KBlasTransposeType, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                        if (!workInPlace) {
                            var A_temp: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(matA.rows(), matA.columns());
                            java.lang.System.arraycopy(matA.data(), 0, A_temp.data(), 0, matA.columns() * matA.rows());
                            var dlu: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(A_temp.rows(), A_temp.columns());
                            dlu.factor(A_temp, blas);
                            if (dlu.isSingular()) {
                                return null;
                            }
                            var B_temp: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(matB.rows(), matB.columns());
                            java.lang.System.arraycopy(matB.data(), 0, B_temp.data(), 0, matB.columns() * matB.rows());
                            dlu.transSolve(B_temp, transB, blas);
                            return B_temp;
                        } else {
                            var dlu: util.maths.structure.matrix.solver.LU = new util.maths.structure.matrix.solver.LU(matA.rows(), matA.columns());
                            dlu.factor(matA, blas);
                            if (dlu.isSingular()) {
                                return null;
                            }
                            dlu.transSolve(matB, transB, blas);
                            return matB;
                        }
                    }

                    public static compareMatrix(matA: util.maths.structure.KArray2D, matB: util.maths.structure.KArray2D): number {
                        var err: number = 0;
                        for (var i: number = 0; i < matA.rows(); i++) {
                            for (var j: number = 0; j < matA.columns(); j++) {
                                if (err < Math.abs(matA.get(i, j) - matB.get(i, j))) {
                                    err = Math.abs(matA.get(i, j) - matB.get(i, j));
                                }
                            }
                        }
                        return err;
                    }

                }

                export namespace solver {
                    export class LU {

                        private LU: util.maths.structure.KArray2D;
                        private piv: Int32Array;
                        private singular: boolean;
                        public getLU(): util.maths.structure.KArray2D {
                            return this.LU;
                        }

                        constructor(m: number, n: number) {
                            this.LU = new util.maths.structure.impl.NativeArray2D(m, n);
                            this.piv = new Int32Array(Math.min(m, n));
                        }

                        public static factorize(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.LU {
                            return new util.maths.structure.matrix.solver.LU(A.rows(), A.columns()).factor(A, blas);
                        }

                        public factor(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.LU {
                            this.singular = false;
                            var info: Int32Array = new Int32Array(1);
                            info[0] = 0;
                            blas.dgetrf(A.rows(), A.columns(), A.data(), 0, A.rows(), this.piv, 0, info);
                            if (info[0] > 0) {
                                this.singular = true;
                            } else {
                                if (info[0] < 0) {
                                    throw new Error();
                                }
                            }
                            this.LU.setData(A.data());
                            return this;
                        }

                        public getLower(): util.maths.structure.KArray2D {
                            var numRows: number = this.LU.rows();
                            var numCols: number = this.LU.rows() < this.LU.columns() ? this.LU.rows() : this.LU.columns();
                            var lower: util.maths.structure.impl.NativeArray2D = new util.maths.structure.impl.NativeArray2D(numRows, numCols);
                            for (var i: number = 0; i < numCols; i++) {
                                lower.set(i, i, 1.0);
                                for (var j: number = 0; j < i; j++) {
                                    lower.set(i, j, this.LU.get(i, j));
                                }
                            }
                            if (numRows > numCols) {
                                for (var i: number = numCols; i < numRows; i++) {
                                    for (var j: number = 0; j < numCols; j++) {
                                        lower.set(i, j, this.LU.get(i, j));
                                    }
                                }
                            }
                            return lower;
                        }

                        public getUpper(): util.maths.structure.KArray2D {
                            var numRows: number = this.LU.rows() < this.LU.columns() ? this.LU.rows() : this.LU.columns();
                            var numCols: number = this.LU.columns();
                            var upper: util.maths.structure.KArray2D = new util.maths.structure.impl.NativeArray2D(numRows, numCols);
                            for (var i: number = 0; i < numRows; i++) {
                                for (var j: number = i; j < numCols; j++) {
                                    upper.set(i, j, this.LU.get(i, j));
                                }
                            }
                            return upper;
                        }

                        public getPivots(): Int32Array {
                            return this.piv;
                        }

                        public isSingular(): boolean {
                            return this.singular;
                        }

                        public solve(B: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                            return this.transSolve(B, util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, blas);
                        }

                        public transSolve(B: util.maths.structure.KArray2D, trans: util.maths.structure.blas.KBlasTransposeType, blas: util.maths.structure.blas.KBlas): util.maths.structure.KArray2D {
                            if (B.rows() != this.LU.rows()) {
                                throw new Error("B.numRows() != LU.numRows()");
                            }
                            var info: Int32Array = new Int32Array(1);
                            blas.dgetrs(trans, this.LU.rows(), B.columns(), this.LU.data(), 0, this.LU.rows(), this.piv, 0, B.data(), 0, this.LU.rows(), info);
                            if (info[0] < 0) {
                                throw new Error();
                            }
                            return B;
                        }

                        public invert(A: util.maths.structure.KArray2D, blas: util.maths.structure.blas.KBlas): boolean {
                            var info: Int32Array = new Int32Array(1);
                            info[0] = 0;
                            blas.dgetrf(A.rows(), A.columns(), A.data(), 0, A.rows(), this.piv, 0, info);
                            if (info[0] > 0) {
                                this.singular = true;
                                return false;
                            } else {
                                if (info[0] < 0) {
                                    throw new Error();
                                }
                            }
                            var lwork: number = A.rows() * A.rows();
                            var work: Float64Array = new Float64Array(lwork);
                            for (var i: number = 0; i < lwork; i++) {
                                work[i] = 0;
                            }
                            blas.dgetri(A.rows(), A.data(), 0, A.rows(), this.piv, 0, work, 0, lwork, info);
                            if (info[0] != 0) {
                                return false;
                            } else {
                                return true;
                            }
                        }

                    }

                    export class QR {

                        private Q: util.maths.structure.KArray2D;
                        private R: util.maths.structure.KArray2D;
                        public m: number;
                        public n: number;
                        public k: number;
                        public work: Float64Array;
                        public workGen: Float64Array;
                        public tau: Float64Array;
                        constructor(rows: number, columns: number) {
                            if (columns > rows) {
                                throw new Error("n > m");
                            }
                            this.m = rows;
                            this.n = columns;
                            this.k = Math.min(this.m, this.n);
                            this.tau = new Float64Array(this.k);
                            this.R = new util.maths.structure.impl.NativeArray2D(this.m, this.n);
                        }

                        public static factorize(A: util.maths.structure.KArray2D, workInPlace: boolean, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.QR {
                            return new util.maths.structure.matrix.solver.QR(A.rows(), A.columns()).factor(A, workInPlace, blas);
                        }

                        public factor(matA: util.maths.structure.KArray2D, workInPlace: boolean, blas: util.maths.structure.blas.KBlas): util.maths.structure.matrix.solver.QR {
                            var A: util.maths.structure.KArray2D;
                            if (!workInPlace) {
                                A = matA.clone();
                            } else {
                                A = matA;
                            }
                            var lwork: number;
                            this.work = new Float64Array(1);
                            var info: Int32Array = new Int32Array(1);
                            info[0] = 0;
                            blas.dgeqrf(this.m, this.n, new Float64Array(0), 0, this.m, new Float64Array(0), 0, this.work, 0, -1, info);
                            if (info[0] != 0) {
                                lwork = this.n;
                            } else {
                                lwork = <number>this.work[0];
                            }
                            lwork = Math.max(1, lwork);
                            this.work = new Float64Array(lwork);
                            this.workGen = new Float64Array(1);
                            var info: Int32Array = new Int32Array(1);
                            info[0] = 0;
                            blas.dorgqr(this.m, this.n, this.k, new Float64Array(0), 0, this.m, new Float64Array(0), 0, this.workGen, 0, -1, info);
                            if (info[0] != 0) {
                                lwork = this.n;
                            } else {
                                lwork = <number>this.workGen[0];
                            }
                            lwork = Math.max(1, lwork);
                            this.workGen = new Float64Array(lwork);
                            var info: Int32Array = new Int32Array(1);
                            info[0] = 0;
                            blas.dgeqrf(this.m, this.n, A.data(), 0, this.m, this.tau, 0, this.work, 0, this.work.length, info);
                            if (info[0] < 0) {
                                throw new Error("" + info[0]);
                            }
                            for (var col: number = 0; col < A.columns(); col++) {
                                for (var row: number = 0; row <= col; row++) {
                                    this.R.set(row, col, A.get(row, col));
                                }
                            }
                            info[0] = 0;
                            blas.dorgqr(this.m, this.n, this.k, A.data(), 0, this.m, this.tau, 0, this.workGen, 0, this.workGen.length, info);
                            if (info[0] < 0) {
                                throw new Error();
                            }
                            this.Q = A;
                            return this;
                        }

                        public getR(): util.maths.structure.KArray2D {
                            return this.R;
                        }

                        public getQ(): util.maths.structure.KArray2D {
                            return this.Q;
                        }

                    }

                }
            }
        }
    }
}