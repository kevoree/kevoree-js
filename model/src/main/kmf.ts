import * as java from './java';

export namespace org {
  export namespace kevoree {
    export namespace modeling {
      export namespace infer {
        export class KInferAlgFactory {
          public static build(name: string): org.kevoree.modeling.infer.KInferAlg {
            if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "BinaryPerceptron")) {
              return new org.kevoree.modeling.infer.impl.BinaryPerceptronAlg();
            } else {
              if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "LinearRegression")) {
                return new org.kevoree.modeling.infer.impl.LinearRegressionAlg();
              } else {
                if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "KMeanCluster")) {
                  return new org.kevoree.modeling.infer.impl.KMeanClusterAlg();
                } else {
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "GaussianProfiler")) {
                    return new org.kevoree.modeling.infer.impl.GaussianProfiler();
                  } else {
                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "GaussianClassifier")) {
                      return new org.kevoree.modeling.infer.impl.GaussianClassifierAlg();
                    } else {
                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "GaussianAnomalyDetection")) {
                        return new org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg();
                      } else {
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "Winnow")) {
                          return new org.kevoree.modeling.infer.impl.WinnowAlg();
                        } else {
                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "EmptyInfer")) {
                            return new org.kevoree.modeling.infer.impl.EmptyInfer();
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            return null;
          }
        }
        export namespace impl {
          export class LinearRegressionAlg implements org.kevoree.modeling.infer.KInferAlg {
            private alpha: number = 0.005;
            private gamma: number = 0.000;
            private iterations: number = 10;
            private static rand: java.util.Random = new java.util.Random();
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length + 1;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, org.kevoree.modeling.infer.impl.LinearRegressionAlg.rand.nextDouble(), origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var i: number = 0; i < this.iterations; i++) {
                for (var row: number = 0; row < trainingSet.rows(); row++) {
                  var h: number = this.estimate(trainingSet, row, state);
                  var error: number = -this.alpha * (h - expectedResultSet.get(row, 0));
                  for (var feature: number = 0; feature < origin.metaClass().inputs().length; feature++) {
                    state.set(feature, state.get(feature) * (1 - this.alpha * this.gamma) + error * trainingSet.get(row, feature));
                  }
                  state.add(origin.metaClass().inputs().length, error);
                }
              }
            }
            private estimate(training: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
              var result: number = 0;
              for (var i: number = 0; i < training.columns(); i++) {
                result = result + training.get(row, i) * state.get(i);
              }
              result = result + state.get(training.columns());
              return result;
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length + 1;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var results: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var i: number = 0; i < features.rows(); i++) {
                results.set(i, 0, this.estimate(features, i, state));
              }
              return results;
            }
          }
          export class WinnowAlg implements org.kevoree.modeling.infer.KInferAlg {
            private alpha: number = 2;
            private beta: number = 2;
            private iterations: number = 1;
            private rand: java.util.Random = new java.util.Random();
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved()));
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble(), origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var iter: number = 0; iter < this.iterations; iter++) {
                for (var inst: number = 0; inst < trainingSet.rows(); inst++) {
                  if (this.calculate(trainingSet, inst, state) == expectedResultSet.get(inst, 0)) {
                    continue;
                  }
                  if (expectedResultSet.get(inst, 0) == 0) {
                    for (var i: number = 0; i < size; i++) {
                      state.set(i, state.get(i) / this.beta);
                    }
                  } else {
                    for (var i: number = 0; i < size; i++) {
                      state.set(i, state.get(i) * this.alpha);
                    }
                  }
                }
              }
            }
            private calculate(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
              var result: number = 0;
              for (var i: number = 0; i < features.columns(); i++) {
                result += state.get(i) * features.get(row, i);
              }
              if (result >= features.columns()) {
                return 1.0;
              } else {
                return 0.0;
              }
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved()));
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var inst: number = 0; inst < features.rows(); inst++) {
                result.set(inst, 0, this.calculate(features, inst, state));
              }
              return result;
            }
          }
          export class GaussianProfiler implements org.kevoree.modeling.infer.KInferAlg {
            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            public maxTimeSlots: number = 24;
            private getIndex(input: number, output: number, field: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              return output * (org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1) + 1) + org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS * input + field;
            }
            private getCounter(output: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              return output * (org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1) + 1) + org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS * (meta.origin().inputs().length - 1);
            }
            public getAvg(output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(this.getCounter(output, meta));
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  avg[i] = state.get(this.getIndex(i, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUM, meta)) / total;
                }
              }
              return avg;
            }
            public getVariance(output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, avg: Float64Array, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(this.getCounter(output, meta));
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  variances[i] = state.get(this.getIndex(i, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                }
              }
              return variances;
            }
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResult: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dep: org.kevoree.modeling.meta.KMetaDependencies = origin.metaClass().dependencies();
              var dependenciesIndex: number = dep.index();
              var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS + 1);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(dep.index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, dep.index(), ks, origin.metaClass());
              for (var i: number = 0; i < trainingSet.rows(); i++) {
                var output: number = <number>trainingSet.get(i, 0);
                for (var j: number = 1; j < origin.metaClass().inputs().length; j++) {
                  if (state.get(this.getCounter(output, dep)) == 0) {
                    state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                  } else {
                    if (trainingSet.get(i, j) < state.get(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep))) {
                      state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                    }
                    if (trainingSet.get(i, j) > state.get(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep))) {
                      state.set(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                    }
                    state.add(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                    state.add(this.getIndex(j - 1, output, org.kevoree.modeling.infer.impl.GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                  }
                  if (state.get(this.getCounter(this.maxTimeSlots, dep)) == 0) {
                    state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                    state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                  } else {
                    if (trainingSet.get(i, j) < state.get(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep))) {
                      state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep), trainingSet.get(i, j));
                    }
                    if (trainingSet.get(i, j) > state.get(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep))) {
                      state.set(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep), trainingSet.get(i, j));
                    }
                    state.add(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.SUM, dep), trainingSet.get(i, j));
                    state.add(this.getIndex(j - 1, this.maxTimeSlots, org.kevoree.modeling.infer.impl.GaussianProfiler.SUMSQUARE, dep), trainingSet.get(i, j) * trainingSet.get(i, j));
                  }
                }
                state.add(this.getCounter(output, dep), 1);
                state.add(this.getCounter(this.maxTimeSlots, dep), 1);
              }
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dep: org.kevoree.modeling.meta.KMetaDependencies = origin.metaClass().dependencies();
              var dependenciesIndex: number = dep.index();
              var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * org.kevoree.modeling.infer.impl.GaussianProfiler.NUMOFFIELDS + 1);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, dep.index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var j: number = 0; j < features.rows(); j++) {
                var output: number = <number>features.get(j, 0);
                var values: Float64Array = new Float64Array(features.columns() - 1);
                for (var i: number = 0; i < features.columns() - 1; i++) {
                  values[i] = features.get(j, i + 1);
                }
                if (values[0] >= 0) {
                  result.set(j, 0, this.getProba(values, output, state, dep));
                } else {
                  if (values[0] == -1) {
                    result.set(j, 0, this.getAvg(output, state, dep)[0]);
                  } else {
                    if (values[0] == -2) {
                      result.set(j, 0, state.get(this.getIndex(0, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MIN, dep)));
                    } else {
                      if (values[0] == -3) {
                        result.set(j, 0, state.get(this.getIndex(0, output, org.kevoree.modeling.infer.impl.GaussianProfiler.MAX, dep)));
                      }
                    }
                  }
                }
              }
              return result;
            }
            public getProba(features: Float64Array, output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              var prob: number = 0;
              var avg: Float64Array = this.getAvg(output, state, meta);
              var variance: Float64Array = this.getVariance(output, state, avg, meta);
              prob = org.kevoree.modeling.util.maths.Distribution.gaussian(features, avg, variance);
              return prob;
            }
          }
          export class BinaryPerceptronAlg implements org.kevoree.modeling.infer.KInferAlg {
            private iterations: number = 5;
            private alpha: number = 1;
            private rand: java.util.Random = new java.util.Random();
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length + 1;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble() * 0.1, origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var iter: number = 0; iter < this.iterations; iter++) {
                for (var row: number = 0; row < trainingSet.rows(); row++) {
                  var h: number = this.sigmoid(trainingSet, row, state);
                  var error: number = this.alpha * (expectedResultSet.get(row, 0) - h);
                  for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                    state.add(j, error * trainingSet.get(row, j));
                  }
                  state.add(origin.metaClass().inputs().length, error);
                }
              }
            }
            private addUp(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
              var res: number = 0;
              for (var i: number = 0; i < features.columns(); i++) {
                res = res + state.get(i) * features.get(row, i);
              }
              res = res + state.get(features.columns());
              return res;
            }
            private sigmoid(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
              return 1 / (1 + Math.exp(-this.addUp(features, row, state)));
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = origin.metaClass().inputs().length + 1;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var inst: number = 0; inst < features.rows(); inst++) {
                if (this.sigmoid(features, inst, state) >= 0.5) {
                  result.set(inst, 0, 1.0);
                } else {
                  result.set(inst, 0, 0);
                }
              }
              return result;
            }
          }
          export class EmptyInfer implements org.kevoree.modeling.infer.KInferAlg {
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {}
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var res: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), currentInferObject.metaClass().outputs().length);
              for (var i: number = 0; i < res.rows() * res.columns(); i++) {
                res.setAtIndex(i, 42);
              }
              return res;
            }
          }
          export class KMeanClusterAlg implements org.kevoree.modeling.infer.KInferAlg {
            private k: number = 3;
            private iterations: number = 100;
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              if (trainingSet.rows() < this.k) {
                throw new Error("training setPrimitiveType not enough");
              }
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = this.k * origin.metaClass().inputs().length;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < this.k; i++) {
                  for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                    ks.setDoubleArrayElem(dependenciesIndex, j + i * origin.metaClass().inputs().length, trainingSet.get(i, j), origin.metaClass());
                  }
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var iter: number = 0; iter < this.iterations; iter++) {
                var temporalClassification: number;
                var centroids: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(this.k, origin.metaClass().inputs().length);
                var counters: Int32Array = new Int32Array(this.k);
                for (var i: number = 0; i < trainingSet.rows(); i++) {
                  temporalClassification = this.classify(trainingSet, i, state);
                  for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                    centroids.add(temporalClassification, j, trainingSet.get(i, j));
                  }
                  counters[temporalClassification]++;
                }
                for (var i: number = 0; i < this.k; i++) {
                  if (counters[i] != 0) {
                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                      state.set(j + i * origin.metaClass().inputs().length, centroids.get(i, j) / counters[i]);
                    }
                  } else {
                    var rand: java.util.Random = new java.util.Random();
                    var pos: number = rand.nextInt(trainingSet.rows());
                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                      state.set(j + i * origin.metaClass().inputs().length, trainingSet.get(pos, j));
                    }
                  }
                }
              }
            }
            private classify(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
              var maxdistance: number = -1;
              var classNum: number = -1;
              for (var i: number = 0; i < this.k; i++) {
                var currentdist: number = 0;
                for (var j: number = 0; j < features.columns(); j++) {
                  currentdist += (features.get(row, j) - state.get(i * features.columns() + j)) * (features.get(row, j) - state.get(i * features.columns() + j));
                }
                if (maxdistance < 0) {
                  maxdistance = currentdist;
                  classNum = i;
                } else {
                  if (currentdist < maxdistance) {
                    maxdistance = currentdist;
                    classNum = i;
                  }
                }
              }
              return classNum;
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = this.k * origin.metaClass().inputs().length;
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var inst: number = 0; inst < features.rows(); inst++) {
                result.set(inst, 0, this.classify(features, inst, state));
              }
              return result;
            }
          }
          export class StatInferAlg implements org.kevoree.modeling.infer.KInferAlg {
            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQuare: number = 3;
            private static NUMOFFIELDS: number = 4;
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(dependenciesIndex, org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1, origin.metaClass());
                for (var i: number = 0; i < org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS * trainingSet.columns() + 1, 0, dependenciesIndex, ks, origin.metaClass());
              for (var i: number = 0; i < trainingSet.rows(); i++) {
                for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                  if (state.get(org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS * trainingSet.columns()) == 0) {
                    state.set(org.kevoree.modeling.infer.impl.StatInferAlg.MIN + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    state.set(org.kevoree.modeling.infer.impl.StatInferAlg.MAX + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    state.set(org.kevoree.modeling.infer.impl.StatInferAlg.SUM + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    state.set(org.kevoree.modeling.infer.impl.StatInferAlg.SUMSQuare + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                  } else {
                    if (trainingSet.get(i, j) < state.get(org.kevoree.modeling.infer.impl.StatInferAlg.MIN + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS)) {
                      state.set(org.kevoree.modeling.infer.impl.StatInferAlg.MIN + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    }
                    if (trainingSet.get(i, j) > state.get(org.kevoree.modeling.infer.impl.StatInferAlg.MAX + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS)) {
                      state.set(org.kevoree.modeling.infer.impl.StatInferAlg.MAX + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    }
                    state.add(org.kevoree.modeling.infer.impl.StatInferAlg.SUM + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                    state.add(org.kevoree.modeling.infer.impl.StatInferAlg.SUMSQuare + j * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                  }
                }
                state.add(org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length, 1);
              }
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var tempres: Float64Array = this.getAvgAll(ks, origin.metaClass().dependencies());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, tempres.length);
              for (var i: number = 0; i < tempres.length; i++) {
                result.set(0, i, tempres[i]);
              }
              return result;
            }
            public getAvgAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var result: Float64Array = new Float64Array(meta.origin().inputs().length);
              for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                result[i] = this.getAvg(i, ks, meta);
              }
              return result;
            }
            public getMinAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var result: Float64Array = new Float64Array(meta.origin().inputs().length);
              for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                result[i] = this.getMin(i, ks, meta);
              }
              return result;
            }
            public getMaxAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var result: Float64Array = new Float64Array(meta.origin().inputs().length);
              for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                result[i] = this.getMax(i, ks, meta);
              }
              return result;
            }
            public getVarianceAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies, avgs: Float64Array): Float64Array {
              var result: Float64Array = new Float64Array(meta.origin().inputs().length);
              for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                result[i] = this.getVariance(i, ks, meta, avgs[i]);
              }
              return result;
            }
            public getAvg(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                return 0;
              }
              var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
              if (count == 0) {
                return 0;
              }
              return ks.getDoubleArrayElem(meta.index(), featureNum * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.StatInferAlg.SUM, meta.origin()) / count;
            }
            public getMin(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                return 0;
              }
              var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
              if (count == 0) {
                return 0;
              }
              return ks.getDoubleArrayElem(meta.index(), featureNum * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.StatInferAlg.MIN, meta.origin());
            }
            public getMax(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                return 0;
              }
              var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
              if (count == 0) {
                return 0;
              }
              return ks.getDoubleArrayElem(meta.index(), featureNum * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.StatInferAlg.MAX, meta.origin());
            }
            public getVariance(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies, avg: number): number {
              if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                return 0;
              }
              var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
              if (count == 0) {
                return 0;
              }
              return ks.getDoubleArrayElem(meta.index(), featureNum * org.kevoree.modeling.infer.impl.StatInferAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.StatInferAlg.SUMSQuare, meta.origin()) / count - avg * avg;
            }
          }
          export class GaussianAnomalyDetectionAlg implements org.kevoree.modeling.infer.KInferAlg {
            private _alpha: number = 0.5;
            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            public getProba(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              var prob: number = 0;
              var avg: Float64Array = this.getAvg(state, meta);
              var variance: Float64Array = this.getVariance(state, avg, meta);
              prob = org.kevoree.modeling.util.maths.Distribution.gaussianArray(features, row, avg, variance);
              return prob;
            }
            public getAvg(state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(meta.origin().inputs().length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS);
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  avg[i] = state.get(org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS * i + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUM) / total;
                }
              }
              return avg;
            }
            public getVariance(state: org.kevoree.modeling.util.maths.structure.KArray1D, avg: Float64Array, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(meta.origin().inputs().length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS);
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  variances[i] = state.get(org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS * i + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUMSQUARE) / total - avg[i] * avg[i];
                }
              }
              return variances;
            }
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var alpha: number = <number>origin.getByName("alpha");
              if (alpha == null) {
                alpha = this._alpha;
              }
              var length: number = origin.metaClass().inputs().length;
              var size: number = (length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 2);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var i: number = 0; i < trainingSet.rows(); i++) {
                var output: number = <number>expectedResultSet.get(i, 0);
                if (output == 0) {
                  for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                    if (state.get(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS) == 0) {
                      state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MIN, trainingSet.get(i, j));
                      state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MAX, trainingSet.get(i, j));
                      state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUM, trainingSet.get(i, j));
                      state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUMSQUARE, trainingSet.get(i, j) * trainingSet.get(i, j));
                    } else {
                      if (trainingSet.get(i, j) < state.get(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MIN)) {
                        state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MIN, trainingSet.get(i, j));
                      }
                      if (trainingSet.get(i, j) > state.get(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MAX)) {
                        state.set(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.MAX, trainingSet.get(i, j));
                      }
                      state.add(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUM, trainingSet.get(i, j));
                      state.add(j * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.SUMSQUARE, trainingSet.get(i, j) * trainingSet.get(i, j));
                    }
                  }
                  state.add(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS, 1);
                  var newEpsilon: number = this.getProba(trainingSet, i, state, origin.metaClass().dependencies());
                  var epsilon: number = state.get(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
                  if (newEpsilon < epsilon) {
                    state.set(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1, epsilon + alpha * (newEpsilon - epsilon));
                  }
                } else {
                  var newEpsilon: number = this.getProba(trainingSet, i, state, origin.metaClass().dependencies());
                  var epsilon: number = state.get(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
                  if (newEpsilon > epsilon) {
                    state.set(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1, epsilon + alpha * (newEpsilon - epsilon));
                  }
                }
              }
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var length: number = origin.metaClass().inputs().length;
              var size: number = (length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 2);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              var epsilon: number = state.get(length * org.kevoree.modeling.infer.impl.GaussianAnomalyDetectionAlg.NUMOFFIELDS + 1);
              for (var i: number = 0; i < features.rows(); i++) {
                if (this.getProba(features, i, state, origin.metaClass().dependencies()) >= epsilon) {
                  result.set(i, 0, 0);
                } else {
                  result.set(i, 0, 1);
                }
              }
              return result;
            }
          }
          export class GaussianClassifierAlg implements org.kevoree.modeling.infer.KInferAlg {
            private static MIN: number = 0;
            private static MAX: number = 1;
            private static SUM: number = 2;
            private static SUMSQUARE: number = 3;
            private static NUMOFFIELDS: number = 4;
            private getIndex(input: number, output: number, field: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              return output * (org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS * input + field;
            }
            private getCounter(output: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              return output * (org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length;
            }
            public getAvg(output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(this.getCounter(output, meta));
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  avg[i] = state.get(this.getIndex(i, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUM, meta)) / total;
                }
              }
              return avg;
            }
            public getVariance(output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, avg: Float64Array, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
              var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
              var total: number = state.get(this.getCounter(output, meta));
              if (total != 0) {
                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                  variances[i] = state.get(this.getIndex(i, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                }
              }
              return variances;
            }
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
              var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS + 1);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                for (var i: number = 0; i < size; i++) {
                  ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                }
              }
              var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              for (var i: number = 0; i < trainingSet.rows(); i++) {
                var output: number = <number>expectedResultSet.get(i, 0);
                for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                  if (state.get(this.getCounter(output, origin.metaClass().dependencies())) == 0) {
                    state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                  } else {
                    if (trainingSet.get(i, j) < state.get(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                      state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    }
                    if (trainingSet.get(i, j) > state.get(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                      state.set(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    }
                    state.add(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.add(this.getIndex(j, output, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                  }
                  if (state.get(this.getCounter(maxOutput, origin.metaClass().dependencies())) == 0) {
                    state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                  } else {
                    if (trainingSet.get(i, j) < state.get(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                      state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    }
                    if (trainingSet.get(i, j) > state.get(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                      state.set(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    }
                    state.add(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                    state.add(this.getIndex(j, maxOutput, org.kevoree.modeling.infer.impl.GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                  }
                }
                state.add(this.getCounter(output, origin.metaClass().dependencies()), 1);
                state.add(this.getCounter(maxOutput, origin.metaClass().dependencies()), 1);
              }
            }
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
              var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
              var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
              var dependenciesIndex: number = origin.metaClass().dependencies().index();
              var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * org.kevoree.modeling.infer.impl.GaussianClassifierAlg.NUMOFFIELDS + 1);
              if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                return null;
              }
              var state: org.kevoree.modeling.util.maths.structure.KArray1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
              var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.rows(), 1);
              for (var j: number = 0; j < features.rows(); j++) {
                var maxprob: number = 0;
                var prob: number = 0;
                for (var output: number = 0; output < maxOutput; output++) {
                  prob = this.getProba(features, j, output, state, origin.metaClass().dependencies());
                  if (prob > maxprob) {
                    maxprob = prob;
                    result.set(j, 0, output);
                  }
                }
              }
              return result;
            }
            public getProba(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
              var prob: number = 0;
              var avg: Float64Array = this.getAvg(output, state, meta);
              var variance: Float64Array = this.getVariance(output, state, avg, meta);
              prob = org.kevoree.modeling.util.maths.Distribution.gaussianArray(features, row, avg, variance);
              return prob;
            }
            public getAllProba(features: Float64Array, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies, maxOutput: number): Float64Array {
              var results: Float64Array = new Float64Array(maxOutput);
              for (var i: number = 0; i < maxOutput; i++) {
                var avg: Float64Array = this.getAvg(i, state, meta);
                var variance: Float64Array = this.getVariance(i, state, avg, meta);
                results[i] = org.kevoree.modeling.util.maths.Distribution.gaussian(features, avg, variance);
              }
              return results;
            }
          }
          export class RecommendationAlg implements org.kevoree.modeling.infer.KInferAlg {
            public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {}
            public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
              return new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, 1);
            }
          }
        }
        export interface KInferAlg {
          train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void;
          infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D;
        }
      }
      export namespace scheduler {
        export interface KScheduler {
          dispatch(task: org.kevoree.modeling.scheduler.KTask): void;
          start(): void;
          stop(): void;
        }
        export interface KTask {
          run(): void;
        }
        export namespace impl {
          export class AsyncScheduler implements org.kevoree.modeling.scheduler.KScheduler, java.lang.Runnable {
             dispatch = function(task:org.kevoree.modeling.scheduler.KTask){
                  setTimeout(task,0);
             }
             start = function(){
                  //NNOP
             }
             stop = function(){
                  //NOOP
             }
             run = function(){
                 //NOOP
             }
          }
          export class DirectScheduler implements org.kevoree.modeling.scheduler.KScheduler {
            public dispatch(task: org.kevoree.modeling.scheduler.KTask): void {
              task.run();
            }
            public start(): void {}
            public stop(): void {}
          }
        }
      }
      export interface KOperation<SourceObject extends org.kevoree.modeling.KObject, ResultType> {
        on(source: SourceObject, params: any[], result: org.kevoree.modeling.KCallback<ResultType>): void;
      }
      export interface KModel<A extends org.kevoree.modeling.KUniverse<any, any>> {
        key(): number;
        newUniverse(): A;
        universe(key: number): A;
        manager(): org.kevoree.modeling.memory.manager.KDataManager;
        metaModel(): org.kevoree.modeling.meta.KMetaModel;
        defer(): org.kevoree.modeling.defer.KDefer;
        setOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, operation: org.kevoree.modeling.KOperation<any, any>): void;
        setOperationByName(metaClassName: string, metaOperationName: string, operation: org.kevoree.modeling.KOperation<any, any>): void;
        save(callback: org.kevoree.modeling.KCallback<any>): void;
        connect(callback: org.kevoree.modeling.KCallback<any>): void;
        disconnect(callback: org.kevoree.modeling.KCallback<any>): void;
        lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
        lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        createPreparedLookup(size: number): org.kevoree.modeling.KPreparedLookup;
        lookupPrepared(prepared: org.kevoree.modeling.KPreparedLookup, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        createByName(metaClassName: string, universe: number, time: number): org.kevoree.modeling.KObject;
        create(clazz: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number): org.kevoree.modeling.KObject;
        createListener(universe: number): org.kevoree.modeling.KListener;
        createModelContext(): org.kevoree.modeling.KModelContext;
        createTraversal(startingElements: org.kevoree.modeling.KObject[]): org.kevoree.modeling.traversal.KTraversal;
        createReusableTraversal(): org.kevoree.modeling.traversal.KTraversal;
        indexByName(universe: number, time: number, indexName: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObjectIndex>): void;
        find(metaClass: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number, attributes: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
        findByName(indexName: string, universe: number, time: number, attributes: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
        findAll(metaClass: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        findAllByName(indexName: string, universe: number, time: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
      }
      export class KConfig {
        public static CAS_MAX_TRY: number = 1000;
        public static CALLBACK_HISTORY: number = 1000;
        public static LONG_SIZE: number = 53;
        public static PREFIX_SIZE: number = 16;
        public static BEGINNING_OF_TIME: number = -0x001FFFFFFFFFFFFE;
        public static END_OF_TIME: number = 0x001FFFFFFFFFFFFE;
        public static NULL_LONG: number = 0x001FFFFFFFFFFFFF;
        public static KEY_PREFIX_MASK: number = 0x0000001FFFFFFFFF;
        public static KEY_SEP: string = '|';
        public static ELEM_SEP: string = ';';
        public static VAL_SEP: string = ',';
        public static CHUNK_ELEM_SEP: string = '%';
        public static CHUNK_VAL_SEP: string = '$';
        public static CACHE_INIT_SIZE: number = 16;
        public static CACHE_LOAD_FACTOR: number = (<number>75 / <number>100);
      }
      export namespace operation {
        export interface KOperationStrategy {
          invoke(cdn: org.kevoree.modeling.cdn.KContentDeliveryDriver, metaOperation: org.kevoree.modeling.meta.KMetaOperation, source: org.kevoree.modeling.KObject, param: any[], manager: org.kevoree.modeling.operation.KOperationManager, callback: org.kevoree.modeling.KCallback<any>, additionalClassNames: string[]): void;
        }
        export class OperationStrategies {
          public static ONLY_ONE: org.kevoree.modeling.operation.KOperationStrategy = {
            invoke: function (cdn: org.kevoree.modeling.cdn.KContentDeliveryDriver, metaOperation: org.kevoree.modeling.meta.KMetaOperation, source: org.kevoree.modeling.KObject, param: any[], manager: org.kevoree.modeling.operation.KOperationManager, callback: org.kevoree.modeling.KCallback<any>, additionalClassNames: string[]) {
              var operationCall: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
              operationCall.setType(org.kevoree.modeling.message.impl.Message.OPERATION_CALL_TYPE);
              operationCall.setKeys(new Float64Array([source.universe(), source.now(), source.uuid()]));
              operationCall.setClassName(source.metaClass().metaName());
              operationCall.setOperationName(metaOperation.metaName());
              operationCall.setValues(org.kevoree.modeling.operation.OperationStrategies.serializeParam(metaOperation, param));
              operationCall.setValues2(additionalClassNames);
              cdn.sendToPeer(null, operationCall, (message : org.kevoree.modeling.message.KMessage) => {
                if (message.values() != null) {
                  callback(org.kevoree.modeling.operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, message.values()[0]));
                } else {
                  callback(org.kevoree.modeling.operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, null));
                }
              });
            }
          };
          public static serialize(type: number, elem: any, isArray: boolean): string {
            if (isArray) {
              var elements: any[] = <any[]>elem;
              var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
              for (var i: number = 0; i < elements.length; i++) {
                if (i != 0) {
                  builder.append(org.kevoree.modeling.KConfig.KEY_SEP);
                }
                builder.append(org.kevoree.modeling.operation.OperationStrategies.serialize(type, elements[i], false));
              }
              return builder.toString();
            } else {
              switch (type) {
                case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                if (<boolean>elem) {
                  return "1";
                } else {
                  return "0";
                }
                case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                return org.kevoree.modeling.format.json.JsonString.encode(elem.toString());
                case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                return org.kevoree.modeling.util.Base64.encodeDouble(<number>elem);
                case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                return org.kevoree.modeling.util.Base64.encodeInt(<number>elem);
                case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                return org.kevoree.modeling.util.Base64.encodeLong(<number>elem);
                default:
                return org.kevoree.modeling.util.Base64.encodeInt((<org.kevoree.modeling.meta.KLiteral>elem).index());
              }
            }
          }
          public static serializeParam(metaOperation: org.kevoree.modeling.meta.KMetaOperation, param: any[]): string[] {
            var paramTypes: Int32Array = metaOperation.paramTypes();
            var paramIsArray: boolean[] = metaOperation.paramMultiplicities();
            var stringParams: string[] = new Array<string>(paramTypes.length);
            for (var i: number = 0; i < paramTypes.length; i++) {
              stringParams[i] = org.kevoree.modeling.operation.OperationStrategies.serialize(paramTypes[i], param[i], paramIsArray[i]);
            }
            return stringParams;
          }
          public static serializeReturn(metaOperation: org.kevoree.modeling.meta.KMetaOperation, result: any): string {
            return org.kevoree.modeling.operation.OperationStrategies.serialize(metaOperation.returnType(), result, metaOperation.returnTypeIsArray());
          }
          public static unserialize(metaModel: org.kevoree.modeling.meta.KMetaModel, type: number, payload: string, isArray: boolean): any {
            if (isArray) {
              var params: java.util.List<string> = new java.util.ArrayList<string>();
              var i: number = 0;
              var previous: number = 0;
              while (i < payload.length){
                if (payload.charAt(i) == org.kevoree.modeling.KConfig.KEY_SEP) {
                  if (i != previous) {
                    params.add(payload.substring(previous, i));
                  }
                  previous = i + 1;
                }
                i++;
              }
              if (i != previous) {
                params.add(payload.substring(previous, i));
              }
              var result: any[];
              switch (type) {
                case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                result = new Array<boolean>(params.size());
                break;
                case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                result = new Array<string>(params.size());
                break;
                case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                result = new Array<number>(params.size());
                break;
                case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                result = new Array<number>(params.size());
                break;
                case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                result = new Array<number>(params.size());
                break;
                default:
                result = new Array<org.kevoree.modeling.meta.KLiteral>(params.size());
              }
              for (var j: number = 0; j < params.size(); j++) {
                result[j] = org.kevoree.modeling.operation.OperationStrategies.unserialize(metaModel, type, params.get(j), false);
              }
              return result;
            } else {
              switch (type) {
                case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                return org.kevoree.modeling.util.PrimitiveHelper.equals(payload, "1");
                case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                return org.kevoree.modeling.format.json.JsonString.unescape(payload);
                case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                return org.kevoree.modeling.util.Base64.decodeToDouble(payload);
                case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                return org.kevoree.modeling.util.Base64.decodeToInt(payload);
                case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                return org.kevoree.modeling.util.Base64.decodeToLong(payload);
                default:
                var literalIndex: number = org.kevoree.modeling.util.Base64.decodeToInt(payload);
                return metaModel.metaTypes()[type].literal(literalIndex);
              }
            }
          }
          public static unserializeReturn(metaModel: org.kevoree.modeling.meta.KMetaModel, metaOperation: org.kevoree.modeling.meta.KMetaOperation, resultString: string): any {
            if (resultString != null) {
              return org.kevoree.modeling.operation.OperationStrategies.unserialize(metaModel, metaOperation.returnType(), resultString, metaOperation.returnTypeIsArray());
            } else {
              return null;
            }
          }
          public static unserializeParam(metaModel: org.kevoree.modeling.meta.KMetaModel, metaOperation: org.kevoree.modeling.meta.KMetaOperation, param: string[]): any[] {
            var paramTypes: Int32Array = metaOperation.paramTypes();
            var paramMultiplicities: boolean[] = metaOperation.paramMultiplicities();
            var objParam: any[] = new Array<any>(paramTypes.length);
            for (var i: number = 0; i < paramTypes.length; i++) {
              objParam[i] = org.kevoree.modeling.operation.OperationStrategies.unserialize(metaModel, paramTypes[i], param[i], paramMultiplicities[i]);
            }
            return objParam;
          }
          public static NAMED_PEER(peerName: string): org.kevoree.modeling.operation.KOperationStrategy {
            return {
              invoke: function (cdn: org.kevoree.modeling.cdn.KContentDeliveryDriver, metaOperation: org.kevoree.modeling.meta.KMetaOperation, source: org.kevoree.modeling.KObject, param: any[], manager: org.kevoree.modeling.operation.KOperationManager, callback: org.kevoree.modeling.KCallback<any>, additionalClassNames: string[]) {
                var operationCall: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
                operationCall.setType(org.kevoree.modeling.message.impl.Message.OPERATION_CALL_TYPE);
                operationCall.setKeys(new Float64Array([source.universe(), source.now(), source.uuid()]));
                operationCall.setClassName(source.metaClass().metaName());
                operationCall.setOperationName(metaOperation.metaName());
                operationCall.setValues(org.kevoree.modeling.operation.OperationStrategies.serializeParam(metaOperation, param));
                operationCall.setValues2(additionalClassNames);
                cdn.sendToPeer(peerName, operationCall, (message : org.kevoree.modeling.message.KMessage) => {
                  if (message.values() != null) {
                    callback(org.kevoree.modeling.operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, message.values()[0]));
                  } else {
                    callback(org.kevoree.modeling.operation.OperationStrategies.unserializeReturn(source.manager().model().metaModel(), metaOperation, null));
                  }
                });
              }
            };
          }
        }
        export interface KOperationManager {
          register(operation: org.kevoree.modeling.meta.KMetaOperation, callback: org.kevoree.modeling.KOperation<any, any>): void;
          invoke(source: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.meta.KMetaOperation, param: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, callback: org.kevoree.modeling.KCallback<any>): void;
          dispatch(message: org.kevoree.modeling.message.KMessage): void;
          mappings(): string[];
        }
        export namespace impl {
          export class HashOperationManager implements org.kevoree.modeling.operation.KOperationManager {
            private staticOperations: org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>>>;
            private _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
            constructor(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
              this.staticOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>>>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
              this._manager = p_manager;
            }
            public register(operation: org.kevoree.modeling.meta.KMetaOperation, callback: org.kevoree.modeling.KOperation<any, any>): void {
              var clazzOperations: org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>> = this.staticOperations.get(operation.originMetaClassIndex());
              if (clazzOperations == null) {
                clazzOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<org.kevoree.modeling.KOperation<any, any>>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                this.staticOperations.put(operation.originMetaClassIndex(), clazzOperations);
              }
              clazzOperations.put(operation.index(), callback);
            }
            public invoke(source: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.meta.KMetaOperation, param: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, callback: org.kevoree.modeling.KCallback<any>): void {
              if (operation == null) {
                throw new Error("Operation must be defined to invoke an operation");
              }
              var paramTypes: Int32Array = operation.paramTypes();
              if (paramTypes.length != 0) {
                if (paramTypes.length != param.length) {
                  throw new Error("Bad Number of arguments for method " + operation.metaName());
                }
              }
              var clazzOperations: org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>> = this.staticOperations.get(operation.originMetaClassIndex());
              var resolved: org.kevoree.modeling.KOperation<any, any> = null;
              if (clazzOperations != null) {
                resolved = clazzOperations.get(operation.index());
              }
              if (resolved != null) {
                resolved.on(source, param, callback);
              } else {
                var mc: org.kevoree.modeling.meta.KMetaClass = source.metaClass();
                var mm: org.kevoree.modeling.meta.KMetaModel = source.manager().model().metaModel();
                var parentClasses: java.util.ArrayList<string> = null;
                parentClasses = new java.util.ArrayList<string>();
                while (resolved == null && mc != null && mc.metaParents().length > 0){
                  var metaParents: Int32Array = mc.metaParents();
                  var foundParent: number = -1;
                  var i: number = 0;
                  var loopMetaClass: org.kevoree.modeling.meta.KMetaClass = null;
                  var loopMetaOperation: org.kevoree.modeling.meta.KMetaOperation = null;
                  while (i < metaParents.length && foundParent == -1){
                    loopMetaClass = mm.metaClass(metaParents[i]);
                    loopMetaOperation = loopMetaClass.operation(operation.metaName());
                    if (loopMetaOperation != null) {
                      foundParent = i;
                    }
                    i++;
                  }
                  if (foundParent == -1) {
                    mc = null;
                  } else {
                    parentClasses.add(loopMetaClass.metaName());
                    mc = loopMetaClass;
                    clazzOperations = this.staticOperations.get(loopMetaOperation.originMetaClassIndex());
                    resolved = clazzOperations.get(loopMetaOperation.index());
                  }
                }
                if (resolved != null) {
                  resolved.on(source, param, callback);
                } else {
                  var flatted: string[] = parentClasses.toArray(new Array<string>(parentClasses.size()));
                  strategy.invoke(this._manager.cdn(), operation, source, param, this, callback, flatted);
                }
              }
            }
            public dispatch(message: org.kevoree.modeling.message.KMessage): void {
              if (message.type() == org.kevoree.modeling.message.impl.Message.OPERATION_CALL_TYPE) {
                var sourceKey: Float64Array = message.keys();
                var mc: org.kevoree.modeling.meta.KMetaClass = this._manager.model().metaModel().metaClassByName(message.className());
                var mo: org.kevoree.modeling.meta.KMetaOperation = mc.operation(message.operationName());
                var clazzOperations: org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>> = this.staticOperations.get(mc.index());
                var resolved: org.kevoree.modeling.KOperation<any, any> = null;
                if (clazzOperations != null) {
                  resolved = clazzOperations.get(mo.index());
                }
                if (resolved != null) {
                  var finalResolved: org.kevoree.modeling.KOperation<any, any> = resolved;
                  this._manager.lookup(sourceKey[0], sourceKey[1], sourceKey[2], (kObject : org.kevoree.modeling.KObject) => {
                    if (kObject != null) {
                      finalResolved.on(kObject, org.kevoree.modeling.operation.OperationStrategies.unserializeParam(this._manager.model().metaModel(), mo, message.values()), (operationResult : any) => {
                        if (message.id() != null) {
                          var operationResultMessage: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
                          operationResultMessage.setPeer(message.peer());
                          operationResultMessage.setID(message.id());
                          operationResultMessage.setType(org.kevoree.modeling.message.impl.Message.OPERATION_RESULT_TYPE);
                          operationResultMessage.setValues([org.kevoree.modeling.operation.OperationStrategies.serializeReturn(mo, operationResult)]);
                          this._manager.cdn().sendToPeer(message.peer(), operationResultMessage, null);
                        }
                      });
                    } else {
                      if (message.id() != null) {
                        var operationResultMessage: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
                        operationResultMessage.setID(message.id());
                        operationResultMessage.setPeer(message.peer());
                        operationResultMessage.setType(org.kevoree.modeling.message.impl.Message.OPERATION_RESULT_TYPE);
                        operationResultMessage.setValues(null);
                        this._manager.cdn().sendToPeer(message.peer(), operationResultMessage, null);
                      }
                    }
                  });
                } else {
                  if (message.id() != null) {
                    var operationResultMessage: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
                    operationResultMessage.setID(message.id());
                    operationResultMessage.setPeer(message.peer());
                    operationResultMessage.setType(org.kevoree.modeling.message.impl.Message.OPERATION_RESULT_TYPE);
                    operationResultMessage.setValues(null);
                    this._manager.cdn().sendToPeer(message.peer(), operationResultMessage, null);
                  }
                }
              }
            }
            public mappings(): string[] {
              var mappings: java.util.ArrayList<string> = new java.util.ArrayList<string>();
              this.staticOperations.each((key : number, value : org.kevoree.modeling.memory.chunk.KIntMap<org.kevoree.modeling.KOperation<any, any>>) => {
                if (value != null) {
                  var metaClass: org.kevoree.modeling.meta.KMetaClass = this._manager.model().metaModel().metaClass(key);
                  var metaClassName: string = metaClass.metaName();
                  value.each((key : number, value : org.kevoree.modeling.KOperation<any, any>) => {
                    var metaOperation: org.kevoree.modeling.meta.KMetaOperation = <org.kevoree.modeling.meta.KMetaOperation>metaClass.meta(key);
                    mappings.add(metaClassName);
                    mappings.add(metaOperation.metaName());
                  });
                }
              });
              return mappings.toArray(new Array<string>(mappings.size()));
            }
          }
        }
      }
      export namespace traversal {
        export namespace visitor {
          export interface KModelAttributeVisitor {
            visit(metaAttribute: org.kevoree.modeling.meta.KMetaAttribute, value: any): void;
          }
          export interface KModelVisitor {
            visit(elem: org.kevoree.modeling.KObject): org.kevoree.modeling.traversal.visitor.KVisitResult;
          }
          export class KVisitResult {
            public static CONTINUE: KVisitResult = new KVisitResult();
            public static SKIP: KVisitResult = new KVisitResult();
            public static STOP: KVisitResult = new KVisitResult();
            public equals(other: any): boolean {
              return this == other;
            }
            public static _KVisitResultVALUES : KVisitResult[] = [
              KVisitResult.CONTINUE
              ,KVisitResult.SKIP
              ,KVisitResult.STOP
            ];
            public static values():KVisitResult[]{
              return KVisitResult._KVisitResultVALUES;
            }
          }
        }
        export interface KTraversalFilter {
          filter(obj: org.kevoree.modeling.KObject): boolean;
        }
        export interface KTraversalAction {
          chain(next: org.kevoree.modeling.traversal.KTraversalAction): void;
          execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void;
        }
        export namespace query {
          export namespace impl {
            export class QueryEngine implements org.kevoree.modeling.traversal.query.KQueryEngine {
              private static INSTANCE: org.kevoree.modeling.traversal.query.KQueryEngine = null;
              public static OPEN_BRACKET: string = '[';
              public static CLOSE_BRACKET: string = ']';
              public static PIPE_SEP: string = '|';
              public static VAL_SEP: string = "=";
              public static VALS_SEP: string = ',';
              public static getINSTANCE(): org.kevoree.modeling.traversal.query.KQueryEngine {
                if (org.kevoree.modeling.traversal.query.impl.QueryEngine.INSTANCE == null) {
                  org.kevoree.modeling.traversal.query.impl.QueryEngine.INSTANCE = new org.kevoree.modeling.traversal.query.impl.QueryEngine();
                }
                return org.kevoree.modeling.traversal.query.impl.QueryEngine.INSTANCE;
              }
              public eval(query: string, origins: org.kevoree.modeling.KObject[], p_view: org.kevoree.modeling.KView, callback: org.kevoree.modeling.KCallback<any[]>): void {
                if (callback != null) {
                  this.buildTraversal(query).exec(origins, p_view, callback);
                }
              }
              public buildTraversal(query: string): org.kevoree.modeling.traversal.KTraversal {
                if (query == null || query.length == 0) {
                  return null;
                } else {
                  var traversal: org.kevoree.modeling.traversal.KTraversal = new org.kevoree.modeling.traversal.impl.Traversal(null);
                  var i: number = 0;
                  var escaped: boolean = false;
                  var previousKQueryStart: number = 0;
                  var previousKQueryNameEnd: number = -1;
                  var previousKQueryAttributesEnd: number = -1;
                  var previousKQueryAttributesStart: number = 0;
                  var endEval: boolean = false;
                  while (i < query.length && !endEval){
                    var notLastElem: boolean = (i + 1) != query.length;
                    if (escaped && notLastElem) {
                      escaped = false;
                    } else {
                      var currentChar: string = query.charAt(i);
                      if (currentChar == org.kevoree.modeling.traversal.query.impl.QueryEngine.CLOSE_BRACKET && notLastElem) {
                        previousKQueryAttributesEnd = i;
                      } else {
                        if (currentChar == '\\' && notLastElem) {
                          escaped = true;
                        } else {
                          if (currentChar == org.kevoree.modeling.traversal.query.impl.QueryEngine.OPEN_BRACKET && notLastElem) {
                            previousKQueryNameEnd = i;
                            previousKQueryAttributesStart = i + 1;
                          } else {
                            if (currentChar == org.kevoree.modeling.traversal.query.impl.QueryEngine.PIPE_SEP || !notLastElem) {
                              var relationName: string;
                              var atts: string = null;
                              if (previousKQueryNameEnd == -1) {
                                if (notLastElem) {
                                  previousKQueryNameEnd = i;
                                } else {
                                  previousKQueryNameEnd = i + 1;
                                }
                              } else {
                                if (previousKQueryAttributesStart != -1) {
                                  if (previousKQueryAttributesEnd == -1) {
                                    if (notLastElem || currentChar == org.kevoree.modeling.traversal.query.impl.QueryEngine.PIPE_SEP || currentChar == org.kevoree.modeling.traversal.query.impl.QueryEngine.CLOSE_BRACKET) {
                                      previousKQueryAttributesEnd = i;
                                    } else {
                                      previousKQueryAttributesEnd = i + 1;
                                    }
                                  }
                                  atts = query.substring(previousKQueryAttributesStart, previousKQueryAttributesEnd);
                                  if (atts.length == 0) {
                                    atts = null;
                                  }
                                }
                              }
                              relationName = query.substring(previousKQueryStart, previousKQueryNameEnd).trim();
                              if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "@")) {
                                traversal = traversal.traverseIndex(relationName.substring(1), atts);
                              } else {
                                if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "=")) {
                                  traversal.eval(relationName.substring(1), null);
                                  endEval = true;
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, ">>")) {
                                    traversal = traversal.traverseQuery(relationName.substring(2));
                                    if (atts != null) {
                                      traversal = traversal.attributeQuery(atts);
                                    }
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "<<")) {
                                      traversal = traversal.traverseQuery(relationName);
                                      if (atts != null) {
                                        traversal = traversal.attributeQuery(atts);
                                      }
                                    } else {
                                      traversal = traversal.traverseQuery(relationName);
                                      if (atts != null) {
                                        traversal = traversal.attributeQuery(atts);
                                      }
                                    }
                                  }
                                }
                              }
                              previousKQueryStart = i + 1;
                              previousKQueryNameEnd = -1;
                              previousKQueryAttributesEnd = -1;
                              previousKQueryAttributesStart = -1;
                            }
                          }
                        }
                      }
                    }
                    i = i + 1;
                  }
                  return traversal;
                }
              }
            }
          }
          export interface KQueryEngine {
            eval(query: string, origins: org.kevoree.modeling.KObject[], view: org.kevoree.modeling.KView, callback: org.kevoree.modeling.KCallback<any[]>): void;
            buildTraversal(query: string): org.kevoree.modeling.traversal.KTraversal;
          }
        }
        export namespace impl {
          export class Traversal implements org.kevoree.modeling.traversal.KTraversal {
            private static TERMINATED_MESSAGE: string = "Traversal is terminated by the call of done method, please create another promise";
            private _initObjs: org.kevoree.modeling.KObject[];
            private _initAction: org.kevoree.modeling.traversal.KTraversalAction;
            private _lastAction: org.kevoree.modeling.traversal.KTraversalAction;
            private _terminated: boolean = false;
            constructor(p_roots: org.kevoree.modeling.KObject[]) {
              this._initObjs = p_roots;
            }
            private internal_chain_action(p_action: org.kevoree.modeling.traversal.KTraversalAction): org.kevoree.modeling.traversal.KTraversal {
              if (this._terminated) {
                throw new Error(org.kevoree.modeling.traversal.impl.Traversal.TERMINATED_MESSAGE);
              }
              if (this._initAction == null) {
                this._initAction = p_action;
              }
              if (this._lastAction != null) {
                this._lastAction.chain(p_action);
              }
              this._lastAction = p_action;
              return this;
            }
            public traverse(p_metaReference: org.kevoree.modeling.meta.KMetaRelation): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseAction(p_metaReference));
            }
            public traverseQuery(p_metaReferenceQuery: string): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseQueryAction(p_metaReferenceQuery));
            }
            public withAttribute(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAttributeAction(p_attribute, p_expectedValue));
            }
            public withoutAttribute(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterNotAttributeAction(p_attribute, p_expectedValue));
            }
            public attributeQuery(p_attributeQuery: string): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction(p_attributeQuery));
            }
            public filter(p_filter: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAction(p_filter));
            }
            public collect(metaReference: org.kevoree.modeling.meta.KMetaRelation, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.DeepCollectAction(metaReference, continueCondition));
            }
            public traverseIndex(p_indexName: string, p_attributes: string): org.kevoree.modeling.traversal.KTraversal {
              return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseIndexAction(p_indexName, p_attributes));
            }
            public traverseTime(timeOffset: number, steps: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
              throw new Error("Not Implemented Yet!");
            }
            public traverseUniverse(universeOffset: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
              throw new Error("Not Implemented Yet!");
            }
            public then(cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
              if (this._initObjs != null) {
                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null, (objects : any[]) => {
                  cb(<org.kevoree.modeling.KObject[]>objects);
                }));
              }
            }
            public eval(p_expression: string, callback: org.kevoree.modeling.KCallback<any[]>): void {
              this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.MathExpressionAction(p_expression));
              this._terminated = true;
              if (this._initObjs != null) {
                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null, callback));
              }
            }
            public map(attribute: org.kevoree.modeling.meta.KMetaAttribute, cb: org.kevoree.modeling.KCallback<any[]>): void {
              this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.MapAction(attribute));
              this._terminated = true;
              if (this._initObjs != null) {
                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null, cb));
              }
            }
            public exec(origins: org.kevoree.modeling.KObject[], review: org.kevoree.modeling.KView, callback: org.kevoree.modeling.KCallback<any[]>): void {
              if (this._initObjs == null) {
                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(origins, review, callback));
              }
            }
          }
          export class TraversalContext implements org.kevoree.modeling.traversal.KTraversalActionContext {
            private _inputs: org.kevoree.modeling.KObject[];
            private _view: org.kevoree.modeling.KView;
            private _finalCallback: org.kevoree.modeling.KCallback<any[]>;
            constructor(p_inputs: org.kevoree.modeling.KObject[], p_view: org.kevoree.modeling.KView, p_finalCallback: org.kevoree.modeling.KCallback<any[]>) {
              this._inputs = p_inputs;
              this._view = p_view;
              this._finalCallback = p_finalCallback;
            }
            public inputObjects(): org.kevoree.modeling.KObject[] {
              return this._inputs;
            }
            public setInputObjects(p_newSet: org.kevoree.modeling.KObject[]): void {
              this._inputs = p_newSet;
            }
            public baseView(): org.kevoree.modeling.KView {
              return this._view;
            }
            public finalCallback(): org.kevoree.modeling.KCallback<any[]> {
              return this._finalCallback;
            }
          }
          export namespace actions {
            export class FilterAttributeQueryAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _attributeQuery: string;
              constructor(p_attributeQuery: string) {
                this._attributeQuery = p_attributeQuery;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  var selectedIndexes: boolean[] = new Array<boolean>(context.inputObjects().length);
                  var nbSelected: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                      if (this._attributeQuery == null) {
                        selectedIndexes[i] = true;
                        nbSelected++;
                      } else {
                        var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                        var params: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam> = this.buildParams(this._attributeQuery);
                        var selectedForNext: boolean[] = [true];
                        params.each((key : string, param : org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam) => {
                          for (var j: number = 0; j < metaElements.length; j++) {
                            if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                              var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[j];
                              if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaAttribute.metaName(), "^" + param.name() + "$")) {
                                var o_raw: any = loopObj.get(metaAttribute);
                                if (o_raw != null) {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "null")) {
                                    if (!param.isNegative()) {
                                      selectedForNext[0] = false;
                                    }
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(o_raw.toString(), "^" + param.value() + "$")) {
                                      if (param.isNegative()) {
                                        selectedForNext[0] = false;
                                      }
                                    } else {
                                      if (!param.isNegative()) {
                                        selectedForNext[0] = false;
                                      }
                                    }
                                  }
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "null") || org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "*")) {
                                    if (param.isNegative()) {
                                      selectedForNext[0] = false;
                                    }
                                  }
                                }
                              }
                            }
                          }
                        });
                        if (selectedForNext[0]) {
                          selectedIndexes[i] = true;
                          nbSelected++;
                        }
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                  var nextStepElement: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(nbSelected);
                  var inserted: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    if (selectedIndexes[i]) {
                      nextStepElement[inserted] = context.inputObjects()[i];
                      inserted++;
                    }
                  }
                  if (this._next == null) {
                    context.finalCallback()(nextStepElement);
                  } else {
                    context.setInputObjects(nextStepElement);
                    this._next.execute(context);
                  }
                }
              }
              private buildParams(p_paramString: string): org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam> {
                var params: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                var iParam: number = 0;
                var lastStart: number = iParam;
                while (iParam < p_paramString.length){
                  if (p_paramString.charAt(iParam) == ',') {
                    var p: string = p_paramString.substring(lastStart, iParam).trim();
                    if (!org.kevoree.modeling.util.PrimitiveHelper.equals(p, "") && !org.kevoree.modeling.util.PrimitiveHelper.equals(p, "*")) {
                      if (org.kevoree.modeling.util.PrimitiveHelper.endsWith(p, "=")) {
                        p = p + "*";
                      }
                      var pArray: string[] = p.split("=");
                      var pObject: org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                      if (pArray.length > 1) {
                        var paramKey: string = pArray[0].trim();
                        var negative: boolean = org.kevoree.modeling.util.PrimitiveHelper.endsWith(paramKey, "!");
                        pObject = new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                        params.put(pObject.name(), pObject);
                      }
                    }
                    lastStart = iParam + 1;
                  }
                  iParam = iParam + 1;
                }
                var lastParam: string = p_paramString.substring(lastStart, iParam).trim();
                if (!org.kevoree.modeling.util.PrimitiveHelper.equals(lastParam, "") && !org.kevoree.modeling.util.PrimitiveHelper.equals(lastParam, "*")) {
                  if (org.kevoree.modeling.util.PrimitiveHelper.endsWith(lastParam, "=")) {
                    lastParam = lastParam + "*";
                  }
                  var pArray: string[] = lastParam.split("=");
                  var pObject: org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                  if (pArray.length > 1) {
                    var paramKey: string = pArray[0].trim();
                    var negative: boolean = org.kevoree.modeling.util.PrimitiveHelper.endsWith(paramKey, "!");
                    pObject = new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                    params.put(pObject.name(), pObject);
                  }
                }
                return params;
              }
            }
            export module FilterAttributeQueryAction {
              export class QueryParam {
                private _name: string;
                private _value: string;
                private _negative: boolean;
                constructor(p_name: string, p_value: string, p_negative: boolean) {
                  this._name = p_name;
                  this._value = p_value;
                  this._negative = p_negative;
                }
                public name(): string {
                  return this._name;
                }
                public value(): string {
                  return this._value;
                }
                public isNegative(): boolean {
                  return this._negative;
                }
              }
            }
            export class RemoveDuplicateAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                var elems: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(context.inputObjects().length, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  elems.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                }
                var trimmed: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(elems.size());
                var nbInserted: Int32Array = new Int32Array([0]);
                elems.each((key : number, value : org.kevoree.modeling.KObject) => {
                  trimmed[nbInserted[0]] = value;
                  nbInserted[0]++;
                });
                if (this._next == null) {
                  context.finalCallback()(trimmed);
                } else {
                  context.setInputObjects(trimmed);
                  this._next.execute(context);
                }
              }
            }
            export class FilterAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _filter: org.kevoree.modeling.traversal.KTraversalFilter;
              constructor(p_filter: org.kevoree.modeling.traversal.KTraversalFilter) {
                this._filter = p_filter;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                var selectedIndex: boolean[] = new Array<boolean>(context.inputObjects().length);
                var selected: number = 0;
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  try {
                    if (this._filter.filter(context.inputObjects()[i])) {
                      selectedIndex[i] = true;
                      selected++;
                    }
                  } catch ($ex$) {
                    if ($ex$ instanceof Error) {
                      var e: Error = <Error>$ex$;
                      console.error(e['stack']);
                    } else {
                      throw $ex$;
                    }
                  }
                }
                var nextStepElement: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(selected);
                var inserted: number = 0;
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  if (selectedIndex[i]) {
                    nextStepElement[inserted] = context.inputObjects()[i];
                    inserted++;
                  }
                }
                if (this._next == null) {
                  context.finalCallback()(nextStepElement);
                } else {
                  context.setInputObjects(nextStepElement);
                  this._next.execute(context);
                }
              }
            }
            export class MathExpressionAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _expression: string;
              private _engine: org.kevoree.modeling.util.maths.expression.KMathExpressionEngine;
              constructor(p_expression: string) {
                this._expression = p_expression;
                this._engine = new org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine();
                this._engine.parse(p_expression);
              }
              public chain(next: org.kevoree.modeling.traversal.KTraversalAction): void {}
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                var selected: any[] = new Array<any>(context.inputObjects().length);
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  if (context.inputObjects()[i] != null) {
                    selected[i] = this._engine.eval(context.inputObjects()[i]);
                  }
                }
                if (context.finalCallback() != null) {
                  context.finalCallback()(selected);
                }
              }
            }
            export class TraverseQueryAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private SEP: string = ",";
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _referenceQuery: string;
              constructor(p_referenceQuery: string) {
                this._referenceQuery = p_referenceQuery;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  var currentFirstObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[0];
                  var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                      var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                      var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                      if (raw != null) {
                        if (this._referenceQuery == null) {
                          for (var j: number = 0; j < metaElements.length; j++) {
                            if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                              var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                              if (resolved != null) {
                                for (var k: number = 0; k < resolved.length; k++) {
                                  var idResolved: number = resolved[k];
                                  nextIds.put(idResolved, idResolved);
                                }
                              }
                            }
                          }
                        } else {
                          var queries: string[] = this._referenceQuery.split(this.SEP);
                          for (var k: number = 0; k < queries.length; k++) {
                            queries[k] = queries[k].replace("*", ".*");
                          }
                          for (var h: number = 0; h < metaElements.length; h++) {
                            if (metaElements[h] != null && metaElements[h].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                              var metaReference: org.kevoree.modeling.meta.KMetaRelation = <org.kevoree.modeling.meta.KMetaRelation>metaElements[h];
                              var selected: boolean = false;
                              for (var k: number = 0; k < queries.length; k++) {
                                if (queries[k] != null && org.kevoree.modeling.util.PrimitiveHelper.startsWith(queries[k].trim(), "<<")) {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaReference.oppositeName(), queries[k].trim().substring(2))) {
                                    selected = true;
                                    break;
                                  }
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaReference.metaName(), "^" + queries[k] + "$")) {
                                    selected = true;
                                    break;
                                  }
                                }
                              }
                              if (selected) {
                                var resolved: Float64Array = raw.getLongArray(metaElements[h].index(), loopObj.metaClass());
                                if (resolved != null) {
                                  for (var j: number = 0; j < resolved.length; j++) {
                                    nextIds.put(resolved[j], resolved[j]);
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                  var trimmed: Float64Array = new Float64Array(nextIds.size());
                  var inserted: Int32Array = new Int32Array([0]);
                  nextIds.each((key : number, value : number) => {
                    trimmed[inserted[0]] = key;
                    inserted[0]++;
                  });
                  currentFirstObject._manager.lookupAllObjects(currentFirstObject.universe(), currentFirstObject.now(), trimmed, (nextStepElement : org.kevoree.modeling.KObject[]) => {
                    if (this._next == null) {
                      context.finalCallback()(nextStepElement);
                    } else {
                      context.setInputObjects(nextStepElement);
                      this._next.execute(context);
                    }
                  });
                }
              }
            }
            export class TraverseTimeAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _timeOffset: number;
              private _steps: number;
              private _continueContition: org.kevoree.modeling.traversal.KTraversalFilter;
              constructor(p_timeOffset: number, p_steps: number, p_continueCondition: org.kevoree.modeling.traversal.KTraversalFilter) {
                this._timeOffset = p_timeOffset;
                this._steps = p_steps;
                this._continueContition = p_continueCondition;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                throw new Error("Not implemented Yet!");
              }
            }
            export class TraverseIndexAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _indexName: string;
              private _attributes: string;
              constructor(p_indexName: string, p_attributes: string) {
                this._indexName = p_indexName;
                this._attributes = p_attributes;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                var originView: org.kevoree.modeling.KView = context.baseView();
                if (originView != null) {
                  if (this._attributes == null && this._indexName != null) {
                    originView.model().indexByName(originView.universe(), originView.now(), this._indexName, (index : org.kevoree.modeling.KObjectIndex) => {
                      if (index == null) {
                        if (this._next == null) {
                          context.finalCallback()(new Array<org.kevoree.modeling.KObject>(0));
                        } else {
                          context.setInputObjects(new Array<org.kevoree.modeling.KObject>(0));
                          this._next.execute(context);
                        }
                      } else {
                        originView.model().lookupAllObjects(originView.universe(), originView.now(), index.values(), (selectedElems : org.kevoree.modeling.KObject[]) => {
                          if (this._next == null) {
                            context.finalCallback()(selectedElems);
                          } else {
                            context.setInputObjects(selectedElems);
                            this._next.execute(context);
                          }
                        });
                      }
                    });
                  } else {
                    originView.model().findByName(this._indexName, originView.universe(), originView.now(), this._attributes, (indexedObject : org.kevoree.modeling.KObject) => {
                      var selectedElems: org.kevoree.modeling.KObject[];
                      if (indexedObject == null) {
                        selectedElems = new Array<org.kevoree.modeling.KObject>(0);
                      } else {
                        selectedElems = new Array<org.kevoree.modeling.KObject>(1);
                        selectedElems[0] = indexedObject;
                      }
                      if (this._next == null) {
                        context.finalCallback()(selectedElems);
                      } else {
                        context.setInputObjects(selectedElems);
                        this._next.execute(context);
                      }
                    });
                  }
                } else {
                  throw new Error("Not implemented yet!");
                }
              }
            }
            export class MapAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
              constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute) {
                this._attribute = p_attribute;
              }
              public chain(next: org.kevoree.modeling.traversal.KTraversalAction): void {}
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                var selected: any[] = new Array<any>(context.inputObjects().length);
                var nbElem: number = 0;
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  if (context.inputObjects()[i] != null) {
                    var resolved: any = context.inputObjects()[i].get(this._attribute);
                    if (resolved != null) {
                      selected[i] = resolved;
                      nbElem++;
                    }
                  }
                }
                var trimmed: any[] = new Array<any>(nbElem);
                var nbInserted: number = 0;
                for (var i: number = 0; i < context.inputObjects().length; i++) {
                  if (selected[i] != null) {
                    trimmed[nbInserted] = selected[i];
                    nbInserted++;
                  }
                }
                if (context.finalCallback() != null) {
                  context.finalCallback()(trimmed);
                }
              }
            }
            export class FilterAttributeAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
              private _expectedValue: any;
              constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any) {
                this._attribute = p_attribute;
                this._expectedValue = p_expectedValue;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  var selectedIndexes: boolean[] = new Array<boolean>(context.inputObjects().length);
                  var nbSelected: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                      var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = (loopObj)._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                      if (raw != null) {
                        if (this._attribute == null) {
                          if (this._expectedValue == null) {
                            selectedIndexes[i] = true;
                            nbSelected++;
                          } else {
                            var addToNext: boolean = false;
                            var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                            for (var j: number = 0; j < metaElements.length; j++) {
                              if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                                var resolved: any = raw.getPrimitiveType(metaElements[j].index(), loopObj.metaClass());
                                if (resolved == null) {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                    addToNext = true;
                                  }
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                    addToNext = true;
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                      addToNext = true;
                                    }
                                  }
                                }
                              }
                            }
                            if (addToNext) {
                              selectedIndexes[i] = true;
                              nbSelected++;
                            }
                          }
                        } else {
                          var translatedAtt: org.kevoree.modeling.meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                          if (translatedAtt != null) {
                            var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                            if (this._expectedValue == null) {
                              if (resolved == null) {
                                selectedIndexes[i] = true;
                                nbSelected++;
                              }
                            } else {
                              if (resolved == null) {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                  selectedIndexes[i] = true;
                                  nbSelected++;
                                }
                              } else {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                  selectedIndexes[i] = true;
                                  nbSelected++;
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                    selectedIndexes[i] = true;
                                    nbSelected++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        console.error("WARN: Empty KObject " + loopObj.uuid());
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                  var nextStepElement: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(nbSelected);
                  var inserted: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    if (selectedIndexes[i]) {
                      nextStepElement[inserted] = context.inputObjects()[i];
                      inserted++;
                    }
                  }
                  if (this._next == null) {
                    context.finalCallback()(nextStepElement);
                  } else {
                    context.setInputObjects(nextStepElement);
                    this._next.execute(context);
                  }
                }
              }
            }
            export class FilterNotAttributeAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
              private _expectedValue: any;
              constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any) {
                this._attribute = p_attribute;
                this._expectedValue = p_expectedValue;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  var selectedIndexes: boolean[] = new Array<boolean>(context.inputObjects().length);
                  var nbSelected: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                      var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                      if (raw != null) {
                        if (this._attribute == null) {
                          if (this._expectedValue == null) {
                            selectedIndexes[i] = true;
                            nbSelected++;
                          } else {
                            var addToNext: boolean = true;
                            var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                            for (var j: number = 0; j < metaElements.length; j++) {
                              if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                                var ref: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[j];
                                var resolved: any = raw.getPrimitiveType(ref.index(), loopObj.metaClass());
                                if (resolved == null) {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                    addToNext = false;
                                  }
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                    addToNext = false;
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                      addToNext = false;
                                    }
                                  }
                                }
                              }
                            }
                            if (addToNext) {
                              selectedIndexes[i] = true;
                              nbSelected++;
                            }
                          }
                        } else {
                          var translatedAtt: org.kevoree.modeling.meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                          if (translatedAtt != null) {
                            var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                            if (this._expectedValue == null) {
                              if (resolved != null) {
                                selectedIndexes[i] = true;
                                nbSelected++;
                              }
                            } else {
                              if (resolved == null) {
                                if (!org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                  selectedIndexes[i] = true;
                                  nbSelected++;
                                }
                              } else {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                  } else {
                                    selectedIndexes[i] = true;
                                    nbSelected++;
                                  }
                                }
                              }
                            }
                          }
                        }
                      } else {
                        console.error("WARN: Empty KObject " + loopObj.uuid());
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                  var nextStepElement: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(nbSelected);
                  var inserted: number = 0;
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    if (selectedIndexes[i]) {
                      nextStepElement[inserted] = context.inputObjects()[i];
                      inserted++;
                    }
                  }
                  if (this._next == null) {
                    context.finalCallback()(nextStepElement);
                  } else {
                    context.setInputObjects(nextStepElement);
                    this._next.execute(context);
                  }
                }
              }
            }
            export class TraverseAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _reference: org.kevoree.modeling.meta.KMetaRelation;
              constructor(p_reference: org.kevoree.modeling.meta.KMetaRelation) {
                this._reference = p_reference;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  var currentObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[0];
                  var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                      var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = currentObject._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                      if (raw != null) {
                        if (this._reference == null) {
                          var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                          for (var j: number = 0; j < metaElements.length; j++) {
                            if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                              var ref: org.kevoree.modeling.meta.KMetaRelation = <org.kevoree.modeling.meta.KMetaRelation>metaElements[j];
                              var resolved: Float64Array = raw.getLongArray(ref.index(), currentObject.metaClass());
                              if (resolved != null) {
                                for (var k: number = 0; k < resolved.length; k++) {
                                  nextIds.put(resolved[k], resolved[k]);
                                }
                              }
                            }
                          }
                        } else {
                          var translatedRef: org.kevoree.modeling.meta.KMetaRelation = loopObj.internal_transpose_ref(this._reference);
                          if (translatedRef != null) {
                            var resolved: Float64Array = raw.getLongArray(translatedRef.index(), currentObject.metaClass());
                            if (resolved != null) {
                              for (var j: number = 0; j < resolved.length; j++) {
                                nextIds.put(resolved[j], resolved[j]);
                              }
                            }
                          }
                        }
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                  var trimmed: Float64Array = new Float64Array(nextIds.size());
                  var inserted: Int32Array = new Int32Array([0]);
                  nextIds.each((key : number, value : number) => {
                    trimmed[inserted[0]] = key;
                    inserted[0]++;
                  });
                  currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed, (kObjects : org.kevoree.modeling.KObject[]) => {
                    if (this._next == null) {
                      context.finalCallback()(kObjects);
                    } else {
                      context.setInputObjects(kObjects);
                      this._next.execute(context);
                    }
                  });
                }
              }
            }
            export class DeepCollectAction implements org.kevoree.modeling.traversal.KTraversalAction {
              private _next: org.kevoree.modeling.traversal.KTraversalAction;
              private _reference: org.kevoree.modeling.meta.KMetaRelation;
              private _continueCondition: org.kevoree.modeling.traversal.KTraversalFilter;
              private _alreadyPassed: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.KObject> = null;
              private _finalElements: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.KObject> = null;
              constructor(p_reference: org.kevoree.modeling.meta.KMetaRelation, p_continueCondition: org.kevoree.modeling.traversal.KTraversalFilter) {
                this._reference = p_reference;
                this._continueCondition = p_continueCondition;
              }
              public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                this._next = p_next;
              }
              public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                  if (this._next != null) {
                    this._next.execute(context);
                  } else {
                    context.finalCallback()(context.inputObjects());
                  }
                } else {
                  this._alreadyPassed = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.KObject>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                  this._finalElements = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.KObject>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                  var filtered_inputs: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(context.inputObjects().length);
                  for (var i: number = 0; i < context.inputObjects().length; i++) {
                    if (this._continueCondition == null || this._continueCondition.filter(context.inputObjects()[i])) {
                      filtered_inputs[i] = context.inputObjects()[i];
                      this._alreadyPassed.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                    }
                  }
                  var iterationCallbacks: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>[] = new Array<org.kevoree.modeling.KCallback<any>>(1);
                  iterationCallbacks[0] = (traversed : org.kevoree.modeling.KObject[]) => {
                    var filtered_inputs2: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(traversed.length);
                    var nbSize: number = 0;
                    for (var i: number = 0; i < traversed.length; i++) {
                      if ((this._continueCondition == null || this._continueCondition.filter(traversed[i])) && !this._alreadyPassed.contains(traversed[i].uuid())) {
                        filtered_inputs2[i] = traversed[i];
                        this._alreadyPassed.put(traversed[i].uuid(), traversed[i]);
                        this._finalElements.put(traversed[i].uuid(), traversed[i]);
                        nbSize++;
                      }
                    }
                    if (nbSize > 0) {
                      this.executeStep(filtered_inputs2, iterationCallbacks[0]);
                    } else {
                      var trimmed: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(this._finalElements.size());
                      var nbInserted: Int32Array = new Int32Array([0]);
                      this._finalElements.each((key : number, value : org.kevoree.modeling.KObject) => {
                        trimmed[nbInserted[0]] = value;
                        nbInserted[0]++;
                      });
                      if (this._next == null) {
                        context.finalCallback()(trimmed);
                      } else {
                        context.setInputObjects(trimmed);
                        this._next.execute(context);
                      }
                    }
                  };
                  this.executeStep(filtered_inputs, iterationCallbacks[0]);
                }
              }
              private executeStep(p_inputStep: org.kevoree.modeling.KObject[], private_callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
                var currentObject: org.kevoree.modeling.abs.AbstractKObject = null;
                var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                for (var i: number = 0; i < p_inputStep.length; i++) {
                  if (p_inputStep[i] != null) {
                    try {
                      var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>p_inputStep[i];
                      currentObject = loopObj;
                      var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                      if (raw != null) {
                        if (this._reference == null) {
                          var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                          for (var j: number = 0; j < metaElements.length; j++) {
                            if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                              var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                              if (resolved != null) {
                                for (var k: number = 0; k < resolved.length; k++) {
                                  nextIds.put(resolved[k], resolved[k]);
                                }
                              }
                            }
                          }
                        } else {
                          var translatedRef: org.kevoree.modeling.meta.KMetaRelation = loopObj.internal_transpose_ref(this._reference);
                          if (translatedRef != null) {
                            var resolved: Float64Array = raw.getLongArray(translatedRef.index(), loopObj.metaClass());
                            if (resolved != null) {
                              for (var j: number = 0; j < resolved.length; j++) {
                                nextIds.put(resolved[j], resolved[j]);
                              }
                            }
                          }
                        }
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                }
                var trimmed: Float64Array = new Float64Array(nextIds.size());
                var inserted: Int32Array = new Int32Array([0]);
                nextIds.each((key : number, value : number) => {
                  trimmed[inserted[0]] = key;
                  inserted[0]++;
                });
                currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed, (kObjects : org.kevoree.modeling.KObject[]) => {
                  private_callback(kObjects);
                });
              }
            }
          }
        }
        export interface KTraversal {
          traverse(metaReference: org.kevoree.modeling.meta.KMetaRelation): org.kevoree.modeling.traversal.KTraversal;
          traverseQuery(metaReferenceQuery: string): org.kevoree.modeling.traversal.KTraversal;
          attributeQuery(attributeQuery: string): org.kevoree.modeling.traversal.KTraversal;
          withAttribute(attribute: org.kevoree.modeling.meta.KMetaAttribute, expectedValue: any): org.kevoree.modeling.traversal.KTraversal;
          withoutAttribute(attribute: org.kevoree.modeling.meta.KMetaAttribute, expectedValue: any): org.kevoree.modeling.traversal.KTraversal;
          filter(filter: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;
          then(cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
          eval(expression: string, callback: org.kevoree.modeling.KCallback<any[]>): void;
          map(attribute: org.kevoree.modeling.meta.KMetaAttribute, cb: org.kevoree.modeling.KCallback<any[]>): void;
          collect(metaReference: org.kevoree.modeling.meta.KMetaRelation, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;
          traverseTime(timeOffset: number, steps: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;
          traverseUniverse(universeOffset: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;
          traverseIndex(indexName: string, attributes: string): org.kevoree.modeling.traversal.KTraversal;
          exec(origins: org.kevoree.modeling.KObject[], view: org.kevoree.modeling.KView, callback: org.kevoree.modeling.KCallback<any[]>): void;
        }
        export interface KTraversalActionContext {
          inputObjects(): org.kevoree.modeling.KObject[];
          setInputObjects(newSet: org.kevoree.modeling.KObject[]): void;
          finalCallback(): org.kevoree.modeling.KCallback<any[]>;
          baseView(): org.kevoree.modeling.KView;
        }
      }
      export interface KUniverse<A extends org.kevoree.modeling.KView, B extends org.kevoree.modeling.KUniverse<any, any>> {
        key(): number;
        time(timePoint: number): A;
        diverge(): B;
        equals(other: any): boolean;
        lookupAllTimes(uuid: number, times: Float64Array, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        createListener(): org.kevoree.modeling.KListener;
      }
      export interface KView {
        createByName(metaClassName: string): org.kevoree.modeling.KObject;
        create(clazz: org.kevoree.modeling.meta.KMetaClass): org.kevoree.modeling.KObject;
        select(query: string, cb: org.kevoree.modeling.KCallback<any[]>): void;
        lookup(key: number, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
        lookupAll(keys: Float64Array, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        universe(): number;
        now(): number;
        model(): org.kevoree.modeling.KModel<any>;
        json(): org.kevoree.modeling.format.KModelFormat;
        equals(other: any): boolean;
      }
      export interface KType {
        name(): string;
        id(): number;
      }
      export interface KModelContext {
        set(originTime: number, maxTime: number, originUniverse: number, maxUniverse: number): void;
        originTime(): number;
        originUniverse(): number;
        maxTime(): number;
        maxUniverse(): number;
        listen(callback: org.kevoree.modeling.KCallback<Float64Array>): void;
        model(): org.kevoree.modeling.KModel<any>;
      }
      export namespace cdn {
        export interface KContentUpdateListener {
          onKeysUpdate(updatedKeys: Float64Array): void;
          onOperationCall(operationCallMessage: org.kevoree.modeling.message.KMessage): void;
        }
        export namespace impl {
          export class MemoryContentDeliveryDriver implements org.kevoree.modeling.cdn.KContentDeliveryDriver {
            private backend: org.kevoree.modeling.memory.chunk.KStringMap<string> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<string>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
            private additionalInterceptors: org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<org.kevoree.modeling.cdn.KContentUpdateListener> = null;
            public atomicGetIncrement(key: Float64Array, cb: org.kevoree.modeling.KCallback<number>): void {
              var result: string = this.backend.get(org.kevoree.modeling.KContentKey.toString(key, 0));
              var nextV: number;
              var previousV: number;
              if (result != null) {
                try {
                  previousV = org.kevoree.modeling.util.PrimitiveHelper.parseShort(result);
                } catch ($ex$) {
                  if ($ex$ instanceof Error) {
                    var e: Error = <Error>$ex$;
                    console.error(e['stack']);
                    previousV = org.kevoree.modeling.util.PrimitiveHelper.SHORT_MIN_VALUE();
                  } else {
                    throw $ex$;
                  }
                }
              } else {
                previousV = 0;
              }
              if (previousV == org.kevoree.modeling.util.PrimitiveHelper.SHORT_MAX_VALUE()) {
                nextV = org.kevoree.modeling.util.PrimitiveHelper.SHORT_MIN_VALUE();
              } else {
                nextV = <number>(previousV + 1);
              }
              this.backend.put(org.kevoree.modeling.KContentKey.toString(key, 0), "" + nextV);
              cb(previousV);
            }
            public get(keys: Float64Array, callback: org.kevoree.modeling.KCallback<string[]>): void {
              var nbKeys: number = keys.length / 3;
              var values: string[] = new Array<string>(nbKeys);
              for (var i: number = 0; i < nbKeys; i++) {
                values[i] = this.backend.get(org.kevoree.modeling.KContentKey.toString(keys, i));
              }
              if (callback != null) {
                callback(values);
              }
            }
            public put(p_keys: Float64Array, p_values: string[], p_callback: org.kevoree.modeling.KCallback<Error>, excludeListener: number): void {
              var nbKeys: number = p_keys.length / 3;
              for (var i: number = 0; i < nbKeys; i++) {
                this.backend.put(org.kevoree.modeling.KContentKey.toString(p_keys, i), p_values[i]);
              }
              if (this.additionalInterceptors != null) {
                this.additionalInterceptors.each((key : number, value : org.kevoree.modeling.cdn.KContentUpdateListener) => {
                  if (value != null && key != excludeListener) {
                    value.onKeysUpdate(p_keys);
                  }
                });
              }
              if (p_callback != null) {
                p_callback(null);
              }
            }
            public remove(p_keys: Float64Array, callback: org.kevoree.modeling.KCallback<Error>): void {
              var nbKeys: number = p_keys.length / 3;
              for (var i: number = 0; i < nbKeys; i++) {
                this.backend.remove(org.kevoree.modeling.KContentKey.toString(p_keys, i));
              }
              if (callback != null) {
                callback(null);
              }
            }
            public connect(callback: org.kevoree.modeling.KCallback<Error>): void {
              if (callback != null) {
                callback(null);
              }
            }
            public close(callback: org.kevoree.modeling.KCallback<Error>): void {
              this.backend.clear();
              callback(null);
            }
            private nextListenerID(): number {
               return Math.random();
            }
            public addUpdateListener(p_interceptor: org.kevoree.modeling.cdn.KContentUpdateListener): number {
              if (this.additionalInterceptors == null) {
                this.additionalInterceptors = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<org.kevoree.modeling.cdn.KContentUpdateListener>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
              }
              var newID: number = this.nextListenerID();
              this.additionalInterceptors.put(newID, p_interceptor);
              return newID;
            }
            public removeUpdateListener(id: number): void {
              if (this.additionalInterceptors != null) {
                this.additionalInterceptors.remove(id);
              }
            }
            public peers(): string[] {
              return new Array<string>(0);
            }
            public sendToPeer(peer: string, message: org.kevoree.modeling.message.KMessage, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.message.KMessage>): void {}
          }
        }
        export interface KContentDeliveryDriver {
          get(keys: Float64Array, callback: org.kevoree.modeling.KCallback<string[]>): void;
          atomicGetIncrement(key: Float64Array, cb: org.kevoree.modeling.KCallback<number>): void;
          put(keys: Float64Array, values: string[], error: org.kevoree.modeling.KCallback<Error>, excludeListener: number): void;
          remove(keys: Float64Array, error: org.kevoree.modeling.KCallback<Error>): void;
          connect(callback: org.kevoree.modeling.KCallback<Error>): void;
          close(callback: org.kevoree.modeling.KCallback<Error>): void;
          addUpdateListener(interceptor: org.kevoree.modeling.cdn.KContentUpdateListener): number;
          removeUpdateListener(id: number): void;
          peers(): string[];
          sendToPeer(peer: string, message: org.kevoree.modeling.message.KMessage, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.message.KMessage>): void;
        }
      }
      export interface KObject {
        universe(): number;
        now(): number;
        uuid(): number;
        metaClass(): org.kevoree.modeling.meta.KMetaClass;
        visitAttributes(visitor: org.kevoree.modeling.traversal.visitor.KModelAttributeVisitor): void;
        visit(visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, callback: org.kevoree.modeling.KCallback<any>): void;
        traversal(): org.kevoree.modeling.traversal.KTraversal;
        jump(time: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
        select(query: string, callback: org.kevoree.modeling.KCallback<any[]>): void;
        detach(cb: org.kevoree.modeling.KCallback<any>): void;
        addByName(metaRelationName: string, objToAdd: org.kevoree.modeling.KObject): void;
        add(metaRelation: org.kevoree.modeling.meta.KMetaRelation, objToAdd: org.kevoree.modeling.KObject): void;
        removeByName(metaRelationName: string, objToRemove: org.kevoree.modeling.KObject): void;
        remove(metaRelation: org.kevoree.modeling.meta.KMetaRelation, objToRemove: org.kevoree.modeling.KObject): void;
        addAllByName(metaRelationName: string, objsToAdd: org.kevoree.modeling.KObject[]): void;
        addAll(metaRelation: org.kevoree.modeling.meta.KMetaRelation, objsToAdd: org.kevoree.modeling.KObject[]): void;
        removeAllByName(metaRelationName: string, callback: org.kevoree.modeling.KCallback<any>): void;
        removeAll(metaRelation: org.kevoree.modeling.meta.KMetaRelation, callback: org.kevoree.modeling.KCallback<any>): void;
        getRelationByName(metaRelationName: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        getRelation(metaRelation: org.kevoree.modeling.meta.KMetaRelation, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
        getRelationValuesByName(metaRelationName: string): Float64Array;
        getRelationValues(metaRelation: org.kevoree.modeling.meta.KMetaRelation): Float64Array;
        get(metaAttribute: org.kevoree.modeling.meta.KMetaAttribute): any;
        getByName(metaAttributeName: string): any;
        set(metaAttribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): void;
        setByName(metaAttributeName: string, payload: any): void;
        enforceTimepoint(): void;
        timeDephasing(): number;
        allTimes(cb: org.kevoree.modeling.KCallback<Float64Array>): void;
        timesBefore(endOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void;
        timesAfter(beginningOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void;
        timesBetween(beginningOfSearch: number, endOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void;
        toJSON(): string;
        equals(other: any): boolean;
        referencesWith(o: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMetaRelation[];
        invokeOperation(operation: org.kevoree.modeling.meta.KMetaOperation, params: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, cb: org.kevoree.modeling.KCallback<any>): void;
        invokeOperationByName(operationName: string, params: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, cb: org.kevoree.modeling.KCallback<any>): void;
        manager(): org.kevoree.modeling.memory.manager.KDataManager;
        compare(target: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMeta[];
      }
      export namespace extrapolation {
        export namespace impl {
          export class PolynomialExtrapolation implements org.kevoree.modeling.extrapolation.Extrapolation {
            private static _maxDegree: number = 20;
            private static DEGREE: number = 0;
            private static NUMSAMPLES: number = 1;
            private static STEP: number = 2;
            private static LASTTIME: number = 3;
            private static WEIGHTS: number = 4;
            private static INSTANCE: org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation;
            public extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (raw != null) {
                var extrapolatedValue: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), current.now(), raw.time());
                var attTypeId: number = attribute.attributeTypeId();
                switch (attTypeId) {
                  case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                  return extrapolatedValue;
                  case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                  return extrapolatedValue;
                  default:
                  return null;
                }
              } else {
                return null;
              }
            }
            private extrapolateValue(segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number, time: number, timeOrigin: number): number {
              if (segment.getDoubleArraySize(index, meta) == 0) {
                return 0.0;
              }
              var result: number = 0;
              var power: number = 1;
              var inferSTEP: number = segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.STEP, meta);
              if (inferSTEP == 0) {
                return segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS, meta);
              }
              var t: number = (time - timeOrigin) / inferSTEP;
              var inferArraySize: number = segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.DEGREE, meta);
              for (var j: number = 0; j <= inferArraySize; j++) {
                result += segment.getDoubleArrayElem(index, (j + org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS), meta) * power;
                power = power * t;
              }
              return result;
            }
            private maxErr(precision: number, degree: number): number {
              return precision / Math.pow(2, degree + 3);
            }
            public insert(time: number, value: number, timeOrigin: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, precision: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
              if (raw.getDoubleArraySize(index, metaClass) == 0) {
                this.initial_feed(time, value, raw, index, metaClass);
                return true;
              }
              if (raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, metaClass) == 1) {
                var timeStep: number = time - timeOrigin;
                if (timeStep == 0) {
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS, value, metaClass);
                  return true;
                } else {
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.STEP, <number>timeStep, metaClass);
                }
              }
              var deg: number = <number>raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.DEGREE, metaClass);
              var num: number = <number>raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, metaClass);
              var stp: number = raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.STEP, metaClass);
              var maxError: number = this.maxErr(precision, deg);
              if (Math.abs(this.extrapolateValue(raw, metaClass, index, time, timeOrigin) - value) <= maxError) {
                var nexNumSamples: number = raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, metaClass) + 1;
                raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, nexNumSamples, metaClass);
                raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                return true;
              }
              var newMaxDegree: number = Math.min(num, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation._maxDegree);
              if (deg < newMaxDegree) {
                deg++;
                var ss: number = num * 2;
                var times: Float64Array = new Float64Array(ss + 1);
                var values: Float64Array = new Float64Array(ss + 1);
                var inc: number = 0;
                if (ss > 1) {
                  inc = raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, metaClass) / (stp * (ss - 1));
                }
                for (var i: number = 0; i < ss; i++) {
                  times[i] = i * inc;
                  values[i] = this.internal_extrapolate(times[i], raw, index, metaClass);
                }
                times[ss] = (time - timeOrigin) / stp;
                values[ss] = value;
                var pf: org.kevoree.modeling.util.maths.PolynomialFit = new org.kevoree.modeling.util.maths.PolynomialFit(deg);
                pf.fit(times, values);
                if (this.tempError(pf.getCoef(), times, values) <= maxError) {
                  raw.extendDoubleArray(index, (raw.getDoubleArraySize(index, metaClass) + 1), metaClass);
                  for (var i: number = 0; i < pf.getCoef().length; i++) {
                    raw.setDoubleArrayElem(index, i + org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS, pf.getCoef()[i], metaClass);
                  }
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.DEGREE, deg, metaClass);
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, num + 1, metaClass);
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                  return true;
                }
              }
              return false;
            }
            private tempError(computedWeights: Float64Array, times: Float64Array, values: Float64Array): number {
              var maxErr: number = 0;
              var temp: number;
              for (var i: number = 0; i < times.length; i++) {
                temp = Math.abs(values[i] - org.kevoree.modeling.util.maths.PolynomialFit.extrapolate(times[i], computedWeights));
                if (temp > maxErr) {
                  maxErr = temp;
                }
              }
              return maxErr;
            }
            private internal_extrapolate(t: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
              var result: number = 0;
              var power: number = 1;
              if (raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.STEP, metaClass) == 0) {
                return raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS, metaClass);
              }
              for (var j: number = 0; j <= raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.DEGREE, metaClass); j++) {
                result += raw.getDoubleArrayElem(index, (j + org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS), metaClass) * power;
                power = power * t;
              }
              return result;
            }
            private initial_feed(time: number, value: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
              raw.extendDoubleArray(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS + 1, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.DEGREE, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.NUMSAMPLES, 1, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.STEP, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.WEIGHTS, value, metaClass);
            }
            public mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (raw.getDoubleArraySize(attribute.index(), current.metaClass()) == 0) {
                raw = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              }
              if (!this.insert(current.now(), this.castNumber(payload), raw.time(), raw, attribute.index(), attribute.precision(), current.metaClass())) {
                var prevTime: number = <number>raw.getDoubleArrayElem(attribute.index(), org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, current.metaClass()) + raw.time();
                var newSegment: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), prevTime, current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                var metaElements: org.kevoree.modeling.meta.KMeta[] = current.metaClass().metaElements();
                for (var i: number = 0; i < metaElements.length; i++) {
                  if (metaElements[i].metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                    var att: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                    if (att.strategy() == this) {
                      newSegment.clearDoubleArray(att.index(), current.metaClass());
                      if (att.index() != attribute.index()) {
                        var val: number = this.extrapolateValue(raw, current.metaClass(), att.index(), prevTime, raw.time());
                        this.insert(prevTime, val, prevTime, newSegment, att.index(), att.precision(), current.metaClass());
                        var newTime: number = <number>raw.getDoubleArrayElem(att.index(), org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.LASTTIME, current.metaClass()) + raw.time();
                        if (newTime >= current.now()) {
                          val = this.extrapolateValue(raw, current.metaClass(), att.index(), newTime, raw.time());
                          this.insert(newTime, val, prevTime, newSegment, att.index(), att.precision(), current.metaClass());
                        }
                      }
                    }
                  }
                }
                var val: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), prevTime, raw.time());
                this.insert(prevTime, val, prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                this.insert(current.now(), this.castNumber(payload), prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
              }
            }
            private castNumber(payload: any): number {
               return +payload;
            }
            public static instance(): org.kevoree.modeling.extrapolation.Extrapolation {
              if (org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.INSTANCE == null) {
                org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.INSTANCE = new org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation();
              }
              return org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.INSTANCE;
            }
          }
          export class DiscreteExtrapolation implements org.kevoree.modeling.extrapolation.Extrapolation {
            private static INSTANCE: org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation;
            public static instance(): org.kevoree.modeling.extrapolation.Extrapolation {
              if (org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.INSTANCE == null) {
                org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.INSTANCE = new org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation();
              }
              return org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.INSTANCE;
            }
            public extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any {
              var payload: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (payload != null) {
                if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                  var metaEnum: org.kevoree.modeling.meta.KMetaEnum = (<org.kevoree.modeling.abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                  return metaEnum.literal(<number>payload.getPrimitiveType(attribute.index(), current.metaClass()));
                } else {
                  return payload.getPrimitiveType(attribute.index(), current.metaClass());
                }
              } else {
                return null;
              }
            }
            public mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var internalPreviousPayload: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (internalPreviousPayload != null) {
                var toSetValue: any;
                if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                  if (payload instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                    toSetValue = (<org.kevoree.modeling.meta.KLiteral>payload).index();
                  } else {
                    var metaEnum: org.kevoree.modeling.meta.KMetaEnum = (<org.kevoree.modeling.abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                    var foundLiteral: org.kevoree.modeling.meta.KLiteral = metaEnum.literalByName(payload.toString());
                    if (foundLiteral != null) {
                      toSetValue = foundLiteral.index();
                    } else {
                      toSetValue = null;
                    }
                  }
                } else {
                  if (payload == null) {
                    toSetValue = null;
                  } else {
                    toSetValue = this.convert(attribute, payload);
                  }
                }
                var previousValue: any = internalPreviousPayload.getPrimitiveType(attribute.index(), current.metaClass());
                if (previousValue == null && toSetValue == null) {
                  return;
                }
                if (previousValue != null && toSetValue != null) {
                  switch (attribute.attributeTypeId()) {
                    case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                    var previousBoolOrdinal: boolean = <boolean>previousValue;
                    var nextBoolOrdinal: boolean = <boolean>toSetValue;
                    if (previousBoolOrdinal == nextBoolOrdinal) {
                      return;
                    }
                    break;
                    case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                    var previousContinuousOrdinal: number = <number>previousValue;
                    var nextContinuousOrdinal: number = <number>toSetValue;
                    if (previousContinuousOrdinal == nextContinuousOrdinal) {
                      return;
                    }
                    break;
                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                    var previousDoubleOrdinal: number = <number>previousValue;
                    var nextDoubleOrdinal: number = <number>toSetValue;
                    if (previousDoubleOrdinal == nextDoubleOrdinal) {
                      return;
                    }
                    break;
                    case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                    var previousIntOrdinal: number = <number>previousValue;
                    var nextIntOrdinal: number = <number>toSetValue;
                    if (previousIntOrdinal == nextIntOrdinal) {
                      return;
                    }
                    break;
                    case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                    var previousLongOrdinal: number = <number>previousValue;
                    var nextLongOrdinal: number = <number>toSetValue;
                    if (previousLongOrdinal == nextLongOrdinal) {
                      return;
                    }
                    break;
                    case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                    var previousString: string = <string>previousValue;
                    var nextString: string = <string>toSetValue;
                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(previousString, nextString)) {
                      return;
                    }
                    break;
                    default:
                    if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                      var previousEnumOrdinal: number = <number>previousValue;
                      var nextEnumOrdinal: number = <number>toSetValue;
                      if (previousEnumOrdinal == nextEnumOrdinal) {
                        return;
                      }
                    }
                    break;
                  }
                }
                var previousHash: string = null;
                if (attribute.key()) {
                  var metas: org.kevoree.modeling.meta.KMeta[] = current.metaClass().metaElements();
                  for (var i: number = 0; i < metas.length; i++) {
                    if (metas[i].metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE) && (<org.kevoree.modeling.meta.KMetaAttribute>metas[i]).key()) {
                      var loopElem: any = internalPreviousPayload.getPrimitiveType(metas[i].index(), current.metaClass());
                      if (loopElem != null) {
                        if (previousHash == null) {
                          previousHash = loopElem.toString();
                        } else {
                          previousHash += loopElem.toString();
                        }
                      }
                    }
                  }
                }
                var internalPayload: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                if (internalPayload != null) {
                  internalPayload.setPrimitiveType(attribute.index(), toSetValue, current.metaClass());
                  var newHash: string = null;
                  if (attribute.key()) {
                    var metas: org.kevoree.modeling.meta.KMeta[] = current.metaClass().metaElements();
                    for (var i: number = 0; i < metas.length; i++) {
                      if (metas[i].metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE) && (<org.kevoree.modeling.meta.KMetaAttribute>metas[i]).key()) {
                        var loopElem: any = internalPayload.getPrimitiveType(metas[i].index(), current.metaClass());
                        if (loopElem != null) {
                          if (newHash == null) {
                            newHash = loopElem.toString();
                          } else {
                            newHash += loopElem.toString();
                          }
                        }
                      }
                    }
                    var finalPreviousHash: string = previousHash;
                    var finalNewHash: string = newHash;
                    dataManager.index(current.universe(), current.now(), current.metaClass().metaName(), (classIndex : org.kevoree.modeling.KObjectIndex) => {
                      if (finalPreviousHash != null) {
                        classIndex.setIndex(finalPreviousHash, org.kevoree.modeling.KConfig.NULL_LONG);
                      }
                      if (finalNewHash != null) {
                        classIndex.setIndex(finalNewHash, current.uuid());
                      }
                    });
                  }
                }
              }
            }
            private convert(attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): any {
               return payload;
            }
          }
          export class DoublePolynomialExtrapolation implements org.kevoree.modeling.extrapolation.Extrapolation {
            private static _TIMERR: number = 0.001;
            private static _maxDegree: number = 20;
            private static _maxTimeDegree: number = 7;
            private static TIMEDEG: number = 0;
            private static NUMSAMPLES: number = 1;
            private static POLYDEG: number = 2;
            private static STEP: number = 3;
            private static TIMEWEIGHT: number = 4;
            private static INSTANCE: org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation;
            public extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (raw != null) {
                var extrapolatedValue: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), current.now(), raw.time());
                var attTypeId: number = attribute.attributeTypeId();
                switch (attTypeId) {
                  case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                  return extrapolatedValue;
                  case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                  return extrapolatedValue;
                  default:
                  return null;
                }
              } else {
                return null;
              }
            }
            private getPolyWeightIndex(segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number): number {
              return org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT + <number>segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEDEG, meta) + 1;
            }
            private getTime(num: number, segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number): number {
              if (segment.getDoubleArraySize(index, meta) == 0) {
                return 0.0;
              }
              var result: number = 0;
              var power: number = 1;
              if (segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEDEG, meta) == 0) {
                return segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT, meta);
              }
              var t: number = num;
              var inferArraySize: number = segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, meta);
              for (var j: number = 0; j <= inferArraySize; j++) {
                result += segment.getDoubleArrayElem(index, (j + org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT), meta) * power;
                power = power * t;
              }
              return result;
            }
            private getLastTime(segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number): number {
              return this.getTime(<number>segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, meta) - 1, segment, meta, index);
            }
            private extrapolateValue(segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number, time: number, timeOrigin: number): number {
              if (segment.getDoubleArraySize(index, meta) == 0) {
                return 0.0;
              }
              var result: number = 0;
              var power: number = 1;
              var inferSTEP: number = segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, meta);
              var polyw: number = this.getPolyWeightIndex(segment, meta, index);
              if (inferSTEP == 0) {
                return segment.getDoubleArrayElem(index, polyw, meta);
              }
              var t: number = (time - timeOrigin) / inferSTEP;
              var inferArraySize: number = segment.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, meta);
              for (var j: number = 0; j <= inferArraySize; j++) {
                result += segment.getDoubleArrayElem(index, (j + polyw), meta) * power;
                power = power * t;
              }
              return result;
            }
            private maxErr(precision: number, degree: number): number {
              return precision / Math.pow(2, degree + 0.5);
            }
            public insert(time: number, value: number, timeOrigin: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, precision: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
              if (raw.getDoubleArraySize(index, metaClass) == 0) {
                this.initial_feed(time, value, raw, index, metaClass);
                return true;
              }
              if (raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, metaClass) == 1) {
                raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, (time - timeOrigin), metaClass);
              }
              var timedeg: number = <number>raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEDEG, metaClass);
              var deg: number = <number>raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, metaClass);
              var num: number = <number>raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, metaClass);
              var maxError: number = this.maxErr(precision, deg);
              var normTime: number = (time - timeOrigin) / raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, metaClass);
              if (Math.abs(this.getTime(num, raw, metaClass, index) - time) > org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation._TIMERR) {
                if (timedeg < Math.min(num, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation._maxTimeDegree)) {
                  timedeg++;
                  var ss: number = Math.min(deg * 2, num);
                  var times: Float64Array = new Float64Array(ss + 1);
                  var values: Float64Array = new Float64Array(ss + 1);
                  for (var i: number = 0; i < ss; i++) {
                    times[i] = (i * num / ss);
                    values[i] = this.getTime(<number>times[i], raw, metaClass, index);
                  }
                  times[ss] = num;
                  values[ss] = normTime;
                  var pf: org.kevoree.modeling.util.maths.PolynomialFit = new org.kevoree.modeling.util.maths.PolynomialFit(timedeg);
                  pf.fit(times, values);
                  for (var i: number = 0; i < pf.getCoef().length; i++) {
                    raw.setDoubleArrayElem(index, i + org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT, pf.getCoef()[i], metaClass);
                  }
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEDEG, timedeg, metaClass);
                } else {
                  return false;
                }
              }
              if (Math.abs(this.extrapolateValue(raw, metaClass, index, time, timeOrigin) - value) <= maxError) {
                var nexNumSamples: number = raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, metaClass) + 1;
                raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, nexNumSamples, metaClass);
                return true;
              }
              var newMaxDegree: number = Math.min(num, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation._maxDegree);
              if (deg < newMaxDegree) {
                deg++;
                var ss: number = Math.min(deg * 2, num);
                var times: Float64Array = new Float64Array(ss + 1);
                var values: Float64Array = new Float64Array(ss + 1);
                for (var i: number = 0; i < ss; i++) {
                  times[i] = this.getTime(i * num / ss, raw, metaClass, index);
                  values[i] = this.internal_extrapolate(times[i], raw, index, metaClass);
                }
                times[ss] = normTime;
                values[ss] = value;
                var pf: org.kevoree.modeling.util.maths.PolynomialFit = new org.kevoree.modeling.util.maths.PolynomialFit(deg);
                pf.fit(times, values);
                if (this.tempError(pf.getCoef(), times, values) <= maxError) {
                  var pWeight: number = this.getPolyWeightIndex(raw, metaClass, index);
                  raw.extendDoubleArray(index, (raw.getDoubleArraySize(index, metaClass) + 1), metaClass);
                  for (var i: number = 0; i < pf.getCoef().length; i++) {
                    raw.setDoubleArrayElem(index, i + pWeight, pf.getCoef()[i], metaClass);
                  }
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, deg, metaClass);
                  raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, num + 1, metaClass);
                  return true;
                }
              }
              return false;
            }
            private tempError(computedWeights: Float64Array, times: Float64Array, values: Float64Array): number {
              var maxErr: number = 0;
              var temp: number;
              for (var i: number = 0; i < times.length; i++) {
                temp = Math.abs(values[i] - org.kevoree.modeling.util.maths.PolynomialFit.extrapolate(times[i], computedWeights));
                if (temp > maxErr) {
                  maxErr = temp;
                }
              }
              return maxErr;
            }
            private internal_extrapolate(t: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
              var result: number = 0;
              var power: number = 1;
              var pWeight: number = this.getPolyWeightIndex(raw, metaClass, index);
              if (raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, metaClass) == 0) {
                return raw.getDoubleArrayElem(index, pWeight, metaClass);
              }
              for (var j: number = 0; j <= raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, metaClass); j++) {
                result += raw.getDoubleArrayElem(index, (j + pWeight), metaClass) * power;
                power = power * t;
              }
              return result;
            }
            private initial_feed(time: number, value: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
              raw.extendDoubleArray(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT + 2, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEDEG, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.NUMSAMPLES, 1, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.POLYDEG, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT, 0, metaClass);
              raw.setDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.TIMEWEIGHT + 1, value, metaClass);
            }
            public mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              if (raw.getDoubleArraySize(attribute.index(), current.metaClass()) == 0) {
                raw = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              }
              if (!this.insert(current.now(), this.castNumber(payload), raw.time(), raw, attribute.index(), attribute.precision(), current.metaClass())) {
                var prevTime: number = this.getLastTimeLong(raw, current.metaClass(), attribute.index()) + raw.time();
                var val: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), prevTime, raw.time());
                var newSegment: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), prevTime, current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                newSegment.clearDoubleArray(attribute.index(), current.metaClass());
                this.insert(prevTime, val, prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                this.insert(current.now(), this.castNumber(payload), prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
              }
            }
            private getLastTimeLong(raw: org.kevoree.modeling.memory.chunk.KObjectChunk, kMetaClass: org.kevoree.modeling.meta.KMetaClass, index: number): number {
              return <number>(this.getLastTime(raw, kMetaClass, index) * raw.getDoubleArrayElem(index, org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.STEP, kMetaClass));
            }
            private castNumber(payload: any): number {
               return +payload;
            }
            public static instance(): org.kevoree.modeling.extrapolation.Extrapolation {
              if (org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.INSTANCE == null) {
                org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.INSTANCE = new org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation();
              }
              return org.kevoree.modeling.extrapolation.impl.DoublePolynomialExtrapolation.INSTANCE;
            }
          }
        }
        export interface Extrapolation {
          extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any;
          mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void;
        }
      }
      export namespace memory {
        export interface KChunk {
          serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string;
          init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void;
          counter(): number;
          inc(): number;
          dec(): number;
          free(metaModel: org.kevoree.modeling.meta.KMetaModel): void;
          type(): number;
          space(): org.kevoree.modeling.memory.space.KChunkSpace;
          getFlags(): number;
          setFlags(bitsToEnable: number, bitsToDisable: number): void;
          universe(): number;
          time(): number;
          obj(): number;
          dependencies(): Float64Array;
          addDependency(universe: number, time: number, uuid: number): void;
        }
        export namespace chunk {
          export interface KLongLongMap extends org.kevoree.modeling.memory.KChunk {
            metaClassIndex(): number;
            contains(key: number): boolean;
            get(key: number): number;
            put(key: number, value: number): void;
            remove(key: number): void;
            each(callback: org.kevoree.modeling.memory.chunk.KLongLongMapCallBack<any>): void;
            size(): number;
            clear(): void;
          }
          export interface KLongMapCallBack<V> {
            (key: number, value: V): void;
          }
          export interface KStringLongMapCallBack {
            (key: string, value: number): void;
          }
          export interface KLongMap<V> {
            contains(key: number): boolean;
            get(key: number): V;
            put(key: number, value: V): void;
            each(callback: org.kevoree.modeling.memory.chunk.KLongMapCallBack<V>): void;
            size(): number;
            clear(): void;
          }
          export interface KStringMap<V> {
            contains(key: string): boolean;
            get(key: string): V;
            put(key: string, value: V): void;
            each(callback: org.kevoree.modeling.memory.chunk.KStringMapCallBack<V>): void;
            size(): number;
            clear(): void;
            remove(key: string): void;
          }
          export interface KLongTree extends org.kevoree.modeling.memory.chunk.KTree {
            insertKey(key: number): void;
            previousOrEqual(key: number): number;
            lookup(key: number): number;
            range(startKey: number, endKey: number, walker: org.kevoree.modeling.memory.chunk.KTreeWalker): void;
          }
          export interface KTree extends org.kevoree.modeling.memory.KChunk {
            size(): number;
          }
          export interface KLongLongMapCallBack<V> {
            (key: number, value: number): void;
          }
          export interface KIntMapCallBack<V> {
            (key: number, value: V): void;
          }
          export namespace impl {
            export class ArrayLongLongMap implements org.kevoree.modeling.memory.chunk.KLongLongMap {
              public elementCount: number;
              public droppedCount: number;
              public state: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = null;
              public threshold: number;
              private initialCapacity: number = 16;
              private static loadFactor: number = (<number>75 / <number>100);
              private _flags: java.util.concurrent.atomic.AtomicLong;
              private _counter: java.util.concurrent.atomic.AtomicInteger;
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              private _universe: number;
              private _time: number;
              private _obj: number;
              private _metaClassIndex: number = -1;
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._universe = p_universe;
                this._time = p_time;
                this._obj = p_obj;
                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                this._space = p_space;
                this.elementCount = 0;
                this.droppedCount = 0;
                var newstate: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                for (var i: number = 0; i < this.initialCapacity; i++) {
                  newstate.elementNext[i] = -1;
                  newstate.elementHash[i] = -1;
                }
                this.state = newstate;
                this.threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.loadFactor);
              }
              public counter(): number {
                return this._counter.get();
              }
              public inc(): number {
                return this._counter.incrementAndGet();
              }
              public dec(): number {
                return this._counter.decrementAndGet();
              }
              public clear(): void {
                if (this.elementCount > 0) {
                  this.elementCount = 0;
                  this.droppedCount = 0;
                  var newstate: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                  for (var i: number = 0; i < this.initialCapacity; i++) {
                    newstate.elementNext[i] = -1;
                    newstate.elementHash[i] = -1;
                  }
                  this.state = newstate;
                  this.threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.loadFactor);
                }
              }
              public rehashCapacity(capacity: number): void {
                var length: number = (capacity == 0 ? 1 : capacity << 1);
                var newElementKV: Float64Array = new Float64Array(length * 2);
                java.lang.System.arraycopy(this.state.elementKV, 0, newElementKV, 0, this.state.elementKV.length);
                var newElementNext: Int32Array = new Int32Array(length);
                var newElementHash: Int32Array = new Int32Array(length);
                for (var i: number = 0; i < length; i++) {
                  newElementNext[i] = -1;
                  newElementHash[i] = -1;
                }
                for (var i: number = 0; i < this.state.elementNext.length; i++) {
                  if (this.state.elementNext[i] != -1) {
                    var index: number = (<number>this.state.elementKV[i * 2] & 0x7FFFFFFF) % length;
                    var currentHashedIndex: number = newElementHash[index];
                    if (currentHashedIndex != -1) {
                      newElementNext[i] = currentHashedIndex;
                    } else {
                      newElementNext[i] = -2;
                    }
                    newElementHash[index] = i;
                  }
                }
                this.state = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                this.threshold = <number>(length * org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.loadFactor);
              }
              public each(callback: org.kevoree.modeling.memory.chunk.KLongLongMapCallBack<any>): void {
                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                  if (internalState.elementNext[i] != -1) {
                    callback(internalState.elementKV[i * 2], internalState.elementKV[i * 2 + 1]);
                  }
                }
              }
              public metaClassIndex(): number {
                return this._metaClassIndex;
              }
              public contains(key: number): boolean {
                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return false;
                }
                var hash: number = <number>(key);
                var index: number = (hash & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = internalState.elementHash[index];
                while (m >= 0){
                  if (key == internalState.elementKV[m * 2]) {
                    return true;
                  }
                  m = internalState.elementNext[m];
                }
                return false;
              }
              public get(key: number): number {
                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
                var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = internalState.elementHash[index];
                while (m >= 0){
                  if (key == internalState.elementKV[m * 2]) {
                    return internalState.elementKV[(m * 2) + 1];
                  } else {
                    m = internalState.elementNext[m];
                  }
                }
                return org.kevoree.modeling.KConfig.NULL_LONG;
              }
              public put(key: number, value: number): void {
                var entry: number = -1;
                var index: number = -1;
                var hash: number = <number>(key);
                if (this.state.elementDataSize != 0) {
                  index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                  entry = this.findNonNullKeyEntry(key, index);
                }
                if (entry == -1) {
                  if (++this.elementCount > this.threshold) {
                    this.rehashCapacity(this.state.elementDataSize);
                    index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                  }
                  var newIndex: number = (this.elementCount + this.droppedCount - 1);
                  this.state.elementKV[newIndex * 2] = key;
                  this.state.elementKV[newIndex * 2 + 1] = value;
                  var currentHashedIndex: number = this.state.elementHash[index];
                  if (currentHashedIndex != -1) {
                    this.state.elementNext[newIndex] = currentHashedIndex;
                  } else {
                    this.state.elementNext[newIndex] = -2;
                  }
                  this.state.elementHash[index] = newIndex;
                } else {
                  this.state.elementKV[entry + 1] = value;
                }
                this.internal_set_dirty();
              }
              public findNonNullKeyEntry(key: number, index: number): number {
                var m: number = this.state.elementHash[index];
                while (m >= 0){
                  if (key == this.state.elementKV[m * 2]) {
                    return m;
                  }
                  m = this.state.elementNext[m];
                }
                return -1;
              }
              public remove(key: number): void {
                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return;
                }
                var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = this.state.elementHash[index];
                var last: number = -1;
                while (m >= 0){
                  if (key == this.state.elementKV[m * 2]) {
                    break;
                  }
                  last = m;
                  m = this.state.elementNext[m];
                }
                if (m == -1) {
                  return;
                }
                if (last == -1) {
                  if (this.state.elementNext[m] > 0) {
                    this.state.elementHash[index] = m;
                  } else {
                    this.state.elementHash[index] = -1;
                  }
                } else {
                  this.state.elementNext[last] = this.state.elementNext[m];
                }
                this.state.elementNext[m] = -1;
                this.elementCount--;
                this.droppedCount++;
              }
              public size(): number {
                return this.elementCount;
              }
              public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                this._metaClassIndex = metaClassIndex;
                if (payload == null || payload.length == 0) {
                  return;
                }
                var initPos: number = 0;
                var cursor: number = 0;
                while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != '/'){
                  cursor++;
                }
                if (cursor >= payload.length) {
                  return;
                }
                if (payload.charAt(cursor) == ',') {
                  this._metaClassIndex = metaModel.metaClassByName(payload.substring(initPos, cursor)).index();
                  cursor++;
                  initPos = cursor;
                }
                while (cursor < payload.length && payload.charAt(cursor) != '/'){
                  cursor++;
                }
                var nbElement: number = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                var length: number = (nbElement == 0 ? 1 : nbElement << 1);
                var newElementKV: Float64Array = new Float64Array(length * 2);
                var newElementNext: Int32Array = new Int32Array(length);
                var newElementHash: Int32Array = new Int32Array(length);
                for (var i: number = 0; i < length; i++) {
                  newElementNext[i] = -1;
                  newElementHash[i] = -1;
                }
                var temp_state: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                while (cursor < payload.length){
                  cursor++;
                  var beginChunk: number = cursor;
                  while (cursor < payload.length && payload.charAt(cursor) != ':'){
                    cursor++;
                  }
                  var middleChunk: number = cursor;
                  while (cursor < payload.length && payload.charAt(cursor) != ','){
                    cursor++;
                  }
                  var loopKey: number = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, beginChunk, middleChunk);
                  var loopVal: number = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, middleChunk + 1, cursor);
                  var index: number = ((<number>(loopKey)) & 0x7FFFFFFF) % temp_state.elementDataSize;
                  var newIndex: number = this.elementCount;
                  temp_state.elementKV[newIndex * 2] = loopKey;
                  temp_state.elementKV[newIndex * 2 + 1] = loopVal;
                  var currentHashedIndex: number = temp_state.elementHash[index];
                  if (currentHashedIndex != -1) {
                    temp_state.elementNext[newIndex] = currentHashedIndex;
                  } else {
                    temp_state.elementNext[newIndex] = -2;
                  }
                  temp_state.elementHash[index] = newIndex;
                  this.elementCount++;
                }
                this.elementCount = nbElement;
                this.droppedCount = 0;
                this.state = temp_state;
                this.threshold = <number>(length * org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.loadFactor);
              }
              public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                if (this._metaClassIndex != -1) {
                  buffer.append(metaModel.metaClass(this._metaClassIndex).metaName());
                  buffer.append(',');
                }
                org.kevoree.modeling.util.Base64.encodeIntToBuffer(this.elementCount, buffer);
                buffer.append('/');
                var isFirst: boolean = true;
                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                  if (internalState.elementNext[i] != -1) {
                    var loopKey: number = internalState.elementKV[i * 2];
                    var loopValue: number = internalState.elementKV[i * 2 + 1];
                    if (!isFirst) {
                      buffer.append(",");
                    }
                    isFirst = false;
                    org.kevoree.modeling.util.Base64.encodeLongToBuffer(loopKey, buffer);
                    buffer.append(":");
                    org.kevoree.modeling.util.Base64.encodeLongToBuffer(loopValue, buffer);
                  }
                }
                return buffer.toString();
              }
              public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                this.clear();
              }
              public type(): number {
                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
              }
              public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                return this._space;
              }
              private internal_set_dirty(): void {
                if (this._space != null) {
                  if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                    this._space.declareDirty(this);
                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                  }
                } else {
                  this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                }
              }
              public getFlags(): number {
                return this._flags.get();
              }
              public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                var val: number;
                var nval: number;
                do {
                  val = this._flags.get();
                  nval = val & ~bitsToDisable | bitsToEnable;
                } while (!this._flags.compareAndSet(val, nval))
              }
              public universe(): number {
                return this._universe;
              }
              public time(): number {
                return this._time;
              }
              public obj(): number {
                return this._obj;
              }
              public dependencies(): Float64Array {
                return null;
              }
              public addDependency(universe: number, time: number, uuid: number): void {
                throw new Error("Not implemented yet");
              }
            }
            export module ArrayLongLongMap {
              export class InternalState {
                public elementDataSize: number;
                public elementKV: Float64Array;
                public elementNext: Int32Array;
                public elementHash: Int32Array;
                constructor(elementDataSize: number, elementKV: Float64Array, elementNext: Int32Array, elementHash: Int32Array) {
                  this.elementDataSize = elementDataSize;
                  this.elementKV = elementKV;
                  this.elementNext = elementNext;
                  this.elementHash = elementHash;
                }
              }
            }
            export class ArrayLongMap<V> implements org.kevoree.modeling.memory.chunk.KLongMap<V> {
               constructor(initalCapacity: number, loadFactor : number) { }
               public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];} } }
               public get(key:number):V { return this[key]; }
               public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
               public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
               public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
               public size():number { return Object.keys(this).length; }
               public each(callback: org.kevoree.modeling.memory.chunk.KLongMapCallBack<V>): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
            }
            export class ArrayIntMap<V> implements org.kevoree.modeling.memory.chunk.KIntMap<V> {
               constructor(initalCapacity: number, loadFactor : number) { }
               public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];}} }
               public get(key:number):V { return this[key]; }
               public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
               public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
               public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
               public size():number { return Object.keys(this).length; }
               public each(callback: org.kevoree.modeling.memory.chunk.KIntMapCallBack<V>): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
            }
            export class HeapObjectChunk implements org.kevoree.modeling.memory.chunk.KObjectChunk {
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              private _flags: java.util.concurrent.atomic.AtomicLong;
              private _counter: java.util.concurrent.atomic.AtomicInteger;
              private _dependencies: java.util.concurrent.atomic.AtomicReference<Float64Array>;
              private _universe: number;
              private _time: number;
              private _obj: number;
              private raw: any[];
              private _metaClassIndex: number = -1;
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._universe = p_universe;
                this._time = p_time;
                this._obj = p_obj;
                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                this._dependencies = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
                this._space = p_space;
              }
              public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                return this._space;
              }
              public metaClassIndex(): number {
                return this._metaClassIndex;
              }
              public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                var isFirst: boolean = true;
                var metaElements: org.kevoree.modeling.meta.KMeta[] = metaClass.metaElements();
                if (this.raw != null && metaElements != null) {
                  for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                    if (this.raw[i] != null) {
                      if (isFirst) {
                        isFirst = false;
                      } else {
                        builder.append(org.kevoree.modeling.KConfig.CHUNK_ELEM_SEP);
                      }
                      org.kevoree.modeling.util.Base64.encodeStringToBuffer(metaElements[i].metaName(), builder);
                      builder.append(org.kevoree.modeling.KConfig.CHUNK_VAL_SEP);
                      if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                        var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                        var metaAttId: number = metaAttribute.attributeTypeId();
                        switch (metaAttId) {
                          case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                          org.kevoree.modeling.util.Base64.encodeStringToBuffer(<string>this.raw[i], builder);
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                          org.kevoree.modeling.util.Base64.encodeLongToBuffer(<number>this.raw[i], builder);
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                          var castedArr: Float64Array = <Float64Array>this.raw[i];
                          org.kevoree.modeling.util.Base64.encodeIntToBuffer(castedArr.length, builder);
                          for (var j: number = 0; j < castedArr.length; j++) {
                            builder.append(org.kevoree.modeling.KConfig.CHUNK_VAL_SEP);
                            org.kevoree.modeling.util.Base64.encodeDoubleToBuffer(castedArr[j], builder);
                          }
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                          if (<boolean>this.raw[i]) {
                            builder.append("1");
                          } else {
                            builder.append("0");
                          }
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                          org.kevoree.modeling.util.Base64.encodeDoubleToBuffer(<number>this.raw[i], builder);
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                          org.kevoree.modeling.util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                          break;
                          default:
                          if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                            org.kevoree.modeling.util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                          }
                          break;
                        }
                      } else {
                        if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                          var castedArr: Float64Array = <Float64Array>this.raw[i];
                          org.kevoree.modeling.util.Base64.encodeIntToBuffer(castedArr.length, builder);
                          for (var j: number = 0; j < castedArr.length; j++) {
                            builder.append(org.kevoree.modeling.KConfig.CHUNK_VAL_SEP);
                            org.kevoree.modeling.util.Base64.encodeLongToBuffer(castedArr[j], builder);
                          }
                        } else {
                          if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.INPUT || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.OUTPUT) {
                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                            org.kevoree.modeling.util.Base64.encodeIntToBuffer(castedArr.length, builder);
                            for (var j: number = 0; j < castedArr.length; j++) {
                              builder.append(org.kevoree.modeling.KConfig.CHUNK_VAL_SEP);
                              org.kevoree.modeling.util.Base64.encodeDoubleToBuffer(castedArr[j], builder);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                return builder.toString();
              }
              private loadObject(metaAttribute: org.kevoree.modeling.meta.KMetaAttribute, p_payload: string, p_start: number, p_end: number): any {
                var metaAttId: number = metaAttribute.attributeTypeId();
                switch (metaAttId) {
                  case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                  return org.kevoree.modeling.util.Base64.decodeToStringWithBounds(p_payload, p_start, p_end);
                  case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                  return org.kevoree.modeling.util.Base64.decodeToLongWithBounds(p_payload, p_start, p_end);
                  case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                  return org.kevoree.modeling.util.Base64.decodeToIntWithBounds(p_payload, p_start, p_end);
                  case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                  if (p_payload.charAt(p_start) == '1') {
                    return true;
                  } else {
                    return false;
                  }
                  case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                  return org.kevoree.modeling.util.Base64.decodeToDoubleWithBounds(p_payload, p_start, p_end);
                  default:
                  return null;
                }
              }
              public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                if (this._metaClassIndex == -1) {
                  this._metaClassIndex = metaClassIndex;
                }
                if (this._metaClassIndex == -1) {
                  return;
                }
                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                this.raw = new Array<any>(metaClass.metaElements().length);
                if (payload != null) {
                  var i: number = 0;
                  var payloadSize: number = payload.length;
                  var previousMeta: org.kevoree.modeling.meta.KMeta = null;
                  var previousValStart: number = 0;
                  var doubleArray: Float64Array = null;
                  var longArray: Float64Array = null;
                  var currentArrayIndex: number = -1;
                  while (i < payloadSize){
                    if (payload.charAt(i) == org.kevoree.modeling.KConfig.CHUNK_ELEM_SEP) {
                      if (previousMeta != null) {
                        if (previousMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE) && (<org.kevoree.modeling.meta.KMetaAttribute>previousMeta).attributeTypeId() != org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                          this.raw[previousMeta.index()] = this.loadObject(<org.kevoree.modeling.meta.KMetaAttribute>previousMeta, payload, previousValStart, i);
                        } else {
                          if (previousMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.RELATION) && longArray != null) {
                            longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                            this.raw[previousMeta.index()] = longArray;
                            longArray = null;
                          } else {
                            if (doubleArray != null) {
                              doubleArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                              this.raw[previousMeta.index()] = doubleArray;
                              doubleArray = null;
                            }
                          }
                        }
                      }
                      previousMeta = null;
                      previousValStart = i + 1;
                    } else {
                      if (payload.charAt(i) == org.kevoree.modeling.KConfig.CHUNK_VAL_SEP) {
                        if (previousMeta == null) {
                          previousMeta = metaClass.metaByName(org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i));
                        } else {
                          if (previousMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.RELATION)) {
                            if (longArray == null) {
                              longArray = new Float64Array(org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                              currentArrayIndex = 0;
                            } else {
                              longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                              currentArrayIndex++;
                            }
                          } else {
                            if (doubleArray == null) {
                              doubleArray = new Float64Array(org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                              currentArrayIndex = 0;
                            } else {
                              doubleArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                              currentArrayIndex++;
                            }
                          }
                        }
                        previousValStart = i + 1;
                      }
                    }
                    i++;
                  }
                  if (previousMeta != null) {
                    if (previousMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE) && (<org.kevoree.modeling.meta.KMetaAttribute>previousMeta).attributeTypeId() != org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                      this.raw[previousMeta.index()] = this.loadObject(<org.kevoree.modeling.meta.KMetaAttribute>previousMeta, payload, previousValStart, i);
                    } else {
                      if (previousMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.RELATION) && longArray != null) {
                        longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                        this.raw[previousMeta.index()] = longArray;
                      } else {
                        if (doubleArray != null) {
                          doubleArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToDoubleWithBounds(payload, previousValStart, i);
                          this.raw[previousMeta.index()] = doubleArray;
                        }
                      }
                    }
                  }
                }
              }
              public counter(): number {
                return this._counter.get();
              }
              public inc(): number {
                return this._counter.incrementAndGet();
              }
              public dec(): number {
                return this._counter.decrementAndGet();
              }
              public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                this.raw = null;
              }
              public type(): number {
                return org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
              }
              public getPrimitiveType(index: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass): any {
                if (this.raw != null) {
                  return this.raw[index];
                } else {
                  return null;
                }
              }
              public getLongArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                var existing: Float64Array = <Float64Array>this.raw[index];
                if (existing != null) {
                  return existing.length;
                }
                return 0;
              }
              public getLongArrayElem(index: number, refIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                var existing: Float64Array = <Float64Array>this.raw[index];
                if (existing != null) {
                  return existing[refIndex];
                } else {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
              }
              public getLongArray(index: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                var previousObj: any = this.raw[index];
                if (previousObj != null) {
                  return <Float64Array>previousObj;
                }
                return null;
              }
              public addLongToArray(index: number, newRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                if (this.raw != null) {
                  var previous: Float64Array = <Float64Array>this.raw[index];
                  if (previous == null) {
                    previous = new Float64Array(1);
                    previous[0] = newRef;
                  } else {
                    for (var i: number = 0; i < previous.length; i++) {
                      if (previous[i] == newRef) {
                        return false;
                      }
                    }
                    var incArray: Float64Array = new Float64Array(previous.length + 1);
                    java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                    incArray[previous.length] = newRef;
                    previous = incArray;
                  }
                  this.raw[index] = previous;
                  this.internal_set_dirty();
                  return true;
                }
                return false;
              }
              public removeLongToArray(index: number, refToRemove: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                if (this.raw != null) {
                  var previous: Float64Array = <Float64Array>this.raw[index];
                  if (previous != null) {
                    var indexToRemove: number = -1;
                    for (var i: number = 0; i < previous.length; i++) {
                      if (previous[i] == refToRemove) {
                        indexToRemove = i;
                        break;
                      }
                    }
                    if (indexToRemove != -1) {
                      if ((previous.length - 1) == 0) {
                        this.raw[index] = null;
                      } else {
                        var newArray: Float64Array = new Float64Array(previous.length - 1);
                        java.lang.System.arraycopy(previous, 0, newArray, 0, indexToRemove);
                        java.lang.System.arraycopy(previous, indexToRemove + 1, newArray, indexToRemove, previous.length - indexToRemove - 1);
                        this.raw[index] = newArray;
                      }
                      this.internal_set_dirty();
                      return true;
                    }
                  }
                }
                return false;
              }
              public clearLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                this.raw[index] = null;
              }
              public getDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                var previousObj: any = this.raw[index];
                if (previousObj != null) {
                  return <Float64Array>previousObj;
                }
                return null;
              }
              public getDoubleArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                var previousObj: any = this.raw[index];
                if (previousObj != null) {
                  return (<Float64Array>previousObj).length;
                }
                return 0;
              }
              public getDoubleArrayElem(index: number, arrayIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                var res: Float64Array = this.getDoubleArray(index, metaClass);
                if (org.kevoree.modeling.util.Checker.isDefined(res)) {
                  return res[arrayIndex];
                }
                return 0;
              }
              public setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                var res: Float64Array = this.getDoubleArray(index, metaClass);
                if (org.kevoree.modeling.util.Checker.isDefined(res)) {
                  res[arrayIndex] = valueToInsert;
                  this.internal_set_dirty();
                }
              }
              public extendDoubleArray(index: number, newSize: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                if (this.raw != null) {
                  var previous: Float64Array = <Float64Array>this.raw[index];
                  if (previous == null) {
                    previous = new Float64Array(newSize);
                  } else {
                    var incArray: Float64Array = new Float64Array(newSize);
                    java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                    previous = incArray;
                  }
                  this.raw[index] = previous;
                  this.internal_set_dirty();
                }
              }
              public clearDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                this.raw[index] = null;
              }
              public setPrimitiveType(index: number, content: any, p_metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                this.raw[index] = content;
                this.internal_set_dirty();
              }
              public clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                if (this.raw == null) {
                  return new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                } else {
                  var cloned: any[] = new Array<any>(this.raw.length);
                  java.lang.System.arraycopy(this.raw, 0, cloned, 0, this.raw.length);
                  var clonedEntry: org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk = new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                  clonedEntry.raw = cloned;
                  clonedEntry._metaClassIndex = this._metaClassIndex;
                  clonedEntry.internal_set_dirty();
                  return clonedEntry;
                }
              }
              public toJSON(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                builder.append("{");
                var isFirst: boolean = true;
                var metaElements: org.kevoree.modeling.meta.KMeta[] = metaClass.metaElements();
                if (this.raw != null && metaElements != null) {
                  for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                    if (this.raw[i] != null) {
                      if (isFirst) {
                        builder.append("\"");
                        isFirst = false;
                      } else {
                        builder.append(",\"");
                      }
                      builder.append(metaElements[i].metaName());
                      builder.append("\":");
                      if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                        var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                        var metaAttId: number = metaAttribute.attributeTypeId();
                        switch (metaAttId) {
                          case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                          builder.append("\"");
                          builder.append(org.kevoree.modeling.format.json.JsonString.encode(<string>this.raw[i]));
                          builder.append("\"");
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                          builder.append(this.raw[i]);
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                          builder.append("[");
                          var castedArr: Float64Array = <Float64Array>this.raw[i];
                          for (var j: number = 0; j < castedArr.length; j++) {
                            if (j != 0) {
                              builder.append(",");
                            }
                            builder.append(castedArr[j]);
                          }
                          builder.append("]");
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                          if (<boolean>this.raw[i]) {
                            builder.append("1");
                          } else {
                            builder.append("0");
                          }
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                          builder.append(this.raw[i]);
                          break;
                          case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                          builder.append(this.raw[i]);
                          break;
                          default:
                          if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                            org.kevoree.modeling.util.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                          }
                          break;
                        }
                      } else {
                        if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                          builder.append("[");
                          var castedArr: Float64Array = <Float64Array>this.raw[i];
                          for (var j: number = 0; j < castedArr.length; j++) {
                            if (j != 0) {
                              builder.append(",");
                            }
                            builder.append(castedArr[j]);
                          }
                          builder.append("]");
                        } else {
                          if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.INPUT || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.OUTPUT) {
                            builder.append("[");
                            var castedArr: Float64Array = <Float64Array>this.raw[i];
                            for (var j: number = 0; j < castedArr.length; j++) {
                              if (j != 0) {
                                builder.append(",");
                              }
                              builder.append(castedArr[j]);
                            }
                            builder.append("]");
                          }
                        }
                      }
                    }
                  }
                }
                builder.append("}");
                return builder.toString();
              }
              private internal_set_dirty(): void {
                if (this._space != null) {
                  if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                    this._space.declareDirty(this);
                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                  }
                } else {
                  this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                }
              }
              public getFlags(): number {
                return this._flags.get();
              }
              public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                var val: number;
                var nval: number;
                do {
                  val = this._flags.get();
                  nval = val & ~bitsToDisable | bitsToEnable;
                } while (!this._flags.compareAndSet(val, nval))
              }
              public universe(): number {
                return this._universe;
              }
              public time(): number {
                return this._time;
              }
              public obj(): number {
                return this._obj;
              }
              public dependencies(): Float64Array {
                return this._dependencies.get();
              }
              public addDependency(universe: number, time: number, uuid: number): void {
                var previousVal: Float64Array;
                var newVal: Float64Array;
                do {
                  previousVal = this._dependencies.get();
                  if (previousVal == null) {
                    newVal = new Float64Array([universe, time, uuid]);
                  } else {
                    newVal = new Float64Array(previousVal.length + 3);
                    var previousLength: number = previousVal.length;
                    java.lang.System.arraycopy(previousVal, 0, newVal, 0, previousLength);
                    newVal[previousLength] = universe;
                    newVal[previousLength + 1] = time;
                    newVal[previousLength + 2] = uuid;
                  }
                } while (!this._dependencies.compareAndSet(previousVal, newVal))
              }
            }
            export class ArrayLongLongTree extends org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree implements org.kevoree.modeling.memory.chunk.KLongLongTree {
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                super(p_universe, p_time, p_obj, p_space);
                this.kvSize = 2;
              }
              public previousOrEqualValue(p_key: number): number {
                var result: number = this.internal_previousOrEqual_index(p_key);
                if (result != -1) {
                  return this.value(result);
                } else {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
              }
              public lookupValue(p_key: number): number {
                return this.internal_lookup_value(p_key);
              }
              public insert(p_key: number, p_value: number): void {
                this.internal_insert(p_key, p_value);
              }
              public type(): number {
                return -1;
              }
            }
            export abstract class AbstractArrayTree implements org.kevoree.modeling.memory.KChunk {
              private static BLACK_LEFT: string = '{';
              private static BLACK_RIGHT: string = '}';
              private static RED_LEFT: string = '[';
              private static RED_RIGHT: string = ']';
              private static META_SIZE: number = 3;
              private static LOAD_FACTOR: number = (<number>75 / <number>100);
              public kvSize: number = 1;
              private _threshold: number = 0;
              private _root_index: number = -1;
              private _size: number = 0;
              private state: org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState;
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              private _flags: java.util.concurrent.atomic.AtomicLong;
              private _counter: java.util.concurrent.atomic.AtomicInteger;
              private _universe: number;
              private _time: number;
              private _obj: number;
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._universe = p_universe;
                this._time = p_time;
                this._obj = p_obj;
                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                this._space = p_space;
              }
              public counter(): number {
                return this._counter.get();
              }
              public inc(): number {
                return this._counter.incrementAndGet();
              }
              public dec(): number {
                return this._counter.decrementAndGet();
              }
              public universe(): number {
                return this._universe;
              }
              public time(): number {
                return this._time;
              }
              public obj(): number {
                return this._obj;
              }
              public getFlags(): number {
                return this._flags.get();
              }
              public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                var val: number;
                var nval: number;
                do {
                  val = this._flags.get();
                  nval = val & ~bitsToDisable | bitsToEnable;
                } while (!this._flags.compareAndSet(val, nval))
              }
              public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                return this._space;
              }
              private allocate(capacity: number): void {
                this.state = new org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState(new Int32Array(capacity * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE), new Float64Array(capacity * this.kvSize), new Array<boolean>(capacity));
                this._threshold = <number>(capacity * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.LOAD_FACTOR);
              }
              private reallocate(newCapacity: number): void {
                this._threshold = <number>(newCapacity * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.LOAD_FACTOR);
                var new_back_kv: Float64Array = new Float64Array(newCapacity * this.kvSize);
                if (this.state != null && this.state._back_kv != null) {
                  java.lang.System.arraycopy(this.state._back_kv, 0, new_back_kv, 0, this._size * this.kvSize);
                }
                var new_back_colors: boolean[] = new Array<boolean>(newCapacity);
                if (this.state != null && this.state._back_colors != null) {
                  java.lang.System.arraycopy(this.state._back_colors, 0, new_back_colors, 0, this._size);
                  for (var i: number = this._size; i < newCapacity; i++) {
                    new_back_colors[i] = false;
                  }
                }
                var new_back_meta: Int32Array = new Int32Array(newCapacity * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE);
                if (this.state != null && this.state._back_meta != null) {
                  java.lang.System.arraycopy(this.state._back_meta, 0, new_back_meta, 0, this._size * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE);
                  for (var i: number = this._size * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE; i < newCapacity * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE; i++) {
                    new_back_meta[i] = -1;
                  }
                }
                this.state = new org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState(new_back_meta, new_back_kv, new_back_colors);
              }
              public size(): number {
                return this._size;
              }
              public key(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                return this.state._back_kv[p_currentIndex * this.kvSize];
              }
              private setKey(p_currentIndex: number, p_paramIndex: number): void {
                this.state._back_kv[p_currentIndex * this.kvSize] = p_paramIndex;
              }
              public value(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                return this.state._back_kv[(p_currentIndex * this.kvSize) + 1];
              }
              private setValue(p_currentIndex: number, p_paramIndex: number): void {
                this.state._back_kv[(p_currentIndex * this.kvSize) + 1] = p_paramIndex;
              }
              private left(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                return this.state._back_meta[p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE];
              }
              private setLeft(p_currentIndex: number, p_paramIndex: number): void {
                this.state._back_meta[p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE] = p_paramIndex;
              }
              private right(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                return this.state._back_meta[(p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE) + 1];
              }
              private setRight(p_currentIndex: number, p_paramIndex: number): void {
                this.state._back_meta[(p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE) + 1] = p_paramIndex;
              }
              private parent(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                return this.state._back_meta[(p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE) + 2];
              }
              private setParent(p_currentIndex: number, p_paramIndex: number): void {
                this.state._back_meta[(p_currentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE) + 2] = p_paramIndex;
              }
              private color(p_currentIndex: number): boolean {
                if (p_currentIndex == -1) {
                  return true;
                }
                return this.state._back_colors[p_currentIndex];
              }
              private setColor(p_currentIndex: number, p_paramIndex: boolean): void {
                this.state._back_colors[p_currentIndex] = p_paramIndex;
              }
              private grandParent(p_currentIndex: number): number {
                if (p_currentIndex == -1) {
                  return -1;
                }
                if (this.parent(p_currentIndex) != -1) {
                  return this.parent(this.parent(p_currentIndex));
                } else {
                  return -1;
                }
              }
              private sibling(p_currentIndex: number): number {
                if (this.parent(p_currentIndex) == -1) {
                  return -1;
                } else {
                  if (p_currentIndex == this.left(this.parent(p_currentIndex))) {
                    return this.right(this.parent(p_currentIndex));
                  } else {
                    return this.left(this.parent(p_currentIndex));
                  }
                }
              }
              private uncle(p_currentIndex: number): number {
                if (this.parent(p_currentIndex) != -1) {
                  return this.sibling(this.parent(p_currentIndex));
                } else {
                  return -1;
                }
              }
              private previous(p_index: number): number {
                var p: number = p_index;
                if (this.left(p) != -1) {
                  p = this.left(p);
                  while (this.right(p) != -1){
                    p = this.right(p);
                  }
                  return p;
                } else {
                  if (this.parent(p) != -1) {
                    if (p == this.right(this.parent(p))) {
                      return this.parent(p);
                    } else {
                      while (this.parent(p) != -1 && p == this.left(this.parent(p))){
                        p = this.parent(p);
                      }
                      return this.parent(p);
                    }
                  } else {
                    return -1;
                  }
                }
              }
              private next(p_index: number): number {
                var p: number = p_index;
                if (this.right(p) != -1) {
                  p = this.right(p);
                  while (this.left(p) != -1){
                    p = this.left(p);
                  }
                  return p;
                } else {
                  if (this.parent(p) != -1) {
                    if (p == this.left(this.parent(p))) {
                      return this.parent(p);
                    } else {
                      while (this.parent(p) != -1 && p == this.right(this.parent(p))){
                        p = this.parent(p);
                      }
                      return this.parent(p);
                    }
                  } else {
                    return -1;
                  }
                }
              }
              public lookup(p_key: number): number {
                var n: number = this._root_index;
                if (n == -1) {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
                while (n != -1){
                  if (p_key == this.key(n)) {
                    return this.key(n);
                  } else {
                    if (p_key < this.key(n)) {
                      n = this.left(n);
                    } else {
                      n = this.right(n);
                    }
                  }
                }
                return n;
              }
              public range(startKey: number, endKey: number, walker: org.kevoree.modeling.memory.chunk.KTreeWalker): void {
                var indexEnd: number = this.internal_previousOrEqual_index(endKey);
                while (indexEnd != -1 && this.key(indexEnd) >= startKey){
                  walker.elem(this.key(indexEnd));
                  indexEnd = this.previous(indexEnd);
                }
              }
              public internal_previousOrEqual_index(p_key: number): number {
                var p: number = this._root_index;
                if (p == -1) {
                  return p;
                }
                while (p != -1){
                  if (p_key == this.key(p)) {
                    return p;
                  }
                  if (p_key > this.key(p)) {
                    if (this.right(p) != -1) {
                      p = this.right(p);
                    } else {
                      return p;
                    }
                  } else {
                    if (this.left(p) != -1) {
                      p = this.left(p);
                    } else {
                      var parent: number = this.parent(p);
                      var ch: number = p;
                      while (parent != -1 && ch == this.left(parent)){
                        ch = parent;
                        parent = this.parent(parent);
                      }
                      return parent;
                    }
                  }
                }
                return -1;
              }
              private rotateLeft(n: number): void {
                var r: number = this.right(n);
                this.replaceNode(n, r);
                this.setRight(n, this.left(r));
                if (this.left(r) != -1) {
                  this.setParent(this.left(r), n);
                }
                this.setLeft(r, n);
                this.setParent(n, r);
              }
              private rotateRight(n: number): void {
                var l: number = this.left(n);
                this.replaceNode(n, l);
                this.setLeft(n, this.right(l));
                if (this.right(l) != -1) {
                  this.setParent(this.right(l), n);
                }
                this.setRight(l, n);
                this.setParent(n, l);
              }
              private replaceNode(oldn: number, newn: number): void {
                if (this.parent(oldn) == -1) {
                  this._root_index = newn;
                } else {
                  if (oldn == this.left(this.parent(oldn))) {
                    this.setLeft(this.parent(oldn), newn);
                  } else {
                    this.setRight(this.parent(oldn), newn);
                  }
                }
                if (newn != -1) {
                  this.setParent(newn, this.parent(oldn));
                }
              }
              private insertCase1(n: number): void {
                if (this.parent(n) == -1) {
                  this.setColor(n, true);
                } else {
                  this.insertCase2(n);
                }
              }
              private insertCase2(n: number): void {
                if (!this.color(this.parent(n))) {
                  this.insertCase3(n);
                }
              }
              private insertCase3(n: number): void {
                if (!this.color(this.uncle(n))) {
                  this.setColor(this.parent(n), true);
                  this.setColor(this.uncle(n), true);
                  this.setColor(this.grandParent(n), false);
                  this.insertCase1(this.grandParent(n));
                } else {
                  this.insertCase4(n);
                }
              }
              private insertCase4(n_n: number): void {
                var n: number = n_n;
                if (n == this.right(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                  this.rotateLeft(this.parent(n));
                  n = this.left(n);
                } else {
                  if (n == this.left(this.parent(n)) && this.parent(n) == this.right(this.grandParent(n))) {
                    this.rotateRight(this.parent(n));
                    n = this.right(n);
                  }
                }
                this.insertCase5(n);
              }
              private insertCase5(n: number): void {
                this.setColor(this.parent(n), true);
                this.setColor(this.grandParent(n), false);
                if (n == this.left(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                  this.rotateRight(this.grandParent(n));
                } else {
                  this.rotateLeft(this.grandParent(n));
                }
              }
              public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                if (this._root_index == -1) {
                  return "0";
                }
                var savedRoot: number = this._root_index;
                var internalState: org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState = this.state;
                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                var treeSize: number = 0;
                for (var i: number = 0; i < internalState._back_meta.length / org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE; i++) {
                  var parentIndex: number = internalState._back_meta[(i * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE) + 2];
                  if (parentIndex != -1 || i == savedRoot) {
                    var isOnLeft: boolean = false;
                    if (parentIndex != -1) {
                      isOnLeft = internalState._back_meta[parentIndex * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE] == i;
                    }
                    if (!this.color(i)) {
                      if (isOnLeft) {
                        builder.append(org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT);
                      } else {
                        builder.append(org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT);
                      }
                    } else {
                      if (isOnLeft) {
                        builder.append(org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT);
                      } else {
                        builder.append(org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT);
                      }
                    }
                    org.kevoree.modeling.util.Base64.encodeLongToBuffer(internalState._back_kv[i * this.kvSize], builder);
                    builder.append(',');
                    if (parentIndex != -1) {
                      org.kevoree.modeling.util.Base64.encodeIntToBuffer(parentIndex, builder);
                    }
                    if (this.kvSize > 1) {
                      builder.append(',');
                      org.kevoree.modeling.util.Base64.encodeLongToBuffer(internalState._back_kv[(i * this.kvSize) + 1], builder);
                    }
                    treeSize++;
                  }
                }
                return org.kevoree.modeling.util.Base64.encodeInt(treeSize) + "," + org.kevoree.modeling.util.Base64.encodeInt(savedRoot) + builder.toString();
              }
              public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                if (payload == null || payload.length == 0) {
                  return;
                }
                var initPos: number = 0;
                var cursor: number = 0;
                while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT){
                  cursor++;
                }
                if (payload.charAt(cursor) == ',') {
                  this._size = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                  cursor++;
                  initPos = cursor;
                }
                while (cursor < payload.length && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT){
                  cursor++;
                }
                this._root_index = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                this.allocate(this._size);
                for (var i: number = 0; i < this._size; i++) {
                  var offsetI: number = i * org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.META_SIZE;
                  this.state._back_meta[offsetI] = -1;
                  this.state._back_meta[offsetI + 1] = -1;
                  this.state._back_meta[offsetI + 2] = -1;
                }
                var currentLoopIndex: number = 0;
                while (cursor < payload.length){
                  while (cursor < payload.length && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT){
                    cursor++;
                  }
                  if (cursor < payload.length) {
                    var elem: string = payload.charAt(cursor);
                    var isOnLeft: boolean = false;
                    if (elem == org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT || elem == org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT) {
                      isOnLeft = true;
                    }
                    if (elem == org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT || elem == org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT) {
                      this.setColor(currentLoopIndex, false);
                    } else {
                      this.setColor(currentLoopIndex, true);
                    }
                    cursor++;
                    var beginChunk: number = cursor;
                    while (cursor < payload.length && payload.charAt(cursor) != ','){
                      cursor++;
                    }
                    var loopKey: number = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                    this.setKey(currentLoopIndex, loopKey);
                    cursor++;
                    beginChunk = cursor;
                    while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT){
                      cursor++;
                    }
                    if (cursor > beginChunk) {
                      var parentRaw: number = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, beginChunk, cursor);
                      this.setParent(currentLoopIndex, parentRaw);
                      if (isOnLeft) {
                        this.setLeft(parentRaw, currentLoopIndex);
                      } else {
                        this.setRight(parentRaw, currentLoopIndex);
                      }
                    }
                    if (cursor < payload.length && payload.charAt(cursor) == ',') {
                      cursor++;
                      beginChunk = cursor;
                      while (cursor < payload.length && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.RED_RIGHT){
                        cursor++;
                      }
                      if (cursor > beginChunk) {
                        var currentValue: number = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                        this.setValue(currentLoopIndex, currentValue);
                      }
                    }
                    currentLoopIndex++;
                  }
                }
              }
              public free(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                this.state = null;
                this._size = 0;
                this._threshold = 0;
              }
              public internal_insert(p_key: number, p_value: number): void {
                if ((this._size + 1) > this._threshold) {
                  var length: number = (this._size == 0 ? 1 : this._size << 1);
                  this.reallocate(length);
                }
                var newIndex: number = this._size;
                if (newIndex == 0) {
                  this.setKey(newIndex, p_key);
                  if (this.kvSize == 2) {
                    this.setValue(newIndex, p_value);
                  }
                  this.setColor(newIndex, false);
                  this.setLeft(newIndex, -1);
                  this.setRight(newIndex, -1);
                  this.setParent(newIndex, -1);
                  this._root_index = newIndex;
                  this._size = 1;
                } else {
                  var n: number = this._root_index;
                  while (true){
                    if (p_key == this.key(n)) {
                      return;
                    } else {
                      if (p_key < this.key(n)) {
                        if (this.left(n) == -1) {
                          this.setKey(newIndex, p_key);
                          if (this.kvSize == 2) {
                            this.setValue(newIndex, p_value);
                          }
                          this.setColor(newIndex, false);
                          this.setLeft(newIndex, -1);
                          this.setRight(newIndex, -1);
                          this.setParent(newIndex, -1);
                          this.setLeft(n, newIndex);
                          this._size++;
                          break;
                        } else {
                          n = this.left(n);
                        }
                      } else {
                        if (this.right(n) == -1) {
                          this.setKey(newIndex, p_key);
                          if (this.kvSize == 2) {
                            this.setValue(newIndex, p_value);
                          }
                          this.setColor(newIndex, false);
                          this.setLeft(newIndex, -1);
                          this.setRight(newIndex, -1);
                          this.setParent(newIndex, -1);
                          this.setRight(n, newIndex);
                          this._size++;
                          break;
                        } else {
                          n = this.right(n);
                        }
                      }
                    }
                  }
                  this.setParent(newIndex, n);
                }
                this.insertCase1(newIndex);
                this.internal_set_dirty();
              }
              public internal_lookup_value(p_key: number): number {
                var n: number = this._root_index;
                if (n == -1) {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
                while (n != -1){
                  if (p_key == this.key(n)) {
                    return this.value(n);
                  } else {
                    if (p_key < this.key(n)) {
                      n = this.left(n);
                    } else {
                      n = this.right(n);
                    }
                  }
                }
                return n;
              }
              private internal_set_dirty(): void {
                if (this._space != null) {
                  if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                    this._space.declareDirty(this);
                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                  }
                } else {
                  this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                }
              }
              public abstract type(): number;
              public dependencies(): Float64Array {
                return null;
              }
              public addDependency(universe: number, time: number, uuid: number): void {
                throw new Error("Not implemented yet");
              }
            }
            export module AbstractArrayTree {
              export class InternalState {
                public _back_meta: Int32Array;
                public _back_kv: Float64Array;
                public _back_colors: boolean[];
                constructor(_back_meta: Int32Array, _back_kv: Float64Array, _back_colors: boolean[]) {
                  this._back_meta = _back_meta;
                  this._back_kv = _back_kv;
                  this._back_colors = _back_colors;
                }
              }
            }
            export class HeapObjectIndexChunk implements org.kevoree.modeling.memory.chunk.KObjectIndexChunk {
              public elementCount: number;
              public droppedCount: number;
              public state: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = null;
              public threshold: number;
              private initialCapacity: number = 16;
              private static loadFactor: number = (<number>75 / <number>100);
              private _flags: java.util.concurrent.atomic.AtomicLong;
              private _counter: java.util.concurrent.atomic.AtomicInteger;
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              private _universe: number;
              private _time: number;
              private _obj: number;
              private _metaClassIndex: number = -1;
              private _dependencies: java.util.concurrent.atomic.AtomicReference<Float64Array>;
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._universe = p_universe;
                this._time = p_time;
                this._obj = p_obj;
                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                this._space = p_space;
                this.elementCount = 0;
                this.droppedCount = 0;
                var newstate: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.initialCapacity, new Array<string>(this.initialCapacity), new Float64Array(this.initialCapacity), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                for (var i: number = 0; i < this.initialCapacity; i++) {
                  newstate.elementNext[i] = -1;
                  newstate.elementHash[i] = -1;
                }
                this.state = newstate;
                this.threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.loadFactor);
                this._dependencies = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
              }
              public clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                var cloned: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk = new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk(p_universe, p_time, p_obj, this._space);
                cloned._metaClassIndex = this._metaClassIndex;
                cloned.state = this.state.clone();
                cloned.elementCount = this.elementCount;
                cloned.droppedCount = this.droppedCount;
                cloned.threshold = this.threshold;
                cloned.internal_set_dirty();
                return cloned;
              }
              public metaClassIndex(): number {
                return this._metaClassIndex;
              }
              public toJSON(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                return null;
              }
              public setPrimitiveType(index: number, content: any, metaClass: org.kevoree.modeling.meta.KMetaClass): void {}
              public getPrimitiveType(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): any {
                return null;
              }
              public getLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                return new Float64Array(0);
              }
              public getLongArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                return 0;
              }
              public getLongArrayElem(index: number, refIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                return 0;
              }
              public addLongToArray(index: number, newRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                return false;
              }
              public removeLongToArray(index: number, previousRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                return false;
              }
              public clearLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {}
              public getDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                return new Float64Array(0);
              }
              public getDoubleArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                return 0;
              }
              public getDoubleArrayElem(index: number, arrayIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                return 0;
              }
              public setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {}
              public extendDoubleArray(index: number, newSize: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {}
              public clearDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {}
              public counter(): number {
                return this._counter.get();
              }
              public inc(): number {
                return this._counter.incrementAndGet();
              }
              public dec(): number {
                return this._counter.decrementAndGet();
              }
              public clear(): void {
                if (this.elementCount > 0) {
                  this.elementCount = 0;
                  this.droppedCount = 0;
                  var newstate: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.initialCapacity, new Array<string>(this.initialCapacity), new Float64Array(this.initialCapacity), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                  for (var i: number = 0; i < this.initialCapacity; i++) {
                    newstate.elementNext[i] = -1;
                    newstate.elementHash[i] = -1;
                  }
                  this.state = newstate;
                  this.threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.loadFactor);
                }
              }
              public rehashCapacity(capacity: number): void {
                var length: number = (capacity == 0 ? 1 : capacity << 1);
                var newElementK: string[] = new Array<string>(length * 2);
                var newElementV: Float64Array = new Float64Array(length * 2);
                java.lang.System.arraycopy(this.state.elementK, 0, newElementK, 0, this.state.elementK.length);
                java.lang.System.arraycopy(this.state.elementV, 0, newElementV, 0, this.state.elementV.length);
                var newElementNext: Int32Array = new Int32Array(length);
                var newElementHash: Int32Array = new Int32Array(length);
                for (var i: number = 0; i < length; i++) {
                  newElementNext[i] = -1;
                  newElementHash[i] = -1;
                }
                for (var i: number = 0; i < this.state.elementNext.length; i++) {
                  if (this.state.elementNext[i] != -1) {
                    var index: number = (org.kevoree.modeling.util.PrimitiveHelper.stringHash(this.state.elementK[i]) & 0x7FFFFFFF) % length;
                    var currentHashedIndex: number = newElementHash[index];
                    if (currentHashedIndex != -1) {
                      newElementNext[i] = currentHashedIndex;
                    } else {
                      newElementNext[i] = -2;
                    }
                    newElementHash[index] = i;
                  }
                }
                this.state = new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState(length, newElementK, newElementV, newElementNext, newElementHash);
                this.threshold = <number>(length * org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.loadFactor);
              }
              public each(callback: org.kevoree.modeling.memory.chunk.KStringLongMapCallBack): void {
                var internalState: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                  if (internalState.elementNext[i] != -1) {
                    callback(internalState.elementK[i], internalState.elementV[i]);
                  }
                }
              }
              public contains(key: string): boolean {
                var internalState: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return false;
                }
                var hash: number = org.kevoree.modeling.util.PrimitiveHelper.stringHash(key);
                var index: number = (hash & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = internalState.elementHash[index];
                while (m >= 0){
                  if (key == internalState.elementK[m * 2]) {
                    return true;
                  }
                  m = internalState.elementNext[m];
                }
                return false;
              }
              public get(key: string): number {
                var internalState: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
                var index: number = (org.kevoree.modeling.util.PrimitiveHelper.stringHash(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = internalState.elementHash[index];
                while (m >= 0){
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(key, internalState.elementK[m])) {
                    return internalState.elementV[m];
                  } else {
                    m = internalState.elementNext[m];
                  }
                }
                return org.kevoree.modeling.KConfig.NULL_LONG;
              }
              public put(key: string, value: number): void {
                var entry: number = -1;
                var index: number = -1;
                var hash: number = org.kevoree.modeling.util.PrimitiveHelper.stringHash(key);
                if (this.state.elementDataSize != 0) {
                  index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                  entry = this.findNonNullKeyEntry(key, index);
                }
                if (entry == -1) {
                  if (++this.elementCount > this.threshold) {
                    this.rehashCapacity(this.state.elementDataSize);
                    index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                  }
                  var newIndex: number = (this.elementCount + this.droppedCount - 1);
                  this.state.elementK[newIndex] = key;
                  this.state.elementV[newIndex] = value;
                  var currentHashedIndex: number = this.state.elementHash[index];
                  if (currentHashedIndex != -1) {
                    this.state.elementNext[newIndex] = currentHashedIndex;
                  } else {
                    this.state.elementNext[newIndex] = -2;
                  }
                  this.state.elementHash[index] = newIndex;
                } else {
                  this.state.elementV[entry] = value;
                }
                this.internal_set_dirty();
              }
              public findNonNullKeyEntry(key: string, index: number): number {
                var m: number = this.state.elementHash[index];
                while (m >= 0){
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(key, this.state.elementK[m])) {
                    return m;
                  }
                  m = this.state.elementNext[m];
                }
                return -1;
              }
              public remove(key: string): void {
                var internalState: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                if (this.state.elementDataSize == 0) {
                  return;
                }
                var index: number = (org.kevoree.modeling.util.PrimitiveHelper.stringHash(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = this.state.elementHash[index];
                var last: number = -1;
                while (m >= 0){
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(key, this.state.elementK[m])) {
                    break;
                  }
                  last = m;
                  m = this.state.elementNext[m];
                }
                if (m == -1) {
                  return;
                }
                if (last == -1) {
                  if (this.state.elementNext[m] > 0) {
                    this.state.elementHash[index] = m;
                  } else {
                    this.state.elementHash[index] = -1;
                  }
                } else {
                  this.state.elementNext[last] = this.state.elementNext[m];
                }
                this.state.elementNext[m] = -1;
                this.elementCount--;
                this.droppedCount++;
              }
              public size(): number {
                return this.elementCount;
              }
              public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                if (this._metaClassIndex == -1) {
                  this._metaClassIndex = metaClassIndex;
                }
                if (payload == null || payload.length == 0) {
                  return;
                }
                var initPos: number = 1;
                var cursor: number = 0;
                while (cursor < payload.length && payload.charAt(cursor) != '/'){
                  cursor++;
                }
                var nbElement: number = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                var length: number = (nbElement == 0 ? 1 : nbElement << 1);
                var newElementK: string[] = new Array<string>(length);
                var newElementV: Float64Array = new Float64Array(length);
                var newElementNext: Int32Array = new Int32Array(length);
                var newElementHash: Int32Array = new Int32Array(length);
                for (var i: number = 0; i < length; i++) {
                  newElementNext[i] = -1;
                  newElementHash[i] = -1;
                }
                var temp_state: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState(length, newElementK, newElementV, newElementNext, newElementHash);
                while (cursor < payload.length){
                  cursor++;
                  var beginChunk: number = cursor;
                  while (cursor < payload.length && payload.charAt(cursor) != ':'){
                    cursor++;
                  }
                  var middleChunk: number = cursor;
                  while (cursor < payload.length && payload.charAt(cursor) != ','){
                    cursor++;
                  }
                  var loopKey: string = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, beginChunk, middleChunk);
                  var loopVal: number = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, middleChunk + 1, cursor);
                  var index: number = (org.kevoree.modeling.util.PrimitiveHelper.stringHash(loopKey) & 0x7FFFFFFF) % temp_state.elementDataSize;
                  var newIndex: number = this.elementCount;
                  temp_state.elementK[newIndex] = loopKey;
                  temp_state.elementV[newIndex] = loopVal;
                  var currentHashedIndex: number = temp_state.elementHash[index];
                  if (currentHashedIndex != -1) {
                    temp_state.elementNext[newIndex] = currentHashedIndex;
                  } else {
                    temp_state.elementNext[newIndex] = -2;
                  }
                  temp_state.elementHash[index] = newIndex;
                  this.elementCount++;
                }
                this.elementCount = nbElement;
                this.droppedCount = 0;
                this.state = temp_state;
                this.threshold = <number>(length * org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.loadFactor);
              }
              public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                buffer.append("#");
                org.kevoree.modeling.util.Base64.encodeIntToBuffer(this.elementCount, buffer);
                buffer.append('/');
                var isFirst: boolean = true;
                var internalState: org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState = this.state;
                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                  if (internalState.elementNext[i] != -1) {
                    var loopKey: string = internalState.elementK[i];
                    var loopValue: number = internalState.elementV[i];
                    if (!isFirst) {
                      buffer.append(",");
                    }
                    isFirst = false;
                    org.kevoree.modeling.util.Base64.encodeStringToBuffer(loopKey, buffer);
                    buffer.append(":");
                    org.kevoree.modeling.util.Base64.encodeLongToBuffer(loopValue, buffer);
                  }
                }
                return buffer.toString();
              }
              public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                this.clear();
              }
              public type(): number {
                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
              }
              public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                return this._space;
              }
              private internal_set_dirty(): void {
                if (this._space != null) {
                  if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                    this._space.declareDirty(this);
                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                  }
                } else {
                  this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                }
              }
              public getFlags(): number {
                return this._flags.get();
              }
              public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                var val: number;
                var nval: number;
                do {
                  val = this._flags.get();
                  nval = val & ~bitsToDisable | bitsToEnable;
                } while (!this._flags.compareAndSet(val, nval))
              }
              public universe(): number {
                return this._universe;
              }
              public time(): number {
                return this._time;
              }
              public obj(): number {
                return this._obj;
              }
              public dependencies(): Float64Array {
                return this._dependencies.get();
              }
              public addDependency(universe: number, time: number, uuid: number): void {
                var previousVal: Float64Array;
                var newVal: Float64Array;
                do {
                  previousVal = this._dependencies.get();
                  if (previousVal == null) {
                    newVal = new Float64Array([universe, time, uuid]);
                  } else {
                    newVal = new Float64Array(previousVal.length + 3);
                    var previousLength: number = previousVal.length;
                    java.lang.System.arraycopy(previousVal, 0, newVal, 0, previousLength);
                    newVal[previousLength] = universe;
                    newVal[previousLength + 1] = time;
                    newVal[previousLength + 2] = uuid;
                  }
                } while (!this._dependencies.compareAndSet(previousVal, newVal))
              }
            }
            export module HeapObjectIndexChunk {
              export class InternalState {
                public elementDataSize: number;
                public elementK: string[];
                public elementV: Float64Array;
                public elementNext: Int32Array;
                public elementHash: Int32Array;
                constructor(elementDataSize: number, elementK: string[], elementV: Float64Array, elementNext: Int32Array, elementHash: Int32Array) {
                  this.elementDataSize = elementDataSize;
                  this.elementK = elementK;
                  this.elementV = elementV;
                  this.elementNext = elementNext;
                  this.elementHash = elementHash;
                }
                public clone(): org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState {
                  var clonedElementK: string[] = new Array<string>(this.elementK.length);
                  java.lang.System.arraycopy(this.elementK, 0, clonedElementK, 0, this.elementK.length);
                  var clonedElementV: Float64Array = new Float64Array(this.elementV.length);
                  java.lang.System.arraycopy(this.elementV, 0, clonedElementV, 0, this.elementV.length);
                  var clonedElementNext: Int32Array = new Int32Array(this.elementNext.length);
                  java.lang.System.arraycopy(this.elementNext, 0, clonedElementNext, 0, this.elementNext.length);
                  var clonedElementHash: Int32Array = new Int32Array(this.elementHash.length);
                  java.lang.System.arraycopy(this.elementHash, 0, clonedElementHash, 0, this.elementHash.length);
                  return new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk.InternalState(this.elementDataSize, clonedElementK, clonedElementV, clonedElementNext, clonedElementHash);
                }
              }
            }
            export class ArrayStringMap<V> implements org.kevoree.modeling.memory.chunk.KStringMap<V> {
               constructor(initalCapacity: number, loadFactor : number) { }
               public clear():void { for(var p in this){ if(this.hasOwnProperty(p)){ delete this[p];} } }
               public get(key:string):V { return this[key]; }
               public put(key:string, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
               public contains(key:string):boolean { return this.hasOwnProperty(key);}
               public remove(key:string):V { var tmp = this[key]; delete this[key]; return tmp; }
               public size():number { return Object.keys(this).length; }
               public each(callback: org.kevoree.modeling.memory.chunk.KStringMapCallBack<V>): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(<string>p,this[p]); } } }
            }
            export class ArrayLongTree extends org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree implements org.kevoree.modeling.memory.chunk.KLongTree {
              constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                super(p_universe, p_time, p_obj, p_space);
              }
              public previousOrEqual(key: number): number {
                var result: number = this.internal_previousOrEqual_index(key);
                if (result != -1) {
                  return this.key(result);
                } else {
                  return org.kevoree.modeling.KConfig.NULL_LONG;
                }
              }
              public insertKey(p_key: number): void {
                this.internal_insert(p_key, p_key);
              }
              public type(): number {
                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE;
              }
            }
          }
          export interface KObjectChunk extends org.kevoree.modeling.memory.KChunk {
            clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;
            metaClassIndex(): number;
            toJSON(metaModel: org.kevoree.modeling.meta.KMetaModel): string;
            setPrimitiveType(index: number, content: any, metaClass: org.kevoree.modeling.meta.KMetaClass): void;
            getPrimitiveType(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): any;
            getLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array;
            getLongArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;
            getLongArrayElem(index: number, refIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;
            addLongToArray(index: number, newRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean;
            removeLongToArray(index: number, previousRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean;
            clearLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;
            getDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array;
            getDoubleArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;
            getDoubleArrayElem(index: number, arrayIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;
            setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;
            extendDoubleArray(index: number, newSize: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;
            clearDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;
          }
          export interface KStringMapCallBack<V> {
            (key: string, value: V): void;
          }
          export interface KIntMap<V> {
            contains(key: number): boolean;
            get(key: number): V;
            put(key: number, value: V): void;
            each(callback: org.kevoree.modeling.memory.chunk.KIntMapCallBack<V>): void;
          }
          export interface KTreeWalker {
            elem(t: number): void;
          }
          export interface KObjectIndexChunk extends org.kevoree.modeling.memory.chunk.KObjectChunk, org.kevoree.modeling.memory.chunk.KStringLongMap {
          }
          export interface KStringLongMap {
            contains(key: string): boolean;
            get(key: string): number;
            put(key: string, value: number): void;
            each(callback: org.kevoree.modeling.memory.chunk.KStringLongMapCallBack): void;
            size(): number;
            clear(): void;
            remove(key: string): void;
          }
          export interface KLongLongTree extends org.kevoree.modeling.memory.chunk.KTree {
            insert(key: number, value: number): void;
            previousOrEqualValue(key: number): number;
            lookupValue(key: number): number;
          }
        }
        export namespace resolver {
          export namespace impl {
            export class DistortedTimeResolver implements org.kevoree.modeling.memory.resolver.KResolver {
              private static KEYS_SIZE: number = 3;
              private _spaceManager: org.kevoree.modeling.memory.space.KChunkSpaceManager;
              private _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
              constructor(p_cache: org.kevoree.modeling.memory.space.KChunkSpaceManager, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                this._spaceManager = p_cache;
                this._manager = p_manager;
                this._spaceManager.setResolver(this);
              }
              public lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): org.kevoree.modeling.scheduler.KTask {
                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                return {
                  run: function () {
                    try {
                      selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                        if (theGlobalUniverseOrderElement != null) {
                          selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid, (theObjectUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                            if (theObjectUniverseOrderElement == null) {
                              selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                              callback(null);
                            } else {
                              var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>theObjectUniverseOrderElement, time, universe);
                              selfPointer.getOrLoadAndMark(closestUniverse, org.kevoree.modeling.KConfig.NULL_LONG, uuid, (theObjectTimeTreeElement : org.kevoree.modeling.memory.KChunk) => {
                                if (theObjectTimeTreeElement == null) {
                                  selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                  selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                  callback(null);
                                } else {
                                  var closestTime: number = (<org.kevoree.modeling.memory.chunk.KLongTree>theObjectTimeTreeElement).previousOrEqual(time);
                                  if (closestTime == org.kevoree.modeling.KConfig.NULL_LONG) {
                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                    callback(null);
                                    return;
                                  }
                                  selfPointer.getOrLoadAndMark(closestUniverse, closestTime, uuid, (theObjectChunk : org.kevoree.modeling.memory.KChunk) => {
                                    if (theObjectChunk == null) {
                                      selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                      selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                      selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                      callback(null);
                                    } else {
                                      var metaClassIndex: number = (<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunk).metaClassIndex();
                                      var newProxy: org.kevoree.modeling.KObject;
                                      if (metaClassIndex == org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE.index()) {
                                        newProxy = new org.kevoree.modeling.meta.impl.GenericObjectIndex(universe, time, uuid, selfPointer._manager, closestUniverse, closestTime);
                                      } else {
                                        var resolvedMetaClass: org.kevoree.modeling.meta.KMetaClass = selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunk).metaClassIndex());
                                        newProxy = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuid, resolvedMetaClass, closestUniverse, closestTime);
                                      }
                                      selfPointer._spaceManager.register(newProxy);
                                      callback(newProxy);
                                    }
                                  });
                                }
                              });
                            }
                          });
                        } else {
                          callback(null);
                        }
                      });
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                };
              }
              public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask {
                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                return {
                  run: function () {
                    try {
                      selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                        if (theGlobalUniverseOrderElement != null) {
                          var tempObjectUniverseKeys: Float64Array = new Float64Array(uuids.length * 3);
                          for (var i: number = 0; i < uuids.length; i++) {
                            tempObjectUniverseKeys[i * 3] = org.kevoree.modeling.KConfig.NULL_LONG;
                            tempObjectUniverseKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                            tempObjectUniverseKeys[i * 3 + 2] = uuids[i];
                          }
                          selfPointer.getOrLoadAndMarkAll(tempObjectUniverseKeys, (objectUniverseOrderElements : org.kevoree.modeling.memory.KChunk[]) => {
                            if (objectUniverseOrderElements == null || objectUniverseOrderElements.length == 0) {
                              selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                              callback(new Array<org.kevoree.modeling.KObject>(0));
                              return;
                            }
                            var tempObjectTimeTreeKeys: Float64Array = new Float64Array(uuids.length * 3);
                            for (var i: number = 0; i < uuids.length; i++) {
                              var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>objectUniverseOrderElements[i], time, universe);
                              tempObjectTimeTreeKeys[i * 3] = closestUniverse;
                              tempObjectTimeTreeKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                              tempObjectTimeTreeKeys[i * 3 + 2] = uuids[i];
                            }
                            selfPointer.getOrLoadAndMarkAll(tempObjectTimeTreeKeys, (objectTimeTreeElements : org.kevoree.modeling.memory.KChunk[]) => {
                              if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                callback(new Array<org.kevoree.modeling.KObject>(0));
                                return;
                              }
                              var tempObjectChunkKeys: Float64Array = new Float64Array(uuids.length * 3);
                              for (var i: number = 0; i < uuids.length; i++) {
                                var closestTime: number = (<org.kevoree.modeling.memory.chunk.KLongTree>objectTimeTreeElements[i]).previousOrEqual(time);
                                if (closestTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                  tempObjectChunkKeys[i * 3] = tempObjectTimeTreeKeys[i * 3];
                                  tempObjectChunkKeys[i * 3 + 1] = closestTime;
                                  tempObjectChunkKeys[i * 3 + 2] = uuids[i];
                                } else {
                                  java.lang.System.arraycopy(org.kevoree.modeling.KContentKey.NULL_KEY, 0, tempObjectChunkKeys, (i * 3), 3);
                                }
                              }
                              selfPointer.getOrLoadAndMarkAll(tempObjectChunkKeys, (theObjectChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                if (theObjectChunks == null || theObjectChunks.length == 0) {
                                  selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                  selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                  selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                  callback(new Array<org.kevoree.modeling.KObject>(0));
                                } else {
                                  var finalResult: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(uuids.length);
                                  for (var h: number = 0; h < theObjectChunks.length; h++) {
                                    if (theObjectChunks[h] != null) {
                                      finalResult[h] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuids[h], selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunks[h]).metaClassIndex()), tempObjectTimeTreeKeys[h * 3], tempObjectChunkKeys[h * 3 + 1]);
                                    } else {
                                      finalResult[h] = null;
                                    }
                                  }
                                  selfPointer._spaceManager.registerAll(finalResult);
                                  callback(finalResult);
                                }
                              });
                            });
                          });
                        }
                      });
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                };
              }
              public lookupPreciseKeys(keys: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask {
                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                return {
                  run: function () {
                    try {
                      selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                        if (theGlobalUniverseOrderElement != null) {
                          var allOrderedKeys: Float64Array = new Float64Array(keys.length * 3);
                          var insertIndex: number = 0;
                          var nbKeys: number = keys.length / 3;
                          for (var i: number = 0; i < nbKeys; i++) {
                            allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                            insertIndex++;
                            allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3];
                            insertIndex++;
                            allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3];
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3 + 1];
                            insertIndex++;
                            allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                            insertIndex++;
                          }
                          selfPointer.getOrLoadAndMarkAll(allOrderedKeys, (kChunks : org.kevoree.modeling.memory.KChunk[]) => {
                            if (kChunks == null || kChunks.length == 0) {
                              selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                              callback(new Array<org.kevoree.modeling.KObject>(0));
                              return;
                            } else {
                              var finalResult: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(nbKeys);
                              var insertIndex: number = 0;
                              var previousClassIndex: number = -1;
                              for (var h: number = 0; h < kChunks.length; h++) {
                                if (kChunks[h] != null && kChunks[h].type() == org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK) {
                                  finalResult[insertIndex] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(kChunks[h].universe(), kChunks[h].time(), kChunks[h].obj(), selfPointer._manager.model().metaModel().metaClass(previousClassIndex), kChunks[h].universe(), kChunks[h].time());
                                  insertIndex++;
                                } else {
                                  if (kChunks[h] != null && kChunks[h].type() == org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP) {
                                    var casted: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>kChunks[h];
                                    previousClassIndex = casted.metaClassIndex();
                                  }
                                }
                              }
                              selfPointer._spaceManager.registerAll(finalResult);
                              callback(finalResult);
                            }
                          });
                        }
                      });
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                };
              }
              public lookupPrepared(preparedLookup: org.kevoree.modeling.KPreparedLookup, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask {
                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                var nbObjs: number = preparedLookup.flatLookup().length / 3;
                var flat: Float64Array = preparedLookup.flatLookup();
                return {
                  run: function () {
                    try {
                      selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                        if (theGlobalUniverseOrderElement != null) {
                          var tempObjectUniverseKeys: Float64Array = new Float64Array(nbObjs * 3);
                          for (var i: number = 0; i < nbObjs; i++) {
                            tempObjectUniverseKeys[i * 3] = org.kevoree.modeling.KConfig.NULL_LONG;
                            tempObjectUniverseKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                            tempObjectUniverseKeys[i * 3 + 2] = flat[i * 3 + 2];
                          }
                          selfPointer.getOrLoadAndMarkAll(tempObjectUniverseKeys, (objectUniverseOrderElements : org.kevoree.modeling.memory.KChunk[]) => {
                            if (objectUniverseOrderElements == null || objectUniverseOrderElements.length == 0) {
                              selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                              callback(new Array<org.kevoree.modeling.KObject>(0));
                              return;
                            }
                            var tempObjectTimeTreeKeys: Float64Array = new Float64Array(nbObjs * 3);
                            for (var i: number = 0; i < nbObjs; i++) {
                              var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>objectUniverseOrderElements[i], flat[i * 3 + 1], flat[i * 3]);
                              tempObjectTimeTreeKeys[i * 3] = closestUniverse;
                              tempObjectTimeTreeKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                              tempObjectTimeTreeKeys[i * 3 + 2] = flat[i * 3 + 2];
                            }
                            selfPointer.getOrLoadAndMarkAll(tempObjectTimeTreeKeys, (objectTimeTreeElements : org.kevoree.modeling.memory.KChunk[]) => {
                              if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                callback(new Array<org.kevoree.modeling.KObject>(0));
                                return;
                              }
                              var tempObjectChunkKeys: Float64Array = new Float64Array(nbObjs * 3);
                              for (var i: number = 0; i < nbObjs; i++) {
                                var closestTime: number = (<org.kevoree.modeling.memory.chunk.KLongTree>objectTimeTreeElements[i]).previousOrEqual(flat[i * 3 + 1]);
                                if (closestTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                  tempObjectChunkKeys[i * 3] = tempObjectTimeTreeKeys[i * 3];
                                  tempObjectChunkKeys[i * 3 + 1] = closestTime;
                                  tempObjectChunkKeys[i * 3 + 2] = flat[i * 3 + 2];
                                } else {
                                  java.lang.System.arraycopy(org.kevoree.modeling.KContentKey.NULL_KEY, 0, tempObjectChunkKeys, (i * 3), 3);
                                }
                              }
                              selfPointer.getOrLoadAndMarkAll(tempObjectChunkKeys, (theObjectChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                if (theObjectChunks == null || theObjectChunks.length == 0) {
                                  selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                  selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                  selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                  callback(new Array<org.kevoree.modeling.KObject>(0));
                                } else {
                                  var finalResult: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(nbObjs);
                                  for (var h: number = 0; h < theObjectChunks.length; h++) {
                                    if (theObjectChunks[h] != null) {
                                      finalResult[h] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(flat[h * 3], flat[h * 3 + 1], flat[h * 3 + 2], selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunks[h]).metaClassIndex()), tempObjectTimeTreeKeys[h * 3], tempObjectChunkKeys[h * 3 + 1]);
                                    } else {
                                      finalResult[h] = null;
                                    }
                                  }
                                  selfPointer._spaceManager.registerAll(finalResult);
                                  callback(finalResult);
                                }
                              });
                            });
                          });
                        }
                      });
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                };
              }
              public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask {
                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                return {
                  run: function () {
                    try {
                      selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                        if (theGlobalUniverseOrderElement != null) {
                          selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid, (theObjectUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                            if (theObjectUniverseOrderElement == null) {
                              selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                              callback(null);
                            } else {
                              var closestUniverses: Float64Array = new Float64Array(times.length);
                              var closestUnikUniverse: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                              var nbUniverseToload: number = 0;
                              for (var i: number = 0; i < times.length; i++) {
                                closestUniverses[i] = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>theObjectUniverseOrderElement, times[i], universe);
                                if (!closestUnikUniverse.contains(closestUniverses[i])) {
                                  closestUnikUniverse.put(closestUniverses[i], nbUniverseToload);
                                  nbUniverseToload++;
                                }
                              }
                              var toLoadUniverseKeys: Float64Array = new Float64Array(nbUniverseToload * 3);
                              closestUnikUniverse.each((key : number, value : number) => {
                                var currentIndex: number = <number>(value * 3);
                                toLoadUniverseKeys[currentIndex] = value;
                                toLoadUniverseKeys[currentIndex + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                toLoadUniverseKeys[currentIndex + 2] = uuid;
                              });
                              selfPointer.getOrLoadAndMarkAll(toLoadUniverseKeys, (objectTimeTreeElements : org.kevoree.modeling.memory.KChunk[]) => {
                                if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                  selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                  selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                  callback(null);
                                } else {
                                  var closestTimes: Float64Array = new Float64Array(times.length);
                                  var closestUnikTimes: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                  var reverseTimeUniverse: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                  var nbTimesToload: number = 0;
                                  for (var i: number = 0; i < times.length; i++) {
                                    var alignedIndexOfUniverse: number = <number>closestUnikUniverse.get(closestUniverses[i]);
                                    closestTimes[i] = (<org.kevoree.modeling.memory.chunk.KLongTree>objectTimeTreeElements[alignedIndexOfUniverse]).previousOrEqual(times[i]);
                                    if (!closestUnikTimes.contains(closestTimes[i])) {
                                      closestUnikTimes.put(closestTimes[i], nbTimesToload);
                                      reverseTimeUniverse.put(closestTimes[i], closestUniverses[i]);
                                      nbTimesToload++;
                                    }
                                  }
                                  var toLoadTimesKeys: Float64Array = new Float64Array(nbTimesToload * 3);
                                  closestUnikTimes.each((key : number, value : number) => {
                                    var currentIndex: number = <number>(value * 3);
                                    toLoadTimesKeys[currentIndex] = reverseTimeUniverse.get(key);
                                    toLoadTimesKeys[currentIndex + 1] = key;
                                    toLoadTimesKeys[currentIndex + 2] = uuid;
                                  });
                                  selfPointer.getOrLoadAndMarkAll(toLoadTimesKeys, (objectChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                    if (objectChunks == null || objectChunks.length == 0) {
                                      selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                      selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                      selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                      callback(null);
                                    } else {
                                      var result: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(times.length);
                                      for (var i: number = 0; i < times.length; i++) {
                                        var resolvedUniverse: number = closestUniverses[i];
                                        var resolvedTime: number = closestTimes[i];
                                        var indexChunks: number = <number>closestUnikTimes.get(closestTimes[i]);
                                        if (indexChunks != -1 && resolvedUniverse != org.kevoree.modeling.KConfig.NULL_LONG && resolvedTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                          result[i] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, times[i], uuid, selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>objectChunks[indexChunks]).metaClassIndex()), resolvedUniverse, resolvedTime);
                                        } else {
                                          result[i] = null;
                                        }
                                      }
                                      selfPointer._spaceManager.registerAll(result);
                                      callback(result);
                                    }
                                  });
                                }
                              });
                            }
                          });
                        }
                      });
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                };
              }
              public preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                return this.internal_chunk(universe, time, uuid, false, metaClass, previousResolution);
              }
              public closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                return this.internal_chunk(universe, time, uuid, true, metaClass, previousResolution);
              }
              private internal_chunk(universe: number, requestedTime: number, uuid: number, useClosest: boolean, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                var time: number = requestedTime;
                if (metaClass.temporalResolution() != 1) {
                  time = time - (time % metaClass.temporalResolution());
                }
                var currentEntry: org.kevoree.modeling.memory.chunk.KObjectChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                if (currentEntry != null) {
                  var previous: Float64Array;
                  var current: Float64Array;
                  var diff: boolean = false;
                  do {
                    previous = previousResolution.get();
                    if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                      current = new Float64Array([universe, time]);
                      diff = true;
                    } else {
                      current = previous;
                    }
                  } while (!previousResolution.compareAndSet(previous, current))
                  if (diff) {
                    this._spaceManager.unmark(previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                  } else {
                    this._spaceManager.unmarkMemoryElement(currentEntry);
                  }
                  return currentEntry;
                }
                var objectUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid);
                if (objectUniverseTree == null) {
                  return null;
                }
                var globalUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                if (globalUniverseTree == null) {
                  this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                  return null;
                }
                var resolvedUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(globalUniverseTree, objectUniverseTree, time, universe);
                var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.getAndMark(resolvedUniverse, org.kevoree.modeling.KConfig.NULL_LONG, uuid);
                if (timeTree == null) {
                  this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                  this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                  return null;
                }
                var resolvedTime: number = timeTree.previousOrEqual(time);
                if (resolvedTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                  var needTimeCopy: boolean = !useClosest && (resolvedTime != time);
                  var needUniverseCopy: boolean = !useClosest && (resolvedUniverse != universe);
                  currentEntry = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(resolvedUniverse, resolvedTime, uuid);
                  if (currentEntry == null) {
                    console.error("DePhasing problem, null chunk unexpected");
                    this._spaceManager.unmarkMemoryElement(timeTree);
                    this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                    this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                    return null;
                  }
                  if (!needTimeCopy && !needUniverseCopy) {
                    var previous: Float64Array;
                    var current: Float64Array;
                    var diff: boolean = false;
                    do {
                      previous = previousResolution.get();
                      if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != resolvedUniverse || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != resolvedTime) {
                        current = new Float64Array([resolvedUniverse, resolvedTime]);
                        diff = true;
                      } else {
                        current = previous;
                      }
                    } while (!previousResolution.compareAndSet(previous, current))
                    if (diff) {
                      this._spaceManager.unmark(previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                    } else {
                      this._spaceManager.unmarkMemoryElement(currentEntry);
                    }
                    this._spaceManager.unmarkMemoryElement(timeTree);
                    this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                    this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                    return currentEntry;
                  } else {
                    var previous: Float64Array;
                    var current: Float64Array;
                    var diff: boolean = false;
                    do {
                      previous = previousResolution.get();
                      if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                        current = new Float64Array([universe, time]);
                        diff = true;
                      } else {
                        current = previous;
                      }
                    } while (!previousResolution.compareAndSet(previous, current))
                    if (diff) {
                      var clonedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._spaceManager.cloneAndMark(currentEntry, universe, time, uuid, this._manager.model().metaModel());
                      if (currentEntry.counter() > 2) {
                        currentEntry.addDependency(universe, time, uuid);
                        this._spaceManager.markMemoryElement(clonedChunk);
                      }
                      if (!needUniverseCopy) {
                        timeTree.insertKey(time);
                      } else {
                        var newTemporalTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.createAndMark(universe, org.kevoree.modeling.KConfig.NULL_LONG, uuid, org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE);
                        newTemporalTree.insertKey(time);
                        this._spaceManager.unmarkMemoryElement(timeTree);
                        objectUniverseTree.put(universe, time);
                      }
                      this._spaceManager.unmarkMemoryElement(currentEntry);
                      this._spaceManager.unmarkMemoryElement(currentEntry);
                      this._spaceManager.unmarkMemoryElement(timeTree);
                      this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                      this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                      return clonedChunk;
                    } else {
                      console.error("Should not be here !!!!");
                      this._spaceManager.unmarkMemoryElement(timeTree);
                      this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                      this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                      var waitingChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                      var i: number = 0;
                      while (waitingChunk == null && i < org.kevoree.modeling.KConfig.CAS_MAX_TRY){
                        waitingChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                        i++;
                      }
                      if (waitingChunk == null) {
                        throw new Error("CAS synchronisation problem!");
                      } else {
                        this._spaceManager.unmarkMemoryElement(currentEntry);
                        return waitingChunk;
                      }
                    }
                  }
                } else {
                  this._spaceManager.unmarkMemoryElement(timeTree);
                  this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                  this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                  return null;
                }
              }
              public indexObject(obj: org.kevoree.modeling.KObject): void {
                var metaClassIndex: number = obj.metaClass().index();
                var chunkType: number = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
                if (metaClassIndex == org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE.index()) {
                  chunkType = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK_INDEX;
                }
                var cacheEntry: org.kevoree.modeling.memory.chunk.KObjectChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.createAndMark(obj.universe(), obj.now(), obj.uuid(), chunkType);
                cacheEntry.init(null, this._manager.model().metaModel(), metaClassIndex);
                cacheEntry.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                cacheEntry.space().declareDirty(cacheEntry);
                var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.createAndMark(obj.universe(), org.kevoree.modeling.KConfig.NULL_LONG, obj.uuid(), org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE);
                timeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                timeTree.insertKey(obj.now());
                var universeTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.createAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, obj.uuid(), org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP);
                universeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                universeTree.put(obj.universe(), obj.now());
                this._spaceManager.register(obj);
              }
              public getOrLoadAndMark(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.memory.KChunk>): void {
                if (universe == org.kevoree.modeling.KContentKey.NULL_KEY[0] && time == org.kevoree.modeling.KContentKey.NULL_KEY[1] && uuid == org.kevoree.modeling.KContentKey.NULL_KEY[2]) {
                  callback(null);
                  return;
                }
                var cached: org.kevoree.modeling.memory.KChunk = this._spaceManager.getAndMark(universe, time, uuid);
                if (cached != null) {
                  callback(cached);
                } else {
                  this.load(new Float64Array([universe, time, uuid]), (loadedElements : org.kevoree.modeling.memory.KChunk[]) => {
                    callback(loadedElements[0]);
                  });
                }
              }
              public getOrLoadAndMarkAll(keys: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.memory.KChunk[]>): void {
                var nbKeys: number = keys.length / org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE;
                var toLoadIndexes: boolean[] = new Array<boolean>(nbKeys);
                var nbElem: number = 0;
                var result: org.kevoree.modeling.memory.KChunk[] = new Array<org.kevoree.modeling.memory.KChunk>(nbKeys);
                for (var i: number = 0; i < nbKeys; i++) {
                  if (keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE] == org.kevoree.modeling.KContentKey.NULL_KEY[0] && keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 1] == org.kevoree.modeling.KContentKey.NULL_KEY[1] && keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 2] == org.kevoree.modeling.KContentKey.NULL_KEY[2]) {
                    toLoadIndexes[i] = false;
                    result[i] = null;
                  } else {
                    result[i] = this._spaceManager.getAndMark(keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE], keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 1], keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 2]);
                    if (result[i] == null) {
                      toLoadIndexes[i] = true;
                      nbElem++;
                    } else {
                      toLoadIndexes[i] = false;
                    }
                  }
                }
                if (nbElem == 0) {
                  callback(result);
                } else {
                  var keysToLoad: Float64Array = new Float64Array(nbElem * 3);
                  var lastInsertedIndex: number = 0;
                  for (var i: number = 0; i < nbKeys; i++) {
                    if (toLoadIndexes[i]) {
                      keysToLoad[lastInsertedIndex] = keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE];
                      lastInsertedIndex++;
                      keysToLoad[lastInsertedIndex] = keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 1];
                      lastInsertedIndex++;
                      keysToLoad[lastInsertedIndex] = keys[i * org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.KEYS_SIZE + 2];
                      lastInsertedIndex++;
                    }
                  }
                  this.load(keysToLoad, (loadedElements : org.kevoree.modeling.memory.KChunk[]) => {
                    var currentIndexToMerge: number = 0;
                    for (var i: number = 0; i < nbKeys; i++) {
                      if (toLoadIndexes[i]) {
                        result[i] = loadedElements[currentIndexToMerge];
                        currentIndexToMerge++;
                      }
                    }
                    callback(result);
                  });
                }
              }
              public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<Float64Array>): void {
                var keys: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, currentUuid]);
                this.getOrLoadAndMarkAll(keys, (kMemoryChunks : org.kevoree.modeling.memory.KChunk[]) => {
                  if (kMemoryChunks == null || kMemoryChunks.length == 0) {
                    callback(new Float64Array(0));
                    return;
                  }
                  var collectedUniverse: Float64Array = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.universeSelectByRange(<org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[0], <org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[1], startTime, endTime, currentUniverse);
                  var nbKeys: number = collectedUniverse.length * 3;
                  var timeTreeKeys: Float64Array = new Float64Array(nbKeys);
                  for (var i: number = 0; i < collectedUniverse.length; i++) {
                    timeTreeKeys[i * 3] = collectedUniverse[i];
                    timeTreeKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                    timeTreeKeys[i * 3 + 2] = currentUuid;
                  }
                  var objUniverse: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[1];
                  this.getOrLoadAndMarkAll(timeTreeKeys, (timeTrees : org.kevoree.modeling.memory.KChunk[]) => {
                    if (timeTrees == null || timeTrees.length == 0) {
                      this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                      callback(new Float64Array(0));
                      return;
                    }
                    var collector: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                    var previousDivergenceTime: number = endTime;
                    for (var i: number = 0; i < collectedUniverse.length; i++) {
                      var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>timeTrees[i];
                      if (timeTree != null) {
                        var currentDivergenceTime: number = objUniverse.get(collectedUniverse[i]);
                        currentDivergenceTime = currentDivergenceTime > startTime ? currentDivergenceTime : startTime;
                        var finalPreviousDivergenceTime: number = previousDivergenceTime;
                        timeTree.range(currentDivergenceTime, previousDivergenceTime, {
                          elem: function (t: number) {
                            if (collector.size() == 0) {
                              collector.put(collector.size(), t);
                            } else {
                              if (t != finalPreviousDivergenceTime) {
                                collector.put(collector.size(), t);
                              }
                            }
                          }
                        });
                        previousDivergenceTime = currentDivergenceTime;
                      }
                    }
                    var orderedTime: Float64Array = new Float64Array(collector.size());
                    for (var i: number = 0; i < collector.size(); i++) {
                      orderedTime[i] = collector.get(i);
                    }
                    this._spaceManager.unmarkAllMemoryElements(timeTrees);
                    this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                    callback(orderedTime);
                  });
                });
              }
              public static resolve_universe(globalTree: org.kevoree.modeling.memory.chunk.KLongLongMap, objUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap, timeToResolve: number, originUniverseId: number): number {
                if (globalTree == null || objUniverseTree == null) {
                  return originUniverseId;
                }
                var currentUniverse: number = originUniverseId;
                var previousUniverse: number = org.kevoree.modeling.KConfig.NULL_LONG;
                var divergenceTime: number = objUniverseTree.get(currentUniverse);
                while (currentUniverse != previousUniverse){
                  if (divergenceTime != org.kevoree.modeling.KConfig.NULL_LONG && divergenceTime <= timeToResolve) {
                    return currentUniverse;
                  }
                  previousUniverse = currentUniverse;
                  currentUniverse = globalTree.get(currentUniverse);
                  divergenceTime = objUniverseTree.get(currentUniverse);
                }
                return originUniverseId;
              }
              public static universeSelectByRange(globalTree: org.kevoree.modeling.memory.chunk.KLongLongMap, objUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap, rangeMin: number, rangeMax: number, originUniverseId: number): Float64Array {
                var collected: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                var currentUniverse: number = originUniverseId;
                var previousUniverse: number = org.kevoree.modeling.KConfig.NULL_LONG;
                var divergenceTime: number = objUniverseTree.get(currentUniverse);
                while (currentUniverse != previousUniverse){
                  if (divergenceTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                    if (divergenceTime <= rangeMin) {
                      collected.put(collected.size(), currentUniverse);
                      break;
                    } else {
                      if (divergenceTime <= rangeMax) {
                        collected.put(collected.size(), currentUniverse);
                      }
                    }
                  }
                  previousUniverse = currentUniverse;
                  currentUniverse = globalTree.get(currentUniverse);
                  divergenceTime = objUniverseTree.get(currentUniverse);
                }
                var trimmed: Float64Array = new Float64Array(collected.size());
                for (var i: number = 0; i < collected.size(); i++) {
                  trimmed[<number>i] = collected.get(i);
                }
                return trimmed;
              }
              private load(keys: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.memory.KChunk[]>): void {
                this._manager.cdn().get(keys, (payloads : string[]) => {
                  var results: org.kevoree.modeling.memory.KChunk[] = new Array<org.kevoree.modeling.memory.KChunk>(keys.length / 3);
                  for (var i: number = 0; i < payloads.length; i++) {
                    var loopUniverse: number = keys[i * 3];
                    var loopTime: number = keys[i * 3 + 1];
                    var loopUuid: number = keys[i * 3 + 2];
                    var elemType: number;
                    if (loopUniverse == org.kevoree.modeling.KConfig.NULL_LONG) {
                      elemType = org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
                    } else {
                      if (loopTime == org.kevoree.modeling.KConfig.NULL_LONG) {
                        elemType = org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE;
                      } else {
                        if (payloads[i] == null || payloads[i].length < 1) {
                          elemType = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
                        } else {
                          var flag: string = payloads[i].charAt(0);
                          if (flag == '#') {
                            elemType = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK_INDEX;
                          } else {
                            elemType = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
                          }
                        }
                      }
                    }
                    results[i] = this._spaceManager.createAndMark(loopUniverse, loopTime, loopUuid, elemType);
                    var classIndex: number = -1;
                    if (loopUniverse != org.kevoree.modeling.KConfig.NULL_LONG && loopTime != org.kevoree.modeling.KConfig.NULL_LONG && loopUuid != org.kevoree.modeling.KConfig.NULL_LONG) {
                      var alreadyLoadedOrder: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, loopUuid);
                      if (alreadyLoadedOrder != null) {
                        classIndex = alreadyLoadedOrder.metaClassIndex();
                        this._spaceManager.unmarkMemoryElement(alreadyLoadedOrder);
                      }
                    }
                    results[i].init(payloads[i], this._manager.model().metaModel(), classIndex);
                  }
                  callback(results);
                });
              }
              public getRelatedKeysResultSize(): number {
                return 4;
              }
              public getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void {
                result[0] = universe;
                result[1] = time;
                result[2] = uuid;
                result[3] = universe;
                result[4] = org.kevoree.modeling.KConfig.NULL_LONG;
                result[5] = uuid;
                result[6] = org.kevoree.modeling.KConfig.NULL_LONG;
                result[7] = org.kevoree.modeling.KConfig.NULL_LONG;
                result[8] = uuid;
                result[9] = org.kevoree.modeling.KConfig.NULL_LONG;
                result[10] = org.kevoree.modeling.KConfig.NULL_LONG;
                result[11] = org.kevoree.modeling.KConfig.NULL_LONG;
              }
            }
          }
          export interface KResolver {
            lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): org.kevoree.modeling.scheduler.KTask;
            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask;
            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask;
            lookupPreciseKeys(keys: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask;
            lookupPrepared(preparedLookup: org.kevoree.modeling.KPreparedLookup, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): org.kevoree.modeling.scheduler.KTask;
            preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;
            closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;
            indexObject(obj: org.kevoree.modeling.KObject): void;
            resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<Float64Array>): void;
            getRelatedKeysResultSize(): number;
            getRelatedKeys(universe: number, time: number, uuid: number, result: Float64Array): void;
          }
        }
        export interface KOffHeapChunk extends org.kevoree.modeling.memory.KChunk {
          memoryAddress(): number;
          setMemoryAddress(address: number): void;
        }
        export namespace manager {
          export class DataManagerBuilder {
            private _driver: org.kevoree.modeling.cdn.KContentDeliveryDriver;
            private _scheduler: org.kevoree.modeling.scheduler.KScheduler;
            private _strategy: org.kevoree.modeling.memory.strategy.KMemoryStrategy;
            private _blas: org.kevoree.modeling.util.maths.structure.blas.KBlas;
            public driver(): org.kevoree.modeling.cdn.KContentDeliveryDriver {
              if (this._driver == null) {
                this._driver = new org.kevoree.modeling.cdn.impl.MemoryContentDeliveryDriver();
              }
              return this._driver;
            }
            public blas(): org.kevoree.modeling.util.maths.structure.blas.KBlas {
              if (this._blas == null) {
                this._blas = new org.kevoree.modeling.util.maths.structure.blas.impl.JavaBlas();
              }
              return this._blas;
            }
            public scheduler(): org.kevoree.modeling.scheduler.KScheduler {
               if (this._scheduler == null) { this._scheduler = new org.kevoree.modeling.scheduler.impl.DirectScheduler(); }
               return this._scheduler;
            }
            public strategy(): org.kevoree.modeling.memory.strategy.KMemoryStrategy {
              if (this._strategy == null) {
                this._strategy = new org.kevoree.modeling.memory.strategy.impl.HeapMemoryStrategy();
              }
              return this._strategy;
            }
            public static create(): org.kevoree.modeling.memory.manager.DataManagerBuilder {
              return new org.kevoree.modeling.memory.manager.DataManagerBuilder();
            }
            public withContentDeliveryDriver(p_driver: org.kevoree.modeling.cdn.KContentDeliveryDriver): org.kevoree.modeling.memory.manager.DataManagerBuilder {
              this._driver = p_driver;
              return this;
            }
            public withScheduler(p_scheduler: org.kevoree.modeling.scheduler.KScheduler): org.kevoree.modeling.memory.manager.DataManagerBuilder {
              this._scheduler = p_scheduler;
              return this;
            }
            public withMemoryStrategy(p_strategy: org.kevoree.modeling.memory.strategy.KMemoryStrategy): org.kevoree.modeling.memory.manager.DataManagerBuilder {
              this._strategy = p_strategy;
              return this;
            }
            public withBlas(p_blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.memory.manager.DataManagerBuilder {
              this._blas = p_blas;
              return this;
            }
            public build(): org.kevoree.modeling.memory.manager.internal.KInternalDataManager {
              return new org.kevoree.modeling.memory.manager.impl.DataManager(this.driver(), this.scheduler(), this.strategy(), this.blas());
            }
            public static buildDefault(): org.kevoree.modeling.memory.manager.internal.KInternalDataManager {
              return org.kevoree.modeling.memory.manager.DataManagerBuilder.create().build();
            }
          }
          export interface KDataManager {
            index(universe: number, time: number, indexName: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObjectIndex>): void;
            lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void;
            lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
            lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
            createPreparedLookup(size: number): org.kevoree.modeling.KPreparedLookup;
            lookupPrepared(prepared: org.kevoree.modeling.KPreparedLookup, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void;
            save(callback: org.kevoree.modeling.KCallback<Error>): void;
            model(): org.kevoree.modeling.KModel<any>;
            connect(callback: org.kevoree.modeling.KCallback<Error>): void;
            close(callback: org.kevoree.modeling.KCallback<Error>): void;
            blas(): org.kevoree.modeling.util.maths.structure.blas.KBlas;
          }
          export namespace impl {
            export class ListenerManager {
              private _keyGen: org.kevoree.modeling.memory.manager.impl.KeyCalculator;
              public _listeners: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.memory.manager.impl.HeapListener>;
              public _listener2Objects: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<Float64Array>;
              public _obj2Listener: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<Float64Array>;
              constructor() {
                this._keyGen = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(<number>0, 0);
                this._listeners = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<org.kevoree.modeling.memory.manager.impl.HeapListener>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                this._obj2Listener = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<Float64Array>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                this._listener2Objects = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<Float64Array>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
              }
              public clear(): void {
                this._listeners.clear();
                this._obj2Listener.clear();
                this._listener2Objects.clear();
              }
              public createListener(p_universe: number): org.kevoree.modeling.KListener {
                var newListener: org.kevoree.modeling.memory.manager.impl.HeapListener = new org.kevoree.modeling.memory.manager.impl.HeapListener(p_universe, this, this._keyGen.nextKey());
                this._listeners.put(newListener.listenerID(), newListener);
                return newListener;
              }
              public manageRegistration(listenerID: number, origin: org.kevoree.modeling.KObject): void {
                if (origin != null) {
                  if (!this._listener2Objects.contains(listenerID)) {
                    var newRec: Float64Array = new Float64Array(1);
                    newRec[0] = origin.uuid();
                    this._listener2Objects.put(listenerID, newRec);
                  } else {
                    var previous: Float64Array = this._listener2Objects.get(listenerID);
                    var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                    java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                    newArrayRec[previous.length] = origin.uuid();
                    this._listener2Objects.put(listenerID, newArrayRec);
                  }
                  if (!this._obj2Listener.contains(origin.uuid())) {
                    var newRec: Float64Array = new Float64Array(1);
                    newRec[0] = listenerID;
                    this._obj2Listener.put(origin.uuid(), newRec);
                  } else {
                    var previous: Float64Array = this._obj2Listener.get(origin.uuid());
                    var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                    java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                    newArrayRec[previous.length] = listenerID;
                    this._obj2Listener.put(origin.uuid(), newArrayRec);
                  }
                } else {
                  var objs: Float64Array = this._listener2Objects.get(listenerID);
                  if (objs != null) {
                    this._listener2Objects.remove(listenerID);
                    for (var i: number = 0; i < objs.length; i++) {
                      var registeredListener: Float64Array = this._obj2Listener.get(objs[i]);
                      var foundIndex: number = -1;
                      for (var j: number = 0; j < registeredListener.length; j++) {
                        if (registeredListener[j] == listenerID) {
                          foundIndex = j;
                        }
                      }
                      if (foundIndex != -1) {
                        if (foundIndex == 0) {
                          var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                          java.lang.System.arraycopy(objs, foundIndex, registeredListener2, 0, registeredListener.length - 1);
                          this._obj2Listener.put(objs[i], registeredListener2);
                        } else {
                          var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                          java.lang.System.arraycopy(objs, 0, registeredListener2, 0, foundIndex - 1);
                          java.lang.System.arraycopy(objs, foundIndex + 1, registeredListener2, foundIndex, registeredListener.length - foundIndex - 1);
                          this._obj2Listener.put(objs[i], registeredListener2);
                        }
                      }
                    }
                  }
                }
              }
              public isListened(obj: number): boolean {
                var notifier: Float64Array = this._obj2Listener.get(obj);
                if (notifier != null && notifier.length > 0) {
                  return true;
                }
                return false;
              }
              public dispatch(objects: org.kevoree.modeling.KObject[]): void {
                for (var i: number = 0; i < objects.length; i++) {
                  if (objects[i] != null) {
                    var notifier: Float64Array = this._obj2Listener.get(objects[i].uuid());
                    if (notifier != null && notifier.length > 0) {
                      for (var j: number = 0; j < notifier.length; j++) {
                        var ll: org.kevoree.modeling.memory.manager.impl.HeapListener = this._listeners.get(notifier[j]);
                        var cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject> = ll.cb;
                        if (cb != null) {
                          cb(objects[i]);
                        }
                      }
                    }
                  }
                }
              }
            }
            export class KeyCalculator {
               private _prefix: string;
               private _currentIndex: number;
              constructor(prefix: number, currentIndex: number) {
                 this._prefix = "0x" + prefix.toString(org.kevoree.modeling.KConfig.PREFIX_SIZE);
                 this._currentIndex = currentIndex;
              }
              public nextKey(): number {
                 if (this._currentIndex == org.kevoree.modeling.KConfig.KEY_PREFIX_MASK) {
                 throw new Error("Object Index could not be created because it exceeded the capacity of the current prefix. Ask for a new prefix.");
                 }
                 this._currentIndex++;
                 var indexHex = this._currentIndex.toString(org.kevoree.modeling.KConfig.PREFIX_SIZE);
                 var objectKey = parseInt(this._prefix + "000000000".substring(0,9-indexHex.length) + indexHex, org.kevoree.modeling.KConfig.PREFIX_SIZE);
                 if (objectKey >= org.kevoree.modeling.KConfig.NULL_LONG) {
                 throw new Error("Object Index exceeds teh maximum JavaScript number capacity. (2^"+org.kevoree.modeling.KConfig.LONG_SIZE+")");
                 }
                 return objectKey;
              }
              public lastComputedIndex(): number {
                 return this._currentIndex;
              }
              public prefix(): number {
                 return parseInt(this._prefix,org.kevoree.modeling.KConfig.PREFIX_SIZE);
              }
            }
            export class DataManager implements org.kevoree.modeling.memory.manager.KDataManager, org.kevoree.modeling.memory.manager.internal.KInternalDataManager {
              private static UNIVERSE_NOT_CONNECTED_ERROR: string = "Please connect your createModel prior to create a universe or an object";
              private _operationManager: org.kevoree.modeling.operation.KOperationManager;
              private _db: org.kevoree.modeling.cdn.KContentDeliveryDriver;
              private _scheduler: org.kevoree.modeling.scheduler.KScheduler;
              private _listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager;
              private _modelKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator;
              private _resolver: org.kevoree.modeling.memory.resolver.KResolver;
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              private _spaceManager: org.kevoree.modeling.memory.space.KChunkSpaceManager;
              private _blas: org.kevoree.modeling.util.maths.structure.blas.KBlas;
              private _objectKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator = null;
              private _universeKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator = null;
              private isConnected: boolean = false;
              private _prefix: number;
              private _model: org.kevoree.modeling.KModel<any>;
              private static UNIVERSE_INDEX: number = 0;
              private static OBJ_INDEX: number = 1;
              private static GLO_TREE_INDEX: number = 2;
              private static zeroPrefix: number = 0;
              private currentCdnListener: number = -1;
              private static PREFIX_TO_SAVE_SIZE: number = 2;
              private static KEY_SIZE: number = 3;
              public setModel(p_model: org.kevoree.modeling.KModel<any>): void {
                this._model = p_model;
              }
              constructor(p_cdn: org.kevoree.modeling.cdn.KContentDeliveryDriver, p_scheduler: org.kevoree.modeling.scheduler.KScheduler, p_factory: org.kevoree.modeling.memory.strategy.KMemoryStrategy, p_blas: org.kevoree.modeling.util.maths.structure.blas.KBlas) {
                this._space = p_factory.newSpace();
                this._scheduler = p_scheduler;
                this._spaceManager = p_factory.newSpaceManager(this._space, this._scheduler);
                this._resolver = new org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver(this._spaceManager, this);
                this._listenerManager = new org.kevoree.modeling.memory.manager.impl.ListenerManager();
                this._modelKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(org.kevoree.modeling.memory.manager.impl.DataManager.zeroPrefix, 0);
                this._db = p_cdn;
                this.attachContentDeliveryDriver(new org.kevoree.modeling.cdn.impl.MemoryContentDeliveryDriver());
                this._operationManager = new org.kevoree.modeling.operation.impl.HashOperationManager(this);
                this._blas = p_blas;
              }
              public model(): org.kevoree.modeling.KModel<any> {
                return this._model;
              }
              public blas(): org.kevoree.modeling.util.maths.structure.blas.KBlas {
                return this._blas;
              }
              public nextUniverseKey(): number {
                if (this._universeKeyCalculator == null) {
                  throw new Error(org.kevoree.modeling.memory.manager.impl.DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                }
                return this._universeKeyCalculator.nextKey();
              }
              public nextObjectKey(): number {
                if (this._objectKeyCalculator == null) {
                  throw new Error(org.kevoree.modeling.memory.manager.impl.DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                }
                return this._objectKeyCalculator.nextKey();
              }
              public nextModelKey(): number {
                return this._modelKeyCalculator.nextKey();
              }
              public initUniverse(p_universe: number, p_parent: number): void {
                var cached: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._space.get(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                if (cached != null && !cached.contains(p_universe)) {
                  cached.put(p_universe, p_parent);
                }
              }
              public save(callback: org.kevoree.modeling.KCallback<Error>): void {
                var selfPointer: org.kevoree.modeling.memory.manager.impl.DataManager = this;
                this._scheduler.dispatch({
                  run: function () {
                    var dirtyIterator: org.kevoree.modeling.memory.space.KChunkIterator = selfPointer._space.detachDirties();
                    if (dirtyIterator.size() == 0) {
                      if (callback != null) {
                        callback(null);
                      }
                      return;
                    }
                    var toSaveKeys: Float64Array = new Float64Array((dirtyIterator.size() + org.kevoree.modeling.memory.manager.impl.DataManager.PREFIX_TO_SAVE_SIZE) * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE);
                    var toSaveValues: string[] = new Array<string>(dirtyIterator.size() + org.kevoree.modeling.memory.manager.impl.DataManager.PREFIX_TO_SAVE_SIZE);
                    var i: number = 0;
                    var _mm: org.kevoree.modeling.meta.KMetaModel = selfPointer._model.metaModel();
                    while (dirtyIterator.hasNext()){
                      var loopChunkKeys: Float64Array = dirtyIterator.next();
                      var loopChunk: org.kevoree.modeling.memory.KChunk = selfPointer._spaceManager.getAndMark(loopChunkKeys[0], loopChunkKeys[1], loopChunkKeys[2]);
                      if (loopChunk != null && (loopChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) == org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT && (loopChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) != org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) {
                        toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] = loopChunk.universe();
                        toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] = loopChunk.time();
                        toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] = loopChunk.obj();
                        try {
                          toSaveValues[i] = loopChunk.serialize(_mm);
                          loopChunk.setFlags(0, org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT);
                          i++;
                        } catch ($ex$) {
                          if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);
                          } else {
                            throw $ex$;
                          }
                        }
                        selfPointer._spaceManager.unmarkMemoryElement(loopChunk);
                      }
                    }
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] = org.kevoree.modeling.KConfig.BEGINNING_OF_TIME;
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] = selfPointer._objectKeyCalculator.prefix();
                    toSaveValues[i] = "" + selfPointer._objectKeyCalculator.lastComputedIndex();
                    i++;
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] = org.kevoree.modeling.KConfig.END_OF_TIME;
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                    toSaveKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] = selfPointer._universeKeyCalculator.prefix();
                    toSaveValues[i] = "" + selfPointer._universeKeyCalculator.lastComputedIndex();
                    selfPointer._db.put(toSaveKeys, toSaveValues, callback, selfPointer.currentCdnListener);
                  }
                });
              }
              public initKObject(obj: org.kevoree.modeling.KObject): void {
                this._resolver.indexObject(obj);
              }
              public preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                var resolvedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._resolver.preciseChunk(universe, time, uuid, metaClass, previousResolution);
                if (resolvedChunk != null) {
                  return resolvedChunk;
                } else {
                  throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                }
              }
              public closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                var resolvedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._resolver.closestChunk(universe, time, uuid, metaClass, previousResolution);
                if (resolvedChunk != null) {
                  return resolvedChunk;
                } else {
                  throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                }
              }
              public connect(connectCallback: org.kevoree.modeling.KCallback<Error>): void {
                if (this.isConnected) {
                  if (connectCallback != null) {
                    connectCallback(null);
                  }
                }
                if (this._db == null) {
                  if (connectCallback != null) {
                    connectCallback(new Error("Please attach a KDataBase AND a KBroker first !"));
                  }
                } else {
                  var selfPointer: org.kevoree.modeling.memory.manager.impl.DataManager = this;
                  selfPointer._scheduler.start();
                  selfPointer._scheduler.dispatch({
                    run: function () {
                      selfPointer._db.connect((throwable : Error) => {
                        if (throwable == null) {
                          var mappings: string[] = selfPointer._operationManager.mappings();
                          if (mappings != null && mappings.length >= 1) {
                            var operationMapping: org.kevoree.modeling.message.KMessage = new org.kevoree.modeling.message.impl.Message();
                            operationMapping.setType(org.kevoree.modeling.message.impl.Message.OPERATION_MAPPING);
                            operationMapping.setValues(mappings);
                            selfPointer._db.sendToPeer(null, operationMapping, null);
                          }
                          selfPointer._db.atomicGetIncrement(new Float64Array([org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]), (newPrefix : number) => {
                            selfPointer._prefix = newPrefix;
                            var connectionKeys: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, newPrefix, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, newPrefix, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]);
                            selfPointer._db.get(connectionKeys, (strings : string[]) => {
                              if (strings.length == 3) {
                                var detected: Error = null;
                                try {
                                  var uniIndexPayload: string = strings[org.kevoree.modeling.memory.manager.impl.DataManager.UNIVERSE_INDEX];
                                  if (uniIndexPayload == null || org.kevoree.modeling.util.PrimitiveHelper.equals(uniIndexPayload, "")) {
                                    uniIndexPayload = "0";
                                  }
                                  var objIndexPayload: string = strings[org.kevoree.modeling.memory.manager.impl.DataManager.OBJ_INDEX];
                                  if (objIndexPayload == null || org.kevoree.modeling.util.PrimitiveHelper.equals(objIndexPayload, "")) {
                                    objIndexPayload = "0";
                                  }
                                  var globalUniverseTreePayload: string = strings[org.kevoree.modeling.memory.manager.impl.DataManager.GLO_TREE_INDEX];
                                  var globalUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>selfPointer._spaceManager.createAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP);
                                  if (globalUniverseTreePayload != null) {
                                    try {
                                      globalUniverseTree.init(globalUniverseTreePayload, selfPointer.model().metaModel(), -1);
                                    } catch ($ex$) {
                                      if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);
                                      } else {
                                        throw $ex$;
                                      }
                                    }
                                  }
                                  var newUniIndex: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(uniIndexPayload);
                                  var newObjIndex: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objIndexPayload);
                                  selfPointer._universeKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(selfPointer._prefix, newUniIndex);
                                  selfPointer._objectKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(selfPointer._prefix, newObjIndex);
                                  selfPointer.isConnected = true;
                                } catch ($ex$) {
                                  if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    detected = e;
                                  } else {
                                    throw $ex$;
                                  }
                                }
                                if (connectCallback != null) {
                                  connectCallback(detected);
                                }
                              } else {
                                if (connectCallback != null) {
                                  connectCallback(new Error("Error while connecting the KDataStore..."));
                                }
                              }
                            });
                          });
                        } else {
                          if (connectCallback != null) {
                            connectCallback(throwable);
                          }
                        }
                      });
                    }
                  });
                }
              }
              public close(callback: org.kevoree.modeling.KCallback<Error>): void {
                if (this.isConnected) {
                  this._scheduler.stop();
                  this.isConnected = false;
                  if (this._db != null) {
                    this._db.close(callback);
                  } else {
                    if (callback != null) {
                      callback(null);
                    }
                  }
                } else {
                  if (callback != null) {
                    callback(null);
                  }
                }
              }
              public deleteUniverse(p_universe: org.kevoree.modeling.KUniverse<any, any>, callback: org.kevoree.modeling.KCallback<Error>): void {
                throw new Error("Not implemented yet !");
              }
              public lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
                this._scheduler.dispatch(this._resolver.lookup(universe, time, uuid, callback));
              }
              public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
                this._scheduler.dispatch(this._resolver.lookupAllObjects(universe, time, uuids, callback));
              }
              public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
                this._scheduler.dispatch(this._resolver.lookupAllTimes(universe, times, uuid, callback));
              }
              public createPreparedLookup(p_size: number): org.kevoree.modeling.KPreparedLookup {
                return new org.kevoree.modeling.memory.manager.impl.PreparedLookup(p_size);
              }
              public lookupPrepared(prepared: org.kevoree.modeling.KPreparedLookup, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
                this._scheduler.dispatch(this._resolver.lookupPrepared(prepared, callback));
              }
              public cdn(): org.kevoree.modeling.cdn.KContentDeliveryDriver {
                return this._db;
              }
              public scheduler(): org.kevoree.modeling.scheduler.KScheduler {
                return this._scheduler;
              }
              private attachContentDeliveryDriver(p_dataBase: org.kevoree.modeling.cdn.KContentDeliveryDriver): void {
                var selfPointer: org.kevoree.modeling.memory.manager.impl.DataManager = this;
                this.currentCdnListener = selfPointer._db.addUpdateListener({
                  onKeysUpdate: function (updatedKeys: Float64Array) {
                    var toLoadKeys: Float64Array = new Float64Array(updatedKeys.length);
                    var toInsertNotifyKey: number = 0;
                    var toNotifyKeys: Float64Array = new Float64Array(updatedKeys.length);
                    var nbElements: number = updatedKeys.length / org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE;
                    var toInsertKey: number = 0;
                    for (var i: number = 0; i < nbElements; i++) {
                      var currentChunk: org.kevoree.modeling.memory.KChunk = selfPointer._spaceManager.getAndMark(updatedKeys[i * 3], updatedKeys[i * 3 + 1], updatedKeys[i * 3 + 2]);
                      if (currentChunk != null) {
                        if ((currentChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                          toLoadKeys[toInsertKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE];
                          toLoadKeys[toInsertKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1];
                          toLoadKeys[toInsertKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2];
                          toInsertKey++;
                        }
                        selfPointer._spaceManager.unmarkMemoryElement(currentChunk);
                      }
                      if (selfPointer._listenerManager.isListened(updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2]) && updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] != org.kevoree.modeling.KConfig.NULL_LONG && updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] != org.kevoree.modeling.KConfig.NULL_LONG && updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] != org.kevoree.modeling.KConfig.NULL_LONG) {
                        toNotifyKeys[toInsertNotifyKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE];
                        toNotifyKeys[toInsertNotifyKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 1];
                        toNotifyKeys[toInsertNotifyKey * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2] = updatedKeys[i * org.kevoree.modeling.memory.manager.impl.DataManager.KEY_SIZE + 2];
                        toInsertNotifyKey++;
                      }
                    }
                    if (toInsertKey == 0 && toInsertNotifyKey == 0) {
                      return;
                    }
                    var trimmedToLoad: Float64Array = new Float64Array(toInsertKey * 3);
                    java.lang.System.arraycopy(toLoadKeys, 0, trimmedToLoad, 0, toInsertKey * 3);
                    var trimmedToNotify: Float64Array = new Float64Array(toInsertNotifyKey * 3);
                    java.lang.System.arraycopy(toNotifyKeys, 0, trimmedToNotify, 0, toInsertNotifyKey * 3);
                    var mm: org.kevoree.modeling.meta.KMetaModel = selfPointer._model.metaModel();
                    selfPointer._db.get(trimmedToLoad, (payloads : string[]) => {
                      for (var i: number = 0; i < payloads.length; i++) {
                        if (payloads[i] != null) {
                          var currentChunk: org.kevoree.modeling.memory.KChunk = selfPointer._spaceManager.getAndMark(trimmedToLoad[i * 3], trimmedToLoad[i * 3 + 1], trimmedToLoad[i * 3 + 2]);
                          if (currentChunk != null) {
                            currentChunk.init(payloads[i], mm, -1);
                            selfPointer._spaceManager.unmarkMemoryElement(currentChunk);
                          }
                        }
                      }
                      selfPointer._resolver.lookupPreciseKeys(trimmedToNotify, (updatedObjects : org.kevoree.modeling.KObject[]) => {
                        selfPointer._listenerManager.dispatch(updatedObjects);
                      }).run();
                    });
                  },
                  onOperationCall: function (operationCallMessage: org.kevoree.modeling.message.KMessage) {
                    selfPointer._operationManager.dispatch(operationCallMessage);
                  }
                });
              }
              public operationManager(): org.kevoree.modeling.operation.KOperationManager {
                return this._operationManager;
              }
              public createListener(p_universe: number): org.kevoree.modeling.KListener {
                return this._listenerManager.createListener(p_universe);
              }
              public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<Float64Array>): void {
                this._resolver.resolveTimes(currentUniverse, currentUuid, startTime, endTime, callback);
              }
              public spaceSize(): number {
                return this._space.size();
              }
              public printDebug(): void {
                this._space.printDebug(this._model.metaModel());
              }
              public index(universe: number, time: number, indexName: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObjectIndex>): void {
                var selfPointer: org.kevoree.modeling.memory.manager.impl.DataManager = this;
                selfPointer._scheduler.dispatch(selfPointer._resolver.lookup(universe, time, org.kevoree.modeling.KConfig.END_OF_TIME, (kObject : org.kevoree.modeling.KObject) => {
                  var globalIndex: org.kevoree.modeling.KObjectIndex = <org.kevoree.modeling.KObjectIndex>kObject;
                  if (globalIndex == null) {
                    globalIndex = new org.kevoree.modeling.meta.impl.GenericObjectIndex(universe, time, org.kevoree.modeling.KConfig.END_OF_TIME, selfPointer, universe, time);
                    this.initKObject(globalIndex);
                  }
                  var indexUUID: number = globalIndex.getIndex(indexName);
                  if (indexUUID == org.kevoree.modeling.KConfig.NULL_LONG) {
                    var nextKey: number = this.nextObjectKey();
                    var namedIndex: org.kevoree.modeling.KObjectIndex = new org.kevoree.modeling.meta.impl.GenericObjectIndex(universe, time, nextKey, selfPointer, universe, time);
                    this.initKObject(namedIndex);
                    globalIndex.setIndex(indexName, nextKey);
                    if (org.kevoree.modeling.util.Checker.isDefined(callback)) {
                      callback(namedIndex);
                    }
                  } else {
                    selfPointer._scheduler.dispatch(selfPointer._resolver.lookup(universe, time, indexUUID, (namedIndex : org.kevoree.modeling.KObject) => {
                      if (org.kevoree.modeling.util.Checker.isDefined(callback)) {
                        callback(<org.kevoree.modeling.KObjectIndex>namedIndex);
                      }
                    }));
                  }
                }));
              }
            }
            export class PreparedLookup implements org.kevoree.modeling.KPreparedLookup {
              private _size: number;
              private _flatStatement: Float64Array;
              private _current: number = -1;
              constructor(p_size: number) {
                this._size = p_size;
                this._flatStatement = new Float64Array(p_size * 3);
                this._current = 0;
              }
              public addLookupOperation(universe: number, time: number, uuid: number): void {
                if (this._current >= this._size) {
                  throw new Error("PreparedLookup is full, prepared capacity:" + this._size);
                }
                this._flatStatement[this._current * 3] = universe;
                this._flatStatement[this._current * 3 + 1] = time;
                this._flatStatement[this._current * 3 + 2] = uuid;
                this._current++;
              }
              public flatLookup(): Float64Array {
                return this._flatStatement;
              }
            }
            export class HeapListener implements org.kevoree.modeling.KListener {
              private _universe: number;
              private _listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager;
              private _id: number;
              public cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>;
              public listenerID(): number {
                return this._id;
              }
              constructor(p_universe: number, p_listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager, p_id: number) {
                this._universe = p_universe;
                this._listenerManager = p_listenerManager;
                this._id = p_id;
              }
              public universe(): number {
                return 0;
              }
              public listenObjects(): Float64Array {
                return this._listenerManager._listener2Objects.get(this._id);
              }
              public listen(obj: org.kevoree.modeling.KObject): void {
                this._listenerManager.manageRegistration(this._id, obj);
              }
              public destroy(): void {
                this._listenerManager.manageRegistration(this._id, null);
              }
              public then(p_cb: org.kevoree.modeling.KCallback<any>): void {
                this.cb = p_cb;
              }
            }
          }
          export namespace internal {
            export interface KInternalDataManager extends org.kevoree.modeling.memory.manager.KDataManager {
              createListener(universe: number): org.kevoree.modeling.KListener;
              cdn(): org.kevoree.modeling.cdn.KContentDeliveryDriver;
              scheduler(): org.kevoree.modeling.scheduler.KScheduler;
              preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;
              closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;
              initKObject(obj: org.kevoree.modeling.KObject): void;
              initUniverse(universe: number, parent: number): void;
              nextUniverseKey(): number;
              nextObjectKey(): number;
              nextModelKey(): number;
              deleteUniverse(universe: org.kevoree.modeling.KUniverse<any, any>, callback: org.kevoree.modeling.KCallback<Error>): void;
              operationManager(): org.kevoree.modeling.operation.KOperationManager;
              setModel(model: org.kevoree.modeling.KModel<any>): void;
              resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<Float64Array>): void;
              spaceSize(): number;
              printDebug(): void;
            }
          }
        }
        export namespace strategy {
          export interface KMemoryStrategy {
            newSpace(): org.kevoree.modeling.memory.space.KChunkSpace;
            newSpaceManager(space: org.kevoree.modeling.memory.space.KChunkSpace, scheduler: org.kevoree.modeling.scheduler.KScheduler): org.kevoree.modeling.memory.space.KChunkSpaceManager;
          }
          export namespace impl {
            export class HeapMemoryStrategy implements org.kevoree.modeling.memory.strategy.KMemoryStrategy {
              public newSpace(): org.kevoree.modeling.memory.space.KChunkSpace {
                return new org.kevoree.modeling.memory.space.impl.HeapChunkSpace();
              }
              public newSpaceManager(p_space: org.kevoree.modeling.memory.space.KChunkSpace, p_scheduler: org.kevoree.modeling.scheduler.KScheduler): org.kevoree.modeling.memory.space.KChunkSpaceManager {
                 return new org.kevoree.modeling.memory.space.impl.NoopChunkSpaceManager(p_space);
              }
            }
          }
        }
        export namespace space {
          export interface KChunkSpaceManager {
            getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk;
            unmark(universe: number, time: number, obj: number): void;
            createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk;
            unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void;
            markMemoryElement(element: org.kevoree.modeling.memory.KChunk): void;
            unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void;
            cloneAndMark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;
            clear(): void;
            register(object: org.kevoree.modeling.KObject): void;
            registerAll(objects: org.kevoree.modeling.KObject[]): void;
            setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void;
          }
          export interface KChunkSpace {
            get(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk;
            create(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk;
            clone(previousElement: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;
            clear(metaModel: org.kevoree.modeling.meta.KMetaModel): void;
            free(metaModel: org.kevoree.modeling.meta.KMetaModel): void;
            remove(universe: number, time: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): void;
            size(): number;
            detachDirties(): org.kevoree.modeling.memory.space.KChunkIterator;
            declareDirty(dirtyChunk: org.kevoree.modeling.memory.KChunk): void;
            printDebug(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void;
          }
          export namespace impl {
            export class NoopChunkSpaceManager implements org.kevoree.modeling.memory.space.KChunkSpaceManager {
              private _space: org.kevoree.modeling.memory.space.KChunkSpace;
              constructor(p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._space = p_space;
              }
              public getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                return this._space.get(universe, time, obj);
              }
              public unmark(universe: number, time: number, obj: number): void {}
              public createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                return this._space.create(universe, time, obj, type);
              }
              public unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {}
              public markMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {}
              public unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void {}
              public cloneAndMark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                return this._space.clone(previous, newUniverse, newTime, obj, metaModel);
              }
              public clear(): void {}
              public register(object: org.kevoree.modeling.KObject): void {}
              public registerAll(objects: org.kevoree.modeling.KObject[]): void {}
              public setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void {}
            }
            export class HeapChunkSpace implements org.kevoree.modeling.memory.space.KChunkSpace {
              private static LOAD_FACTOR: number = (<number>75 / <number>100);
              private _state: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState>;
              private _dirtyState: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState>;
              constructor() {
                this._dirtyState = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState>();
                this._state = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState>();
                this._dirtyState.set(new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState());
                var initialCapacity: number = org.kevoree.modeling.KConfig.CACHE_INIT_SIZE;
                var newstate: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array<org.kevoree.modeling.memory.KChunk>(initialCapacity));
                for (var i: number = 0; i < initialCapacity; i++) {
                  newstate.elementNext[i] = -1;
                  newstate.elementHash.set(i, -1);
                }
                newstate._threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.space.impl.HeapChunkSpace.LOAD_FACTOR);
                this._state.set(newstate);
              }
              public get(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                var internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                if (internalState.elementDataSize == 0) {
                  return null;
                }
                var index: number = ((<number>(universe ^ time ^ obj)) & 0x7FFFFFFF) % internalState.elementDataSize;
                var m: number = internalState.elementHash.get(index);
                while (m != -1){
                  if (universe == internalState.elementK3[(m * 3)] && time == internalState.elementK3[((m * 3) + 1)] && obj == internalState.elementK3[((m * 3) + 2)]) {
                    return internalState.values[m];
                  } else {
                    m = internalState.elementNext[m];
                  }
                }
                return null;
              }
              public create(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                var newElement: org.kevoree.modeling.memory.KChunk = this.internal_createElement(universe, time, obj, type);
                return this.internal_put(universe, time, obj, newElement);
              }
              public clone(previousElement: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                return <org.kevoree.modeling.memory.chunk.KObjectChunk>this.internal_put(newUniverse, newTime, newObj, previousElement.clone(newUniverse, newTime, newObj, metaModel));
              }
              private internal_createElement(p_universe: number, p_time: number, p_obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                switch (type) {
                  case org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK:
                  return new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this);
                  case org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP:
                  return new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(p_universe, p_time, p_obj, this);
                  case org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE:
                  return new org.kevoree.modeling.memory.chunk.impl.ArrayLongTree(p_universe, p_time, p_obj, this);
                  case org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK_INDEX:
                  return new org.kevoree.modeling.memory.chunk.impl.HeapObjectIndexChunk(p_universe, p_time, p_obj, this);
                  default:
                  return null;
                }
              }
              private internal_put(universe: number, time: number, p_obj: number, payload: org.kevoree.modeling.memory.KChunk): org.kevoree.modeling.memory.KChunk {
                var currentState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                var nextState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                var result: org.kevoree.modeling.memory.KChunk;
                var nbTry: number = 0;
                do {
                  currentState = this._state.get();
                  var entry: number = -1;
                  var index: number = -1;
                  var hash: number = <number>(universe ^ time ^ p_obj);
                  if (currentState.elementDataSize != 0) {
                    index = (hash & 0x7FFFFFFF) % currentState.elementDataSize;
                    entry = this.findNonNullKeyEntry(universe, time, p_obj, index, currentState);
                  }
                  if (entry == -1) {
                    var nextValueIndex: number = currentState._valuesIndex.getAndIncrement();
                    if (nextValueIndex > currentState._threshold) {
                      return this.complex_insert(universe, time, p_obj, payload, hash, nextValueIndex);
                    } else {
                      nextState = currentState;
                    }
                    nextState.elementK3[(nextValueIndex * 3)] = universe;
                    nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                    nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                    nextState.values[nextValueIndex] = payload;
                    nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                    nextState._elementCount.incrementAndGet();
                    result = payload;
                  } else {
                    nextState = currentState;
                    result = nextState.values[entry];
                  }
                  nbTry++;
                  if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                    throw new Error("CompareAndSwap error, failed to converge");
                  }
                } while (!this._state.compareAndSet(currentState, nextState))
                return result;
              }
              private complex_insert(universe: number, time: number, p_obj: number, payload: org.kevoree.modeling.memory.KChunk, prehash: number, nextValueIndex: number): org.kevoree.modeling.memory.KChunk {
                var currentState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                var nextState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                do {
                  currentState = this._state.get();
                  if (nextValueIndex > currentState._threshold) {
                    nextState = this.rehashCapacity(currentState);
                  } else {
                    nextState = currentState;
                  }
                  var index: number = (prehash & 0x7FFFFFFF) % nextState.elementDataSize;
                  nextState.elementK3[(nextValueIndex * 3)] = universe;
                  nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                  nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                  nextState.values[nextValueIndex] = payload;
                  nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                  nextState._elementCount.incrementAndGet();
                } while (!this._state.compareAndSet(currentState, nextState))
                return payload;
              }
              private rehashCapacity(previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState): org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState {
                var length: number = (previousState.elementDataSize == 0 ? 1 : previousState.elementDataSize << 1);
                var newElementKV: Float64Array = new Float64Array(length * 3);
                var newValues: org.kevoree.modeling.memory.KChunk[] = new Array<org.kevoree.modeling.memory.KChunk>(length);
                var previousIsSparse: boolean = previousState.sparse;
                if (!previousIsSparse) {
                  java.lang.System.arraycopy(previousState.elementK3, 0, newElementKV, 0, previousState.elementDataSize * 3);
                  java.lang.System.arraycopy(previousState.values, 0, newValues, 0, previousState.elementDataSize);
                }
                var newElementNext: Int32Array = new Int32Array(length);
                var newElementHash: Int32Array = new Int32Array(length);
                for (var i: number = 0; i < length; i++) {
                  newElementNext[i] = -1;
                  newElementHash[i] = -1;
                }
                var currentIndex: number = 0;
                for (var i: number = 0; i < previousState.elementDataSize; i++) {
                  if (previousState.values[i] != null) {
                    var hash: number = <number>(previousState.elementK3[(i * 3)] ^ previousState.elementK3[(i * 3) + 1] ^ previousState.elementK3[(i * 3) + 2]);
                    var index: number = (hash & 0x7FFFFFFF) % length;
                    newElementNext[i] = newElementHash[index];
                    newElementHash[index] = i;
                    if (previousIsSparse) {
                      newValues[currentIndex] = previousState.values[i];
                      newElementKV[(currentIndex * 3)] = previousState.elementK3[(i * 3)];
                      newElementKV[(currentIndex * 3) + 1] = previousState.elementK3[(i * 3) + 1];
                      newElementKV[(currentIndex * 3) + 2] = previousState.elementK3[(i * 3) + 2];
                      currentIndex++;
                    }
                  }
                }
                var newState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(length, newElementKV, newElementNext, newElementHash, newValues);
                newState._threshold = <number>(length * org.kevoree.modeling.memory.space.impl.HeapChunkSpace.LOAD_FACTOR);
                newState._valuesIndex.set(previousState._valuesIndex.get());
                if (previousIsSparse) {
                  newState._elementCount.set(currentIndex);
                  newState._valuesIndex.set(currentIndex);
                } else {
                  newState._elementCount.set(previousState._elementCount.get());
                  newState._valuesIndex.set(previousState._valuesIndex.get());
                }
                return newState;
              }
              public findNonNullKeyEntry(universe: number, time: number, obj: number, index: number, internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState): number {
                var m: number = internalState.elementHash.get(index);
                while (m >= 0){
                  if (universe == internalState.elementK3[m * 3] && time == internalState.elementK3[(m * 3) + 1] && obj == internalState.elementK3[(m * 3) + 2]) {
                    return m;
                  }
                  m = internalState.elementNext[m];
                }
                return -1;
              }
              public detachDirties(): org.kevoree.modeling.memory.space.KChunkIterator {
                var detachedState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState = this._dirtyState.getAndSet(new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState());
                var maxIndex: number = detachedState._dirtyIndex.get();
                var shrinked: Float64Array = new Float64Array(maxIndex * 3);
                java.lang.System.arraycopy(detachedState._dirtyList, 0, shrinked, 0, maxIndex * 3);
                return new org.kevoree.modeling.memory.space.impl.ChunkIterator(shrinked, this);
              }
              public declareDirty(dirtyChunk: org.kevoree.modeling.memory.KChunk): void {
                var nbTry: number = 0;
                var current: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState;
                do {
                  current = this._dirtyState.get();
                  current.declareDirty(dirtyChunk.universe(), dirtyChunk.time(), dirtyChunk.obj());
                  nbTry++;
                  if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                    throw new Error("CompareAndSwap error, failed to converge");
                  }
                } while (!this._dirtyState.compareAndSet(current, current))
              }
              public remove(universe: number, time: number, obj: number, p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                var previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                var nbTry: number = 0;
                do {
                  previousState = this._state.get();
                  var hash: number = <number>(universe ^ time ^ obj);
                  var index: number = (hash & 0x7FFFFFFF) % previousState.elementDataSize;
                  if (previousState.elementDataSize == 0) {
                    return;
                  }
                  var m: number = previousState.elementHash.get(index);
                  var last: number = -1;
                  while (m >= 0){
                    if (universe == previousState.elementK3[m * 3] && time == previousState.elementK3[(m * 3) + 1] && obj == previousState.elementK3[(m * 3) + 2]) {
                      break;
                    }
                    last = m;
                    m = previousState.elementNext[m];
                  }
                  if (m == -1) {
                    return;
                  }
                  if (last == -1) {
                    var previousNext: number = previousState.elementNext[m];
                    if (!previousState.elementHash.compareAndSet(index, m, previousNext)) {
                    }
                  } else {
                    previousState.elementNext[last] = previousState.elementNext[m];
                  }
                  previousState.elementNext[m] = -1;
                  var previousValue: org.kevoree.modeling.memory.KChunk = previousState.values[m];
                  previousState.values[m] = null;
                  if (previousValue != null) {
                    previousValue.free(p_metaModel);
                  }
                  previousState._elementCount.decrementAndGet();
                  nbTry++;
                  if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                    throw new Error("CompareAndSwap error, failed to converge");
                  }
                } while (!this._state.compareAndSet(previousState, previousState))
              }
              public clear(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                var previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                if (previousState._elementCount.get() > 0) {
                  for (var i: number = 0; i < previousState.elementDataSize; i++) {
                    if (previousState.values[i] != null) {
                      previousState.values[i].free(metaModel);
                    }
                  }
                  var initialCapacity: number = org.kevoree.modeling.KConfig.CACHE_INIT_SIZE;
                  var newstate: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array<org.kevoree.modeling.memory.KChunk>(initialCapacity));
                  for (var i: number = 0; i < initialCapacity; i++) {
                    newstate.elementNext[i] = -1;
                    newstate.elementHash.set(i, -1);
                  }
                  newstate._elementCount.set(0);
                  newstate._valuesIndex.set(0);
                  newstate._threshold = <number>(newstate.elementDataSize * org.kevoree.modeling.memory.space.impl.HeapChunkSpace.LOAD_FACTOR);
                  this._state.set(newstate);
                }
              }
              public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                var internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.getAndSet(null);
                for (var i: number = 0; i < internalState.elementDataSize; i++) {
                  if (internalState.values[i] != null) {
                    internalState.values[i].free(metaModel);
                  }
                }
                internalState._elementCount.set(0);
                internalState._valuesIndex.set(0);
                internalState._threshold = 0;
              }
              public printDebug(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                try {
                  var state: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                  for (var i: number = 0; i < state.values.length; i++) {
                    var loopChunk: org.kevoree.modeling.memory.KChunk = state.values[i];
                    if (loopChunk != null) {
                      var content: string = loopChunk.serialize(p_metaModel);
                      console.log(state.elementK3[i * 3] + "," + state.elementK3[i * 3 + 1] + "," + state.elementK3[i * 3 + 2] + "=>" + loopChunk.type() + "(count:" + loopChunk.counter() + ",flag:" + loopChunk.getFlags() + ")" + "==>" + content);
                    }
                  }
                } catch ($ex$) {
                  if ($ex$ instanceof Error) {
                    var e: Error = <Error>$ex$;
                    console.error(e['stack']);
                  } else {
                    throw $ex$;
                  }
                }
              }
              public size(): number {
                return this._state.get()._elementCount.get();
              }
            }
            export module HeapChunkSpace {
              export class InternalState {
                public sparse: boolean = false;
                public elementDataSize: number;
                public elementK3: Float64Array;
                public elementNext: Int32Array;
                public elementHash: java.util.concurrent.atomic.AtomicIntegerArray;
                public values: org.kevoree.modeling.memory.KChunk[];
                public _elementCount: java.util.concurrent.atomic.AtomicInteger;
                public _valuesIndex: java.util.concurrent.atomic.AtomicInteger;
                public _threshold: number;
                constructor(p_elementDataSize: number, p_elementKE: Float64Array, p_elementNext: Int32Array, p_elementHash: Int32Array, p_values: org.kevoree.modeling.memory.KChunk[]) {
                  this.elementDataSize = p_elementDataSize;
                  this.elementK3 = p_elementKE;
                  this.elementNext = p_elementNext;
                  this.elementHash = new java.util.concurrent.atomic.AtomicIntegerArray(p_elementHash);
                  this.values = p_values;
                  this._elementCount = new java.util.concurrent.atomic.AtomicInteger(0);
                  this._valuesIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                }
              }

              export class InternalDirtyState {
                public _dirtyList: Float64Array;
                public _dirtyIndex: java.util.concurrent.atomic.AtomicInteger;
                constructor() {
                  this._dirtyList = new Float64Array(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE * 3);
                  this._dirtyIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                }
                public declareDirty(universe: number, time: number, obj: number): void {
                  var nextIndex: number = this._dirtyIndex.getAndIncrement() * 3;
                  if (nextIndex + 2 < this._dirtyList.length) {
                    this._dirtyList[nextIndex] = universe;
                    this._dirtyList[nextIndex + 1] = time;
                    this._dirtyList[nextIndex + 2] = obj;
                  } else {
                    this.reallocate(nextIndex);
                    this._dirtyList[nextIndex] = universe;
                    this._dirtyList[nextIndex + 1] = time;
                    this._dirtyList[nextIndex + 2] = obj;
                  }
                }
                private reallocate(wantedIndex: number): void {
                  if (wantedIndex + 2 >= this._dirtyList.length) {
                    var newlength: number = wantedIndex << 1;
                    var previousList: Float64Array = this._dirtyList;
                    this._dirtyList = new Float64Array(newlength);
                    java.lang.System.arraycopy(previousList, 0, this._dirtyList, 0, wantedIndex);
                  }
                }
              }
            }
            export abstract class AbstractCountingChunkSpaceManager implements org.kevoree.modeling.memory.space.KChunkSpaceManager {
              public _space: org.kevoree.modeling.memory.space.KChunkSpace;
              public _metaModel: org.kevoree.modeling.meta.KMetaModel;
              constructor(p_storage: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._space = p_storage;
              }
              public getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                var resolvedElement: org.kevoree.modeling.memory.KChunk = this._space.get(universe, time, obj);
                if (resolvedElement != null && (resolvedElement.getFlags() & org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) != org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) {
                  resolvedElement.inc();
                }
                return resolvedElement;
              }
              public unmark(universe: number, time: number, obj: number): void {
                var resolvedElement: org.kevoree.modeling.memory.KChunk = this._space.get(universe, time, obj);
                if (resolvedElement != null) {
                  var newCount: number = resolvedElement.dec();
                  if (newCount <= 0) {
                    this.cleanDependenciesAndPotentiallyRemoveChunk(resolvedElement);
                  }
                }
              }
              public createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                var newCreatedElement: org.kevoree.modeling.memory.KChunk = this._space.create(universe, time, obj, type);
                if (newCreatedElement != null) {
                  newCreatedElement.inc();
                }
                return newCreatedElement;
              }
              public unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {
                var newCount: number = element.dec();
                if (newCount <= 0) {
                  this.cleanDependenciesAndPotentiallyRemoveChunk(element);
                }
              }
              public markMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {
                element.inc();
              }
              public unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void {
                for (var i: number = 0; i < elements.length; i++) {
                  var loopChunk: org.kevoree.modeling.memory.KChunk = elements[i];
                  var newCount: number = elements[i].dec();
                  if (newCount <= 0) {
                    this.cleanDependenciesAndPotentiallyRemoveChunk(loopChunk);
                  }
                }
              }
              private cleanDependenciesAndPotentiallyRemoveChunk(toRemoveChunk: org.kevoree.modeling.memory.KChunk): void {
                var dependencies: Float64Array = toRemoveChunk.dependencies();
                if (dependencies != null && dependencies.length > 0) {
                  for (var i: number = 0; i < dependencies.length; i = i + 3) {
                    this.unmark(dependencies[i], dependencies[i + 1], dependencies[i + 2]);
                  }
                }
                if ((toRemoveChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                  toRemoveChunk.setFlags(org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT, 0);
                  this._space.remove(toRemoveChunk.universe(), toRemoveChunk.time(), toRemoveChunk.obj(), this._metaModel);
                }
              }
              public cloneAndMark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                var newCreatedElement: org.kevoree.modeling.memory.chunk.KObjectChunk = this._space.clone(previous, newUniverse, newTime, obj, metaModel);
                newCreatedElement.inc();
                return newCreatedElement;
              }
              public clear(): void {}
              public abstract register(object: org.kevoree.modeling.KObject): void;
              public abstract registerAll(objects: org.kevoree.modeling.KObject[]): void;
              public abstract setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void;
            }
            export class ChunkIterator implements org.kevoree.modeling.memory.space.KChunkIterator {
              private _dirties: Float64Array;
              private _origin: org.kevoree.modeling.memory.space.KChunkSpace;
              private currentIndex: number = 0;
              private maxIndex: number = 0;
              private tempKeys: Float64Array;
              constructor(p_dirties: Float64Array, p_origin: org.kevoree.modeling.memory.space.KChunkSpace) {
                this._dirties = p_dirties;
                this._origin = p_origin;
                this.maxIndex = p_dirties.length / 3;
                this.tempKeys = new Float64Array(3);
              }
              public hasNext(): boolean {
                return this.currentIndex < this.maxIndex;
              }
              public next(): Float64Array {
                if (this.currentIndex < this.maxIndex) {
                  this.tempKeys[0] = this._dirties[this.currentIndex * 3];
                  this.tempKeys[1] = this._dirties[this.currentIndex * 3 + 1];
                  this.tempKeys[2] = this._dirties[this.currentIndex * 3 + 2];
                }
                this.currentIndex++;
                return this.tempKeys;
              }
              public size(): number {
                return this.maxIndex;
              }
            }
          }
          export interface KChunkIterator {
            hasNext(): boolean;
            next(): Float64Array;
            size(): number;
          }
          export class KChunkTypes {
            public static OBJECT_CHUNK: number = 0;
            public static OBJECT_CHUNK_INDEX: number = 1;
            public static LONG_TREE: number = 2;
            public static LONG_LONG_MAP: number = 3;
          }
        }
        export class KChunkFlags {
          public static DIRTY_BIT_INDEX: number = 0;
          public static DIRTY_BIT: number = 1 << org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT_INDEX;
          public static REMOVED_BIT_INDEX: number = 1;
          public static REMOVED_BIT: number = 1 << org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT_INDEX;
        }
      }
      export namespace format {
        export interface KModelFormat {
          save(model: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<string>): void;
          load(payload: string, cb: org.kevoree.modeling.KCallback<any>): void;
        }
        export namespace json {
          export class JsonObjectReader {
             private readObject:any;
             public parseObject(payload:string):void {
             this.readObject = JSON.parse(payload);
             }
             public get(name:string):any {
             return this.readObject[name];
             }
             public getAsStringArray(name:string):string[] {
             return <string[]> this.readObject[name];
             }
             public keys():string[] {
             var keysArr: string[] = []
             for (var key in this.readObject) {
             keysArr.push(key);
             }
             return keysArr;
             }
          }
          export class JsonRaw {
            public static encode(raw: org.kevoree.modeling.memory.chunk.KObjectChunk, uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass): string {
              var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
              builder.append("{\"@class\":\"");
              builder.append(p_metaClass.metaName());
              builder.append("\",\"@uuid\":");
              builder.append(uuid);
              var metaElements: org.kevoree.modeling.meta.KMeta[] = p_metaClass.metaElements();
              for (var i: number = 0; i < metaElements.length; i++) {
                var loopMeta: org.kevoree.modeling.meta.KMeta = metaElements[i];
                if (loopMeta != null && loopMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                  var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>loopMeta;
                  var metaAttId: number = metaAttribute.attributeTypeId();
                  if (metaAttId == org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                    var inferAtt: Float64Array = raw.getDoubleArray(loopMeta.index(), p_metaClass);
                    if (inferAtt != null) {
                      builder.append(",\"");
                      builder.append(loopMeta.metaName());
                      builder.append("\":[");
                      for (var j: number = 0; j < inferAtt.length; j++) {
                        if (j != 0) {
                          builder.append(",");
                        }
                        builder.append(inferAtt[j]);
                      }
                      builder.append("]");
                    }
                  } else {
                    var payload_res: any = raw.getPrimitiveType(loopMeta.index(), p_metaClass);
                    if (payload_res != null) {
                      builder.append(",\"");
                      builder.append(loopMeta.metaName());
                      builder.append("\":\"");
                      if (metaAttId == org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID) {
                        builder.append(org.kevoree.modeling.format.json.JsonString.encode(payload_res.toString()));
                      } else {
                        builder.append(payload_res.toString());
                      }
                      builder.append("\"");
                    }
                  }
                } else {
                  if (loopMeta != null && loopMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.RELATION)) {
                    var refPayload: Float64Array = raw.getLongArray(loopMeta.index(), p_metaClass);
                    if (refPayload != null) {
                      builder.append(",\"");
                      builder.append(loopMeta.metaName());
                      builder.append("\":[");
                      for (var j: number = 0; j < refPayload.length; j++) {
                        if (j != 0) {
                          builder.append(",");
                        }
                        builder.append(refPayload[j]);
                      }
                      builder.append("]");
                    }
                  }
                }
              }
              builder.append("}");
              return builder.toString();
            }
          }
          export class JsonModelSerializer {
            public static serialize(model: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<string>): void {
              var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
              builder.append("[\n");
              org.kevoree.modeling.format.json.JsonModelSerializer.printJSON(model, builder);
              model.visit({
                visit: function (elem: org.kevoree.modeling.KObject) {
                  var isRoot2: boolean = false;
                  builder.append(",\n");
                  try {
                    org.kevoree.modeling.format.json.JsonModelSerializer.printJSON(elem, builder);
                  } catch ($ex$) {
                    if ($ex$ instanceof Error) {
                      var e: Error = <Error>$ex$;
                      console.error(e['stack']);
                      builder.append("{}");
                    } else {
                      throw $ex$;
                    }
                  }
                  return org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE;
                }
              }, (throwable : Error) => {
                builder.append("\n]\n");
                callback(builder.toString());
              });
            }
            public static printJSON(elem: org.kevoree.modeling.KObject, builder: java.lang.StringBuilder): void {
              if (elem != null) {
                var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = (<org.kevoree.modeling.abs.AbstractKObject>elem)._manager.closestChunk(elem.universe(), elem.now(), elem.uuid(), elem.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>elem).previousResolved());
                if (raw != null) {
                  builder.append(org.kevoree.modeling.format.json.JsonRaw.encode(raw, elem.uuid(), elem.metaClass()));
                }
              }
            }
          }
          export class JsonModelLoader {
            public static load(manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, universe: number, time: number, payload: string, callback: org.kevoree.modeling.KCallback<Error>): void {
               if (payload == null) {
               callback(null);
               } else {
               var toLoadObj = JSON.parse(payload);
               var rootElem: any[] = [];
               var mappedKeys: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1,-1,-1,null);
               for(var i = 0; i < toLoadObj.length; i++) {
               var elem = toLoadObj[i];
               var kid = elem[org.kevoree.modeling.format.json.JsonFormat.KEY_UUID];
               mappedKeys.put(<number>kid, manager.nextObjectKey());
               }
               for(var i = 0; i < toLoadObj.length; i++) {
               var elemRaw = toLoadObj[i];
               var elem2 = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(Object.keys(elemRaw).length, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
               for(var ik in elemRaw){ elem2[ik] = elemRaw[ik]; }
               try {
               org.kevoree.modeling.format.json.JsonModelLoader.loadObj(elem2, manager, universe, time, mappedKeys, rootElem);
               } catch(e){ console.error(e); }
               }
               if (callback != null) { callback(null); }
               }
            }
            private static loadObj(p_param: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, universe: number, time: number, p_mappedKeys: org.kevoree.modeling.memory.chunk.KLongLongMap, p_rootElem: org.kevoree.modeling.KObject[]): void {
              var kid: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(p_param.get(org.kevoree.modeling.format.json.JsonFormat.KEY_UUID).toString());
              var meta: string = p_param.get(org.kevoree.modeling.format.json.JsonFormat.KEY_META).toString();
              var metaClass: org.kevoree.modeling.meta.KMetaClass = manager.model().metaModel().metaClassByName(meta);
              var current: org.kevoree.modeling.KObject = (<org.kevoree.modeling.abs.AbstractKModel<any>>manager.model()).createProxy(universe, time, p_mappedKeys.get(kid), metaClass, universe, time);
              manager.initKObject(current);
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
              p_param.each((metaKey : string, payload_content : any) => {
                var metaElement: org.kevoree.modeling.meta.KMeta = metaClass.metaByName(metaKey);
                if (payload_content != null) {
                  if (metaElement != null && metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                    var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElement;
                    var metaAttId: number = metaAttribute.attributeTypeId();
                    switch (metaAttId) {
                      case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                      var plainRawSet: string[] = <string[]>p_param.get(metaAttribute.metaName());
                      var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                      for (var l: number = 0; l < plainRawSet.length; l++) {
                        try {
                          convertedRaw[l] = org.kevoree.modeling.util.PrimitiveHelper.parseDouble(plainRawSet[l]);
                        } catch ($ex$) {
                          if ($ex$ instanceof Error) {
                            var e: Error = <Error>$ex$;
                            console.error(e['stack']);
                          } else {
                            throw $ex$;
                          }
                        }
                      }
                      raw.setPrimitiveType(metaElement.index(), convertedRaw, current.metaClass());
                      break;
                      default:
                      var converted: any = null;
                      var rawPayload: string = p_param.get(metaElement.metaName()).toString();
                      switch (metaAttId) {
                        case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                        converted = org.kevoree.modeling.format.json.JsonString.unescape(rawPayload);
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                        converted = org.kevoree.modeling.util.PrimitiveHelper.parseLong(rawPayload);
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                        converted = org.kevoree.modeling.util.PrimitiveHelper.parseInt(rawPayload);
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                        converted = org.kevoree.modeling.util.PrimitiveHelper.parseBoolean(rawPayload);
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                        converted = org.kevoree.modeling.util.PrimitiveHelper.parseDouble(rawPayload);
                        break;
                      }
                      raw.setPrimitiveType(metaElement.index(), converted, current.metaClass());
                      break;
                    }
                  } else {
                    if (metaElement != null && metaElement.metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                      try {
                        raw.setPrimitiveType(metaElement.index(), org.kevoree.modeling.format.json.JsonModelLoader.transposeArr(<java.util.ArrayList<string>>payload_content, p_mappedKeys), current.metaClass());
                      } catch ($ex$) {
                        if ($ex$ instanceof Error) {
                          var e: Error = <Error>$ex$;
                          console.error(e['stack']);
                        } else {
                          throw $ex$;
                        }
                      }
                    }
                  }
                }
              });
            }
            private static transposeArr(plainRawSet: java.util.ArrayList<string>, p_mappedKeys: org.kevoree.modeling.memory.chunk.KLongLongMap): Float64Array {
              if (plainRawSet == null) {
                return null;
              }
              var sizeOfL: number = org.kevoree.modeling.format.json.JsonModelLoader.sizeOfList(plainRawSet);
              var convertedRaw: Float64Array = new Float64Array(sizeOfL);
              for (var l: number = 0; l < sizeOfL; l++) {
                try {
                  var converted: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(org.kevoree.modeling.format.json.JsonModelLoader.getString(plainRawSet, l));
                  if (p_mappedKeys.contains(converted)) {
                    converted = p_mappedKeys.get(converted);
                  }
                  convertedRaw[l] = converted;
                } catch ($ex$) {
                  if ($ex$ instanceof Error) {
                    var e: Error = <Error>$ex$;
                    console.error(e['stack']);
                  } else {
                    throw $ex$;
                  }
                }
              }
              return convertedRaw;
            }
            private static sizeOfList(plainRawSet: java.util.ArrayList<string>): number {
               if(plainRawSet != null && plainRawSet != undefined){
               if(plainRawSet.size != undefined){
               return plainRawSet.size();
               } else {
               return plainRawSet.length;
               }
               }
            }
            private static getString(plainRawSet: java.util.ArrayList<string>, l: number): string {
               if(plainRawSet.get != undefined){
               return plainRawSet.get(l);
               } else {
               return plainRawSet[l];
               }
            }
          }
          export class JsonFormat implements org.kevoree.modeling.format.KModelFormat {
            public static KEY_META: string = "@class";
            public static KEY_UUID: string = "@uuid";
            private _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
            private _universe: number;
            private _time: number;
            private static NULL_PARAM_MSG: string = "one parameter is null";
            constructor(p_universe: number, p_time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
              this._manager = p_manager;
              this._universe = p_universe;
              this._time = p_time;
            }
            public save(model: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<string>): void {
              if (org.kevoree.modeling.util.Checker.isDefined(model) && org.kevoree.modeling.util.Checker.isDefined(cb)) {
                org.kevoree.modeling.format.json.JsonModelSerializer.serialize(model, cb);
              } else {
                throw new Error(org.kevoree.modeling.format.json.JsonFormat.NULL_PARAM_MSG);
              }
            }
            public load(payload: string, cb: org.kevoree.modeling.KCallback<any>): void {
              if (org.kevoree.modeling.util.Checker.isDefined(payload)) {
                org.kevoree.modeling.format.json.JsonModelLoader.load(this._manager, this._universe, this._time, payload, cb);
              } else {
                throw new Error(org.kevoree.modeling.format.json.JsonFormat.NULL_PARAM_MSG);
              }
            }
          }
          export class JsonString {
            private static ESCAPE_CHAR: string = '\\';
            public static encodeBuffer(buffer: java.lang.StringBuilder, chain: string): void {
              if (chain == null) {
                return;
              }
              var i: number = 0;
              while (i < chain.length){
                var ch: string = chain.charAt(i);
                if (ch == '"') {
                  buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                  buffer.append('"');
                } else {
                  if (ch == org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR) {
                    buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                    buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                  } else {
                    if (ch == '\n') {
                      buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                      buffer.append('n');
                    } else {
                      if (ch == '\r') {
                        buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                        buffer.append('r');
                      } else {
                        if (ch == '\t') {
                          buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                          buffer.append('t');
                        } else {
                          if (ch == '\u2028') {
                            buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                            buffer.append('u');
                            buffer.append('2');
                            buffer.append('0');
                            buffer.append('2');
                            buffer.append('8');
                          } else {
                            if (ch == '\u2029') {
                              buffer.append(org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR);
                              buffer.append('u');
                              buffer.append('2');
                              buffer.append('0');
                              buffer.append('2');
                              buffer.append('9');
                            } else {
                              buffer.append(ch);
                            }
                          }
                        }
                      }
                    }
                  }
                }
                i = i + 1;
              }
            }
            public static encode(p_chain: string): string {
              var sb: java.lang.StringBuilder = new java.lang.StringBuilder();
              org.kevoree.modeling.format.json.JsonString.encodeBuffer(sb, p_chain);
              return sb.toString();
            }
            public static unescape(p_src: string): string {
              if (p_src == null) {
                return null;
              }
              if (p_src.length == 0) {
                return p_src;
              }
              var builder: java.lang.StringBuilder = null;
              var i: number = 0;
              while (i < p_src.length){
                var current: string = p_src.charAt(i);
                if (current == org.kevoree.modeling.format.json.JsonString.ESCAPE_CHAR) {
                  if (builder == null) {
                    builder = new java.lang.StringBuilder();
                    builder.append(p_src.substring(0, i));
                  }
                  i++;
                  var current2: string = p_src.charAt(i);
                  switch (current2) {
                    case '"':
                    builder.append('\"');
                    break;
                    case '\\':
                    builder.append(current2);
                    break;
                    case '/':
                    builder.append(current2);
                    break;
                    case 'b':
                    builder.append('\b');
                    break;
                    case 'f':
                    builder.append('\f');
                    break;
                    case 'n':
                    builder.append('\n');
                    break;
                    case 'r':
                    builder.append('\r');
                    break;
                    case 't':
                    builder.append('\t');
                    break;
                    case '{':
                    builder.append("\\{");
                    break;
                    case '}':
                    builder.append("\\}");
                    break;
                    case '[':
                    builder.append("\\[");
                    break;
                    case ']':
                    builder.append("\\]");
                    break;
                    case ',':
                    builder.append("\\,");
                    break;
                  }
                } else {
                  if (builder != null) {
                    builder = builder.append(current);
                  }
                }
                i++;
              }
              if (builder != null) {
                return builder.toString();
              } else {
                return p_src;
              }
            }
          }
        }
        export namespace xmi {
        }
      }
      export interface KListener {
        universe(): number;
        listenObjects(): Float64Array;
        listen(obj: org.kevoree.modeling.KObject): void;
        destroy(): void;
        then(updatedObjects: org.kevoree.modeling.KCallback<any>): void;
      }
      export interface KCallback<A> {
        (a: A): void;
      }
      export namespace meta {
        export interface KMetaDependencies extends org.kevoree.modeling.meta.KMeta {
          origin(): org.kevoree.modeling.meta.KMetaClass;
          allDependencies(): org.kevoree.modeling.meta.KMetaDependency[];
          dependencyByName(dependencyName: string): org.kevoree.modeling.meta.KMetaDependency;
          addDependency(dependencyName: string, p_referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency;
        }
        export interface KMetaAttribute extends org.kevoree.modeling.meta.KMeta {
          key(): boolean;
          attributeTypeId(): number;
          strategy(): org.kevoree.modeling.extrapolation.Extrapolation;
          precision(): number;
          setExtrapolation(extrapolation: org.kevoree.modeling.extrapolation.Extrapolation): void;
          setPrecision(precision: number): void;
          setKey(key: boolean): void;
        }
        export interface KMeta {
          index(): number;
          metaName(): string;
          metaType(): org.kevoree.modeling.meta.MetaType;
        }
        export interface KMetaDependency extends org.kevoree.modeling.meta.KMeta {
          referredMetaClassIndex(): number;
        }
        export interface KMetaRelation extends org.kevoree.modeling.meta.KMeta {
          originMetaClassIndex(): number;
          referredMetaClassIndex(): number;
          oppositeName(): string;
          visible(): boolean;
          maxBound(): number;
          setMaxBound(bound: number): void;
        }
        export namespace impl {
          export class MetaModel implements org.kevoree.modeling.meta.KMetaModel {
            private _name: string;
            private _index: number;
            private _metaClasses: org.kevoree.modeling.meta.KMetaClass[];
            private _metaClasses_indexes: org.kevoree.modeling.memory.chunk.KStringMap<number> = null;
            private _metaTypes: org.kevoree.modeling.meta.KMetaEnum[];
            private _metaTypes_indexes: org.kevoree.modeling.memory.chunk.KStringMap<number> = null;
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.MODEL;
            }
            constructor(p_name: string) {
              this._name = p_name;
              this._index = 0;
              this._metaClasses = new Array<org.kevoree.modeling.meta.KMetaClass>(0);
              this._metaTypes = new Array<org.kevoree.modeling.meta.KMetaEnum>(0);
              this._metaClasses_indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<number>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
              this._metaTypes_indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<number>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
            }
            public init(p_metaClasses: org.kevoree.modeling.meta.KMetaClass[], p_metaEnums: org.kevoree.modeling.meta.KMetaEnum[]): void {
              this._metaClasses_indexes.clear();
              this._metaTypes_indexes.clear();
              this._metaClasses = p_metaClasses;
              this._metaTypes = p_metaEnums;
              for (var i: number = 0; i < this._metaClasses.length; i++) {
                this._metaClasses_indexes.put(p_metaClasses[i].metaName(), p_metaClasses[i].index());
              }
              for (var i: number = 0; i < this._metaTypes.length; i++) {
                this._metaTypes_indexes.put(p_metaEnums[i].metaName(), p_metaEnums[i].index());
              }
            }
            public metaClasses(): org.kevoree.modeling.meta.KMetaClass[] {
              return this._metaClasses;
            }
            public metaClassByName(name: string): org.kevoree.modeling.meta.KMetaClass {
              if (this._metaClasses_indexes == null) {
                return null;
              }
              var resolved: number = this._metaClasses_indexes.get(name);
              if (resolved == null) {
                if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE.metaName())) {
                  return org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE;
                } else {
                  return null;
                }
              } else {
                return this._metaClasses[resolved];
              }
            }
            public metaClass(index: number): org.kevoree.modeling.meta.KMetaClass {
              if (index == org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE.index()) {
                return org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE;
              }
              if (index >= 0 && index < this._metaClasses.length) {
                return this._metaClasses[index];
              }
              return null;
            }
            public addMetaClass(metaClassName: string): org.kevoree.modeling.meta.KMetaClass {
              return this.internal_addmetaclass(metaClassName, null);
            }
            public addInferMetaClass(metaClassName: string, inferAlg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass {
              return this.internal_addmetaclass(metaClassName, inferAlg);
            }
            public metaTypes(): org.kevoree.modeling.meta.KMetaEnum[] {
              return this._metaTypes;
            }
            public metaTypeByName(p_name: string): org.kevoree.modeling.meta.KMetaEnum {
              if (this._metaTypes == null) {
                return null;
              }
              var resolved: number = this._metaTypes_indexes.get(p_name);
              if (resolved == null) {
                return null;
              } else {
                return this._metaTypes[resolved];
              }
            }
            public addMetaEnum(enumName: string): org.kevoree.modeling.meta.KMetaEnum {
              var newEnumType: org.kevoree.modeling.meta.KMetaEnum = new org.kevoree.modeling.meta.impl.MetaEnum(enumName, this._metaTypes.length);
              this.internal_add_type(newEnumType);
              return newEnumType;
            }
            private internal_addmetaclass(metaClassName: string, alg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass {
              if (this._metaClasses_indexes.contains(metaClassName)) {
                return this.metaClassByName(metaClassName);
              } else {
                if (this._metaClasses == null) {
                  this._metaClasses = new Array<org.kevoree.modeling.meta.KMetaClass>(1);
                  this._metaClasses[0] = new org.kevoree.modeling.meta.impl.MetaClass(metaClassName, 0, alg, new Int32Array([]));
                  this._metaClasses_indexes.put(metaClassName, this._metaClasses[0].index());
                  return this._metaClasses[0];
                } else {
                  var newMetaClass: org.kevoree.modeling.meta.KMetaClass = new org.kevoree.modeling.meta.impl.MetaClass(metaClassName, this._metaClasses.length, alg, new Int32Array([]));
                  this.internal_add_meta_class(newMetaClass);
                  return newMetaClass;
                }
              }
            }
            private internal_add_meta_class(p_newMetaClass: org.kevoree.modeling.meta.KMetaClass): void {
               this._metaClasses[p_newMetaClass.index()] = p_newMetaClass;
               this._metaClasses_indexes.put(p_newMetaClass.metaName(), p_newMetaClass.index());
            }
            private internal_add_type(p_newType: org.kevoree.modeling.meta.KMetaEnum): void {
               this._metaTypes[p_newType.index()] = p_newType;
               this._metaTypes_indexes.put(p_newType.metaName(), p_newType.index());
            }
            public createModel(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.KModel<any> {
              return new org.kevoree.modeling.meta.impl.GenericModel(this, p_manager);
            }
          }
          export class MetaEnum implements org.kevoree.modeling.meta.KMetaEnum {
            private _name: string;
            private _index: number;
            private _literals: org.kevoree.modeling.meta.KLiteral[];
            private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<number> = null;
            constructor(p_name: string, p_index: number) {
              this._name = p_name;
              this._index = p_index;
              this._literals = new Array<org.kevoree.modeling.meta.KLiteral>(0);
              this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<number>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
            }
            public init(lits: org.kevoree.modeling.meta.KLiteral[]): void {
              this._literals = lits;
              for (var i: number = 0; i < lits.length; i++) {
                this._indexes.put(lits[i].metaName(), lits[i].index());
              }
            }
            public literals(): org.kevoree.modeling.meta.KLiteral[] {
              return this._literals;
            }
            public literalByName(p_name: string): org.kevoree.modeling.meta.KLiteral {
              if (this._indexes != null) {
                var resolvedIndex: number = this._indexes.get(p_name);
                if (resolvedIndex != null) {
                  return this._literals[resolvedIndex];
                }
              }
              return null;
            }
            public literal(p_index: number): org.kevoree.modeling.meta.KLiteral {
              return this._literals[p_index];
            }
            public addLiteral(p_name: string): org.kevoree.modeling.meta.KLiteral {
              var newLiteral: org.kevoree.modeling.meta.impl.MetaLiteral = new org.kevoree.modeling.meta.impl.MetaLiteral(p_name, this._literals.length, this._name);
              this.internal_add_meta(newLiteral);
              return newLiteral;
            }
            public name(): string {
              return this._name;
            }
            public id(): number {
              return this._index;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.ENUM;
            }
            private internal_add_meta(p_new_meta: org.kevoree.modeling.meta.KLiteral): void {
               this._literals[p_new_meta.index()] = p_new_meta;
               this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }
          }
          export class GenericView extends org.kevoree.modeling.abs.AbstractKView {
            constructor(p_universe: number, _time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
              super(p_universe, _time, p_manager);
            }
          }
          export class MetaInferInput implements org.kevoree.modeling.meta.KMetaInferInput {
            private _name: string;
            private _index: number;
            private _extractor: string;
            private _cachedTraversal: org.kevoree.modeling.traversal.KTraversal;
            constructor(p_name: string, p_index: number, p_extractor: string) {
              this._name = p_name;
              this._index = p_index;
              this._extractor = p_extractor;
            }
            public extractorQuery(): string {
              return this._extractor;
            }
            public extractor(): org.kevoree.modeling.traversal.KTraversal {
              if (this._cachedTraversal != null) {
                return this._cachedTraversal;
              } else {
                return this.cacheTraversal();
              }
            }
            private cacheTraversal(): org.kevoree.modeling.traversal.KTraversal {
              this._cachedTraversal = org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().buildTraversal(this._extractor);
              return this._cachedTraversal;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.INPUT;
            }
          }
          export class GenericObjectIndex extends org.kevoree.modeling.abs.AbstractKObjectIndex {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
              super(p_universe, p_time, p_uuid, p_manager, currentUniverse, currentTime);
            }
          }
          export class MetaInferOutput implements org.kevoree.modeling.meta.KMetaInferOutput {
            private _name: string;
            private _index: number;
            private _type: number;
            constructor(p_name: string, p_index: number, p_type: number) {
              this._name = p_name;
              this._index = p_index;
              this._type = p_type;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.OUTPUT;
            }
            public attributeTypeId(): number {
              return this._type;
            }
          }
          export class MetaOperation implements org.kevoree.modeling.meta.KMetaOperation {
            private _name: string;
            private _index: number;
            private _originMetaClassIndex: number;
            private _paramTypes: Int32Array = null;
            private _paramIsArray: boolean[] = null;
            private _returnType: number;
            private _returnIsArray: boolean = false;
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.OPERATION;
            }
            public originMetaClassIndex(): number {
              return this._originMetaClassIndex;
            }
            public paramTypes(): Int32Array {
              return this._paramTypes;
            }
            public paramMultiplicities(): boolean[] {
              return this._paramIsArray;
            }
            public returnType(): number {
              return this._returnType;
            }
            public returnTypeIsArray(): boolean {
              return this._returnIsArray;
            }
            constructor(p_name: string, p_index: number, p_originMetaClassIndex: number, p_paramTypes: Int32Array, p_returnType: number, p_paramIsArray: boolean[], p_returnIsArray: boolean) {
              this._name = p_name;
              this._index = p_index;
              this._originMetaClassIndex = p_originMetaClassIndex;
              this._paramTypes = p_paramTypes;
              this._returnType = p_returnType;
              this._paramIsArray = p_paramIsArray;
              this._returnIsArray = p_returnIsArray;
            }
            public addParam(type: org.kevoree.modeling.KType, isArray: boolean): void {
              var newParam: Int32Array = new Int32Array(this._paramTypes.length + 1);
              var newParamIsArray: boolean[] = new Array<boolean>(this._paramIsArray.length + 1);
              java.lang.System.arraycopy(this._paramTypes, 0, newParam, 0, this._paramTypes.length);
              java.lang.System.arraycopy(this._paramIsArray, 0, newParamIsArray, 0, this._paramIsArray.length);
              newParam[this._paramTypes.length] = type.id();
              newParamIsArray[this._paramIsArray.length] = isArray;
              this._paramTypes = newParam;
              this._paramIsArray = newParamIsArray;
            }
            public setReturnType(type: org.kevoree.modeling.KType, isArray: boolean): void {
              this._returnType = type.id();
              this._returnIsArray = isArray;
            }
          }
          export class MetaClassIndex {
            public static INSTANCE: org.kevoree.modeling.meta.KMetaClass = new org.kevoree.modeling.meta.impl.MetaClass("index", -3, null, new Int32Array([]));
          }
          export class MetaDependency implements org.kevoree.modeling.meta.KMetaDependency {
            private _name: string;
            private _index: number;
            private _referredMetaClassIndex: number;
            public referredMetaClassIndex(): number {
              return this._referredMetaClassIndex;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.DEPENDENCY;
            }
            constructor(p_name: string, p_index: number, p_origin: org.kevoree.modeling.meta.KMetaDependencies, p_referredMetaClassIndex: number) {
              this._name = p_name;
              this._index = p_index;
              this._referredMetaClassIndex = p_referredMetaClassIndex;
            }
          }
          export class MetaClass implements org.kevoree.modeling.meta.KMetaClass {
            private _name: string;
            private _index: number;
            private _meta: org.kevoree.modeling.meta.KMeta[];
            private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<number> = null;
            private _alg: org.kevoree.modeling.infer.KInferAlg;
            private _cachedInputs: org.kevoree.modeling.meta.KMetaInferInput[] = null;
            private _cachedOutputs: org.kevoree.modeling.meta.KMetaInferOutput[] = null;
            private _parents: Int32Array = null;
            private _temporalResolution: number = 1;
            constructor(p_name: string, p_index: number, p_alg: org.kevoree.modeling.infer.KInferAlg, p_parents: Int32Array) {
              this._name = p_name;
              this._index = p_index;
              this._meta = new Array<org.kevoree.modeling.meta.KMeta>(0);
              this._alg = p_alg;
              this._parents = p_parents;
              this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<number>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
              if (this._alg != null) {
                this.internal_add_meta(new org.kevoree.modeling.meta.impl.MetaDependencies(this._meta.length, this));
              }
            }
            public init(p_metaElements: org.kevoree.modeling.meta.KMeta[]): void {
              this._indexes.clear();
              this._meta = p_metaElements;
              for (var i: number = 0; i < this._meta.length; i++) {
                this._indexes.put(p_metaElements[i].metaName(), p_metaElements[i].index());
              }
              this.clearCached();
            }
            public metaByName(name: string): org.kevoree.modeling.meta.KMeta {
              if (this._indexes != null) {
                var resolvedIndex: number = this._indexes.get(name);
                if (resolvedIndex != null) {
                  return this._meta[resolvedIndex];
                }
              }
              return null;
            }
            public metaParents(): Int32Array {
              return this._parents;
            }
            public attribute(name: string): org.kevoree.modeling.meta.KMetaAttribute {
              var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
              if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                return <org.kevoree.modeling.meta.KMetaAttribute>resolved;
              }
              return null;
            }
            public reference(name: string): org.kevoree.modeling.meta.KMetaRelation {
              var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
              if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                return <org.kevoree.modeling.meta.KMetaRelation>resolved;
              }
              return null;
            }
            public operation(name: string): org.kevoree.modeling.meta.KMetaOperation {
              var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
              if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.OPERATION) {
                return <org.kevoree.modeling.meta.KMetaOperation>resolved;
              }
              return null;
            }
            public metaElements(): org.kevoree.modeling.meta.KMeta[] {
              return this._meta;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.CLASS;
            }
            public meta(index: number): org.kevoree.modeling.meta.KMeta {
              if (index >= 0 && index < this._meta.length) {
                return this._meta[index];
              } else {
                return null;
              }
            }
            public addAttribute(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute {
              return this.internal_addatt(attributeName, p_type);
            }
            private internal_addatt(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute {
              var precisionCleaned: number = -1;
              var extrapolation: org.kevoree.modeling.extrapolation.Extrapolation;
              if (p_type.id() == org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                extrapolation = org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.instance();
                precisionCleaned = 0.1;
              } else {
                extrapolation = org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance();
              }
              var tempAttribute: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute(attributeName, this._meta.length, precisionCleaned, false, p_type.id(), extrapolation);
              this.internal_add_meta(tempAttribute);
              return tempAttribute;
            }
            public addRelation(relationName: string, p_metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string): org.kevoree.modeling.meta.KMetaRelation {
              return this.internal_addref(relationName, p_metaClass, oppositeName);
            }
            private internal_addref(referenceName: string, p_metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string): org.kevoree.modeling.meta.KMetaRelation {
              var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
              var opName: string = oppositeName;
              if (opName == null) {
                opName = "op_" + referenceName;
                (<org.kevoree.modeling.meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, false);
              } else {
                (<org.kevoree.modeling.meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, true);
              }
              var tempReference: org.kevoree.modeling.meta.impl.MetaRelation = new org.kevoree.modeling.meta.impl.MetaRelation(referenceName, this._meta.length, true, p_metaClass.index(), opName, tempOrigin.index(), -1);
              this.internal_add_meta(tempReference);
              return tempReference;
            }
            private getOrCreate(p_name: string, p_oppositeName: string, p_oppositeClass: org.kevoree.modeling.meta.KMetaClass, p_visible: boolean): org.kevoree.modeling.meta.KMetaRelation {
              var previous: org.kevoree.modeling.meta.KMetaRelation = this.reference(p_name);
              if (previous != null) {
                return previous;
              }
              var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
              var tempReference: org.kevoree.modeling.meta.KMetaRelation = new org.kevoree.modeling.meta.impl.MetaRelation(p_name, this._meta.length, p_visible, p_oppositeClass.index(), p_oppositeName, tempOrigin.index(), -1);
              this.internal_add_meta(tempReference);
              return tempReference;
            }
            public addOperation(operationName: string): org.kevoree.modeling.meta.KMetaOperation {
              var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
              var tempOperation: org.kevoree.modeling.meta.impl.MetaOperation = new org.kevoree.modeling.meta.impl.MetaOperation(operationName, this._meta.length, tempOrigin.index(), new Int32Array([]), -1, [], false);
              this.internal_add_meta(tempOperation);
              return tempOperation;
            }
            public inferAlg(): org.kevoree.modeling.infer.KInferAlg {
              return this._alg;
            }
            public addDependency(dependencyName: string, referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency {
              var currentDeps: org.kevoree.modeling.meta.KMetaDependencies = this.dependencies();
              if (currentDeps != null) {
                return currentDeps.addDependency(dependencyName, referredMetaClassIndex);
              }
              return null;
            }
            public addInput(p_name: string, p_extractor: string): org.kevoree.modeling.meta.KMetaInferInput {
              var newInput: org.kevoree.modeling.meta.KMetaInferInput = new org.kevoree.modeling.meta.impl.MetaInferInput(p_name, this._meta.length, p_extractor);
              this.internal_add_meta_noindex(newInput);
              return newInput;
            }
            public addOutput(p_name: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaInferOutput {
              var newOutput: org.kevoree.modeling.meta.KMetaInferOutput = new org.kevoree.modeling.meta.impl.MetaInferOutput(p_name, this._meta.length, p_type.id());
              this.internal_add_meta(newOutput);
              return newOutput;
            }
            public dependencies(): org.kevoree.modeling.meta.KMetaDependencies {
              return <org.kevoree.modeling.meta.KMetaDependencies>this.metaByName(org.kevoree.modeling.meta.impl.MetaDependencies.DEPENDENCIES_NAME);
            }
            public inputs(): org.kevoree.modeling.meta.KMetaInferInput[] {
              if (this._cachedInputs == null) {
                this.cacheInputs();
              }
              return this._cachedInputs;
            }
            private cacheInputs(): void {
              var nb: number = 0;
              for (var i: number = 0; i < this._meta.length; i++) {
                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.INPUT)) {
                  nb++;
                }
              }
              this._cachedInputs = new Array<org.kevoree.modeling.meta.KMetaInferInput>(nb);
              nb = 0;
              for (var i: number = 0; i < this._meta.length; i++) {
                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.INPUT)) {
                  this._cachedInputs[nb] = <org.kevoree.modeling.meta.KMetaInferInput>this._meta[i];
                  nb++;
                }
              }
            }
            public outputs(): org.kevoree.modeling.meta.KMetaInferOutput[] {
              if (this._cachedOutputs == null) {
                this.cacheOuputs();
              }
              return this._cachedOutputs;
            }
            public temporalResolution(): number {
              return this._temporalResolution;
            }
            public setTemporalResolution(p_tempo: number): void {
              this._temporalResolution = p_tempo;
            }
            private cacheOuputs(): void {
              var nb: number = 0;
              for (var i: number = 0; i < this._meta.length; i++) {
                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.OUTPUT)) {
                  nb++;
                }
              }
              this._cachedOutputs = new Array<org.kevoree.modeling.meta.KMetaInferOutput>(nb);
              nb = 0;
              for (var i: number = 0; i < this._meta.length; i++) {
                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.OUTPUT)) {
                  this._cachedOutputs[nb] = <org.kevoree.modeling.meta.KMetaInferOutput>this._meta[i];
                  nb++;
                }
              }
            }
            private clearCached(): void {
              this._cachedOutputs = null;
              this._cachedInputs = null;
            }
            private internal_add_meta(p_new_meta: org.kevoree.modeling.meta.KMeta): void {
               this.clearCached();
               this._meta[p_new_meta.index()] = p_new_meta;
               this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }
            private internal_add_meta_noindex(p_new_meta: org.kevoree.modeling.meta.KMeta): void {
               this.clearCached();
               this._meta[p_new_meta.index()] = p_new_meta;
            }
            public addParent(parentMetaClass: org.kevoree.modeling.meta.KMeta): void {
              var newParents: Int32Array = new Int32Array(this._parents.length + 1);
              java.lang.System.arraycopy(this._parents, 0, newParents, 0, this._parents.length);
              newParents[this._parents.length] = parentMetaClass.index();
              this._parents = newParents;
            }
          }
          export class GenericUniverse extends org.kevoree.modeling.abs.AbstractKUniverse<any, any> {
            constructor(p_key: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
              super(p_key, p_manager);
            }
            public internal_create(timePoint: number): org.kevoree.modeling.KView {
              return new org.kevoree.modeling.meta.impl.GenericView(this._universe, timePoint, this._manager);
            }
          }
          export class GenericObject extends org.kevoree.modeling.abs.AbstractKObject {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
              super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
            }
          }
          export class MetaAttribute implements org.kevoree.modeling.meta.KMetaAttribute {
            private _name: string;
            private _index: number;
            public _precision: number;
            private _key: boolean;
            private _attributeTypeId: number;
            private _extrapolation: org.kevoree.modeling.extrapolation.Extrapolation;
            public attributeTypeId(): number {
              return this._attributeTypeId;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.ATTRIBUTE;
            }
            public precision(): number {
              return this._precision;
            }
            public key(): boolean {
              return this._key;
            }
            public strategy(): org.kevoree.modeling.extrapolation.Extrapolation {
              return this._extrapolation;
            }
            public setExtrapolation(extrapolation: org.kevoree.modeling.extrapolation.Extrapolation): void {
              this._extrapolation = extrapolation;
            }
            public setPrecision(p_precision: number): void {
              this._precision = p_precision;
            }
            public setKey(p_key: boolean): void {
              this._key = p_key;
            }
            constructor(p_name: string, p_index: number, p_precision: number, p_key: boolean, p_attributeTypeId: number, p_extrapolation: org.kevoree.modeling.extrapolation.Extrapolation) {
              this._name = p_name;
              this._index = p_index;
              this._precision = p_precision;
              this._key = p_key;
              this._attributeTypeId = p_attributeTypeId;
              this._extrapolation = p_extrapolation;
              if (this._extrapolation == null) {
                this._extrapolation = org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance();
              }
            }
          }
          export class GenericObjectInfer extends org.kevoree.modeling.abs.AbstractKObjectInfer {
            constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
              super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
            }
          }
          export class MetaDependencies implements org.kevoree.modeling.meta.KMetaDependencies {
            private _origin: org.kevoree.modeling.meta.KMetaClass;
            private _dependencies: org.kevoree.modeling.meta.KMetaDependency[];
            public static DEPENDENCIES_NAME: string = "allDependencies";
            private _index: number;
            private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<number> = null;
            constructor(p_index: number, p_origin: org.kevoree.modeling.meta.KMetaClass) {
              this._index = p_index;
              this._origin = p_origin;
              this._dependencies = new Array<org.kevoree.modeling.meta.KMetaDependency>(0);
              this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<number>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
            }
            public origin(): org.kevoree.modeling.meta.KMetaClass {
              return this._origin;
            }
            public allDependencies(): org.kevoree.modeling.meta.KMetaDependency[] {
              return this._dependencies;
            }
            public dependencyByName(dependencyName: string): org.kevoree.modeling.meta.KMetaDependency {
              var foundedIndex: number = this._indexes.get(dependencyName);
              if (foundedIndex != null) {
                return this._dependencies[foundedIndex];
              } else {
                return null;
              }
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return org.kevoree.modeling.meta.impl.MetaDependencies.DEPENDENCIES_NAME;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.DEPENDENCIES;
            }
            public addDependency(p_dependencyName: string, p_referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency {
              var newDependency: org.kevoree.modeling.meta.KMetaDependency = new org.kevoree.modeling.meta.impl.MetaDependency(p_dependencyName, this._dependencies.length, this, p_referredMetaClassIndex);
              this.internal_add_dep(newDependency);
              return newDependency;
            }
            private internal_add_dep(p_new_meta: org.kevoree.modeling.meta.KMetaDependency): void {
               this._dependencies[p_new_meta.index()] = p_new_meta;
               this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
            }
          }
          export class MetaLiteral implements org.kevoree.modeling.meta.KLiteral {
            private _name: string;
            private _index: number;
            private _className: string;
            constructor(p_name: string, p_index: number, p_className: string) {
              this._name = p_name;
              this._index = p_index;
              this._className = p_className;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.LITERAL;
            }
            public toString(): string {
              return "KLiteral@" + this._className + "." + this._name;
            }
          }
          export class MetaRelation implements org.kevoree.modeling.meta.KMetaRelation {
            private _name: string;
            private _index: number;
            private _visible: boolean;
            private _referredMetaClassIndex: number;
            private _op_name: string;
            private _originMetaClassIndex: number;
            private _maxBound: number = -1;
            public referredMetaClassIndex(): number {
              return this._referredMetaClassIndex;
            }
            public oppositeName(): string {
              return this._op_name;
            }
            public originMetaClassIndex(): number {
              return this._originMetaClassIndex;
            }
            public index(): number {
              return this._index;
            }
            public metaName(): string {
              return this._name;
            }
            public metaType(): org.kevoree.modeling.meta.MetaType {
              return org.kevoree.modeling.meta.MetaType.RELATION;
            }
            public visible(): boolean {
              return this._visible;
            }
            public maxBound(): number {
              return this._maxBound;
            }
            public setMaxBound(p_maxBound: number): void {
              this._maxBound = p_maxBound;
            }
            constructor(p_name: string, p_index: number, p_visible: boolean, p_referredMetaClassIndex: number, op_name: string, p_originMetaClassIndex: number, p_maxBound: number) {
              this._name = p_name;
              this._index = p_index;
              this._visible = p_visible;
              this._referredMetaClassIndex = p_referredMetaClassIndex;
              this._op_name = op_name;
              this._originMetaClassIndex = p_originMetaClassIndex;
              this._maxBound = p_maxBound;
            }
          }
          export class GenericModel extends org.kevoree.modeling.abs.AbstractKModel<any> {
            private _p_metaModel: org.kevoree.modeling.meta.KMetaModel;
            constructor(mm: org.kevoree.modeling.meta.KMetaModel, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
              super(p_manager);
              this._p_metaModel = mm;
            }
            public metaModel(): org.kevoree.modeling.meta.KMetaModel {
              return this._p_metaModel;
            }
            public internalCreateUniverse(universe: number): org.kevoree.modeling.KUniverse<any, any> {
              return new org.kevoree.modeling.meta.impl.GenericUniverse(universe, this._manager);
            }
            public internalCreateObject(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
              if (clazz.index() == org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE.index()) {
                return new org.kevoree.modeling.meta.impl.GenericObjectIndex(universe, time, uuid, this._manager, previousUniverse, previousTime);
              } else {
                if (clazz.inferAlg() != null) {
                  return new org.kevoree.modeling.meta.impl.GenericObjectInfer(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                } else {
                  return new org.kevoree.modeling.meta.impl.GenericObject(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                }
              }
            }
          }
        }
        export interface KMetaEnum extends org.kevoree.modeling.KType, org.kevoree.modeling.meta.KMeta {
          literals(): org.kevoree.modeling.meta.KLiteral[];
          literalByName(name: string): org.kevoree.modeling.meta.KLiteral;
          literal(index: number): org.kevoree.modeling.meta.KLiteral;
          addLiteral(name: string): org.kevoree.modeling.meta.KLiteral;
        }
        export interface KMetaModel extends org.kevoree.modeling.meta.KMeta {
          metaClasses(): org.kevoree.modeling.meta.KMetaClass[];
          metaClassByName(name: string): org.kevoree.modeling.meta.KMetaClass;
          metaClass(index: number): org.kevoree.modeling.meta.KMetaClass;
          addMetaClass(metaClassName: string): org.kevoree.modeling.meta.KMetaClass;
          addInferMetaClass(metaClassName: string, inferAlg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass;
          metaTypes(): org.kevoree.modeling.meta.KMetaEnum[];
          metaTypeByName(name: string): org.kevoree.modeling.meta.KMetaEnum;
          addMetaEnum(enumName: string): org.kevoree.modeling.meta.KMetaEnum;
          createModel(manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.KModel<any>;
        }
        export interface KLiteral extends org.kevoree.modeling.meta.KMeta {
        }
        export interface KMetaOperation extends org.kevoree.modeling.meta.KMeta {
          originMetaClassIndex(): number;
          paramTypes(): Int32Array;
          paramMultiplicities(): boolean[];
          returnType(): number;
          returnTypeIsArray(): boolean;
          addParam(type: org.kevoree.modeling.KType, isArray: boolean): void;
          setReturnType(type: org.kevoree.modeling.KType, isArray: boolean): void;
        }
        export interface KMetaClass extends org.kevoree.modeling.meta.KMeta {
          metaElements(): org.kevoree.modeling.meta.KMeta[];
          meta(index: number): org.kevoree.modeling.meta.KMeta;
          metaByName(name: string): org.kevoree.modeling.meta.KMeta;
          metaParents(): Int32Array;
          attribute(name: string): org.kevoree.modeling.meta.KMetaAttribute;
          reference(name: string): org.kevoree.modeling.meta.KMetaRelation;
          operation(name: string): org.kevoree.modeling.meta.KMetaOperation;
          addAttribute(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute;
          addRelation(relationName: string, metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string): org.kevoree.modeling.meta.KMetaRelation;
          addDependency(dependencyName: string, referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency;
          addInput(dependencyName: string, extractor: string): org.kevoree.modeling.meta.KMetaInferInput;
          addOutput(name: string, metaClass: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaInferOutput;
          addOperation(operationName: string): org.kevoree.modeling.meta.KMetaOperation;
          inferAlg(): org.kevoree.modeling.infer.KInferAlg;
          dependencies(): org.kevoree.modeling.meta.KMetaDependencies;
          inputs(): org.kevoree.modeling.meta.KMetaInferInput[];
          outputs(): org.kevoree.modeling.meta.KMetaInferOutput[];
          temporalResolution(): number;
          setTemporalResolution(tempo: number): void;
          addParent(parentMetaClass: org.kevoree.modeling.meta.KMeta): void;
        }
        export interface KMetaInferInput extends org.kevoree.modeling.meta.KMeta {
          extractorQuery(): string;
          extractor(): org.kevoree.modeling.traversal.KTraversal;
        }
        export class KPrimitiveTypes {
          public static BOOL_ID: number = -1;
          public static STRING_ID: number = -2;
          public static LONG_ID: number = -3;
          public static INT_ID: number = -4;
          public static DOUBLE_ID: number = -5;
          public static CONTINUOUS_ID: number = -6;
          public static BOOL: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("BOOL", org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID);
          public static STRING: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("STRING", org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID);
          public static LONG: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("LONG", org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID);
          public static INT: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("INT", org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID);
          public static DOUBLE: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("DOUBLE", org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID);
          public static CONTINUOUS: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("CONTINUOUS", org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID);
          public static isEnum(attributeTypeId: number): boolean {
            return attributeTypeId >= 0;
          }
        }
        export class MetaType {
          public static ATTRIBUTE: MetaType = new MetaType();
          public static RELATION: MetaType = new MetaType();
          public static DEPENDENCY: MetaType = new MetaType();
          public static DEPENDENCIES: MetaType = new MetaType();
          public static INPUT: MetaType = new MetaType();
          public static OUTPUT: MetaType = new MetaType();
          public static OPERATION: MetaType = new MetaType();
          public static CLASS: MetaType = new MetaType();
          public static MODEL: MetaType = new MetaType();
          public static ENUM: MetaType = new MetaType();
          public static LITERAL: MetaType = new MetaType();
          public equals(other: any): boolean {
            return this == other;
          }
          public static _MetaTypeVALUES : MetaType[] = [
            MetaType.ATTRIBUTE
            ,MetaType.RELATION
            ,MetaType.DEPENDENCY
            ,MetaType.DEPENDENCIES
            ,MetaType.INPUT
            ,MetaType.OUTPUT
            ,MetaType.OPERATION
            ,MetaType.CLASS
            ,MetaType.MODEL
            ,MetaType.ENUM
            ,MetaType.LITERAL
          ];
          public static values():MetaType[]{
            return MetaType._MetaTypeVALUES;
          }
        }
        export interface KMetaInferOutput extends org.kevoree.modeling.meta.KMeta {
          attributeTypeId(): number;
        }
      }
      export namespace message {
        export interface KMessage {
          id(): number;
          setID(val: number): void;
          type(): number;
          setType(val: number): void;
          operationName(): string;
          setOperationName(val: string): void;
          className(): string;
          setClassName(val: string): void;
          keys(): Float64Array;
          setKeys(val: Float64Array): void;
          values(): string[];
          setValues(val: string[]): void;
          values2(): string[];
          setValues2(val: string[]): void;
          peer(): string;
          setPeer(val: string): void;
          save(): string;
        }
        export namespace impl {
          export class Message implements org.kevoree.modeling.message.KMessage {
            private static TYPE_INDEX: number = 0;
            private static ID_INDEX: number = 1;
            private static OPERATION_INDEX: number = 2;
            private static CLASS_INDEX: number = 3;
            private static PEER_INDEX: number = 4;
            private static KEYS_INDEX: number = 5;
            private static VALUES_INDEX: number = 6;
            private static VALUES2_INDEX: number = 7;
            private static KEYS_NAME: string[] = ['T', 'I', 'O', 'C', 'P', 'K', 'V', 'W'];
            public static EVENTS_TYPE: number = 0;
            public static GET_REQ_TYPE: number = 1;
            public static GET_RES_TYPE: number = 2;
            public static PUT_REQ_TYPE: number = 3;
            public static PUT_RES_TYPE: number = 4;
            public static OPERATION_CALL_TYPE: number = 5;
            public static OPERATION_RESULT_TYPE: number = 6;
            public static ATOMIC_GET_INC_REQUEST_TYPE: number = 7;
            public static ATOMIC_GET_INC_RESULT_TYPE: number = 8;
            public static OPERATION_MAPPING: number = 9;
            private static NB_ELEM: number = 8;
            private internal: any[] = new Array<any>(org.kevoree.modeling.message.impl.Message.NB_ELEM);
            public id(): number {
              return <number>this.internal[org.kevoree.modeling.message.impl.Message.ID_INDEX];
            }
            public setID(val: number): void {
              this.internal[org.kevoree.modeling.message.impl.Message.ID_INDEX] = val;
            }
            public type(): number {
              return <number>this.internal[org.kevoree.modeling.message.impl.Message.TYPE_INDEX];
            }
            public setType(val: number): void {
              this.internal[org.kevoree.modeling.message.impl.Message.TYPE_INDEX] = val;
            }
            public operationName(): string {
              return <string>this.internal[org.kevoree.modeling.message.impl.Message.OPERATION_INDEX];
            }
            public setOperationName(val: string): void {
              this.internal[org.kevoree.modeling.message.impl.Message.OPERATION_INDEX] = val;
            }
            public className(): string {
              return <string>this.internal[org.kevoree.modeling.message.impl.Message.CLASS_INDEX];
            }
            public setClassName(val: string): void {
              this.internal[org.kevoree.modeling.message.impl.Message.CLASS_INDEX] = val;
            }
            public keys(): Float64Array {
              return <Float64Array>this.internal[org.kevoree.modeling.message.impl.Message.KEYS_INDEX];
            }
            public setKeys(val: Float64Array): void {
              this.internal[org.kevoree.modeling.message.impl.Message.KEYS_INDEX] = val;
            }
            public values(): string[] {
              return <string[]>this.internal[org.kevoree.modeling.message.impl.Message.VALUES_INDEX];
            }
            public setValues(val: string[]): void {
              this.internal[org.kevoree.modeling.message.impl.Message.VALUES_INDEX] = val;
            }
            public values2(): string[] {
              return <string[]>this.internal[org.kevoree.modeling.message.impl.Message.VALUES2_INDEX];
            }
            public setValues2(val: string[]): void {
              this.internal[org.kevoree.modeling.message.impl.Message.VALUES2_INDEX] = val;
            }
            public peer(): string {
              return <string>this.internal[org.kevoree.modeling.message.impl.Message.PEER_INDEX];
            }
            public setPeer(val: string): void {
              this.internal[org.kevoree.modeling.message.impl.Message.PEER_INDEX] = val;
            }
            public save(): string {
              var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
              var isFirst: boolean = true;
              for (var i: number = 0; i < org.kevoree.modeling.message.impl.Message.NB_ELEM; i++) {
                if (this.internal[i] != null) {
                  if (!isFirst) {
                    buffer.append(org.kevoree.modeling.KConfig.ELEM_SEP);
                  }
                  isFirst = false;
                  buffer.append(org.kevoree.modeling.message.impl.Message.KEYS_NAME[i]);
                  buffer.append(org.kevoree.modeling.KConfig.VAL_SEP);
                  switch (i) {
                    case 0:
                    org.kevoree.modeling.util.Base64.encodeIntToBuffer(<number>this.internal[i], buffer);
                    break;
                    case 1:
                    org.kevoree.modeling.util.Base64.encodeIntToBuffer(<number>this.internal[i], buffer);
                    break;
                    case 2:
                    org.kevoree.modeling.util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                    break;
                    case 3:
                    org.kevoree.modeling.util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                    break;
                    case 4:
                    org.kevoree.modeling.util.Base64.encodeStringToBuffer(<string>this.internal[i], buffer);
                    break;
                    case 5:
                    var lkeys: Float64Array = <Float64Array>this.internal[i];
                    org.kevoree.modeling.util.Base64.encodeIntToBuffer(lkeys.length, buffer);
                    for (var j: number = 0; j < lkeys.length; j++) {
                      buffer.append(org.kevoree.modeling.KConfig.VAL_SEP);
                      org.kevoree.modeling.util.Base64.encodeLongToBuffer(lkeys[j], buffer);
                    }
                    break;
                    case 6:
                    var lvalues: string[] = <string[]>this.internal[i];
                    org.kevoree.modeling.util.Base64.encodeIntToBuffer(lvalues.length, buffer);
                    for (var j: number = 0; j < lvalues.length; j++) {
                      buffer.append(org.kevoree.modeling.KConfig.VAL_SEP);
                      if (lvalues[j] != null) {
                        org.kevoree.modeling.util.Base64.encodeStringToBuffer(lvalues[j], buffer);
                      }
                    }
                    break;
                    case 7:
                    var lvalues2: string[] = <string[]>this.internal[i];
                    org.kevoree.modeling.util.Base64.encodeIntToBuffer(lvalues2.length, buffer);
                    for (var j: number = 0; j < lvalues2.length; j++) {
                      buffer.append(org.kevoree.modeling.KConfig.VAL_SEP);
                      if (lvalues2[j] != null) {
                        org.kevoree.modeling.util.Base64.encodeStringToBuffer(lvalues2[j], buffer);
                      }
                    }
                    break;
                  }
                }
              }
              return buffer.toString();
            }
            public static load(payload: string): org.kevoree.modeling.message.KMessage {
              var msg: org.kevoree.modeling.message.impl.Message = new org.kevoree.modeling.message.impl.Message();
              if (payload == null) {
                return null;
              }
              var i: number = 0;
              var readElemIndex: number = -1;
              var previousValStart: number = -1;
              var longArray: Float64Array = null;
              var stringArray: string[] = null;
              var currentArrayIndex: number = -1;
              var payloadSize: number = payload.length;
              while (i < payloadSize){
                if (payload.charAt(i) == org.kevoree.modeling.KConfig.ELEM_SEP) {
                  if (readElemIndex != -1) {
                    if (readElemIndex < 2) {
                      msg.internal[readElemIndex] = org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, previousValStart, i);
                    } else {
                      if (readElemIndex < 5) {
                        msg.internal[readElemIndex] = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                      } else {
                        if (readElemIndex == 5 && longArray != null) {
                          longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                          msg.internal[readElemIndex] = longArray;
                          longArray = null;
                        } else {
                          if (stringArray != null) {
                            stringArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                            msg.internal[readElemIndex] = stringArray;
                            stringArray = null;
                          }
                        }
                      }
                    }
                  }
                  previousValStart = -1;
                  readElemIndex = -1;
                } else {
                  if (payload.charAt(i) == org.kevoree.modeling.KConfig.VAL_SEP) {
                    if (readElemIndex == -1) {
                      var pastType: string = payload.charAt(i - 1);
                      for (var h: number = 0; h < org.kevoree.modeling.message.impl.Message.NB_ELEM; h++) {
                        if (pastType == org.kevoree.modeling.message.impl.Message.KEYS_NAME[h]) {
                          readElemIndex = h;
                        }
                      }
                    } else {
                      if (readElemIndex > 5) {
                        if (stringArray == null) {
                          stringArray = new Array<string>(org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                          currentArrayIndex = 0;
                        } else {
                          stringArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                          currentArrayIndex++;
                        }
                      } else {
                        if (longArray == null) {
                          longArray = new Float64Array(org.kevoree.modeling.util.Base64.decodeToIntWithBounds(payload, previousValStart, i));
                          currentArrayIndex = 0;
                        } else {
                          longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, previousValStart, i);
                          currentArrayIndex++;
                        }
                      }
                    }
                    previousValStart = i + 1;
                  }
                }
                i++;
              }
              if (readElemIndex != -1) {
                if (readElemIndex < 2) {
                  msg.internal[readElemIndex] = org.kevoree.modeling.util.Base64.decodeToInt(payload.substring(previousValStart, i));
                } else {
                  if (readElemIndex < 5) {
                    msg.internal[readElemIndex] = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                  } else {
                    if (readElemIndex == 5 && longArray != null) {
                      longArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToLong(payload.substring(previousValStart, i));
                      msg.internal[readElemIndex] = longArray;
                    } else {
                      if (stringArray != null) {
                        stringArray[currentArrayIndex] = org.kevoree.modeling.util.Base64.decodeToStringWithBounds(payload, previousValStart, i);
                        msg.internal[readElemIndex] = stringArray;
                      }
                    }
                  }
                }
              }
              return msg;
            }
          }
        }
      }
      export interface KObjectInfer extends org.kevoree.modeling.KObject {
        genericTrain(dependencies: org.kevoree.modeling.KObject[], expectedOutputs: any[], callback: org.kevoree.modeling.KCallback<any>): void;
        genericTrainAll(trainingSet: org.kevoree.modeling.KObject[][], expectedResultSet: any[][], callback: org.kevoree.modeling.KCallback<any>): void;
        genericInfer(features: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any[]>): void;
        genericInferAll(features: org.kevoree.modeling.KObject[][], callback: org.kevoree.modeling.KCallback<any[][]>): void;
        resetLearning(): void;
      }
      export namespace util {
        export namespace maths {
          export namespace structure {
            export namespace blas {
              export interface KBlas {
                dgemm(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, m: number, n: number, k: number, alpha: number, matA: Float64Array, offsetA: number, ldA: number, matB: Float64Array, offsetB: number, ldB: number, beta: number, matC: Float64Array, offsetC: number, ldC: number): void;
                dgetrs(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, dim: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void;
                dgetri(dim: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, work: Float64Array, offsetWork: number, ldWork: number, info: Int32Array): void;
                dgetrf(rows: number, columns: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiv: number, info: Int32Array): void;
                dorgqr(m: number, n: number, k: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetWork: number, lWork: number, info: Int32Array): void;
                dgeqrf(m: number, n: number, matA: Float64Array, offsetA: number, ldA: number, taw: Float64Array, offsetTaw: number, work: Float64Array, offsetwork: number, lWork: number, info: Int32Array): void;
                shutdown(): void;
              }
              export class KBlasOrientationType {
                public static UPPER: KBlasOrientationType = new KBlasOrientationType();
                public static LOWER: KBlasOrientationType = new KBlasOrientationType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasOrientationTypeVALUES : KBlasOrientationType[] = [
                  KBlasOrientationType.UPPER
                  ,KBlasOrientationType.LOWER
                ];
                public static values():KBlasOrientationType[]{
                  return KBlasOrientationType._KBlasOrientationTypeVALUES;
                }
              }
              export class KBlasUnitType {
                public static UNIT: KBlasUnitType = new KBlasUnitType();
                public static NONUNIT: KBlasUnitType = new KBlasUnitType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasUnitTypeVALUES : KBlasUnitType[] = [
                  KBlasUnitType.UNIT
                  ,KBlasUnitType.NONUNIT
                ];
                public static values():KBlasUnitType[]{
                  return KBlasUnitType._KBlasUnitTypeVALUES;
                }
              }
              export namespace impl {
                export class JavaBlas implements org.kevoree.modeling.util.maths.structure.blas.KBlas {
                  public dgemm(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramInt3: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var bool1: boolean = false;
                    var bool2: boolean = false;
                    bool1 = paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                    bool2 = paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                    var i3: number;
                    var i4: number;
                    if ((paramDouble1 == 0)) {
                      if ((paramDouble2 == 0)) {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          i = 1;
                          for (i4 = paramInt1; i4 > 0; i4--) {
                            paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                            i++;
                          }
                          k++;
                        }
                      } else {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          i = 1;
                          for (i4 = paramInt1; i4 > 0; i4--) {
                            paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                            i++;
                          }
                          k++;
                        }
                      }
                      return;
                    }
                    var i5: number;
                    if (bool2) {
                      if (bool1) {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          if ((paramDouble2 == 0)) {
                            i = 1;
                            for (i4 = paramInt1; i4 > 0; i4--) {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                              i++;
                            }
                          } else {
                            i = 1;
                            i4 = paramInt1;
                            for (; ; ) {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                              i++;
                              i4--;
                              if (i4 <= 0) {
                                break;
                              }
                            }
                          }
                          m = 1;
                          for (i4 = paramInt3; i4 > 0; i4--) {
                            if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)] != 0.0)) {
                              d = paramDouble1 * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)];
                              i = 1;
                              for (i5 = paramInt1; i5 > 0; i5--) {
                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt5 + paramInt4)];
                                i++;
                              }
                            }
                            m++;
                          }
                          k++;
                        }
                      } else {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          i = 1;
                          for (i4 = paramInt1; i4 > 0; i4--) {
                            d = 0.0;
                            m = 1;
                            for (i5 = paramInt3; i5 > 0; i5--) {
                              d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt5 + paramInt4)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt7 + paramInt6)];
                              m++;
                            }
                            if ((paramDouble2 == 0)) {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d);
                            } else {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d + paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                            }
                            i++;
                          }
                          k++;
                        }
                      }
                    } else {
                      if (bool1) {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          if ((paramDouble2 == 0)) {
                            i = 1;
                            for (i4 = paramInt1; i4 > 0; i4--) {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = 0.0;
                              i++;
                            }
                          } else {
                            if ((paramDouble2 != 1.0)) {
                              i = 1;
                              i4 = paramInt1;
                              for (; ; ) {
                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                                i++;
                                i4--;
                                if (i4 <= 0) {
                                  break;
                                }
                              }
                            }
                          }
                          m = 1;
                          for (i4 = paramInt3; i4 > 0; i4--) {
                            if ((paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)] != 0.0)) {
                              d = paramDouble1 * paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)];
                              i = 1;
                              for (i5 = paramInt1; i5 > 0; i5--) {
                                paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt5 + paramInt4)];
                                i++;
                              }
                            }
                            m++;
                          }
                          k++;
                        }
                      } else {
                        k = 1;
                        for (i3 = paramInt2; i3 > 0; i3--) {
                          i = 1;
                          for (i4 = paramInt1; i4 > 0; i4--) {
                            d = 0.0;
                            m = 1;
                            for (i5 = paramInt3; i5 > 0; i5--) {
                              d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt5 + paramInt4)] * paramArrayOfDouble2[(k - 1 + (m - 1) * paramInt7 + paramInt6)];
                              m++;
                            }
                            if ((paramDouble2 == 0)) {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d);
                            } else {
                              paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)] = (paramDouble1 * d + paramDouble2 * paramArrayOfDouble3[(i - 1 + (k - 1) * paramInt9 + paramInt8)]);
                            }
                            i++;
                          }
                          k++;
                        }
                      }
                    }
                  }
                  public dgetri(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfInt: Int32Array, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramintW: Int32Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var i2: number = 0;
                    var i3: number = 0;
                    var i4: number = 0;
                    var i5: number = 0;
                    var i6: number = 0;
                    var i7: number = 0;
                    paramintW[0] = 0;
                    i5 = this.ilaenv(1, "DGETRI", " ", paramInt1, -1, -1, -1);
                    i4 = paramInt1 * i5;
                    paramArrayOfDouble2[paramInt5] = i4;
                    i = paramInt6 != -1 ? 0 : 1;
                    if ((paramInt1 < 0)) {
                      paramintW[0] = -1;
                    } else {
                      if ((paramInt3 < Math.max(1, paramInt1))) {
                        paramintW[0] = -3;
                      }
                    }
                    if ((paramintW[0] != 0)) {
                      return;
                    }
                    if (i != 0) {
                      return;
                    }
                    if ((paramInt1 == 0)) {
                      return;
                    }
                    this.dtrtri(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramArrayOfDouble1, paramInt2, paramInt3, paramintW);
                    if ((paramintW[0] > 0)) {
                      return;
                    }
                    i6 = 2;
                    i3 = paramInt1;
                    if (((i5 < paramInt1) ? 1 : 0) != 0) {
                      k = Math.max(i3 * i5, 1);
                      if ((paramInt6 < k)) {
                        i5 = this.floorDiv(paramInt6, i3);
                        i6 = Math.max(2, this.ilaenv(2, "DGETRI", " ", paramInt1, -1, -1, -1));
                      }
                    } else {
                      k = paramInt1;
                    }
                    var i9: number;
                    if (((i5 >= paramInt1))) {
                      m = paramInt1;
                      for (var i8: number = paramInt1; i8 > 0; i8--) {
                        j = m + 1;
                        for (i9 = paramInt1 - (m + 1) + 1; i9 > 0; i9--) {
                          paramArrayOfDouble2[(j - 1 + paramInt5)] = paramArrayOfDouble1[(j - 1 + (m - 1) * paramInt3 + paramInt2)];
                          paramArrayOfDouble1[(j - 1 + (m - 1) * paramInt3 + paramInt2)] = 0.0;
                          j++;
                        }
                        if ((m < paramInt1)) {
                          this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt1 - m, -1.0, paramArrayOfDouble1, (m) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble2, m + paramInt5, 1, 1.0, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, 1);
                        }
                        m += -1;
                      }
                    } else {
                      i7 = this.floorDiv((paramInt1 - 1), i5) * i5 + 1;
                      m = i7;
                      for (var i8: number = this.floorDiv((1 - i7 + -i5), -i5); i8 > 0; i8--) {
                        n = Math.min(i5, paramInt1 - m + 1);
                        i1 = m;
                        for (i9 = n; i9 > 0; i9--) {
                          j = i1 + 1;
                          for (var i10: number = paramInt1 - (i1 + 1) + 1; i10 > 0; i10--) {
                            paramArrayOfDouble2[(j + (i1 - m) * i3 - 1 + paramInt5)] = paramArrayOfDouble1[(j - 1 + (i1 - 1) * paramInt3 + paramInt2)];
                            paramArrayOfDouble1[(j - 1 + (i1 - 1) * paramInt3 + paramInt2)] = 0.0;
                            j++;
                          }
                          i1++;
                        }
                        if ((m + n <= paramInt1)) {
                          this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, n, paramInt1 - m - n + 1, -1.0, paramArrayOfDouble1, (m + n - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble2, m + n - 1 + paramInt5, i3, 1.0, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, paramInt3);
                        }
                        this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, n, 1.0, paramArrayOfDouble2, m - 1 + paramInt5, i3, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, paramInt3);
                        m += -i5;
                      }
                    }
                    m = paramInt1 - 1;
                    for (var i8: number = -1 + paramInt1; i8 > 0; i8--) {
                      i2 = paramArrayOfInt[(m - 1 + paramInt4)];
                      if ((i2 != m)) {
                        this.dswap(paramInt1, paramArrayOfDouble1, (m - 1) * paramInt3 + paramInt2, 1, paramArrayOfDouble1, (i2 - 1) * paramInt3 + paramInt2, 1);
                      }
                      m += -1;
                    }
                    paramArrayOfDouble2[(paramInt5)] = k;
                  }
                  public dgetrf(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void {
                    var i: number = 0;
                    info[0] = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    info[0] = 0;
                    var localintW: Int32Array = new Int32Array(1);
                    localintW[0] = 0;
                    if ((paramInt1 < 0)) {
                      info[0] = -1;
                    } else {
                      if ((paramInt2 < 0)) {
                        info[0] = -2;
                      } else {
                        if ((paramInt4 < Math.max(1, paramInt1))) {
                          info[0] = -4;
                        }
                      }
                    }
                    if ((info[0] != 0)) {
                      return;
                    }
                    if (((paramInt2 == 0))) {
                      return;
                    }
                    m = this.ilaenv(1, "DGETRF", " ", paramInt1, paramInt2, -1, -1);
                    if (((m >= Math.min(paramInt1, paramInt2)))) {
                      this.dgetf2(paramInt1, paramInt2, paramArrayOfDouble, paramInt3, paramInt4, paramArrayOfInt, paramInt5, info);
                    } else {
                      j = 1;
                      for (var n: number = this.floorDiv((Math.min(paramInt1, paramInt2) - 1 + m), m); n > 0; n--) {
                        k = Math.min(Math.min(paramInt1, paramInt2) - j + 1, m);
                        this.dgetf2(paramInt1 - j + 1, k, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfInt, j - 1 + paramInt5, localintW);
                        i = j;
                        for (var i1: number = Math.min(paramInt1, j + k - 1) - j + 1; i1 > 0; i1--) {
                          paramArrayOfInt[(i - 1 + paramInt5)] = (j - 1 + paramArrayOfInt[(i - 1 + paramInt5)]);
                          i++;
                        }
                        this.dlaswp(j - 1, paramArrayOfDouble, paramInt3, paramInt4, j, j + k - 1, paramArrayOfInt, paramInt5, 1);
                        if ((j + k <= paramInt2)) {
                          this.dlaswp(paramInt2 - j - k + 1, paramArrayOfDouble, (j + k - 1) * paramInt4 + paramInt3, paramInt4, j, j + k - 1, paramArrayOfInt, paramInt5, 1);
                          this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, k, paramInt2 - j - k + 1, 1.0, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4);
                          if ((j + k <= paramInt1)) {
                            this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1 - j - k + 1, paramInt2 - j - k + 1, k, -1.0, paramArrayOfDouble, j + k - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4, 1.0, paramArrayOfDouble, j + k - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4);
                          }
                        }
                        j += m;
                      }
                    }
                  }
                  public dgetrs(trans: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, nOrder: number, nrhs: number, matA: Float64Array, offsetA: number, ldA: number, ipiv: Int32Array, offsetIpiV: number, matB: Float64Array, offsetB: number, ldB: number, info: Int32Array): void {
                    var bool: boolean = false;
                    info[0] = 0;
                    bool = trans.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE);
                    if (bool) {
                      this.dlaswp(nrhs, matB, offsetB, ldB, 1, nOrder, ipiv, offsetIpiV, 1);
                      this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                      this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                    } else {
                      this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                      this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, nOrder, nrhs, 1.0, matA, offsetA, ldA, matB, offsetB, ldB);
                      this.dlaswp(nrhs, matB, offsetB, ldB, 1, nOrder, ipiv, offsetIpiV, -1);
                    }
                  }
                  public dorgqr(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number, paramintW: Int32Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var localintW: Int32Array = new Int32Array(1);
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var i2: number = 0;
                    var i3: number = 0;
                    var i4: number = 0;
                    var i5: number = 0;
                    var i6: number = 0;
                    var i7: number = 0;
                    var i8: number = 0;
                    paramintW[0] = 0;
                    i6 = this.ilaenv(1, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1);
                    i5 = Math.max(1, paramInt2) * i6;
                    paramArrayOfDouble3[(paramInt7)] = i5;
                    i = paramInt8 != -1 ? 0 : 1;
                    if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if (((paramInt2 <= paramInt1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if (((paramInt3 <= paramInt2 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                          paramintW[0] = -3;
                        } else {
                          if ((paramInt5 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                            paramintW[0] = -5;
                          }
                        }
                      }
                    }
                    if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                      return;
                    }
                    if (i != 0) {
                      return;
                    }
                    if ((paramInt2 > 0 ? 0 : 1) != 0) {
                      paramArrayOfDouble3[(paramInt7)] = 1;
                      return;
                    }
                    i7 = 2;
                    i8 = 0;
                    m = paramInt2;
                    if (((i6 >= paramInt3 ? 0 : 1) != 0 ? 1 : 0) != 0) {
                      i8 = Math.max(0, this.ilaenv(3, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1));
                      if ((i8 >= paramInt3 ? 0 : 1) != 0) {
                        i4 = paramInt2;
                        m = i4 * i6;
                        if ((paramInt8 >= m ? 0 : 1) != 0) {
                          i6 = paramInt8 / i4;
                          i7 = Math.max(2, this.ilaenv(2, "DORGQR", " ", paramInt1, paramInt2, paramInt3, -1));
                        }
                      }
                    }
                    var i9: number;
                    var i10: number;
                    if (((i8 >= paramInt3 ? 0 : 1) != 0 ? 1 : 0) != 0) {
                      i1 = (paramInt3 - i8 - 1) / i6 * i6;
                      i2 = Math.min(paramInt3, i1 + i6);
                      n = i2 + 1;
                      for (i9 = paramInt2 - (i2 + 1) + 1; i9 > 0; i9--) {
                        j = 1;
                        for (i10 = i2; i10 > 0; i10--) {
                          paramArrayOfDouble1[(j - 1 + (n - 1) * paramInt5 + paramInt4)] = 0.0;
                          j += 1;
                        }
                        n += 1;
                      }
                    } else {
                      i2 = 0;
                    }
                    if ((i2 >= paramInt2 ? 0 : 1) != 0) {
                      this.dorg2r(paramInt1 - i2, paramInt2 - i2, paramInt3 - i2, paramArrayOfDouble1, i2 + (i2) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, i2 + paramInt6, paramArrayOfDouble3, paramInt7, localintW);
                    }
                    if ((i2 <= 0 ? 0 : 1) != 0) {
                      j = i1 + 1;
                      for (i9 = (1 - (i1 + 1) + -i6) / -i6; i9 > 0; i9--) {
                        k = Math.min(i6, paramInt3 - j + 1);
                        if ((j + k > paramInt2 ? 0 : 1) != 0) {
                          this.dlarft(org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD, org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, j - 1 + paramInt6, paramArrayOfDouble3, paramInt7, i4);
                          this.dlarfb(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD, org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, paramInt2 - j - k + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, paramInt7, i4, paramArrayOfDouble1, j - 1 + (j + k - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, k + paramInt7, i4);
                        }
                        this.dorg2r(paramInt1 - j + 1, k, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble2, j - 1 + paramInt6, paramArrayOfDouble3, paramInt7, localintW);
                        n = j;
                        for (i10 = j + k - 1 - j + 1; i10 > 0; i10--) {
                          i3 = 1;
                          for (var i11: number = j - 1; i11 > 0; i11--) {
                            paramArrayOfDouble1[(i3 - 1 + (n - 1) * paramInt5 + paramInt4)] = 0.0;
                            i3 += 1;
                          }
                          n += 1;
                        }
                        j += -i6;
                      }
                    }
                    paramArrayOfDouble3[(paramInt7)] = m;
                  }
                  public dgeqrf(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number, paramintW: Int32Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var localintW: Int32Array = new Int32Array(1);
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var i2: number = 0;
                    var i3: number = 0;
                    var i4: number = 0;
                    var i5: number = 0;
                    paramintW[0] = 0;
                    i3 = this.ilaenv(1, "DGEQRF", " ", paramInt1, paramInt2, -1, -1);
                    i2 = paramInt2 * i3;
                    paramArrayOfDouble3[paramInt6] = i2;
                    i = paramInt7 != -1 ? 0 : 1;
                    if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if ((paramInt2 >= 0 ? 0 : 1) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if ((paramInt4 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                          paramintW[0] = -4;
                        }
                      }
                    }
                    if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                      return;
                    }
                    if (i != 0) {
                      return;
                    }
                    n = Math.min(paramInt1, paramInt2);
                    if ((n != 0 ? 0 : 1) != 0) {
                      paramArrayOfDouble3[paramInt6] = 1;
                      return;
                    }
                    i4 = 2;
                    i5 = 0;
                    m = paramInt2;
                    if (((i3 >= n ? 0 : 1) != 0 ? 1 : 0) != 0) {
                      i5 = Math.max(0, this.ilaenv(3, "DGEQRF", " ", paramInt1, paramInt2, -1, -1));
                      if ((i5 >= n ? 0 : 1) != 0) {
                        i1 = paramInt2;
                        m = i1 * i3;
                        if ((paramInt7 >= m ? 0 : 1) != 0) {
                          i3 = paramInt7 / i1;
                          i4 = Math.max(2, this.ilaenv(2, "DGEQRF", " ", paramInt1, paramInt2, -1, -1));
                        }
                      }
                    }
                    if (((i5 >= n ? 0 : 1) != 0 ? 1 : 0) != 0) {
                      j = 1;
                      for (var i6: number = (n - i5 - 1 + i3) / i3; i6 > 0; i6--) {
                        k = Math.min(n - j + 1, i3);
                        this.dgeqr2(paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, localintW);
                        if ((j + k > paramInt2 ? 0 : 1) != 0) {
                          this.dlarft(org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD, org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, i1);
                          this.dlarfb(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD, org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE, paramInt1 - j + 1, paramInt2 - j - k + 1, k, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, paramInt6, i1, paramArrayOfDouble1, j - 1 + (j + k - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, k + paramInt6, i1);
                        }
                        j += i3;
                      }
                    } else {
                      j = 1;
                    }
                    if ((j > n ? 0 : 1) != 0) {
                      this.dgeqr2(paramInt1 - j + 1, paramInt2 - j + 1, paramArrayOfDouble1, j - 1 + (j - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble2, j - 1 + paramInt5, paramArrayOfDouble3, paramInt6, localintW);
                    }
                    paramArrayOfDouble3[(paramInt6)] = m;
                  }
                  public dorg2r(paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramintW: Int32Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    paramintW[0] = 0;
                    if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if (((paramInt2 <= paramInt1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if (((paramInt3 <= paramInt2 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                          paramintW[0] = -3;
                        } else {
                          if ((paramInt5 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                            paramintW[0] = -5;
                          }
                        }
                      }
                    }
                    if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                      return;
                    }
                    if ((paramInt2 > 0 ? 0 : 1) != 0) {
                      return;
                    }
                    j = paramInt3 + 1;
                    var n: number;
                    for (var m: number = paramInt2 - (paramInt3 + 1) + 1; m > 0; m--) {
                      k = 1;
                      for (n = paramInt1; n > 0; n--) {
                        paramArrayOfDouble1[(k - 1 + (j - 1) * paramInt5 + paramInt4)] = 0.0;
                        k += 1;
                      }
                      paramArrayOfDouble1[(j - 1 + (j - 1) * paramInt5 + paramInt4)] = 1.0;
                      j += 1;
                    }
                    i = paramInt3;
                    for (var m: number = (1 - paramInt3 + -1) / -1; m > 0; m--) {
                      if ((i >= paramInt2 ? 0 : 1) != 0) {
                        paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt5 + paramInt4)] = 1.0;
                        this.dlarf(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, paramInt1 - i + 1, paramInt2 - i, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt5 + paramInt4, 1, paramArrayOfDouble2[(i - 1 + paramInt6)], paramArrayOfDouble1, i - 1 + (i) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble3, paramInt7);
                      }
                      if ((i >= paramInt1 ? 0 : 1) != 0) {
                        this.dscal(paramInt1 - i, -paramArrayOfDouble2[(i - 1 + paramInt6)], paramArrayOfDouble1, i + (i - 1) * paramInt5 + paramInt4, 1);
                      }
                      paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt5 + paramInt4)] = (1.0 - paramArrayOfDouble2[(i - 1 + paramInt6)]);
                      k = 1;
                      for (n = i - 1; n > 0; n--) {
                        paramArrayOfDouble1[(k - 1 + (i - 1) * paramInt5 + paramInt4)] = 0.0;
                        k += 1;
                      }
                      i += -1;
                    }
                  }
                  public dlarfb(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasSideType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramString3: org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType, paramString4: org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramInt3: number, paramArrayOfDouble1: Float64Array, paramInt4: number, paramInt5: number, paramArrayOfDouble2: Float64Array, paramInt6: number, paramInt7: number, paramArrayOfDouble3: Float64Array, paramInt8: number, paramInt9: number, paramArrayOfDouble4: Float64Array, paramInt10: number, paramInt11: number): void {
                    var str: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType;
                    var i: number = 0;
                    var j: number = 0;
                    if (((paramInt2 > 0 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                      return;
                    }
                    if (paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      str = org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE;
                    } else {
                      str = org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE;
                    }
                    var k: number;
                    var m: number;
                    if (paramString4.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                      if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                        if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT)) {
                          j = 1;
                          for (k = paramInt3; k > 0; k--) {
                            this.dcopy(paramInt2, paramArrayOfDouble3, j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                            j += 1;
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                          if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                            this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt3 + paramInt8, paramInt9, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, str, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                          if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                            this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt3 + (1 - 1) * paramInt9 + paramInt8, paramInt9);
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                          j = 1;
                          for (k = paramInt3; k > 0; k--) {
                            i = 1;
                            for (m = paramInt2; m > 0; m--) {
                              paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                              i += 1;
                            }
                            j += 1;
                          }
                        } else {
                          if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT)) {
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              this.dcopy(paramInt1, paramArrayOfDouble3, (j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                              j += 1;
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt3 + paramInt4, paramInt5, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            j = 1;
                            k = paramInt3;
                            for (; ; ) {
                              i = 1;
                              for (m = paramInt1; m > 0; m--) {
                                paramArrayOfDouble3[(i - 1 + (j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                i += 1;
                              }
                              j += 1;
                              k--;
                              if (k <= 0) {
                                break;
                              }
                            }
                          }
                        }
                      } else {
                        if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT)) {
                          j = 1;
                          for (k = paramInt3; k > 0; k--) {
                            this.dcopy(paramInt2, paramArrayOfDouble3, paramInt1 - paramInt3 + j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                            j += 1;
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt1 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                          if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                            this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, str, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                          if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                            this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                          }
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt1 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                          j = 1;
                          for (k = paramInt3; k > 0; k--) {
                            i = 1;
                            for (m = paramInt2; m > 0; m--) {
                              paramArrayOfDouble3[(paramInt1 - paramInt3 + j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                              i += 1;
                            }
                            j += 1;
                          }
                        } else {
                          if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT)) {
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              this.dcopy(paramInt1, paramArrayOfDouble3, (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                              j += 1;
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt2 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt2 - paramInt3 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            j = 1;
                            k = paramInt3;
                            for (; ; ) {
                              i = 1;
                              for (m = paramInt1; m > 0; m--) {
                                paramArrayOfDouble3[(i - 1 + (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                i += 1;
                              }
                              j += 1;
                              k--;
                              if (k <= 0) {
                                break;
                              }
                            }
                          }
                        }
                      }
                    } else {
                      if (paramString4.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.ROWWISE)) {
                        if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                          if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT)) {
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              this.dcopy(paramInt2, paramArrayOfDouble3, j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                              j += 1;
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt3 + paramInt8, paramInt9, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, str, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt3 + (1 - 1) * paramInt9 + paramInt8, paramInt9);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              i = 1;
                              for (m = paramInt2; m > 0; m--) {
                                paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                i += 1;
                              }
                              j += 1;
                            }
                          } else {
                            if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT)) {
                              j = 1;
                              for (k = paramInt3; k > 0; k--) {
                                this.dcopy(paramInt1, paramArrayOfDouble3, (j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                j += 1;
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                              if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                              if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, (paramInt3) * paramInt5 + paramInt4, paramInt5, 1.0, paramArrayOfDouble3, (paramInt3) * paramInt9 + paramInt8, paramInt9);
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                              j = 1;
                              k = paramInt3;
                              for (; ; ) {
                                i = 1;
                                for (m = paramInt1; m > 0; m--) {
                                  paramArrayOfDouble3[(i - 1 + (j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                  i += 1;
                                }
                                j += 1;
                                k--;
                                if (k <= 0) {
                                  break;
                                }
                              }
                            }
                          }
                        } else {
                          if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT)) {
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              this.dcopy(paramInt2, paramArrayOfDouble3, paramInt1 - paramInt3 + j - 1 + paramInt8, paramInt9, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                              j += 1;
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, (paramInt1 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt2, paramInt3, paramInt1 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, str, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                            if ((paramInt1 <= paramInt3 ? 0 : 1) != 0) {
                              this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt3, paramInt2, paramInt3, -1.0, paramArrayOfDouble1, paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                            }
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt2, paramInt3, 1.0, paramArrayOfDouble1, (paramInt1 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                            j = 1;
                            for (k = paramInt3; k > 0; k--) {
                              i = 1;
                              for (m = paramInt2; m > 0; m--) {
                                paramArrayOfDouble3[(paramInt1 - paramInt3 + j - 1 + (i - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                i += 1;
                              }
                              j += 1;
                            }
                          } else {
                            if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT)) {
                              j = 1;
                              for (k = paramInt3; k > 0; k--) {
                                this.dcopy(paramInt1, paramArrayOfDouble3, (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8, 1, paramArrayOfDouble4, (j - 1) * paramInt11 + paramInt10, 1);
                                j += 1;
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, (paramInt2 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                              if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt3, paramInt2 - paramInt3, 1.0, paramArrayOfDouble3, paramInt8, paramInt9, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble4, paramInt10, paramInt11);
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble2, paramInt6, paramInt7, paramArrayOfDouble4, paramInt10, paramInt11);
                              if ((paramInt2 <= paramInt3 ? 0 : 1) != 0) {
                                this.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2 - paramInt3, paramInt3, -1.0, paramArrayOfDouble4, paramInt10, paramInt11, paramArrayOfDouble1, paramInt4, paramInt5, 1.0, paramArrayOfDouble3, paramInt8, paramInt9);
                              }
                              this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT, paramInt1, paramInt3, 1.0, paramArrayOfDouble1, (paramInt2 - paramInt3) * paramInt5 + paramInt4, paramInt5, paramArrayOfDouble4, paramInt10, paramInt11);
                              j = 1;
                              k = paramInt3;
                              for (; ; ) {
                                i = 1;
                                for (m = paramInt1; m > 0; m--) {
                                  paramArrayOfDouble3[(i - 1 + (paramInt2 - paramInt3 + j - 1) * paramInt9 + paramInt8)] -= paramArrayOfDouble4[(i - 1 + (j - 1) * paramInt11 + paramInt10)];
                                  i += 1;
                                }
                                j += 1;
                                k--;
                                if (k <= 0) {
                                  break;
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  public dcopy(n: number, x: Float64Array, offsetx: number, incx: number, y: Float64Array, offsety: number, incy: number): void {
                    if (n <= 0) {
                      return;
                    }
                    var indexX: number = offsetx;
                    var indexY: number = offsety;
                    for (var i: number = 0; i < n; i++) {
                      y[indexY] = x[indexX];
                      indexY += incy;
                      indexX += incx;
                    }
                  }
                  public dlarft(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramInt7: number): void {
                    var i: number = 0;
                    var j: number = 0;
                    var d: number = 0.0;
                    if ((paramInt1 != 0 ? 0 : 1) != 0) {
                      return;
                    }
                    var k: number;
                    var m: number;
                    if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasDirectionType.FORWARD)) {
                      i = 1;
                      for (k = paramInt2; k > 0; k--) {
                        if ((paramArrayOfDouble2[(i - 1 + paramInt5)] != 0.0 ? 0 : 1) != 0) {
                          j = 1;
                          for (m = i; m > 0; m--) {
                            paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt7 + paramInt6)] = 0.0;
                            j += 1;
                          }
                        } else {
                          d = paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                          paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                          if (paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                            this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - i + 1, i - 1, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i - 1 + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, 1, 0.0, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                          } else {
                            this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, i - 1, paramInt1 - i + 1, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, (i - 1) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, paramInt4, 0.0, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                          }
                          paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                          this.dtrmv(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, i - 1, paramArrayOfDouble3, paramInt6, paramInt7, paramArrayOfDouble3, (i - 1) * paramInt7 + paramInt6, 1);
                          paramArrayOfDouble3[(i - 1 + (i - 1) * paramInt7 + paramInt6)] = paramArrayOfDouble2[(i - 1 + paramInt5)];
                        }
                        i += 1;
                      }
                    } else {
                      i = paramInt2;
                      for (k = (1 - paramInt2 + -1) / -1; k > 0; k--) {
                        if ((paramArrayOfDouble2[(i - 1 + paramInt5)] != 0.0 ? 0 : 1) != 0) {
                          j = i;
                          for (m = paramInt2 - i + 1; m > 0; m--) {
                            paramArrayOfDouble3[(j - 1 + (i - 1) * paramInt7 + paramInt6)] = 0.0;
                            j += 1;
                          }
                        } else {
                          if ((i >= paramInt2 ? 0 : 1) != 0) {
                            if (paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasMajorType.COLUMNWISE)) {
                              d = paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)];
                              paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                              this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1 - paramInt2 + i, paramInt2 - i, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, (i) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble1, (i - 1) * paramInt4 + paramInt3, 1, 0.0, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                              paramArrayOfDouble1[(paramInt1 - paramInt2 + i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                            } else {
                              d = paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)];
                              paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)] = 1.0;
                              this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt2 - i, paramInt1 - paramInt2 + i, -paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i + paramInt3, paramInt4, paramArrayOfDouble1, i - 1 + paramInt3, paramInt4, 0.0, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                              paramArrayOfDouble1[(i - 1 + (paramInt1 - paramInt2 + i - 1) * paramInt4 + paramInt3)] = d;
                            }
                            this.dtrmv(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT, paramInt2 - i, paramArrayOfDouble3, i + (i) * paramInt7 + paramInt6, paramInt7, paramArrayOfDouble3, i + (i - 1) * paramInt7 + paramInt6, 1);
                          }
                          paramArrayOfDouble3[(i - 1 + (i - 1) * paramInt7 + paramInt6)] = paramArrayOfDouble2[(i - 1 + paramInt5)];
                        }
                        i += -1;
                      }
                    }
                  }
                  public dgeqr2(paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramArrayOfDouble3: Float64Array, paramInt6: number, paramintW: Int32Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var d: number = 0.0;
                    paramintW[0] = 0;
                    if ((paramInt1 >= 0 ? 0 : 1) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if ((paramInt2 >= 0 ? 0 : 1) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if ((paramInt4 >= Math.max(1, paramInt1) ? 0 : 1) != 0) {
                          paramintW[0] = -4;
                        }
                      }
                    }
                    if ((paramintW[0] == 0 ? 0 : 1) != 0) {
                      return;
                    }
                    j = Math.min(paramInt1, paramInt2);
                    i = 1;
                    for (var k: number = j; k > 0; k--) {
                      this.dlarfg_adapter(paramInt1 - i + 1, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, paramArrayOfDouble1, Math.min(i + 1, paramInt1) - 1 + (i - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble2, i - 1 + paramInt5);
                      if ((i >= paramInt2 ? 0 : 1) != 0) {
                        d = paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                        paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = 1.0;
                        this.dlarf(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, paramInt1 - i + 1, paramInt2 - i, paramArrayOfDouble1, i - 1 + (i - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble2[(i - 1 + paramInt5)], paramArrayOfDouble1, i - 1 + (i) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble3, paramInt6);
                        paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)] = d;
                      }
                      i += 1;
                    }
                  }
                  private dlarfg_adapter(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramArrayOfDouble2: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble3: Float64Array, paramInt5: number): void {
                    var localdoubleW1: Float64Array = new Float64Array(1);
                    localdoubleW1[0] = (paramArrayOfDouble1[paramInt2]);
                    var localdoubleW2: Float64Array = new Float64Array(1);
                    localdoubleW2[0] = (paramArrayOfDouble3[paramInt5]);
                    this.dlarfg(paramInt1, localdoubleW1, paramArrayOfDouble2, paramInt3, paramInt4, localdoubleW2);
                    paramArrayOfDouble1[paramInt2] = localdoubleW1[0];
                    paramArrayOfDouble3[paramInt5] = localdoubleW2[0];
                  }
                  public dlarf(paramString: org.kevoree.modeling.util.maths.structure.blas.KBlasSideType, paramInt1: number, paramInt2: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramDouble: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number): void {
                    if (paramString.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT)) {
                      if ((paramDouble == 0.0 ? 0 : 1) != 0) {
                        this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.TRANSPOSE, paramInt1, paramInt2, 1.0, paramArrayOfDouble2, paramInt5, paramInt6, paramArrayOfDouble1, paramInt3, paramInt4, 0.0, paramArrayOfDouble3, paramInt7, 1);
                        this.dger(paramInt1, paramInt2, -paramDouble, paramArrayOfDouble1, paramInt3, paramInt4, paramArrayOfDouble3, paramInt7, 1, paramArrayOfDouble2, paramInt5, paramInt6);
                      }
                    } else {
                      if ((paramDouble == 0.0 ? 0 : 1) != 0) {
                        this.dgemv(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramInt1, paramInt2, 1.0, paramArrayOfDouble2, paramInt5, paramInt6, paramArrayOfDouble1, paramInt3, paramInt4, 0.0, paramArrayOfDouble3, paramInt7, 1);
                        this.dger(paramInt1, paramInt2, -paramDouble, paramArrayOfDouble3, paramInt7, 1, paramArrayOfDouble1, paramInt3, paramInt4, paramArrayOfDouble2, paramInt5, paramInt6);
                      }
                    }
                  }
                  public dnrm2(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number {
                    var d1: number = 0.0;
                    var d2: number = 0.0;
                    var d3: number = 0.0;
                    var d4: number = 0.0;
                    var i: number = 0;
                    var d5: number = 0.0;
                    if (((paramInt3 >= 1 ? 0 : 1) == 0 ? 0 : 1) != 0) {
                      d2 = 0.0;
                    } else {
                      if ((paramInt1 != 1 ? 0 : 1) != 0) {
                        d2 = Math.abs(paramArrayOfDouble[(paramInt2)]);
                      } else {
                        d3 = 0.0;
                        d4 = 1.0;
                        i = 1;
                        for (var j: number = (1 + (paramInt1 - 1) * paramInt3 - 1 + paramInt3) / paramInt3; j > 0; j--) {
                          if ((paramArrayOfDouble[(i - 1 + paramInt2)] == 0.0 ? 0 : 1) != 0) {
                            d1 = Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]);
                            if ((d3 >= d1 ? 0 : 1) != 0) {
                              d4 = 1.0 + d4 * Math.pow(d3 / d1, 2);
                              d3 = d1;
                            } else {
                              d4 += Math.pow(d1 / d3, 2);
                            }
                          }
                          i += paramInt3;
                        }
                        d2 = d3 * Math.sqrt(d4);
                      }
                    }
                    d5 = d2;
                    return d5;
                  }
                  public dlapy2(paramDouble1: number, paramDouble2: number): number {
                    var d1: number = 0.0;
                    var d2: number = 0.0;
                    var d3: number = 0.0;
                    var d4: number = 0.0;
                    var d5: number = 0.0;
                    d2 = Math.abs(paramDouble1);
                    d3 = Math.abs(paramDouble2);
                    d1 = Math.max(d2, d3);
                    d4 = Math.min(d2, d3);
                    if ((d4 != 0.0 ? 0 : 1) != 0) {
                      d5 = d1;
                    } else {
                      d5 = d1 * Math.sqrt(1.0 + Math.pow(d4 / d1, 2));
                    }
                    return d5;
                  }
                  private dsign(paramDouble1: number, paramDouble2: number): number {
                    if (paramDouble2 > 0.0) {
                      return Math.abs(paramDouble1);
                    }
                    if (paramDouble2 < 0.0) {
                      return -Math.abs(paramDouble1);
                    }
                    return 0.0;
                  }
                  public dlarfg(paramInt1: number, paramdoubleW1: Float64Array, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramdoubleW2: Float64Array): void {
                    var i: number = 0;
                    var j: number = 0;
                    var d1: number = 0.0;
                    var d2: number = 0.0;
                    var d3: number = 0.0;
                    var d4: number = 0.0;
                    if ((paramInt1 > 1 ? 0 : 1) != 0) {
                      paramdoubleW2[0] = 0.0;
                      return;
                    }
                    d4 = this.dnrm2(paramInt1 - 1, paramArrayOfDouble, paramInt2, paramInt3);
                    if ((d4 != 0.0 ? 0 : 1) != 0) {
                      paramdoubleW2[0] = 0.0;
                    } else {
                      d1 = -this.dsign(this.dlapy2(paramdoubleW1[0], d4), paramdoubleW1[0]);
                      d3 = org.kevoree.modeling.util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                      if ((Math.abs(d1) >= d3 ? 0 : 1) != 0) {
                        d2 = 1.0 / d3;
                        j = 0;
                        do {
                          j += 1;
                          this.dscal(paramInt1 - 1, d2, paramArrayOfDouble, paramInt2, paramInt3);
                          d1 *= d2;
                          paramdoubleW1[0] *= d2;
                        } while ((Math.abs(d1) >= d3 ? 0 : 1) != 0)
                        d4 = this.dnrm2(paramInt1 - 1, paramArrayOfDouble, paramInt2, paramInt3);
                        d1 = -this.dsign(this.dlapy2(paramdoubleW1[0], d4), paramdoubleW1[0]);
                        paramdoubleW2[0] = ((d1 - paramdoubleW1[0]) / d1);
                        this.dscal(paramInt1 - 1, 1.0 / (paramdoubleW1[0] - d1), paramArrayOfDouble, paramInt2, paramInt3);
                        paramdoubleW1[0] = d1;
                        i = 1;
                        for (var k: number = j; k > 0; k--) {
                          paramdoubleW1[0] *= d3;
                          i += 1;
                        }
                      } else {
                        paramdoubleW2[0] = ((d1 - paramdoubleW1[0]) / d1);
                        this.dscal(paramInt1 - 1, 1.0 / (paramdoubleW1[0] - d1), paramArrayOfDouble, paramInt2, paramInt3);
                        paramdoubleW1[0] = d1;
                      }
                    }
                  }
                  public shutdown(): void {}
                  public dtrti2(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void {
                    var bool1: boolean = false;
                    var bool2: boolean = false;
                    var i: number = 0;
                    var d: number = 0.0;
                    paramintW[0] = 0;
                    bool2 = paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER);
                    bool1 = paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT);
                    if ((((!bool2)) && ((!paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER))) ? 1 : 0) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if ((((!bool1)) && ((!paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT))) ? 1 : 0) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if ((paramInt1 < 0)) {
                          paramintW[0] = -3;
                        } else {
                          if ((paramInt3 < Math.max(1, paramInt1))) {
                            paramintW[0] = -5;
                          }
                        }
                      }
                    }
                    if ((paramintW[0] != 0)) {
                      return;
                    }
                    var j: number;
                    if (bool2) {
                      i = 1;
                      for (j = paramInt1; j > 0; j--) {
                        if (bool1) {
                          paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)] = (1.0 / paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)]);
                          d = -paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)];
                        } else {
                          d = -1.0;
                        }
                        this.dtrmv(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, paramArrayOfDouble, paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, 1);
                        this.dscal(i - 1, d, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, 1);
                        i++;
                      }
                    } else {
                      i = paramInt1;
                      for (j = paramInt1; j > 0; j--) {
                        if (bool1) {
                          paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)] = (1.0 / paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)]);
                          d = -paramArrayOfDouble[(i - 1 + (i - 1) * paramInt3 + paramInt2)];
                        } else {
                          d = -1.0;
                        }
                        if ((i < paramInt1)) {
                          this.dtrmv(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i, paramArrayOfDouble, i + (i) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + (i - 1) * paramInt3 + paramInt2, 1);
                          this.dscal(paramInt1 - i, d, paramArrayOfDouble, i + (i - 1) * paramInt3 + paramInt2, 1);
                        }
                        i += -1;
                      }
                    }
                  }
                  private print(paramArrayOfDouble: Float64Array, s: string): void {
                    var t: string = s + ": ";
                    for (var i: number = 0; i < paramArrayOfDouble.length; i++) {
                      t = t + paramArrayOfDouble[i] + " ";
                    }
                    console.log(t);
                  }
                  public dtrmv(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramString3: org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var bool: boolean = false;
                    bool = paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT);
                    if ((paramInt5 <= 0)) {
                      i1 = 1 - (paramInt1 - 1) * paramInt5;
                    } else {
                      if ((paramInt5 != 1)) {
                        i1 = 1;
                      }
                    }
                    var i2: number;
                    var i3: number;
                    if (paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER)) {
                        if ((paramInt5 == 1)) {
                          m = 1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            if ((paramArrayOfDouble2[(m - 1 + paramInt4)] != 0.0)) {
                              d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                              i = 1;
                              for (i3 = m - 1; i3 > 0; i3--) {
                                paramArrayOfDouble2[(i - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                i++;
                              }
                              if (bool) {
                                paramArrayOfDouble2[(m - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                              }
                            }
                            m++;
                          }
                        } else {
                          n = i1;
                          m = 1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            if ((paramArrayOfDouble2[(n - 1 + paramInt4)] != 0.0)) {
                              d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                              k = i1;
                              i = 1;
                              for (i3 = m - 1; i3 > 0; i3--) {
                                paramArrayOfDouble2[(k - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                k += paramInt5;
                                i++;
                              }
                              if (bool) {
                                paramArrayOfDouble2[(n - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                              }
                            }
                            n += paramInt5;
                            m++;
                          }
                        }
                      } else {
                        if ((paramInt5 == 1)) {
                          m = paramInt1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            if ((paramArrayOfDouble2[(m - 1 + paramInt4)] != 0.0)) {
                              d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                              i = paramInt1;
                              for (i3 = -(m - paramInt1); i3 > 0; i3--) {
                                paramArrayOfDouble2[(i - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                i += -1;
                              }
                              if (bool) {
                                paramArrayOfDouble2[(m - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                              }
                            }
                            m += -1;
                          }
                        } else {
                          i1 += (paramInt1 - 1) * paramInt5;
                          n = i1;
                          m = paramInt1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            if ((paramArrayOfDouble2[(n - 1 + paramInt4)] != 0.0)) {
                              d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                              k = i1;
                              i = paramInt1;
                              for (i3 = -(m - paramInt1); i3 > 0; i3--) {
                                paramArrayOfDouble2[(k - 1 + paramInt4)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)];
                                k -= paramInt5;
                                i += -1;
                              }
                              if (bool) {
                                paramArrayOfDouble2[(n - 1 + paramInt4)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                              }
                            }
                            n -= paramInt5;
                            m += -1;
                          }
                        }
                      }
                    } else {
                      if (paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER)) {
                        if ((paramInt5 == 1)) {
                          m = paramInt1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                            if (bool) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                            }
                            i = m - 1;
                            for (i3 = (m - 1); i3 > 0; i3--) {
                              d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(i - 1 + paramInt4)];
                              i += -1;
                            }
                            paramArrayOfDouble2[(m - 1 + paramInt4)] = d;
                            m += -1;
                          }
                        } else {
                          n = i1 + (paramInt1 - 1) * paramInt5;
                          m = paramInt1;
                          for (i2 = -paramInt1; i2 > 0; i2--) {
                            d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                            k = n;
                            if (bool) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                            }
                            i = m - 1;
                            for (i3 = (m - 1); i3 > 0; i3--) {
                              k -= paramInt5;
                              d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(k - 1 + paramInt4)];
                              i += -1;
                            }
                            paramArrayOfDouble2[(n - 1 + paramInt4)] = d;
                            n -= paramInt5;
                            m += -1;
                          }
                        }
                      } else {
                        if ((paramInt5 == 1)) {
                          m = 1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            d = paramArrayOfDouble2[(m - 1 + paramInt4)];
                            if (bool) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                            }
                            i = m + 1;
                            for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                              d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(i - 1 + paramInt4)];
                              i++;
                            }
                            paramArrayOfDouble2[(m - 1 + paramInt4)] = d;
                            m++;
                          }
                        } else {
                          n = i1;
                          m = 1;
                          for (i2 = paramInt1; i2 > 0; i2--) {
                            d = paramArrayOfDouble2[(n - 1 + paramInt4)];
                            k = n;
                            if (bool) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt3 + paramInt2)];
                            }
                            i = m + 1;
                            for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                              k += paramInt5;
                              d += paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt3 + paramInt2)] * paramArrayOfDouble2[(k - 1 + paramInt4)];
                              i++;
                            }
                            paramArrayOfDouble2[(n - 1 + paramInt4)] = d;
                            n += paramInt5;
                            m++;
                          }
                        }
                      }
                    }
                  }
                  public dtrmm(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasSideType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType, paramString3: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramString4: org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var bool1: boolean = false;
                    var bool2: boolean = false;
                    var bool3: boolean = false;
                    bool1 = paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT);
                    if (bool1) {
                      n = paramInt1;
                    } else {
                      n = paramInt2;
                    }
                    bool2 = paramString4.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT);
                    bool3 = paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER);
                    var i1: number;
                    var i2: number;
                    if ((paramDouble == 0)) {
                      k = 1;
                      for (i1 = paramInt2; i1 > 0; i1--) {
                        i = 1;
                        for (i2 = paramInt1; i2 > 0; i2--) {
                          paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = 0.0;
                          i++;
                        }
                        k++;
                      }
                      return;
                    }
                    var i3: number;
                    if (bool1) {
                      if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        if (bool3) {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            m = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                i = 1;
                                for (i3 = m - 1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                  i++;
                                }
                                if (bool2) {
                                  d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                }
                                paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                              }
                              m++;
                            }
                            k++;
                          }
                        } else {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            m = paramInt1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                                if (bool2) {
                                  paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                }
                                i = m + 1;
                                for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                  i++;
                                }
                              }
                              m += -1;
                            }
                            k++;
                          }
                        }
                      } else {
                        if (bool3) {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            i = paramInt1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              d = paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                              if (bool2) {
                                d *= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                              }
                              m = 1;
                              for (i3 = i - 1; i3 > 0; i3--) {
                                d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                m++;
                              }
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * d);
                              i += -1;
                            }
                            k++;
                          }
                        } else {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            i = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              d = paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                              if (bool2) {
                                d *= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                              }
                              m = i + 1;
                              for (i3 = paramInt1 - (i + 1) + 1; i3 > 0; i3--) {
                                d += paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                m++;
                              }
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * d);
                              i++;
                            }
                            k++;
                          }
                        }
                      }
                    } else {
                      if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        if (bool3) {
                          k = paramInt2;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            d = paramDouble;
                            if (bool2) {
                              d *= paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                            }
                            i = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                              i++;
                            }
                            m = 1;
                            for (i2 = k - 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              m++;
                            }
                            k += -1;
                          }
                        } else {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            d = paramDouble;
                            if (bool2) {
                              d *= paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                            }
                            i = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                              i++;
                            }
                            m = k + 1;
                            for (i2 = paramInt2 - (k + 1) + 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              m++;
                            }
                            k++;
                          }
                        }
                      } else {
                        if (bool3) {
                          m = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            k = 1;
                            for (i2 = m - 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              k++;
                            }
                            d = paramDouble;
                            if (bool2) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                            }
                            if ((d != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m++;
                          }
                        } else {
                          m = paramInt2;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            k = m + 1;
                            for (i2 = paramInt2 - (m + 1) + 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramDouble * paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] += d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              k++;
                            }
                            d = paramDouble;
                            if (bool2) {
                              d *= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                            }
                            if ((d != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m += -1;
                          }
                        }
                      }
                    }
                  }
                  public dtrtri(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramintW: Int32Array): void {
                    var bool1: boolean = false;
                    var bool2: boolean = false;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    paramintW[0] = 0;
                    bool2 = paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER);
                    bool1 = paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT);
                    if ((((!bool2)) && ((!paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER))) ? 1 : 0) != 0) {
                      paramintW[0] = -1;
                    } else {
                      if ((((!bool1)) && ((!paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.UNIT))) ? 1 : 0) != 0) {
                        paramintW[0] = -2;
                      } else {
                        if ((paramInt1 < 0)) {
                          paramintW[0] = -3;
                        } else {
                          if ((paramInt3 < Math.max(1, paramInt1))) {
                            paramintW[0] = -5;
                          }
                        }
                      }
                    }
                    if ((paramintW[0] != 0)) {
                      return;
                    }
                    if ((paramInt1 == 0)) {
                      return;
                    }
                    var n: number;
                    if (bool1) {
                      paramintW[0] = 1;
                      for (n = paramInt1; n > 0; n--) {
                        if ((paramArrayOfDouble[(paramintW[0] - 1 + (paramintW[0] - 1) * paramInt3 + paramInt2)] == 0)) {
                          return;
                        }
                        paramintW[0]++;
                      }
                      paramintW[0] = 0;
                    }
                    k = this.ilaenv(1, "DTRTRI", "", paramInt1, -1, -1, -1);
                    if (((k >= paramInt1))) {
                      this.dtrti2(paramString1, paramString2, paramInt1, paramArrayOfDouble, paramInt2, paramInt3, paramintW);
                    } else {
                      if (bool2) {
                        i = 1;
                        for (n = <number>this.floorDiv((paramInt1 - 1 + k), k); n > 0; n--) {
                          j = Math.min(k, paramInt1 - i + 1);
                          this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, j, 1.0, paramArrayOfDouble, paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, paramInt3);
                          this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, i - 1, j, -1.0, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, (i - 1) * paramInt3 + paramInt2, paramInt3);
                          this.dtrti2(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER, paramString2, j, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramintW);
                          i += k;
                        }
                      } else {
                        m = this.floorDiv((paramInt1 - 1), k) * k + 1;
                        i = m;
                        for (n = this.floorDiv((1 - m + -k), -k); n > 0; n--) {
                          j = Math.min(k, paramInt1 - i + 1);
                          if ((i + j <= paramInt1)) {
                            this.dtrmm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i - j + 1, j, 1.0, paramArrayOfDouble, i + j - 1 + (i + j - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + j - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3);
                            this.dtrsm(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.RIGHT, org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, paramString2, paramInt1 - i - j + 1, j, -1.0, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramArrayOfDouble, i + j - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3);
                          }
                          this.dtrti2(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.LOWER, paramString2, j, paramArrayOfDouble, i - 1 + (i - 1) * paramInt3 + paramInt2, paramInt3, paramintW);
                          i += -k;
                        }
                      }
                    }
                  }
                  public dgemv(paramString: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramInt1: number, paramInt2: number, paramDouble1: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramDouble2: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var i2: number = 0;
                    var i3: number = 0;
                    var i4: number = 0;
                    var i5: number = 0;
                    var i6: number = 0;
                    if (paramString.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      i5 = paramInt2;
                      i6 = paramInt1;
                    } else {
                      i5 = paramInt1;
                      i6 = paramInt2;
                    }
                    if ((paramInt6 > 0)) {
                      i3 = 1;
                    } else {
                      i3 = 1 - (i5 - 1) * paramInt6;
                    }
                    if ((paramInt8 > 0)) {
                      i4 = 1;
                    } else {
                      i4 = 1 - (i6 - 1) * paramInt8;
                    }
                    var i7: number;
                    if ((paramDouble2 != 1.0)) {
                      if ((paramInt8 == 1)) {
                        if ((paramDouble2 == 0)) {
                          i = 1;
                          for (i7 = i6; i7 > 0; i7--) {
                            paramArrayOfDouble3[(i - 1 + paramInt7)] = 0.0;
                            i++;
                          }
                        } else {
                          i = 1;
                          for (i7 = i6; i7 > 0; i7--) {
                            paramArrayOfDouble3[(i - 1 + paramInt7)] = (paramDouble2 * paramArrayOfDouble3[(i - 1 + paramInt7)]);
                            i++;
                          }
                        }
                      } else {
                        m = i4;
                        if ((paramDouble2 == 0)) {
                          i = 1;
                          for (i7 = i6; i7 > 0; i7--) {
                            paramArrayOfDouble3[(m - 1 + paramInt7)] = 0.0;
                            m += paramInt8;
                            i++;
                          }
                        } else {
                          i = 1;
                          for (i7 = i6; i7 > 0; i7--) {
                            paramArrayOfDouble3[(m - 1 + paramInt7)] = (paramDouble2 * paramArrayOfDouble3[(m - 1 + paramInt7)]);
                            m += paramInt8;
                            i++;
                          }
                        }
                      }
                    }
                    if ((paramDouble1 == 0)) {
                      return;
                    }
                    var i8: number;
                    if (paramString.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      i1 = i3;
                      if ((paramInt8 == 1)) {
                        n = 1;
                        for (i7 = paramInt2; i7 > 0; i7--) {
                          if ((paramArrayOfDouble2[(i1 - 1 + paramInt5)] != 0.0)) {
                            d = paramDouble1 * paramArrayOfDouble2[(i1 - 1 + paramInt5)];
                            i = 1;
                            for (i8 = paramInt1; i8 > 0; i8--) {
                              paramArrayOfDouble3[(i - 1 + paramInt7)] += d * paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)];
                              i++;
                            }
                          }
                          i1 += paramInt6;
                          n++;
                        }
                      } else {
                        n = 1;
                        for (i7 = paramInt2; i7 > 0; i7--) {
                          if ((paramArrayOfDouble2[(i1 - 1 + paramInt5)] != 0.0)) {
                            d = paramDouble1 * paramArrayOfDouble2[(i1 - 1 + paramInt5)];
                            m = i4;
                            i = 1;
                            for (i8 = paramInt1; i8 > 0; i8--) {
                              paramArrayOfDouble3[(m - 1 + paramInt7)] += d * paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)];
                              m += paramInt8;
                              i++;
                            }
                          }
                          i1 += paramInt6;
                          n++;
                        }
                      }
                    } else {
                      i2 = i4;
                      if ((paramInt6 == 1)) {
                        n = 1;
                        for (i7 = paramInt2; i7 > 0; i7--) {
                          d = 0.0;
                          i = 1;
                          for (i8 = paramInt1; i8 > 0; i8--) {
                            d += paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + paramInt5)];
                            i++;
                          }
                          paramArrayOfDouble3[(i2 - 1 + paramInt7)] += paramDouble1 * d;
                          i2 += paramInt8;
                          n++;
                        }
                      } else {
                        n = 1;
                        for (i7 = paramInt2; i7 > 0; i7--) {
                          d = 0.0;
                          k = i3;
                          i = 1;
                          for (i8 = paramInt1; i8 > 0; i8--) {
                            d += paramArrayOfDouble1[(i - 1 + (n - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(k - 1 + paramInt5)];
                            k += paramInt6;
                            i++;
                          }
                          paramArrayOfDouble3[(i2 - 1 + paramInt7)] += paramDouble1 * d;
                          i2 += paramInt8;
                          n++;
                        }
                      }
                    }
                  }
                  private ilaenv(i: number, dgetrf: string, s: string, paramInt1: number, paramInt2: number, i1: number, i2: number): number {
                    return 64;
                  }
                  public dger(paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number, paramArrayOfDouble3: Float64Array, paramInt7: number, paramInt8: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    if ((paramInt6 > 0)) {
                      n = 1;
                    } else {
                      n = 1 - (paramInt2 - 1) * paramInt6;
                    }
                    var i2: number;
                    var i3: number;
                    if ((paramInt4 == 1)) {
                      m = 1;
                      for (i2 = paramInt2; i2 > 0; i2--) {
                        if ((paramArrayOfDouble2[(n - 1 + paramInt5)] != 0.0)) {
                          d = paramDouble * paramArrayOfDouble2[(n - 1 + paramInt5)];
                          i = 1;
                          for (i3 = paramInt1; i3 > 0; i3--) {
                            paramArrayOfDouble3[(i - 1 + (m - 1) * paramInt8 + paramInt7)] += paramArrayOfDouble1[(i - 1 + paramInt3)] * d;
                            i++;
                          }
                        }
                        n += paramInt6;
                        m++;
                      }
                    } else {
                      if ((paramInt4 > 0)) {
                        i1 = 1;
                      } else {
                        i1 = 1 - (paramInt1 - 1) * paramInt4;
                      }
                      m = 1;
                      for (i2 = paramInt2; i2 > 0; i2--) {
                        if ((paramArrayOfDouble2[(n - 1 + paramInt5)] != 0.0)) {
                          d = paramDouble * paramArrayOfDouble2[(n - 1 + paramInt5)];
                          k = i1;
                          i = 1;
                          for (i3 = paramInt1; i3 > 0; i3--) {
                            paramArrayOfDouble3[(i - 1 + (m - 1) * paramInt8 + paramInt7)] += paramArrayOfDouble1[(k - 1 + paramInt3)] * d;
                            k += paramInt4;
                            i++;
                          }
                        }
                        n += paramInt6;
                        m++;
                      }
                    }
                  }
                  public idamax(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): number {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    k = 0;
                    if (((paramInt3 <= 0))) {
                      return k;
                    }
                    k = 1;
                    if ((paramInt1 == 1)) {
                      return k;
                    }
                    var m: number;
                    if ((paramInt3 == 1)) {
                      d = Math.abs(paramArrayOfDouble[(paramInt2)]);
                      i = 2;
                      for (m = paramInt1 - 1; m > 0; m--) {
                        if ((Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]) > d)) {
                          k = i;
                          d = Math.abs(paramArrayOfDouble[(i - 1 + paramInt2)]);
                        }
                        i++;
                      }
                    } else {
                      j = 1;
                      d = Math.abs(paramArrayOfDouble[(paramInt2)]);
                      j += paramInt3;
                      i = 2;
                      for (m = paramInt1 - 1; m > 0; m--) {
                        if ((Math.abs(paramArrayOfDouble[(j - 1 + paramInt2)]) > d)) {
                          k = i;
                          d = Math.abs(paramArrayOfDouble[(j - 1 + paramInt2)]);
                        }
                        j += paramInt3;
                        i++;
                      }
                    }
                    return k;
                  }
                  public dswap(paramInt1: number, paramArrayOfDouble1: Float64Array, paramInt2: number, paramInt3: number, paramArrayOfDouble2: Float64Array, paramInt4: number, paramInt5: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    if ((paramInt1 <= 0)) {
                      return;
                    }
                    var i1: number;
                    if (((paramInt5 == 1) ? 1 : 0) != 0) {
                      m = paramInt1 % 3;
                      if ((m != 0)) {
                        i = 1;
                        for (i1 = m; i1 > 0; i1--) {
                          d = paramArrayOfDouble1[(i - 1 + paramInt2)];
                          paramArrayOfDouble1[(i - 1 + paramInt2)] = paramArrayOfDouble2[(i - 1 + paramInt4)];
                          paramArrayOfDouble2[(i - 1 + paramInt4)] = d;
                          i++;
                        }
                        if ((paramInt1 < 3)) {
                          return;
                        }
                      }
                      n = m + 1;
                      i = n;
                      for (i1 = this.floorDiv((paramInt1 - n + 3), 3); i1 > 0; i1--) {
                        d = paramArrayOfDouble1[(i - 1 + paramInt2)];
                        paramArrayOfDouble1[(i - 1 + paramInt2)] = paramArrayOfDouble2[(i - 1 + paramInt4)];
                        paramArrayOfDouble2[(i - 1 + paramInt4)] = d;
                        d = paramArrayOfDouble1[(i + paramInt2)];
                        paramArrayOfDouble1[(i + paramInt2)] = paramArrayOfDouble2[(i + paramInt4)];
                        paramArrayOfDouble2[(i + paramInt4)] = d;
                        d = paramArrayOfDouble1[(i + 1 + paramInt2)];
                        paramArrayOfDouble1[(i + 1 + paramInt2)] = paramArrayOfDouble2[(i + 1 + paramInt4)];
                        paramArrayOfDouble2[(i + 1 + paramInt4)] = d;
                        i += 3;
                      }
                    } else {
                      j = 1;
                      k = 1;
                      if ((paramInt3 < 0)) {
                        j = (-paramInt1 + 1) * paramInt3 + 1;
                      }
                      if ((paramInt5 < 0)) {
                        k = (-paramInt1 + 1) * paramInt5 + 1;
                      }
                      i = 1;
                      for (i1 = paramInt1; i1 > 0; i1--) {
                        d = paramArrayOfDouble1[(j - 1 + paramInt2)];
                        paramArrayOfDouble1[(j - 1 + paramInt2)] = paramArrayOfDouble2[(k - 1 + paramInt4)];
                        paramArrayOfDouble2[(k - 1 + paramInt4)] = d;
                        j += paramInt3;
                        k += paramInt5;
                        i++;
                      }
                    }
                  }
                  public dscal(paramInt1: number, paramDouble: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number;
                    if ((paramInt3 == 1)) {
                      j = paramInt1 % 5;
                      if ((j != 0)) {
                        i = 1;
                        for (n = j; n > 0; n--) {
                          paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                          i++;
                        }
                        if ((paramInt1 < 5)) {
                          return;
                        }
                      }
                      k = j + 1;
                      i = k;
                      for (n = this.floorDiv((paramInt1 - k + 5), 5); n > 0; n--) {
                        paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                        paramArrayOfDouble[(i + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + paramInt2)]);
                        paramArrayOfDouble[(i + 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 1 + paramInt2)]);
                        paramArrayOfDouble[(i + 2 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 2 + paramInt2)]);
                        paramArrayOfDouble[(i + 3 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i + 3 + paramInt2)]);
                        i += 5;
                      }
                    } else {
                      m = paramInt1 * paramInt3;
                      i = 1;
                      for (n = this.floorDiv((m - 1 + paramInt3), paramInt3); n > 0; n--) {
                        paramArrayOfDouble[(i - 1 + paramInt2)] = (paramDouble * paramArrayOfDouble[(i - 1 + paramInt2)]);
                        i += paramInt3;
                      }
                    }
                  }
                  public dgetf2(paramInt1: number, paramInt2: number, paramArrayOfDouble: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfInt: Int32Array, paramInt5: number, info: Int32Array): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    info[0] = 0;
                    if ((paramInt1 < 0)) {
                      info[0] = -1;
                    } else {
                      if ((paramInt2 < 0)) {
                        info[0] = -2;
                      } else {
                        if ((paramInt4 < Math.max(1, paramInt1))) {
                          info[0] = -4;
                        }
                      }
                    }
                    if ((info[0] != 0)) {
                      return;
                    }
                    if (((paramInt2 == 0))) {
                      return;
                    }
                    d = org.kevoree.modeling.util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                    j = 1;
                    for (var m: number = Math.min(paramInt1, paramInt2); m > 0; m--) {
                      k = j - 1 + this.idamax(paramInt1 - j + 1, paramArrayOfDouble, j - 1 + (j - 1) * paramInt4 + paramInt3, 1);
                      paramArrayOfInt[(j - 1 + paramInt5)] = k;
                      if ((paramArrayOfDouble[(k - 1 + (j - 1) * paramInt4 + paramInt3)] != 0.0)) {
                        if ((k != j)) {
                          this.dswap(paramInt2, paramArrayOfDouble, j - 1 + paramInt3, paramInt4, paramArrayOfDouble, k - 1 + paramInt3, paramInt4);
                        }
                        if ((j < paramInt1)) {
                          if ((Math.abs(paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)]) >= d)) {
                            this.dscal(paramInt1 - j, 1.0 / paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)], paramArrayOfDouble, j + (j - 1) * paramInt4 + paramInt3, 1);
                          } else {
                            i = 1;
                            for (var n: number = paramInt1 - j; n > 0; n--) {
                              paramArrayOfDouble[(j + i - 1 + (j - 1) * paramInt4 + paramInt3)] /= paramArrayOfDouble[(j - 1 + (j - 1) * paramInt4 + paramInt3)];
                              i++;
                            }
                          }
                        }
                      } else {
                        if ((info[0] == 0)) {
                          info[0] = j;
                        }
                      }
                      if ((j < Math.min(paramInt1, paramInt2))) {
                        this.dger(paramInt1 - j, paramInt2 - j, -1.0, paramArrayOfDouble, j + (j - 1) * paramInt4 + paramInt3, 1, paramArrayOfDouble, j - 1 + (j) * paramInt4 + paramInt3, paramInt4, paramArrayOfDouble, j + (j) * paramInt4 + paramInt3, paramInt4);
                      }
                      j++;
                    }
                  }
                  public dlaswp(paramInt1: number, paramArrayOfDouble: Float64Array, paramInt2: number, paramInt3: number, paramInt4: number, paramInt5: number, paramArrayOfInt: Int32Array, paramInt6: number, paramInt7: number): void {
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var i1: number = 0;
                    var i2: number = 0;
                    var i3: number = 0;
                    var i4: number = 0;
                    var i5: number = 0;
                    var d: number = 0.0;
                    if ((paramInt7 > 0)) {
                      i2 = paramInt4;
                      j = paramInt4;
                      k = paramInt5;
                      m = 1;
                    } else {
                      if ((paramInt7 < 0)) {
                        i2 = 1 + (1 - paramInt5) * paramInt7;
                        j = paramInt5;
                        k = paramInt4;
                        m = -1;
                      } else {
                        return;
                      }
                    }
                    i5 = this.floorDiv(paramInt1, 32) * 32;
                    var i6: number;
                    var i7: number;
                    if ((i5 != 0)) {
                      i3 = 1;
                      for (i6 = this.floorDiv((i5 - 1 + 32), 32); i6 > 0; i6--) {
                        i1 = i2;
                        i = j;
                        for (i7 = this.floorDiv((k - j + m), m); i7 > 0; i7--) {
                          n = paramArrayOfInt[(i1 - 1 + paramInt6)];
                          if ((n != i)) {
                            i4 = i3;
                            for (var i8: number = i3 + 31 - i3 + 1; i8 > 0; i8--) {
                              d = paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                              paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)] = paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                              paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)] = d;
                              i4++;
                            }
                          }
                          i1 += paramInt7;
                          i += m;
                        }
                        i3 += 32;
                      }
                    }
                    if ((i5 != paramInt1)) {
                      i5++;
                      i1 = i2;
                      i = j;
                      for (i6 = this.floorDiv((k - j + m), m); i6 > 0; i6--) {
                        n = paramArrayOfInt[(i1 - 1 + paramInt6)];
                        if ((n != i)) {
                          i4 = i5;
                          for (i7 = paramInt1 - i5 + 1; i7 > 0; i7--) {
                            d = paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                            paramArrayOfDouble[(i - 1 + (i4 - 1) * paramInt3 + paramInt2)] = paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)];
                            paramArrayOfDouble[(n - 1 + (i4 - 1) * paramInt3 + paramInt2)] = d;
                            i4++;
                          }
                        }
                        i1 += paramInt7;
                        i += m;
                      }
                    }
                  }
                  public dtrsm(paramString1: org.kevoree.modeling.util.maths.structure.blas.KBlasSideType, paramString2: org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType, paramString3: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, paramString4: org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType, paramInt1: number, paramInt2: number, paramDouble: number, paramArrayOfDouble1: Float64Array, paramInt3: number, paramInt4: number, paramArrayOfDouble2: Float64Array, paramInt5: number, paramInt6: number): void {
                    var d: number = 0.0;
                    var i: number = 0;
                    var j: number = 0;
                    var k: number = 0;
                    var m: number = 0;
                    var n: number = 0;
                    var bool1: boolean = false;
                    var bool2: boolean = false;
                    var bool3: boolean = false;
                    bool1 = paramString1.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasSideType.LEFT);
                    if (bool1) {
                      n = paramInt1;
                    } else {
                      n = paramInt2;
                    }
                    bool2 = paramString4.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasUnitType.NONUNIT);
                    bool3 = paramString2.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasOrientationType.UPPER);
                    var i1: number;
                    var i2: number;
                    if ((paramDouble == 0)) {
                      k = 1;
                      for (i1 = paramInt2; i1 > 0; i1--) {
                        i = 1;
                        for (i2 = paramInt1; i2 > 0; i2--) {
                          paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = 0.0;
                          i++;
                        }
                        k++;
                      }
                      return;
                    }
                    var i3: number;
                    if (bool1) {
                      if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        if (bool3) {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m = paramInt1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                if (bool2) {
                                  paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] /= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                }
                                i = 1;
                                for (i3 = m - 1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                  i++;
                                }
                              }
                              m += -1;
                            }
                            k++;
                          }
                        } else {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] != 0.0)) {
                                if (bool2) {
                                  paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] /= paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                                }
                                i = m + 1;
                                for (i3 = paramInt1 - (m + 1) + 1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)] * paramArrayOfDouble1[(i - 1 + (m - 1) * paramInt4 + paramInt3)];
                                  i++;
                                }
                              }
                              m++;
                            }
                            k++;
                          }
                        }
                      } else {
                        if (bool3) {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            i = 1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              d = paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                              m = 1;
                              for (i3 = i - 1; i3 > 0; i3--) {
                                d -= paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                m++;
                              }
                              if (bool2) {
                                d /= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                              }
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                              i++;
                            }
                            k++;
                          }
                        } else {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            i = paramInt1;
                            for (i2 = paramInt1; i2 > 0; i2--) {
                              d = paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)];
                              m = i + 1;
                              for (i3 = paramInt1 - i; i3 > 0; i3--) {
                                d -= paramArrayOfDouble1[(m - 1 + (i - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(m - 1 + (k - 1) * paramInt6 + paramInt5)];
                                m++;
                              }
                              if (bool2) {
                                d /= paramArrayOfDouble1[(i - 1 + (i - 1) * paramInt4 + paramInt3)];
                              }
                              paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = d;
                              i += -1;
                            }
                            k++;
                          }
                        }
                      }
                    } else {
                      if (paramString3.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        if (bool3) {
                          k = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m = 1;
                            for (i2 = k - 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              m++;
                            }
                            if (bool2) {
                              d = 1.0 / paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            k++;
                          }
                        } else {
                          k = paramInt2;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m = k + 1;
                            for (i2 = paramInt2 - (k + 1) + 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= paramArrayOfDouble1[(m - 1 + (k - 1) * paramInt4 + paramInt3)] * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              m++;
                            }
                            if (bool2) {
                              d = 1.0 / paramArrayOfDouble1[(k - 1 + (k - 1) * paramInt4 + paramInt3)];
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            k += -1;
                          }
                        }
                      } else {
                        if (bool3) {
                          m = paramInt2;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if (bool2) {
                              d = 1.0 / paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            k = 1;
                            for (i2 = m - 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              k++;
                            }
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m += -1;
                          }
                        } else {
                          m = 1;
                          for (i1 = paramInt2; i1 > 0; i1--) {
                            if (bool2) {
                              d = 1.0 / paramArrayOfDouble1[(m - 1 + (m - 1) * paramInt4 + paramInt3)];
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            k = m + 1;
                            for (i2 = paramInt2 - (m + 1) + 1; i2 > 0; i2--) {
                              if ((paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)] != 0.0)) {
                                d = paramArrayOfDouble1[(k - 1 + (m - 1) * paramInt4 + paramInt3)];
                                i = 1;
                                for (i3 = paramInt1; i3 > 0; i3--) {
                                  paramArrayOfDouble2[(i - 1 + (k - 1) * paramInt6 + paramInt5)] -= d * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)];
                                  i++;
                                }
                              }
                              k++;
                            }
                            if ((paramDouble != 1.0)) {
                              i = 1;
                              for (i2 = paramInt1; i2 > 0; i2--) {
                                paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)] = (paramDouble * paramArrayOfDouble2[(i - 1 + (m - 1) * paramInt6 + paramInt5)]);
                                i++;
                              }
                            }
                            m++;
                          }
                        }
                      }
                    }
                  }
                  private floorDiv(x: number, y: number): number {
                     return Math.floor(x/y);
                  }
                }
              }
              export class KBlasDirectionType {
                public static FORWARD: KBlasDirectionType = new KBlasDirectionType();
                public static BACKWARD: KBlasDirectionType = new KBlasDirectionType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasDirectionTypeVALUES : KBlasDirectionType[] = [
                  KBlasDirectionType.FORWARD
                  ,KBlasDirectionType.BACKWARD
                ];
                public static values():KBlasDirectionType[]{
                  return KBlasDirectionType._KBlasDirectionTypeVALUES;
                }
              }
              export class KBlasSideType {
                public static LEFT: KBlasSideType = new KBlasSideType();
                public static RIGHT: KBlasSideType = new KBlasSideType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasSideTypeVALUES : KBlasSideType[] = [
                  KBlasSideType.LEFT
                  ,KBlasSideType.RIGHT
                ];
                public static values():KBlasSideType[]{
                  return KBlasSideType._KBlasSideTypeVALUES;
                }
              }
              export class KBlasTransposeType {
                public static NOTRANSPOSE: KBlasTransposeType = new KBlasTransposeType();
                public static TRANSPOSE: KBlasTransposeType = new KBlasTransposeType();
                public static CONJUGATE: KBlasTransposeType = new KBlasTransposeType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasTransposeTypeVALUES : KBlasTransposeType[] = [
                  KBlasTransposeType.NOTRANSPOSE
                  ,KBlasTransposeType.TRANSPOSE
                  ,KBlasTransposeType.CONJUGATE
                ];
                public static values():KBlasTransposeType[]{
                  return KBlasTransposeType._KBlasTransposeTypeVALUES;
                }
              }
              export class KBlasMajorType {
                public static COLUMNWISE: KBlasMajorType = new KBlasMajorType();
                public static ROWWISE: KBlasMajorType = new KBlasMajorType();
                public equals(other: any): boolean {
                  return this == other;
                }
                public static _KBlasMajorTypeVALUES : KBlasMajorType[] = [
                  KBlasMajorType.COLUMNWISE
                  ,KBlasMajorType.ROWWISE
                ];
                public static values():KBlasMajorType[]{
                  return KBlasMajorType._KBlasMajorTypeVALUES;
                }
              }
            }
            export interface KArray1D {
              size(): number;
              get(index: number): number;
              set(index: number, value: number): number;
              add(index: number, value: number): number;
              addAll(value: number): void;
              setAll(value: number): void;
              addElement(index: number, numElem: number): void;
              clone(): org.kevoree.modeling.util.maths.structure.KArray1D;
              data(): Float64Array;
              setData(data: Float64Array): void;
            }
            export namespace impl {
              export class Array1D implements org.kevoree.modeling.util.maths.structure.KArray1D {
                private _size: number;
                private _offset: number;
                private _segmentIndex: number;
                private _segment: org.kevoree.modeling.memory.chunk.KObjectChunk;
                private _metaClass: org.kevoree.modeling.meta.KMetaClass;
                constructor(p_size: number, p_offset: number, p_segmentIndex: number, p_segment: org.kevoree.modeling.memory.chunk.KObjectChunk, p_metaClass: org.kevoree.modeling.meta.KMetaClass) {
                  this._size = p_size;
                  this._offset = p_offset;
                  this._segmentIndex = p_segmentIndex;
                  this._segment = p_segment;
                  this._metaClass = p_metaClass;
                }
                public size(): number {
                  return this._size;
                }
                public get(p_index: number): number {
                  return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + p_index, this._metaClass);
                }
                public set(p_index: number, p_value: number): number {
                  this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + p_index, p_value, this._metaClass);
                  return p_value;
                }
                public add(index: number, value: number): number {
                  return this.set(index, this.get(index) + value);
                }
                public addAll(value: number): void {
                  for (var i: number = 0; i < this._size; i++) {
                    this.add(i, value);
                  }
                }
                public setAll(value: number): void {}
                public addElement(index: number, numElem: number): void {}
                public clone(): org.kevoree.modeling.util.maths.structure.KArray1D {
                  return null;
                }
                public data(): Float64Array {
                  return this._segment.getDoubleArray(this._segmentIndex, this._metaClass);
                }
                public setData(data: Float64Array): void {}
              }
              export class NativeArray2D implements org.kevoree.modeling.util.maths.structure.KArray2D {
                private _nbRows: number;
                private _nbColumns: number;
                private _back: Float64Array;
                constructor(p_nbRows: number, p_nbColumns: number) {
                  this._nbRows = p_nbRows;
                  this._nbColumns = p_nbColumns;
                  this._back = new Float64Array(p_nbRows * p_nbColumns);
                }
                private getIndex(p_rowIndex: number, p_columnIndex: number): number {
                  return p_rowIndex + (this._nbRows * p_columnIndex);
                }
                public rows(): number {
                  return this._nbRows;
                }
                public columns(): number {
                  return this._nbColumns;
                }
                public get(p_rowIndex: number, p_columnIndex: number): number {
                  return this._back[this.getIndex(p_rowIndex, p_columnIndex)];
                }
                public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                  this._back[this.getIndex(p_rowIndex, p_columnIndex)] = value;
                  return value;
                }
                public add(rowIndex: number, columnIndex: number, value: number): number {
                  return this.set(rowIndex, columnIndex, this.get(rowIndex, columnIndex) + value);
                }
                public setAll(value: number): void {}
                public addRow(rowindex: number, numRow: number): void {}
                public addCol(colIndex: number, numCol: number): void {}
                public clone(): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var newArr: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(this._nbRows, this._nbColumns);
                  java.lang.System.arraycopy(this._back, 0, newArr._back, 0, this._nbColumns * this._nbRows);
                  return newArr;
                }
                public data(): Float64Array {
                  return this._back;
                }
                public setData(data: Float64Array): void {
                  this._back = data;
                }
                public getAtIndex(index: number): number {
                  return this._back[index];
                }
                public setAtIndex(index: number, value: number): number {
                  this._back[index] = value;
                  return value;
                }
                public addAtIndex(index: number, value: number): number {
                  this._back[index] += value;
                  return this._back[index];
                }
              }
              export class Array2D implements org.kevoree.modeling.util.maths.structure.KArray2D {
                private _nbRows: number;
                private _nbColumns: number;
                private _offset: number;
                private _segmentIndex: number;
                private _segment: org.kevoree.modeling.memory.chunk.KObjectChunk;
                private _metaClass: org.kevoree.modeling.meta.KMetaClass;
                constructor(p_nbRows: number, p_nbColumns: number, p_offset: number, p_segmentIndex: number, p_segment: org.kevoree.modeling.memory.chunk.KObjectChunk, p_metaClass: org.kevoree.modeling.meta.KMetaClass) {
                  this._nbRows = p_nbRows;
                  this._nbColumns = p_nbColumns;
                  this._offset = p_offset;
                  this._segment = p_segment;
                  this._segmentIndex = p_segmentIndex;
                  this._metaClass = p_metaClass;
                }
                public rows(): number {
                  return this._nbRows;
                }
                public columns(): number {
                  return this._nbColumns;
                }
                private getIndex(p_rowIndex: number, p_columnIndex: number): number {
                  return this._offset + p_rowIndex + (this._nbRows * p_columnIndex);
                }
                public get(p_rowIndex: number, p_columnIndex: number): number {
                  return this._segment.getDoubleArrayElem(this._segmentIndex, this.getIndex(p_rowIndex, p_columnIndex), this._metaClass);
                }
                public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                  this._segment.setDoubleArrayElem(this._segmentIndex, this.getIndex(p_rowIndex, p_columnIndex), value, this._metaClass);
                  return value;
                }
                public add(rowIndex: number, columnIndex: number, value: number): number {
                  return this.set(rowIndex, columnIndex, this.get(rowIndex, columnIndex) + value);
                }
                public setAll(value: number): void {
                  for (var i: number = 0; i < this._nbColumns * this._nbRows; i++) {
                    this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + i, value, this._metaClass);
                  }
                }
                public addRow(rowindex: number, numRow: number): void {}
                public addCol(colIndex: number, numCol: number): void {}
                public clone(): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var cloned: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(this._nbRows, this._nbColumns);
                  cloned.setData(this.data());
                  return cloned;
                }
                public data(): Float64Array {
                  return this._segment.getDoubleArray(this._segmentIndex, this._metaClass);
                }
                public setData(p_data: Float64Array): void {
                  for (var i: number = 0; i < p_data.length; i++) {
                    this.setAtIndex(i, p_data[i]);
                  }
                }
                public getAtIndex(index: number): number {
                  return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + index, this._metaClass);
                }
                public setAtIndex(index: number, value: number): number {
                  this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + index, value, this._metaClass);
                  return value;
                }
                public addAtIndex(index: number, value: number): number {
                  return this.setAtIndex(index, this.getAtIndex(index) + value);
                }
              }
            }
            export interface KArray2D {
              rows(): number;
              columns(): number;
              get(rowIndex: number, columnIndex: number): number;
              set(rowIndex: number, columnIndex: number, value: number): number;
              add(rowIndex: number, columnIndex: number, value: number): number;
              setAll(value: number): void;
              addRow(rowindex: number, numRow: number): void;
              addCol(colIndex: number, numCol: number): void;
              getAtIndex(index: number): number;
              setAtIndex(index: number, value: number): number;
              addAtIndex(index: number, value: number): number;
              clone(): org.kevoree.modeling.util.maths.structure.KArray2D;
              data(): Float64Array;
              setData(data: Float64Array): void;
            }
            export namespace matrix {
              export class MatrixOperations {
                public static BLOCK_WIDTH: number = 60;
                public static TRANSPOSE_SWITCH: number = 375;
                public static leadingDimension(matA: org.kevoree.modeling.util.maths.structure.KArray2D): number {
                  return Math.max(matA.columns(), matA.rows());
                }
                public static multiply(matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var matC: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(matA.rows(), matB.columns());
                  blas.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matC.rows(), matC.columns(), matA.columns(), 1.0, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), 0.0, matC.data(), 0, matC.rows());
                  return matC;
                }
                public static multiplyTransposeAlpha(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, alpha: number, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                  if (org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.testDimensionsAB(transA, transB, matA, matB)) {
                    var k: number = 0;
                    var dimC: Int32Array = new Int32Array(2);
                    if (transA.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      k = matA.columns();
                      if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        dimC[0] = matA.rows();
                        dimC[1] = matB.columns();
                      } else {
                        dimC[0] = matA.rows();
                        dimC[1] = matB.rows();
                      }
                    } else {
                      k = matA.rows();
                      if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                        dimC[0] = matA.columns();
                        dimC[1] = matB.columns();
                      } else {
                        dimC[0] = matA.columns();
                        dimC[1] = matB.rows();
                      }
                    }
                    var matC: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(dimC[0], dimC[1]);
                    blas.dgemm(transA, transB, matC.rows(), matC.columns(), k, alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), 0, matC.data(), 0, matC.rows());
                    return matC;
                  } else {
                    throw new Error("Dimensions mismatch between A,B and C");
                  }
                }
                public static multiplyAlphaBetaResult(alpha: number, matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, beta: number, matC: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): void {
                  if (org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.testDimensionsABC(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matA, matB, matC)) {
                    blas.dgemm(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, matC.rows(), matC.columns(), matA.columns(), alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), beta, matC.data(), 0, matC.rows());
                  } else {
                    throw new Error("Dimensions mismatch between A,B and C");
                  }
                }
                public static multiplyTransposeAlphaBetaResult(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, alpha: number, matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, beta: number, matC: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): void {
                  if (org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.testDimensionsABC(transA, transB, matA, matB, matC)) {
                    var k: number;
                    if (transA.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      k = matA.columns();
                    } else {
                      k = matA.rows();
                    }
                    blas.dgemm(transA, transB, matC.rows(), matC.columns(), k, alpha, matA.data(), 0, matA.rows(), matB.data(), 0, matB.rows(), beta, matC.data(), 0, matC.rows());
                  } else {
                    throw new Error("Dimensions mismatch between A,B and C");
                  }
                }
                public static testDimensionsABC(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, matC: org.kevoree.modeling.util.maths.structure.KArray2D): boolean {
                  if (transA.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                    if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      return (matA.columns() == matB.rows() && matC.rows() == matA.rows() && matC.columns() == matB.columns());
                    } else {
                      return (matA.columns() == matB.columns() && matC.rows() == matA.rows() && matC.columns() == matB.rows());
                    }
                  } else {
                    if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      return (matA.rows() == matB.rows() && matC.rows() == matA.columns() && matC.columns() == matB.columns());
                    } else {
                      return (matA.rows() == matB.columns() && matC.rows() == matA.columns() && matC.columns() == matB.rows());
                    }
                  }
                }
                public static testDimensionsAB(transA: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D): boolean {
                  if (transA.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                    if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      return (matA.columns() == matB.rows());
                    } else {
                      return (matA.columns() == matB.columns());
                    }
                  } else {
                    if (transB.equals(org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE)) {
                      return (matA.rows() == matB.rows());
                    } else {
                      return (matA.rows() == matB.columns());
                    }
                  }
                }
                public static initMatrice(matA: org.kevoree.modeling.util.maths.structure.KArray2D, random: boolean): void {
                  var rand: java.util.Random = new java.util.Random();
                  var k: number = 0;
                  for (var j: number = 0; j < matA.columns(); j++) {
                    for (var i: number = 0; i < matA.rows(); i++) {
                      if (random) {
                        matA.set(i, j, rand.nextDouble() * 100 - 50);
                      } else {
                        matA.set(i, j, k);
                      }
                      k++;
                    }
                  }
                }
                public static random(rows: number, columns: number): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var res: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(rows, columns);
                  var rand: java.util.Random = new java.util.Random();
                  for (var i: number = 0; i < rows * columns; i++) {
                    res.setAtIndex(i, rand.nextDouble() * 100 - 50);
                  }
                  return res;
                }
                public static invert(mat: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                  if (mat.rows() != mat.columns()) {
                    return null;
                  }
                  var alg: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                  var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                  var A_temp: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                  java.lang.System.arraycopy(mat.data(), 0, A_temp.data(), 0, mat.columns() * mat.rows());
                  var dlu: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(A_temp.rows(), A_temp.columns());
                  if (dlu.invert(A_temp, blas)) {
                    result.setData(A_temp.data());
                    return result;
                  } else {
                    return null;
                  }
                }
                public static invertInPlace(mat: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): boolean {
                  if (mat.rows() != mat.columns()) {
                    return false;
                  }
                  var alg: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                  var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(mat.rows(), mat.columns());
                  var dlu: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(mat.rows(), mat.columns());
                  return dlu.invert(mat, blas);
                }
                public static scale(alpha: number, matA: org.kevoree.modeling.util.maths.structure.KArray2D): void {
                  if (alpha == 0) {
                    matA.setAll(0);
                    return;
                  }
                  for (var i: number = 0; i < matA.rows() * matA.columns(); i++) {
                    matA.setAtIndex(i, alpha * matA.getAtIndex(i));
                  }
                }
                public static transpose(matA: org.kevoree.modeling.util.maths.structure.KArray2D): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(matA.columns(), matA.rows());
                  if (matA.columns() == matA.rows()) {
                    org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.transposeSquare(matA, result);
                  } else {
                    if (matA.columns() > org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.TRANSPOSE_SWITCH && matA.rows() > org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.TRANSPOSE_SWITCH) {
                      org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.transposeBlock(matA, result);
                    } else {
                      org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.transposeStandard(matA, result);
                    }
                  }
                  return result;
                }
                private static transposeSquare(matA: org.kevoree.modeling.util.maths.structure.KArray2D, result: org.kevoree.modeling.util.maths.structure.KArray2D): void {
                  var index: number = 1;
                  var indexEnd: number = matA.columns();
                  for (var i: number = 0; i < matA.rows(); i++) {
                    var indexOther: number = (i + 1) * matA.columns() + i;
                    var n: number = i * (matA.columns() + 1);
                    result.setAtIndex(n, matA.getAtIndex(n));
                    for (; index < indexEnd; index++) {
                      result.setAtIndex(index, matA.getAtIndex(indexOther));
                      result.setAtIndex(indexOther, matA.getAtIndex(index));
                      indexOther += matA.columns();
                    }
                    index += i + 2;
                    indexEnd += matA.columns();
                  }
                }
                private static transposeStandard(matA: org.kevoree.modeling.util.maths.structure.KArray2D, result: org.kevoree.modeling.util.maths.structure.KArray2D): void {
                  var index: number = 0;
                  for (var i: number = 0; i < result.columns(); i++) {
                    var index2: number = i;
                    var end: number = index + result.rows();
                    while (index < end){
                      result.setAtIndex(index++, matA.getAtIndex(index2));
                      index2 += matA.rows();
                    }
                  }
                }
                private static transposeBlock(matA: org.kevoree.modeling.util.maths.structure.KArray2D, result: org.kevoree.modeling.util.maths.structure.KArray2D): void {
                  for (var j: number = 0; j < matA.columns(); j += org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.BLOCK_WIDTH) {
                    var blockWidth: number = Math.min(org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.BLOCK_WIDTH, matA.columns() - j);
                    var indexSrc: number = j * matA.rows();
                    var indexDst: number = j;
                    for (var i: number = 0; i < matA.rows(); i += org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.BLOCK_WIDTH) {
                      var blockHeight: number = Math.min(org.kevoree.modeling.util.maths.structure.matrix.MatrixOperations.BLOCK_WIDTH, matA.rows() - i);
                      var indexSrcEnd: number = indexSrc + blockHeight;
                      for (; indexSrc < indexSrcEnd; indexSrc++) {
                        var colSrc: number = indexSrc;
                        var colDst: number = indexDst;
                        var end: number = colDst + blockWidth;
                        for (; colDst < end; colDst++) {
                          result.setAtIndex(colDst, matA.getAtIndex(colSrc));
                          colSrc += matA.rows();
                        }
                        indexDst += result.rows();
                      }
                    }
                  }
                }
                public static createIdentity(width: number): org.kevoree.modeling.util.maths.structure.KArray2D {
                  var ret: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(width, width);
                  ret.setAll(0);
                  for (var i: number = 0; i < width; i++) {
                    ret.set(i, i, 1);
                  }
                  return ret;
                }
                public static solve(matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D, workInPlace: boolean, transB: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                  if (!workInPlace) {
                    var A_temp: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(matA.rows(), matA.columns());
                    java.lang.System.arraycopy(matA.data(), 0, A_temp.data(), 0, matA.columns() * matA.rows());
                    var dlu: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(A_temp.rows(), A_temp.columns());
                    dlu.factor(A_temp, blas);
                    if (dlu.isSingular()) {
                      return null;
                    }
                    var B_temp: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(matB.rows(), matB.columns());
                    java.lang.System.arraycopy(matB.data(), 0, B_temp.data(), 0, matB.columns() * matB.rows());
                    dlu.transSolve(B_temp, transB, blas);
                    return B_temp;
                  } else {
                    var dlu: org.kevoree.modeling.util.maths.structure.matrix.solver.LU = new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(matA.rows(), matA.columns());
                    dlu.factor(matA, blas);
                    if (dlu.isSingular()) {
                      return null;
                    }
                    dlu.transSolve(matB, transB, blas);
                    return matB;
                  }
                }
                public static compareMatrix(matA: org.kevoree.modeling.util.maths.structure.KArray2D, matB: org.kevoree.modeling.util.maths.structure.KArray2D): number {
                  var err: number = 0;
                  for (var i: number = 0; i < matA.rows(); i++) {
                    for (var j: number = 0; j < matA.columns(); j++) {
                      if (err < Math.abs(matA.get(i, j) - matB.get(i, j))) {
                        err = Math.abs(matA.get(i, j) - matB.get(i, j));
                      }
                    }
                  }
                  return err;
                }
              }
              export namespace solver {
                export class QR {
                  private Q: org.kevoree.modeling.util.maths.structure.KArray2D;
                  private R: org.kevoree.modeling.util.maths.structure.KArray2D;
                  public m: number;
                  public n: number;
                  public k: number;
                  public work: Float64Array;
                  public workGen: Float64Array;
                  public tau: Float64Array;
                  constructor(rows: number, columns: number) {
                    if (columns > rows) {
                      throw new Error("n > m");
                    }
                    this.m = rows;
                    this.n = columns;
                    this.k = Math.min(this.m, this.n);
                    this.tau = new Float64Array(this.k);
                    this.R = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(this.m, this.n);
                  }
                  public static factorize(A: org.kevoree.modeling.util.maths.structure.KArray2D, workInPlace: boolean, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.matrix.solver.QR {
                    return new org.kevoree.modeling.util.maths.structure.matrix.solver.QR(A.rows(), A.columns()).factor(A, workInPlace, blas);
                  }
                  public factor(matA: org.kevoree.modeling.util.maths.structure.KArray2D, workInPlace: boolean, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.matrix.solver.QR {
                    var A: org.kevoree.modeling.util.maths.structure.KArray2D;
                    if (!workInPlace) {
                      A = matA.clone();
                    } else {
                      A = matA;
                    }
                    var lwork: number;
                    this.work = new Float64Array(1);
                    var info: Int32Array = new Int32Array(1);
                    info[0] = 0;
                    blas.dgeqrf(this.m, this.n, new Float64Array(0), 0, this.m, new Float64Array(0), 0, this.work, 0, -1, info);
                    if (info[0] != 0) {
                      lwork = this.n;
                    } else {
                      lwork = <number>this.work[0];
                    }
                    lwork = Math.max(1, lwork);
                    this.work = new Float64Array(lwork);
                    this.workGen = new Float64Array(1);
                    var info: Int32Array = new Int32Array(1);
                    info[0] = 0;
                    blas.dorgqr(this.m, this.n, this.k, new Float64Array(0), 0, this.m, new Float64Array(0), 0, this.workGen, 0, -1, info);
                    if (info[0] != 0) {
                      lwork = this.n;
                    } else {
                      lwork = <number>this.workGen[0];
                    }
                    lwork = Math.max(1, lwork);
                    this.workGen = new Float64Array(lwork);
                    var info: Int32Array = new Int32Array(1);
                    info[0] = 0;
                    blas.dgeqrf(this.m, this.n, A.data(), 0, this.m, this.tau, 0, this.work, 0, this.work.length, info);
                    if (info[0] < 0) {
                      throw new Error("" + info[0]);
                    }
                    for (var col: number = 0; col < A.columns(); col++) {
                      for (var row: number = 0; row <= col; row++) {
                        this.R.set(row, col, A.get(row, col));
                      }
                    }
                    info[0] = 0;
                    blas.dorgqr(this.m, this.n, this.k, A.data(), 0, this.m, this.tau, 0, this.workGen, 0, this.workGen.length, info);
                    if (info[0] < 0) {
                      throw new Error();
                    }
                    this.Q = A;
                    return this;
                  }
                  public getR(): org.kevoree.modeling.util.maths.structure.KArray2D {
                    return this.R;
                  }
                  public getQ(): org.kevoree.modeling.util.maths.structure.KArray2D {
                    return this.Q;
                  }
                }
                export class LU {
                  private LU: org.kevoree.modeling.util.maths.structure.KArray2D;
                  private piv: Int32Array;
                  private singular: boolean;
                  public getLU(): org.kevoree.modeling.util.maths.structure.KArray2D {
                    return this.LU;
                  }
                  constructor(m: number, n: number) {
                    this.LU = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(m, n);
                    this.piv = new Int32Array(Math.min(m, n));
                  }
                  public static factorize(A: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.matrix.solver.LU {
                    return new org.kevoree.modeling.util.maths.structure.matrix.solver.LU(A.rows(), A.columns()).factor(A, blas);
                  }
                  public factor(A: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.matrix.solver.LU {
                    this.singular = false;
                    var info: Int32Array = new Int32Array(1);
                    info[0] = 0;
                    blas.dgetrf(A.rows(), A.columns(), A.data(), 0, A.rows(), this.piv, 0, info);
                    if (info[0] > 0) {
                      this.singular = true;
                    } else {
                      if (info[0] < 0) {
                        throw new Error();
                      }
                    }
                    this.LU.setData(A.data());
                    return this;
                  }
                  public getLower(): org.kevoree.modeling.util.maths.structure.KArray2D {
                    var numRows: number = this.LU.rows();
                    var numCols: number = this.LU.rows() < this.LU.columns() ? this.LU.rows() : this.LU.columns();
                    var lower: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(numRows, numCols);
                    for (var i: number = 0; i < numCols; i++) {
                      lower.set(i, i, 1.0);
                      for (var j: number = 0; j < i; j++) {
                        lower.set(i, j, this.LU.get(i, j));
                      }
                    }
                    if (numRows > numCols) {
                      for (var i: number = numCols; i < numRows; i++) {
                        for (var j: number = 0; j < numCols; j++) {
                          lower.set(i, j, this.LU.get(i, j));
                        }
                      }
                    }
                    return lower;
                  }
                  public getUpper(): org.kevoree.modeling.util.maths.structure.KArray2D {
                    var numRows: number = this.LU.rows() < this.LU.columns() ? this.LU.rows() : this.LU.columns();
                    var numCols: number = this.LU.columns();
                    var upper: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(numRows, numCols);
                    for (var i: number = 0; i < numRows; i++) {
                      for (var j: number = i; j < numCols; j++) {
                        upper.set(i, j, this.LU.get(i, j));
                      }
                    }
                    return upper;
                  }
                  public getPivots(): Int32Array {
                    return this.piv;
                  }
                  public isSingular(): boolean {
                    return this.singular;
                  }
                  public solve(B: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                    return this.transSolve(B, org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType.NOTRANSPOSE, blas);
                  }
                  public transSolve(B: org.kevoree.modeling.util.maths.structure.KArray2D, trans: org.kevoree.modeling.util.maths.structure.blas.KBlasTransposeType, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): org.kevoree.modeling.util.maths.structure.KArray2D {
                    if (B.rows() != this.LU.rows()) {
                      throw new Error("B.numRows() != LU.numRows()");
                    }
                    var info: Int32Array = new Int32Array(1);
                    blas.dgetrs(trans, this.LU.rows(), B.columns(), this.LU.data(), 0, this.LU.rows(), this.piv, 0, B.data(), 0, this.LU.rows(), info);
                    if (info[0] < 0) {
                      throw new Error();
                    }
                    return B;
                  }
                  public invert(A: org.kevoree.modeling.util.maths.structure.KArray2D, blas: org.kevoree.modeling.util.maths.structure.blas.KBlas): boolean {
                    var info: Int32Array = new Int32Array(1);
                    info[0] = 0;
                    blas.dgetrf(A.rows(), A.columns(), A.data(), 0, A.rows(), this.piv, 0, info);
                    if (info[0] > 0) {
                      this.singular = true;
                      return false;
                    } else {
                      if (info[0] < 0) {
                        throw new Error();
                      }
                    }
                    var lwork: number = A.rows() * A.rows();
                    var work: Float64Array = new Float64Array(lwork);
                    for (var i: number = 0; i < lwork; i++) {
                      work[i] = 0;
                    }
                    blas.dgetri(A.rows(), A.data(), 0, A.rows(), this.piv, 0, work, 0, lwork, info);
                    if (info[0] != 0) {
                      return false;
                    } else {
                      return true;
                    }
                  }
                }
              }
            }
          }
          export class Statistic {
            public static calcHistogram(data: Float64Array, dataratings: Float64Array, numBins: number): void {
              var result: Int32Array = new Int32Array(numBins);
              var max: number;
              var min: number;
              min = data[0];
              max = data[0];
              for (var i: number = 0; i < data.length; i++) {
                if (data[i] < min) {
                  min = data[i];
                }
                if (data[i] > max) {
                  max = data[i];
                }
              }
              var binSize: number = (max - min) / numBins;
              for (var i: number = 0; i < data.length; i++) {
                var bin: number = <number>((data[i] - min) / binSize);
                result[bin]++;
              }
            }
          }
          export class PolynomialFit {
            public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
            public coef: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
            public y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
            public solver: org.kevoree.modeling.util.maths.matrix.solvers.AdjLinearSolverQr;
            constructor(degree: number) {
              this.coef = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(degree + 1, 1);
              this.A = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, degree + 1);
              this.y = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
              this.solver = new org.kevoree.modeling.util.maths.matrix.solvers.AdjLinearSolverQr();
            }
            public getCoef(): Float64Array {
              return this.coef.data;
            }
            public fit(samplePoints: Float64Array, observations: Float64Array): void {
              this.y.reshapeBoolean(observations.length, 1, false);
              java.lang.System.arraycopy(observations, 0, this.y.data, 0, observations.length);
              this.A.reshapeBoolean(this.y.numRows, this.coef.numRows, false);
              for (var i: number = 0; i < observations.length; i++) {
                var obs: number = 1;
                for (var j: number = 0; j < this.coef.numRows; j++) {
                  this.A.cset(i, j, obs);
                  obs *= samplePoints[i];
                }
              }
              this.solver.setA(this.A);
              this.solver.solve(this.y, this.coef);
            }
            public static extrapolate(time: number, weights: Float64Array): number {
              var result: number = 0;
              var power: number = 1;
              for (var j: number = 0; j < weights.length; j++) {
                result += weights[j] * power;
                power = power * time;
              }
              return result;
            }
          }
          export namespace expression {
            export interface KMathExpressionEngine {
              parse(p_expression: string): org.kevoree.modeling.util.maths.expression.KMathExpressionEngine;
              setVarResolver(resolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver): void;
              eval(context: org.kevoree.modeling.KObject): number;
            }
            export interface KMathVariableResolver {
              resolve(potentialVarName: string): number;
            }
            export namespace impl {
              export class MathEntities {
                private static INSTANCE: org.kevoree.modeling.util.maths.expression.impl.MathEntities = null;
                public operators: org.kevoree.modeling.memory.chunk.KStringMap<org.kevoree.modeling.util.maths.expression.impl.MathOperation>;
                public functions: org.kevoree.modeling.memory.chunk.KStringMap<org.kevoree.modeling.util.maths.expression.impl.MathFunction>;
                public static getINSTANCE(): org.kevoree.modeling.util.maths.expression.impl.MathEntities {
                  if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.INSTANCE == null) {
                    org.kevoree.modeling.util.maths.expression.impl.MathEntities.INSTANCE = new org.kevoree.modeling.util.maths.expression.impl.MathEntities();
                  }
                  return org.kevoree.modeling.util.maths.expression.impl.MathEntities.INSTANCE;
                }
                constructor() {
                  this.operators = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.util.maths.expression.impl.MathOperation>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                  this.operators.put("+", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("+", 20, true));
                  this.operators.put("-", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("-", 20, true));
                  this.operators.put("*", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("*", 30, true));
                  this.operators.put("/", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("/", 30, true));
                  this.operators.put("%", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("%", 30, true));
                  this.operators.put("^", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("^", 40, false));
                  this.operators.put("&&", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("&&", 4, false));
                  this.operators.put("||", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("||", 2, false));
                  this.operators.put(">", new org.kevoree.modeling.util.maths.expression.impl.MathOperation(">", 10, false));
                  this.operators.put(">=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation(">=", 10, false));
                  this.operators.put("<", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("<", 10, false));
                  this.operators.put("<=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("<=", 10, false));
                  this.operators.put("==", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("==", 7, false));
                  this.operators.put("!=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("!=", 7, false));
                  this.functions = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<org.kevoree.modeling.util.maths.expression.impl.MathFunction>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                  this.functions.put("NOT", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("NOT", 1));
                  this.functions.put("IF", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("IF", 3));
                  this.functions.put("RAND", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("RAND", 0));
                  this.functions.put("SIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SIN", 1));
                  this.functions.put("COS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("COS", 1));
                  this.functions.put("TAN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("TAN", 1));
                  this.functions.put("ASIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ASIN", 1));
                  this.functions.put("ACOS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ACOS", 1));
                  this.functions.put("ATAN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ATAN", 1));
                  this.functions.put("MAX", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MAX", 2));
                  this.functions.put("MIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MIN", 2));
                  this.functions.put("ABS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ABS", 1));
                  this.functions.put("LOG", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("LOG", 1));
                  this.functions.put("ROUND", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ROUND", 2));
                  this.functions.put("FLOOR", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("FLOOR", 1));
                  this.functions.put("CEILING", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("CEILING", 1));
                  this.functions.put("SQRT", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SQRT", 1));
                  this.functions.put("SECONDS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SECONDS", 1));
                  this.functions.put("MINUTES", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MINUTES", 1));
                  this.functions.put("HOURS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("HOURS", 1));
                  this.functions.put("DAY", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("DAY", 1));
                  this.functions.put("MONTH", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MONTH", 1));
                  this.functions.put("YEAR", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("YEAR", 1));
                  this.functions.put("DAYOFWEEK", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("DAYOFWEEK", 1));
                }
              }
              export class MathExpressionEngine implements org.kevoree.modeling.util.maths.expression.KMathExpressionEngine {
                private varResolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver;
                public static decimalSeparator: string = '.';
                public static minusSign: string = '-';
                private _cacheAST: org.kevoree.modeling.util.maths.expression.impl.MathToken[] = null;
                constructor() {
                  var vars: java.util.HashMap<string, number> = new java.util.HashMap<string, number>();
                  vars.put("PI", Math.PI);
                  vars.put("TRUE", 1.0);
                  vars.put("FALSE", 0.0);
                  this.varResolver = {
                    resolve: function (potentialVarName: string) {
                      return vars.get(potentialVarName);
                    }
                  };
                }
                public static isNumber(st: string): boolean {
                   return !isNaN(+st);
                }
                public static isDigit(c: string): boolean {
                   var cc = c.charCodeAt(0);
                   if ( cc >= 0x30 && cc <= 0x39 ){
                   return true ;
                   }
                   return false ;
                }
                public static isLetter(c: string): boolean {
                   var cc = c.charCodeAt(0);
                   if ( ( cc >= 0x41 && cc <= 0x5A ) || ( cc >= 0x61 && cc <= 0x7A ) ){
                   return true ;
                   }
                   return false ;
                }
                public static isWhitespace(c: string): boolean {
                   var cc = c.charCodeAt(0);
                   if ( ( cc >= 0x0009 && cc <= 0x000D ) || ( cc == 0x0020 ) || ( cc == 0x0085 ) || ( cc == 0x00A0 ) ){
                   return true ;
                   }
                   return false ;
                }
                private shuntingYard(expression: string): java.util.List<string> {
                  var outputQueue: java.util.List<string> = new java.util.ArrayList<string>();
                  var stack: java.util.Stack<string> = new java.util.Stack<string>();
                  var tokenizer: org.kevoree.modeling.util.maths.expression.impl.MathExpressionTokenizer = new org.kevoree.modeling.util.maths.expression.impl.MathExpressionTokenizer(expression);
                  var lastFunction: string = null;
                  var previousToken: string = null;
                  while (tokenizer.hasNext()){
                    var token: string = tokenizer.next();
                    if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                      stack.push(token);
                      lastFunction = token;
                    } else {
                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(",", token)) {
                        while (!stack.isEmpty() && !org.kevoree.modeling.util.PrimitiveHelper.equals("(", stack.peek())){
                          outputQueue.add(stack.pop());
                        }
                        if (stack.isEmpty()) {
                          throw new Error("Parse error for function '" + lastFunction + "'");
                        }
                      } else {
                        if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                          var o1: org.kevoree.modeling.util.maths.expression.impl.MathOperation = org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token);
                          var token2: string = stack.isEmpty() ? null : stack.peek();
                          while (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token2) && ((o1.isLeftAssoc() && o1.getPrecedence() <= org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()) || (o1.getPrecedence() < org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()))){
                            outputQueue.add(stack.pop());
                            token2 = stack.isEmpty() ? null : stack.peek();
                          }
                          stack.push(token);
                        } else {
                          if (org.kevoree.modeling.util.PrimitiveHelper.equals("(", token)) {
                            if (previousToken != null) {
                              if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isNumber(previousToken)) {
                                throw new Error("Missing operator at character position " + tokenizer.getPos());
                              }
                            }
                            stack.push(token);
                          } else {
                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(")", token)) {
                              while (!stack.isEmpty() && !org.kevoree.modeling.util.PrimitiveHelper.equals("(", stack.peek())){
                                outputQueue.add(stack.pop());
                              }
                              if (stack.isEmpty()) {
                                throw new Error("Mismatched parentheses");
                              }
                              stack.pop();
                              if (!stack.isEmpty() && org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(stack.peek().toUpperCase())) {
                                outputQueue.add(stack.pop());
                              }
                            } else {
                              outputQueue.add(token);
                            }
                          }
                        }
                      }
                    }
                    previousToken = token;
                  }
                  while (!stack.isEmpty()){
                    var element: string = stack.pop();
                    if (org.kevoree.modeling.util.PrimitiveHelper.equals("(", element) || org.kevoree.modeling.util.PrimitiveHelper.equals(")", element)) {
                      throw new Error("Mismatched parentheses");
                    }
                    outputQueue.add(element);
                  }
                  return outputQueue;
                }
                public eval(context: org.kevoree.modeling.KObject): number {
                  if (this._cacheAST == null) {
                    throw new Error("Call parse before");
                  }
                  var stack: java.util.Stack<number> = new java.util.Stack<number>();
                  for (var ii: number = 0; ii < this._cacheAST.length; ii++) {
                    var mathToken: org.kevoree.modeling.util.maths.expression.impl.MathToken = this._cacheAST[ii];
                    switch (mathToken.type()) {
                      case 0:
                      var v1: number = stack.pop();
                      var v2: number = stack.pop();
                      var castedOp: org.kevoree.modeling.util.maths.expression.impl.MathOperation = <org.kevoree.modeling.util.maths.expression.impl.MathOperation>mathToken;
                      stack.push(castedOp.eval(v2, v1));
                      break;
                      case 1:
                      var castedFunction: org.kevoree.modeling.util.maths.expression.impl.MathFunction = <org.kevoree.modeling.util.maths.expression.impl.MathFunction>mathToken;
                      var p: Float64Array = new Float64Array(castedFunction.getNumParams());
                      for (var i: number = castedFunction.getNumParams() - 1; i >= 0; i--) {
                        p[i] = stack.pop();
                      }
                      stack.push(castedFunction.eval(p));
                      break;
                      case 2:
                      var castedDouble: org.kevoree.modeling.util.maths.expression.impl.MathDoubleToken = <org.kevoree.modeling.util.maths.expression.impl.MathDoubleToken>mathToken;
                      stack.push(castedDouble.content());
                      break;
                      case 3:
                      var castedFreeToken: org.kevoree.modeling.util.maths.expression.impl.MathFreeToken = <org.kevoree.modeling.util.maths.expression.impl.MathFreeToken>mathToken;
                      if (this.varResolver.resolve(castedFreeToken.content()) != null) {
                        stack.push(this.varResolver.resolve(castedFreeToken.content()));
                      } else {
                        if (context != null) {
                          if (org.kevoree.modeling.util.PrimitiveHelper.equals("TIME", castedFreeToken.content())) {
                            stack.push(<number>context.now());
                          } else {
                            var resolved: any = context.getByName(castedFreeToken.content());
                            if (resolved != null) {
                              if (resolved instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                                stack.push(<number>(<org.kevoree.modeling.meta.impl.MetaLiteral>resolved).index());
                              } else {
                                var valueString: string = resolved.toString();
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(valueString, "true")) {
                                  stack.push(1.0);
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(valueString, "false")) {
                                    stack.push(0.0);
                                  } else {
                                    try {
                                      stack.push(org.kevoree.modeling.util.PrimitiveHelper.parseDouble(resolved.toString()));
                                    } catch ($ex$) {
                                      if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                      } else {
                                        throw $ex$;
                                      }
                                    }
                                  }
                                }
                              }
                            } else {
                              throw new Error("Unknow variable for name " + castedFreeToken.content());
                            }
                          }
                        } else {
                          throw new Error("Unknow variable for name " + castedFreeToken.content());
                        }
                      }
                      break;
                    }
                  }
                  var result: number = stack.pop();
                  if (result == null) {
                    return 0;
                  } else {
                    return result;
                  }
                }
                public buildAST(rpn: java.util.List<string>): org.kevoree.modeling.util.maths.expression.impl.MathToken[] {
                  var result: org.kevoree.modeling.util.maths.expression.impl.MathToken[] = new Array<org.kevoree.modeling.util.maths.expression.impl.MathToken>(rpn.size());
                  for (var ii: number = 0; ii < rpn.size(); ii++) {
                    var token: string = rpn.get(ii);
                    if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                      result[ii] = org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token);
                    } else {
                      if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                        result[ii] = org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.get(token.toUpperCase());
                      } else {
                        if (token.length > 0 && org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(token.charAt(0))) {
                          result[ii] = new org.kevoree.modeling.util.maths.expression.impl.MathFreeToken(token);
                        } else {
                          try {
                            var parsed: number = org.kevoree.modeling.util.PrimitiveHelper.parseDouble(token);
                            result[ii] = new org.kevoree.modeling.util.maths.expression.impl.MathDoubleToken(parsed);
                          } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                              var e: Error = <Error>$ex$;
                              result[ii] = new org.kevoree.modeling.util.maths.expression.impl.MathFreeToken(token);
                            } else {
                              throw $ex$;
                            }
                          }
                        }
                      }
                    }
                  }
                  return result;
                }
                public parse(p_expression: string): org.kevoree.modeling.util.maths.expression.KMathExpressionEngine {
                  var rpn: java.util.List<string> = this.shuntingYard(p_expression);
                  this._cacheAST = this.buildAST(rpn);
                  return this;
                }
                public setVarResolver(p_resolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver): void {
                  this.varResolver = p_resolver;
                }
              }
              export class MathFreeToken implements org.kevoree.modeling.util.maths.expression.impl.MathToken {
                private _content: string;
                constructor(content: string) {
                  this._content = content;
                }
                public content(): string {
                  return this._content;
                }
                public type(): number {
                  return 3;
                }
                public type2(): number {
                  return 0;
                }
              }
              export class MathOperation implements org.kevoree.modeling.util.maths.expression.impl.MathToken {
                private oper: string;
                private precedence: number;
                private leftAssoc: boolean;
                constructor(oper: string, precedence: number, leftAssoc: boolean) {
                  this.oper = oper;
                  this.precedence = precedence;
                  this.leftAssoc = leftAssoc;
                }
                public getOper(): string {
                  return this.oper;
                }
                public getPrecedence(): number {
                  return this.precedence;
                }
                public isLeftAssoc(): boolean {
                  return this.leftAssoc;
                }
                public eval(v1: number, v2: number): number {
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "+")) {
                    return v1 + v2;
                  } else {
                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "-")) {
                      return v1 - v2;
                    } else {
                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "*")) {
                        return v1 * v2;
                      } else {
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "/")) {
                          return v1 / v2;
                        } else {
                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "%")) {
                            return v1 % v2;
                          } else {
                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "^")) {
                              return Math.pow(v1, v2);
                            } else {
                              if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "&&")) {
                                var b1: boolean = !(v1 == 0);
                                var b2: boolean = !(v2 == 0);
                                return b1 && b2 ? 1 : 0;
                              } else {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "||")) {
                                  var b1: boolean = !(v1 == 0);
                                  var b2: boolean = !(v2 == 0);
                                  return b1 || b2 ? 1 : 0;
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, ">")) {
                                    return v1 > v2 ? 1 : 0;
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, ">=")) {
                                      return v1 >= v2 ? 1 : 0;
                                    } else {
                                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "<")) {
                                        return v1 < v2 ? 1 : 0;
                                      } else {
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "<=")) {
                                          return v1 <= v2 ? 1 : 0;
                                        } else {
                                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "==")) {
                                            return v1 == v2 ? 1 : 0;
                                          } else {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "!=")) {
                                              return v1 != v2 ? 1 : 0;
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  return 0;
                }
                public type(): number {
                  return 0;
                }
                public type2(): number {
                  return 0;
                }
              }
              export interface MathToken {
                type(): number;
                type2(): number;
              }
              export class MathFunction implements org.kevoree.modeling.util.maths.expression.impl.MathToken {
                private name: string;
                private numParams: number;
                constructor(name: string, numParams: number) {
                  this.name = name.toUpperCase();
                  this.numParams = numParams;
                }
                public getName(): string {
                  return this.name;
                }
                public getNumParams(): number {
                  return this.numParams;
                }
                public eval(p: Float64Array): number {
                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "NOT")) {
                    return (p[0] == 0) ? 1 : 0;
                  } else {
                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "IF")) {
                      return !(p[0] == 0) ? p[1] : p[2];
                    } else {
                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "RAND")) {
                        return Math.random();
                      } else {
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SIN")) {
                          return Math.sin(p[0]);
                        } else {
                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "COS")) {
                            return Math.cos(p[0]);
                          } else {
                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "TAN")) {
                              return Math.tan(p[0]);
                            } else {
                              if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ASIN")) {
                                return Math.asin(p[0]);
                              } else {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ACOS")) {
                                  return Math.acos(p[0]);
                                } else {
                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ATAN")) {
                                    return Math.atan(p[0]);
                                  } else {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MAX")) {
                                      return p[0] > p[1] ? p[0] : p[1];
                                    } else {
                                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MIN")) {
                                        return p[0] < p[1] ? p[0] : p[1];
                                      } else {
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ABS")) {
                                          return Math.abs(p[0]);
                                        } else {
                                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "LOG")) {
                                            return Math.log(p[0]);
                                          } else {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ROUND")) {
                                              var factor: number = <number>Math.pow(10, p[1]);
                                              var value: number = p[0] * factor;
                                              var tmp: number = Math.round(value);
                                              return <number>tmp / factor;
                                            } else {
                                              if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "FLOOR")) {
                                                return Math.floor(p[0]);
                                              } else {
                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "CEILING")) {
                                                  return Math.ceil(p[0]);
                                                } else {
                                                  if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SQRT")) {
                                                    return Math.sqrt(p[0]);
                                                  } else {
                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SECONDS")) {
                                                      return this.date_to_seconds(p[0]);
                                                    } else {
                                                      if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MINUTES")) {
                                                        return this.date_to_minutes(p[0]);
                                                      } else {
                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "HOURS")) {
                                                          return this.date_to_hours(p[0]);
                                                        } else {
                                                          if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "DAY")) {
                                                            return this.date_to_days(p[0]);
                                                          } else {
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MONTH")) {
                                                              return this.date_to_months(p[0]);
                                                            } else {
                                                              if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "YEAR")) {
                                                                return this.date_to_year(p[0]);
                                                              } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "DAYOFWEEK")) {
                                                                  return this.date_to_dayofweek(p[0]);
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  return 0;
                }
                private date_to_seconds(value: number): number {
                   var date = new Date(value);
                   return date.getSeconds();
                }
                private date_to_minutes(value: number): number {
                   var date = new Date(value);
                   return date.getMinutes();
                }
                private date_to_hours(value: number): number {
                   var date = new Date(value);
                   return date.getHours();
                }
                private date_to_days(value: number): number {
                   var date = new Date(value);
                   return date.getDate();
                }
                private date_to_months(value: number): number {
                   var date = new Date(value);
                   return date.getMonth();
                }
                private date_to_year(value: number): number {
                   var date = new Date(value);
                   return date.getFullYear();
                }
                private date_to_dayofweek(value: number): number {
                   var date = new Date(value);
                   return date.getDay();
                }
                public type(): number {
                  return 1;
                }
                public type2(): number {
                  return 0;
                }
              }
              export class MathDoubleToken implements org.kevoree.modeling.util.maths.expression.impl.MathToken {
                private _content: number;
                public type(): number {
                  return 2;
                }
                constructor(_content: number) {
                  this._content = _content;
                }
                public content(): number {
                  return this._content;
                }
                public type2(): number {
                  return 0;
                }
              }
              export class MathExpressionTokenizer {
                private pos: number = 0;
                private input: string;
                private previousToken: string;
                constructor(input: string) {
                  this.input = input.trim();
                }
                public hasNext(): boolean {
                  return (this.pos < this.input.length);
                }
                private peekNextChar(): string {
                  if (this.pos < (this.input.length - 1)) {
                    return this.input.charAt(this.pos + 1);
                  } else {
                    return '\0';
                  }
                }
                public next(): string {
                  var token: java.lang.StringBuilder = new java.lang.StringBuilder();
                  if (this.pos >= this.input.length) {
                    return this.previousToken = null;
                  }
                  var ch: string = this.input.charAt(this.pos);
                  while (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && this.pos < this.input.length){
                    ch = this.input.charAt(++this.pos);
                  }
                  if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch)) {
                    while ((org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.decimalSeparator) && (this.pos < this.input.length)){
                      token.append(this.input.charAt(this.pos++));
                      ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                    }
                  } else {
                    if (ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign && org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(this.peekNextChar()) && (org.kevoree.modeling.util.PrimitiveHelper.equals("(", this.previousToken) || org.kevoree.modeling.util.PrimitiveHelper.equals(",", this.previousToken) || this.previousToken == null || org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(this.previousToken))) {
                      token.append(org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign);
                      this.pos++;
                      token.append(this.next());
                    } else {
                      if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || (ch == '_')) {
                        while ((org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || (ch == '_')) && (this.pos < this.input.length)){
                          token.append(this.input.charAt(this.pos++));
                          ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                        }
                      } else {
                        if (ch == '(' || ch == ')' || ch == ',') {
                          token.append(ch);
                          this.pos++;
                        } else {
                          while (!org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) && !org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) && ch != '_' && !org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && ch != '(' && ch != ')' && ch != ',' && (this.pos < this.input.length)){
                            token.append(this.input.charAt(this.pos));
                            this.pos++;
                            ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                            if (ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign) {
                              break;
                            }
                          }
                          if (!org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token.toString())) {
                            throw new Error("Unknown operator '" + token + "' at position " + (this.pos - token.length + 1));
                          }
                        }
                      }
                    }
                  }
                  return this.previousToken = token.toString();
                }
                public getPos(): number {
                  return this.pos;
                }
              }
            }
          }
          export class StringDistance {
            public static levenshtein(s0: string, s1: string): number {
              var len0: number = s0.length + 1;
              var len1: number = s1.length + 1;
              var cost: Int32Array = new Int32Array(len0);
              var newcost: Int32Array = new Int32Array(len0);
              for (var i: number = 0; i < len0; i++) {
                cost[i] = i;
              }
              for (var j: number = 1; j < len1; j++) {
                newcost[0] = j;
                for (var i: number = 1; i < len0; i++) {
                  var match: number = (s0.charAt(i - 1) == s1.charAt(j - 1)) ? 0 : 1;
                  var cost_replace: number = cost[i - 1] + match;
                  var cost_insert: number = cost[i] + 1;
                  var cost_delete: number = newcost[i - 1] + 1;
                  newcost[i] = Math.min(Math.min(cost_insert, cost_delete), cost_replace);
                }
                var swap: Int32Array = cost;
                cost = newcost;
                newcost = swap;
              }
              return cost[len0 - 1];
            }
          }
          export class Distribution {
            public static inverseNormalCDF(q: number): number {
              var b: Float64Array = new Float64Array([1.570796288, 0.03706987906, -0.8364353589e-3, -0.2250947176e-3, 0.6841218299e-5, 0.5824238515e-5, -0.104527497e-5, 0.8360937017e-7, -0.3231081277e-8, 0.3657763036e-10, 0.6936233982e-12]);
              if (q < 0.0 || 1.0 < q || q == 0.5) {
                return 0.0;
              }
              var w1: number = q;
              if (q > 0.5) {
                w1 = 1.0 - q;
              }
              var w3: number = -Math.log(4.0 * w1 * (1.0 - w1));
              w1 = b[0];
              for (var i: number = 1; i < 11; i++) {
                w1 += b[i] * Math.pow(w3, i);
              }
              return q > 0.5 ? Math.sqrt(w1 * w3) : -Math.sqrt(w1 * w3);
            }
            public static gaussian(features: Float64Array, means: Float64Array, variances: Float64Array): number {
              var dim: number = features.length;
              var p: number = 1;
              for (var i: number = 0; i < dim; i++) {
                p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
              }
              return p;
            }
            public static gaussianArray(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, means: Float64Array, variances: Float64Array): number {
              var dim: number = features.columns();
              var p: number = 1;
              for (var i: number = 0; i < dim; i++) {
                p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features.get(row, i) - means[i]) * (features.get(row, i) - means[i])) / (2 * variances[i]));
              }
              return p;
            }
            public static parallelGaussian(features: Float64Array, means: Float64Array, variances: Float64Array): Float64Array {
              var dim: number = features.length;
              var p: Float64Array = new Float64Array(dim);
              for (var i: number = 0; i < dim; i++) {
                p[i] = (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
              }
              return p;
            }
            public static gaussianOneFeature(feature: number, mean: number, variance: number): number {
              return (1 / Math.sqrt(2 * Math.PI * variance)) * Math.exp(-((feature - mean) * (feature - mean)) / (2 * variance));
            }
          }
          export namespace matrix {
            export class ComplexMath64F {
              public static conj(input: org.kevoree.modeling.util.maths.matrix.Complex64F, conj: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                conj.real = input.real;
                conj.imaginary = -input.imaginary;
              }
              public static plus(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                result.real = a.real + b.real;
                result.imaginary = a.imaginary + b.imaginary;
              }
              public static minus(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                result.real = a.real - b.real;
                result.imaginary = a.imaginary - b.imaginary;
              }
              public static multiply(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                result.real = a.real * b.real - a.imaginary * b.imaginary;
                result.imaginary = a.real * b.imaginary + a.imaginary * b.real;
              }
              public static divide(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                var norm: number = b.getMagnitude2();
                result.real = (a.real * b.real + a.imaginary * b.imaginary) / norm;
                result.imaginary = (a.imaginary * b.real - a.real * b.imaginary) / norm;
              }
              public static root(a: org.kevoree.modeling.util.maths.matrix.Complex64F, N: number, k: number, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                var r: number = a.getMagnitude();
                var theta: number = Math.atan2(a.imaginary, a.real);
                r = Math.pow(r, 1.0 / N);
                theta = (theta + 2.0 * k * Math.PI) / N;
                result.real = r * Math.cos(theta);
                result.imaginary = r * Math.sin(theta);
              }
              public static sqrt(input: org.kevoree.modeling.util.maths.matrix.Complex64F, root: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                var r: number = input.getMagnitude();
                var a: number = input.real;
                root.real = Math.sqrt((r + a) / 2.0);
                root.imaginary = Math.sqrt((r - a) / 2.0);
                if (input.imaginary < 0) {
                  root.imaginary = -root.imaginary;
                }
              }
            }
            export namespace solvers {
              export class LUDecompositionAlt_D64 {
                public LU: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public maxWidth: number = -1;
                public m: number;
                public n: number;
                public dataLU: Float64Array;
                public vv: Float64Array;
                public indx: Int32Array;
                public pivot: Int32Array;
                public pivsign: number;
                public setExpectedMaxSize(numRows: number, numCols: number): void {
                  this.LU = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                  this.dataLU = this.LU.data;
                  this.maxWidth = Math.max(numRows, numCols);
                  this.vv = new Float64Array(this.maxWidth);
                  this.indx = new Int32Array(this.maxWidth);
                  this.pivot = new Int32Array(this.maxWidth);
                  for (var i: number = 0; i < this.maxWidth; i++) {
                    this.vv[i] = 0;
                    this.indx[i] = 0;
                    this.pivot[i] = 0;
                  }
                }
                public getLU(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  return this.LU;
                }
                public getIndx(): Int32Array {
                  return this.indx;
                }
                public getPivot(): Int32Array {
                  return this.pivot;
                }
                public getLower(lower: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  var numRows: number = this.LU.numRows;
                  var numCols: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                  if (lower == null) {
                    lower = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(lower, 0);
                  }
                  for (var i: number = 0; i < numCols; i++) {
                    lower.set(i, i, 1.0);
                    for (var j: number = 0; j < i; j++) {
                      lower.set(i, j, this.LU.get(i, j));
                    }
                  }
                  if (numRows > numCols) {
                    for (var i: number = numCols; i < numRows; i++) {
                      for (var j: number = 0; j < numCols; j++) {
                        lower.set(i, j, this.LU.get(i, j));
                      }
                    }
                  }
                  return lower;
                }
                public getUpper(upper: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  var numRows: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                  var numCols: number = this.LU.numCols;
                  if (upper == null) {
                    upper = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(upper, 0);
                  }
                  for (var i: number = 0; i < numRows; i++) {
                    for (var j: number = i; j < numCols; j++) {
                      upper.set(i, j, this.LU.get(i, j));
                    }
                  }
                  return upper;
                }
                public decomposeCommonInit(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  if (a.numRows > this.maxWidth || a.numCols > this.maxWidth) {
                    this.setExpectedMaxSize(a.numRows, a.numCols);
                  }
                  this.m = a.numRows;
                  this.n = a.numCols;
                  this.LU.setMatrix(a);
                  for (var i: number = 0; i < this.m; i++) {
                    this.pivot[i] = i;
                  }
                  this.pivsign = 1;
                }
                public _solveVectorInternal(vv: Float64Array): void {
                  var ii: number = 0;
                  for (var i: number = 0; i < this.n; i++) {
                    var ip: number = this.indx[i];
                    var sum: number = vv[ip];
                    vv[ip] = vv[i];
                    if (ii != 0) {
                      var index: number = i * this.n + ii - 1;
                      for (var j: number = ii - 1; j < i; j++) {
                        sum -= this.dataLU[index++] * vv[j];
                      }
                    } else {
                      if (sum != 0.0) {
                        ii = i + 1;
                      }
                    }
                    vv[i] = sum;
                  }
                  org.kevoree.modeling.util.maths.matrix.solvers.TriangularSolver.solveU2arr(this.dataLU, vv, this.n);
                }
                public _getVV(): Float64Array {
                  return this.vv;
                }
                public computeDeterminant(): number {
                  var ret: number = this.pivsign;
                  var total: number = this.m * this.n;
                  for (var i: number = 0; i < total; i += this.n + 1) {
                    ret *= this.dataLU[i];
                  }
                  return ret;
                }
                public decompose(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  this.decomposeCommonInit(a);
                  var LUcolj: Float64Array = this.vv;
                  for (var j: number = 0; j < this.n; j++) {
                    for (var i: number = 0; i < this.m; i++) {
                      LUcolj[i] = this.dataLU[i * this.n + j];
                    }
                    for (var i: number = 0; i < this.m; i++) {
                      var rowIndex: number = i * this.n;
                      var kmax: number = i < j ? i : j;
                      var s: number = 0.0;
                      for (var k: number = 0; k < kmax; k++) {
                        s += this.dataLU[rowIndex + k] * LUcolj[k];
                      }
                      this.dataLU[rowIndex + j] = LUcolj[i] -= s;
                    }
                    var p: number = j;
                    var max: number = Math.abs(LUcolj[p]);
                    for (var i: number = j + 1; i < this.m; i++) {
                      var v: number = Math.abs(LUcolj[i]);
                      if (v > max) {
                        p = i;
                        max = v;
                      }
                    }
                    if (p != j) {
                      var rowP: number = p * this.n;
                      var rowJ: number = j * this.n;
                      var endP: number = rowP + this.n;
                      for (rowP = p * this.n; rowP < endP; rowP++) {
                        var t: number = this.dataLU[rowP];
                        this.dataLU[rowP] = this.dataLU[rowJ];
                        this.dataLU[rowJ] = t;
                        rowJ++;
                      }
                      var k: number = this.pivot[p];
                      this.pivot[p] = this.pivot[j];
                      this.pivot[j] = k;
                      this.pivsign = -this.pivsign;
                    }
                    this.indx[j] = p;
                    if (j < this.m) {
                      var lujj: number = this.dataLU[j * this.n + j];
                      if (lujj != 0) {
                        for (var i: number = j + 1; i < this.m; i++) {
                          this.dataLU[i * this.n + j] /= lujj;
                        }
                      }
                    }
                  }
                  return true;
                }
              }
              export class SvdImplicitQrDecompose_D64 {
                private numRows: number;
                private numCols: number;
                private numRowsT: number;
                private numColsT: number;
                private canUseTallBidiagonal: boolean;
                private bidiag: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F>;
                private qralg: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm = new org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm();
                public diag: Float64Array;
                public off: Float64Array;
                private Ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                private Vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                private singularValues: Float64Array;
                private numSingular: number;
                private compact: boolean;
                private computeU: boolean;
                private computeV: boolean;
                private prefComputeU: boolean;
                private prefComputeV: boolean;
                private transposed: boolean;
                private A_mod: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                constructor(compact: boolean, computeU: boolean, computeV: boolean, canUseTallBidiagonal: boolean) {
                  this.compact = compact;
                  this.prefComputeU = computeU;
                  this.prefComputeV = computeV;
                  this.canUseTallBidiagonal = canUseTallBidiagonal;
                }
                public getSingularValues(): Float64Array {
                  return this.singularValues;
                }
                public numberOfSingularValues(): number {
                  return this.numSingular;
                }
                public isCompact(): boolean {
                  return this.compact;
                }
                public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  if (!this.prefComputeU) {
                    throw new Error("As requested U was not computed.");
                  }
                  if (transpose) {
                    if (U == null) {
                      return this.Ut;
                    } else {
                      if (U.numRows != this.Ut.numRows || U.numCols != this.Ut.numCols) {
                        throw new Error("Unexpected shape of U");
                      }
                    }
                    U.setMatrix(this.Ut);
                  } else {
                    if (U == null) {
                      U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.Ut.numCols, this.Ut.numRows);
                    } else {
                      if (U.numRows != this.Ut.numCols || U.numCols != this.Ut.numRows) {
                        throw new Error("Unexpected shape of U");
                      }
                    }
                    org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.Ut, U);
                  }
                  return U;
                }
                public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  if (!this.prefComputeV) {
                    throw new Error("As requested V was not computed.");
                  }
                  if (transpose) {
                    if (V == null) {
                      return this.Vt;
                    } else {
                      if (V.numRows != this.Vt.numRows || V.numCols != this.Vt.numCols) {
                        throw new Error("Unexpected shape of V");
                      }
                    }
                    V.setMatrix(this.Vt);
                  } else {
                    if (V == null) {
                      V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.Vt.numCols, this.Vt.numRows);
                    } else {
                      if (V.numRows != this.Vt.numCols || V.numCols != this.Vt.numRows) {
                        throw new Error("Unexpected shape of V");
                      }
                    }
                    org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.Vt, V);
                  }
                  return V;
                }
                public getW(W: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  var m: number = this.compact ? this.numSingular : this.numRows;
                  var n: number = this.compact ? this.numSingular : this.numCols;
                  if (W == null) {
                    W = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, n);
                  } else {
                    W.reshapeBoolean(m, n, false);
                    W.zero();
                  }
                  for (var i: number = 0; i < this.numSingular; i++) {
                    W.set(i, i, this.singularValues[i]);
                  }
                  return W;
                }
                public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  if (!this.setup(orig)) {
                    return false;
                  }
                  if (this.bidiagonalization(orig)) {
                    return false;
                  }
                  if (this.computeUWV()) {
                    return false;
                  }
                  this.makeSingularPositive();
                  this.undoTranspose();
                  return true;
                }
                public inputModified(): boolean {
                  return false;
                }
                private bidiagonalization(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  if (this.transposed) {
                    this.A_mod.reshapeBoolean(orig.numCols, orig.numRows, false);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(orig, this.A_mod);
                  } else {
                    this.A_mod.reshapeBoolean(orig.numRows, orig.numCols, false);
                    this.A_mod.setMatrix(orig);
                  }
                  return !this.bidiag.decompose(this.A_mod);
                }
                private undoTranspose(): void {
                  if (this.transposed) {
                    var temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.Vt;
                    this.Vt = this.Ut;
                    this.Ut = temp;
                  }
                }
                private computeUWV(): boolean {
                  this.bidiag.getDiagonal(this.diag, this.off);
                  this.qralg.setMatrix(this.numRowsT, this.numColsT, this.diag, this.off);
                  if (this.computeU) {
                    this.Ut = this.bidiag.getU(this.Ut, true, this.compact);
                  }
                  if (this.computeV) {
                    this.Vt = this.bidiag.getV(this.Vt, true, this.compact);
                  }
                  this.qralg.setFastValues(false);
                  if (this.computeU) {
                    this.qralg.setUt(this.Ut);
                  } else {
                    this.qralg.setUt(null);
                  }
                  if (this.computeV) {
                    this.qralg.setVt(this.Vt);
                  } else {
                    this.qralg.setVt(null);
                  }
                  var ret: boolean = !this.qralg.process();
                  return ret;
                }
                private setup(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  this.transposed = orig.numCols > orig.numRows;
                  if (this.transposed) {
                    this.computeU = this.prefComputeV;
                    this.computeV = this.prefComputeU;
                    this.numRowsT = orig.numCols;
                    this.numColsT = orig.numRows;
                  } else {
                    this.computeU = this.prefComputeU;
                    this.computeV = this.prefComputeV;
                    this.numRowsT = orig.numRows;
                    this.numColsT = orig.numCols;
                  }
                  this.numRows = orig.numRows;
                  this.numCols = orig.numCols;
                  if (this.numRows == 0 || this.numCols == 0) {
                    return false;
                  }
                  if (this.diag == null || this.diag.length < this.numColsT) {
                    this.diag = new Float64Array(this.numColsT);
                    this.off = new Float64Array(this.numColsT - 1);
                  }
                  if (this.canUseTallBidiagonal && this.numRows > this.numCols * 2 && !this.computeU) {
                    if (this.bidiag == null || !(this.bidiag instanceof org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64)) {
                      this.bidiag = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64();
                    }
                  } else {
                    if (this.bidiag == null || !(this.bidiag instanceof org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64)) {
                      this.bidiag = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                    }
                  }
                  return true;
                }
                private makeSingularPositive(): void {
                  this.numSingular = this.qralg.getNumberOfSingularValues();
                  this.singularValues = this.qralg.getSingularValues();
                  for (var i: number = 0; i < this.numSingular; i++) {
                    var val: number = this.qralg.getSingularValue(i);
                    if (val < 0) {
                      this.singularValues[i] = 0.0 - val;
                      if (this.computeU) {
                        var start: number = i * this.Ut.numCols;
                        var stop: number = start + this.Ut.numCols;
                        for (var j: number = start; j < stop; j++) {
                          this.Ut.setValueAtIndex(j, 0.0 - this.Ut.getValueAtIndex(j));
                        }
                      }
                    } else {
                      this.singularValues[i] = val;
                    }
                  }
                }
                public getNumRows(): number {
                  return this.numRows;
                }
                public getNumCols(): number {
                  return this.numCols;
                }
              }
              export class SimpleEVD<T extends org.kevoree.modeling.util.maths.matrix.SimpleMatrix> {
                private eig: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition;
                public mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                constructor(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F) {
                  this.mat = mat;
                  this.eig = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition(mat.numCols, true, 1e-8);
                  if (!this.eig.decompose(mat)) {
                    throw new Error("Eigenvalue Decomposition failed");
                  }
                }
                public getNumberOfEigenvalues(): number {
                  return this.eig.getNumberOfEigenvalues();
                }
                public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                  return this.eig.getEigenvalue(index);
                }
                public getEigenVector(index: number): T {
                  return <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.eig.getEigenVector(index));
                }
                public getEVD(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition {
                  return this.eig;
                }
                public getIndexMax(): number {
                  var indexMax: number = 0;
                  var max: number = this.getEigenvalue(0).getMagnitude2();
                  var N: number = this.getNumberOfEigenvalues();
                  for (var i: number = 1; i < N; i++) {
                    var m: number = this.getEigenvalue(i).getMagnitude2();
                    if (m > max) {
                      max = m;
                      indexMax = i;
                    }
                  }
                  return indexMax;
                }
                public getIndexMin(): number {
                  var indexMin: number = 0;
                  var min: number = this.getEigenvalue(0).getMagnitude2();
                  var N: number = this.getNumberOfEigenvalues();
                  for (var i: number = 1; i < N; i++) {
                    var m: number = this.getEigenvalue(i).getMagnitude2();
                    if (m < min) {
                      min = m;
                      indexMin = i;
                    }
                  }
                  return indexMin;
                }
              }
              export class AdjLinearSolverQr {
                public numRows: number;
                public numCols: number;
                private decomposer: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64;
                public maxRows: number = -1;
                public maxCols: number = -1;
                public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public R: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                private Y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                private Z: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  if (A.numRows > this.maxRows || A.numCols > this.maxCols) {
                    this.setMaxSize(A.numRows, A.numCols);
                  }
                  this.numRows = A.numRows;
                  this.numCols = A.numCols;
                  if (!this.decomposer.decompose(A)) {
                    return false;
                  }
                  this.Q.reshapeBoolean(this.numRows, this.numRows, false);
                  this.R.reshapeBoolean(this.numRows, this.numCols, false);
                  this.decomposer.getQ(this.Q, false);
                  this.decomposer.getR(this.R, false);
                  return true;
                }
                private solveU(U: Float64Array, b: Float64Array, n: number): void {
                  for (var i: number = n - 1; i >= 0; i--) {
                    var sum: number = b[i];
                    var indexU: number = i * n + i + 1;
                    for (var j: number = i + 1; j < n; j++) {
                      sum -= U[indexU++] * b[j];
                    }
                    b[i] = sum / U[i * n + i];
                  }
                }
                public solve(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, X: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  var BnumCols: number = B.numCols;
                  this.Y.reshapeBoolean(this.numRows, 1, false);
                  this.Z.reshapeBoolean(this.numRows, 1, false);
                  for (var colB: number = 0; colB < BnumCols; colB++) {
                    for (var i: number = 0; i < this.numRows; i++) {
                      this.Y.data[i] = B.get(i, colB);
                    }
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA(this.Q, this.Y, this.Z);
                    this.solveU(this.R.data, this.Z.data, this.numCols);
                    for (var i: number = 0; i < this.numCols; i++) {
                      X.cset(i, colB, this.Z.data[i]);
                    }
                  }
                }
                constructor() {
                  this.decomposer = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64();
                }
                public setMaxSize(maxRows: number, maxCols: number): void {
                  maxRows += 5;
                  this.maxRows = maxRows;
                  this.maxCols = maxCols;
                  this.Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, maxRows);
                  this.R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, maxCols);
                  this.Y = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, 1);
                  this.Z = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, 1);
                }
              }
              export class LinearSolverLu_D64 {
                public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public numRows: number;
                public numCols: number;
                public decomp: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64;
                public doImprove: boolean = false;
                public getA(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  return this.A;
                }
                public _setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  this.A = A;
                  this.numRows = A.numRows;
                  this.numCols = A.numCols;
                }
                constructor(decomp: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64) {
                  this.decomp = decomp;
                }
                public setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                  this._setA(A);
                  return this.decomp.decompose(A);
                }
                public invert(A_inv: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  var vv: Float64Array = this.decomp._getVV();
                  var LU: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decomp.getLU();
                  var n: number = this.A.numCols;
                  var dataInv: Float64Array = A_inv.data;
                  for (var j: number = 0; j < n; j++) {
                    for (var i: number = 0; i < n; i++) {
                      if (i == j) {
                        vv[i] = 1;
                      } else {
                        vv[i] = 0;
                      }
                    }
                    this.decomp._solveVectorInternal(vv);
                    var index: number = j;
                    for (var i: number = 0; i < n; i++) {
                      dataInv[index] = vv[i];
                      index += n;
                    }
                  }
                }
                public improveSol(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  var dataA: Float64Array = this.A.data;
                  var dataB: Float64Array = b.data;
                  var dataX: Float64Array = x.data;
                  var nc: number = b.numCols;
                  var n: number = b.numCols;
                  var vv: Float64Array = this.decomp._getVV();
                  for (var k: number = 0; k < nc; k++) {
                    for (var i: number = 0; i < n; i++) {
                      var sdp: number = -dataB[i * nc + k];
                      for (var j: number = 0; j < n; j++) {
                        sdp += dataA[i * n + j] * dataX[j * nc + k];
                      }
                      vv[i] = sdp;
                    }
                    this.decomp._solveVectorInternal(vv);
                    for (var i: number = 0; i < n; i++) {
                      dataX[i * nc + k] -= vv[i];
                    }
                  }
                }
                public modifiesA(): boolean {
                  return false;
                }
                public modifiesB(): boolean {
                  return false;
                }
                public solve(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  var numCols: number = b.numCols;
                  var dataB: Float64Array = b.data;
                  var dataX: Float64Array = x.data;
                  var vv: Float64Array = this.decomp._getVV();
                  for (var j: number = 0; j < numCols; j++) {
                    var index: number = j;
                    for (var i: number = 0; i < this.numCols; i++) {
                      vv[i] = dataB[index];
                      index += numCols;
                    }
                    this.decomp._solveVectorInternal(vv);
                    index = j;
                    for (var i: number = 0; i < this.numCols; i++) {
                      dataX[index] = vv[i];
                      index += numCols;
                    }
                  }
                  if (this.doImprove) {
                    this.improveSol(b, x);
                  }
                }
              }
              export namespace decomposition {
                export class QRDecompositionHouseholderColumn_D64 {
                  public dataQR: org.kevoree.modeling.util.maths.structure.KArray2D;
                  public v: Float64Array;
                  public numCols: number;
                  public numRows: number;
                  public minLength: number;
                  public gammas: Float64Array;
                  public gamma: number;
                  public tau: number;
                  public error: boolean;
                  public setExpectedMaxSize(numRows: number, numCols: number): void {
                    this.numCols = numCols;
                    this.numRows = numRows;
                    this.minLength = Math.min(numCols, numRows);
                    var maxLength: number = Math.max(numCols, numRows);
                    if (this.dataQR == null || this.dataQR.rows() < numRows || this.dataQR.columns() < numCols) {
                      this.dataQR = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(numRows, numCols);
                      this.v = new Float64Array(maxLength);
                      this.gammas = new Float64Array(this.minLength);
                    }
                    if (this.v.length < maxLength) {
                      this.v = new Float64Array(maxLength);
                    }
                    if (this.gammas.length < this.minLength) {
                      this.gammas = new Float64Array(this.minLength);
                    }
                  }
                  public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (compact) {
                      if (Q == null) {
                        Q = org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.identity(this.numRows, this.minLength);
                      } else {
                        org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                      }
                    } else {
                      if (Q == null) {
                        Q = org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.widentity(this.numRows);
                      } else {
                        org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                      }
                    }
                    for (var j: number = this.minLength - 1; j >= 0; j--) {
                      var vv: number = this.dataQR.get(j, j);
                      this.dataQR.set(j, j, 1);
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.rank1UpdateMultR(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                      this.dataQR.set(j, j, vv);
                    }
                    return Q;
                  }
                  public getR(R: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (R == null) {
                      if (compact) {
                        R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.minLength, this.numCols);
                      } else {
                        R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.numRows, this.numCols);
                      }
                    } else {
                      for (var i: number = 0; i < R.numRows; i++) {
                        var min: number = Math.min(i, R.numCols);
                        for (var j: number = 0; j < min; j++) {
                          R.cset(i, j, 0);
                        }
                      }
                    }
                    for (var j: number = 0; j < this.numCols; j++) {
                      var l: number = Math.min(j, this.numRows - 1);
                      for (var i: number = 0; i <= l; i++) {
                        var val: number = this.dataQR.get(i, j);
                        R.cset(i, j, val);
                      }
                    }
                    return R;
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.setExpectedMaxSize(A.numRows, A.numCols);
                    this.convertToColumnMajor(A);
                    this.error = false;
                    for (var j: number = 0; j < this.minLength; j++) {
                      this.householder(j);
                      this.updateA(j);
                    }
                    return !this.error;
                  }
                  public convertToColumnMajor(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    for (var x: number = 0; x < this.numCols; x++) {
                      for (var y: number = 0; y < this.numRows; y++) {
                        this.dataQR.set(y, x, A.data[y * this.numCols + x]);
                      }
                    }
                  }
                  public householder(j: number): void {
                    var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.findMax(this.dataQR, j, j, this.numRows - j);
                    if (max == 0.0) {
                      this.gamma = 0;
                      this.error = true;
                    } else {
                      this.tau = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.computeTauAndDivide(j, this.numRows, this.dataQR, j, max);
                      var u_0: number = this.dataQR.get(j, j) + this.tau;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.divideElements(j + 1, this.numRows, this.dataQR, j, u_0);
                      this.gamma = u_0 / this.tau;
                      this.tau *= max;
                      this.dataQR.set(j, j, -this.tau);
                    }
                    this.gammas[j] = this.gamma;
                  }
                  public updateA(w: number): void {
                    for (var j: number = w + 1; j < this.numCols; j++) {
                      var val: number = this.dataQR.get(w, j);
                      for (var k: number = w + 1; k < this.numRows; k++) {
                        val += this.dataQR.get(k, w) * this.dataQR.get(k, j);
                      }
                      val *= this.gamma;
                      this.dataQR.add(w, j, -val);
                      for (var i: number = w + 1; i < this.numRows; i++) {
                        this.dataQR.add(i, j, -this.dataQR.get(i, w) * val);
                      }
                    }
                  }
                  public static findMax(u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                    var max: number = -1;
                    var index: number = startU;
                    var stopIndex: number = startU + length;
                    for (; index < stopIndex; index++) {
                      var val: number = u.get(index, col);
                      val = (val < 0.0) ? -val : val;
                      if (val > max) {
                        max = val;
                      }
                    }
                    return max;
                  }
                  public static divideElements(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, u_0: number): void {
                    for (var i: number = j; i < numRows; i++) {
                      u.set(i, col, u.get(i, col) / u_0);
                    }
                  }
                  public static computeTauAndDivide(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, max: number): number {
                    var tau: number = 0;
                    for (var i: number = j; i < numRows; i++) {
                      u.set(i, col, u.get(i, col) / max);
                      var d: number = u.get(i, col);
                      tau += d * d;
                    }
                    tau = Math.sqrt(tau);
                    if (u.get(j, col) < 0) {
                      tau = -tau;
                    }
                    return tau;
                  }
                  public inputModified(): boolean {
                    return false;
                  }
                  public static rank1UpdateMultR(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                    }
                    for (var k: number = w0 + 1; k < w1; k++) {
                      var indexA: number = k * A.numCols + colA0;
                      var valU: number = u.get(k, col);
                      for (var i: number = colA0; i < A.numCols; i++) {
                        _temp[i] += valU * A.data[indexA++];
                      }
                    }
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] *= gamma;
                    }
                    for (var i: number = w0; i < w1; i++) {
                      var valU: number = u.get(i, col);
                      var indexA: number = i * A.numCols + colA0;
                      for (var j: number = colA0; j < A.numCols; j++) {
                        A.data[indexA++] -= valU * _temp[j];
                      }
                    }
                  }
                }
                export class SymmetricQRAlgorithmDecomposition_D64 {
                  private decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64;
                  private helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                  private vector: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm;
                  private computeVectorsWithValues: boolean = false;
                  private values: Float64Array;
                  private diag: Float64Array;
                  private off: Float64Array;
                  private diagSaved: Float64Array;
                  private offSaved: Float64Array;
                  private V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private eigenvectors: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                  public computeVectors: boolean;
                  constructor(decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64, computeVectors: boolean) {
                    this.decomp = decomp;
                    this.computeVectors = computeVectors;
                    this.helper = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper();
                    this.vector = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm(this.helper);
                  }
                  public setComputeVectorsWithValues(computeVectorsWithValues: boolean): void {
                    if (!this.computeVectors) {
                      throw new Error("Compute eigenvalues has been set to false");
                    }
                    this.computeVectorsWithValues = computeVectorsWithValues;
                  }
                  public setMaxIterations(max: number): void {
                    this.vector.setMaxIterations(max);
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.helper.getMatrixSize();
                  }
                  public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                    var c: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                    c.setValues(this.values[index], 0);
                    return c;
                  }
                  public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.eigenvectors[index];
                  }
                  public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    if (orig.numCols != orig.numRows) {
                      throw new Error("Matrix must be square.");
                    }
                    if (orig.numCols <= 0) {
                      return false;
                    }
                    var N: number = orig.numRows;
                    if (!this.decomp.decompose(orig)) {
                      return false;
                    }
                    if (this.diag == null || this.diag.length < N) {
                      this.diag = new Float64Array(N);
                      this.off = new Float64Array(N - 1);
                    }
                    this.decomp.getDiagonal(this.diag, this.off);
                    this.helper.init(this.diag, this.off, N);
                    if (this.computeVectors) {
                      if (this.computeVectorsWithValues) {
                        return this.extractTogether();
                      } else {
                        return this.extractSeparate(N);
                      }
                    } else {
                      return this.computeEigenValues();
                    }
                  }
                  public inputModified(): boolean {
                    return this.decomp.inputModified();
                  }
                  private extractTogether(): boolean {
                    this.V = this.decomp.getQ(this.V, true);
                    this.helper.setQ(this.V);
                    this.vector.setFastEigenvalues(false);
                    if (!this.vector.process3arg(-1, null, null)) {
                      return false;
                    }
                    this.eigenvectors = org.kevoree.modeling.util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                    this.values = this.helper.copyEigenvalues(this.values);
                    return true;
                  }
                  private extractSeparate(numCols: number): boolean {
                    if (!this.computeEigenValues()) {
                      return false;
                    }
                    this.helper.reset(numCols);
                    this.diagSaved = this.helper.swapDiag(this.diagSaved);
                    this.offSaved = this.helper.swapOff(this.offSaved);
                    this.V = this.decomp.getQ(this.V, true);
                    this.vector.setQ(this.V);
                    if (!this.vector.process(-1, null, null, this.values)) {
                      return false;
                    }
                    this.values = this.helper.copyEigenvalues(this.values);
                    this.eigenvectors = org.kevoree.modeling.util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                    return true;
                  }
                  private computeEigenValues(): boolean {
                    this.diagSaved = this.helper.copyDiag(this.diagSaved);
                    this.offSaved = this.helper.copyOff(this.offSaved);
                    this.vector.setQ(null);
                    this.vector.setFastEigenvalues(true);
                    if (!this.vector.process3arg(-1, null, null)) {
                      return false;
                    }
                    this.values = this.helper.copyEigenvalues(this.values);
                    return true;
                  }
                }
                export class EigenvalueSmall {
                  public value0: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                  public value1: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                  public value2x2(a11: number, a12: number, a21: number, a22: number): void {
                    var c: number, s: number;
                    if (a12 + a21 == 0) {
                      c = s = 1.0 / Math.sqrt(2);
                    } else {
                      var aa: number = (a11 - a22);
                      var bb: number = (a12 + a21);
                      var t_hat: number = aa / bb;
                      var t: number = t_hat / (1.0 + Math.sqrt(1.0 + t_hat * t_hat));
                      c = 1.0 / Math.sqrt(1.0 + t * t);
                      s = c * t;
                    }
                    var c2: number = c * c;
                    var s2: number = s * s;
                    var cs: number = c * s;
                    var b11: number = c2 * a11 + s2 * a22 - cs * (a12 + a21);
                    var b12: number = c2 * a12 - s2 * a21 + cs * (a11 - a22);
                    var b21: number = c2 * a21 - s2 * a12 + cs * (a11 - a22);
                    if (b21 * b12 >= 0) {
                      if (b12 == 0) {
                        c = 0;
                        s = 1;
                      } else {
                        s = Math.sqrt(b21 / (b12 + b21));
                        c = Math.sqrt(b12 / (b12 + b21));
                      }
                      cs = c * s;
                      a11 = b11 - cs * (b12 + b21);
                      a22 = b11 + cs * (b12 + b21);
                      this.value0.real = a11;
                      this.value1.real = a22;
                      this.value0.imaginary = this.value1.imaginary = 0;
                    } else {
                      this.value0.real = this.value1.real = b11;
                      this.value0.imaginary = Math.sqrt(-b21 * b12);
                      this.value1.imaginary = -this.value0.imaginary;
                    }
                  }
                  public value2x2_fast(a11: number, a12: number, a21: number, a22: number): void {
                    var left: number = (a11 + a22) / 2.0;
                    var inside: number = 4.0 * a12 * a21 + (a11 - a22) * (a11 - a22);
                    if (inside < 0) {
                      this.value0.real = this.value1.real = left;
                      this.value0.imaginary = Math.sqrt(-inside) / 2.0;
                      this.value1.imaginary = -this.value0.imaginary;
                    } else {
                      var right: number = Math.sqrt(inside) / 2.0;
                      this.value0.real = (left + right);
                      this.value1.real = (left - right);
                      this.value0.imaginary = this.value1.imaginary = 0.0;
                    }
                  }
                  public symm2x2_fast(a11: number, a12: number, a22: number): void {
                    var left: number = (a11 + a22) * 0.5;
                    var b: number = (a11 - a22) * 0.5;
                    var right: number = Math.sqrt(b * b + a12 * a12);
                    this.value0.real = left + right;
                    this.value1.real = left - right;
                  }
                }
                export class BidiagonalDecompositionTall_D64 implements org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F> {
                  public decompQRP: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64();
                  public decompBi: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F> = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                  public B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                  public m: number;
                  public n: number;
                  public min: number;
                  public getDiagonal(diag: Float64Array, off: Float64Array): void {
                    diag[0] = this.B.getValueAtIndex(0);
                    for (var i: number = 1; i < this.n; i++) {
                      diag[i] = this.B.get(i, i);
                      off[i - 1] = this.B.get(i - 1, i);
                    }
                  }
                  public getB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    B = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                    B.set(0, 0, this.B.get(0, 0));
                    for (var i: number = 1; i < this.min; i++) {
                      B.set(i, i, this.B.get(i, i));
                      B.set(i - 1, i, this.B.get(i - 1, i));
                    }
                    if (this.n > this.m) {
                      B.set(this.min - 1, this.min, this.B.get(this.min - 1, this.min));
                    }
                    return B;
                  }
                  public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    U = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, false, compact, this.m, this.n, this.min);
                    if (compact) {
                      var Q1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(null, true);
                      var U1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                      org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q1, U1, U);
                    } else {
                      var Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(U, false);
                      var U1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                      var Q1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = org.kevoree.modeling.util.maths.matrix.CommonOps.extract4Int(Q, 0, Q.numRows, 0, this.min);
                      var tmp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(Q1.numRows, U1.numCols);
                      org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q1, U1, tmp);
                      org.kevoree.modeling.util.maths.matrix.CommonOps.insert(tmp, Q, 0, 0);
                    }
                    if (transpose) {
                      org.kevoree.modeling.util.maths.matrix.CommonOps.transpose(U);
                    }
                    return U;
                  }
                  public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.decompBi.getV(V, transpose, compact);
                  }
                  public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    if (!this.decompQRP.decompose(orig)) {
                      return false;
                    }
                    this.m = orig.numRows;
                    this.n = orig.numCols;
                    this.min = Math.min(this.m, this.n);
                    this.B.reshapeBoolean(this.min, this.n, false);
                    this.decompQRP.getR(this.B, true);
                    var result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.min, this.n);
                    var P: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getPivotMatrix(null);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.multTransB(this.B, P, result);
                    this.B.setMatrix(result);
                    return this.decompBi.decompose(this.B);
                  }
                  public inputModified(): boolean {
                    return this.decompQRP.inputModified();
                  }
                }
                export class QRxColPivDecompositionHouseholderColumn_D64 extends org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64 {
                  public pivots: Int32Array;
                  public normsCol: Float64Array;
                  public maxAbs: number;
                  public singularThreshold: number = org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                  public rank: number;
                  constructor() {
                    super();
                  }
                  public setSingularThreshold(threshold: number): void {
                    this.singularThreshold = threshold;
                  }
                  public setExpectedMaxSize(numRows: number, numCols: number): void {
                    super.setExpectedMaxSize(numRows, numCols);
                    if (this.pivots == null || this.pivots.length < numCols) {
                      this.pivots = new Int32Array(numCols);
                      this.normsCol = new Float64Array(numCols);
                    }
                  }
                  public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (compact) {
                      if (Q == null) {
                        Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity(this.numRows, this.minLength);
                      } else {
                        if (Q.numRows != this.numRows || Q.numCols != this.minLength) {
                          throw new Error("Unexpected matrix dimension.");
                        } else {
                          org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                        }
                      }
                    } else {
                      if (Q == null) {
                        Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.numRows);
                      } else {
                        if (Q.numRows != this.numRows || Q.numCols != this.numRows) {
                          throw new Error("Unexpected matrix dimension.");
                        } else {
                          org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                        }
                      }
                    }
                    for (var j: number = this.rank - 1; j >= 0; j--) {
                      var vv: number = this.dataQR.get(j, j);
                      this.dataQR.set(j, j, 1);
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultRArray(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                      this.dataQR.set(j, j, vv);
                    }
                    return Q;
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.setExpectedMaxSize(A.numRows, A.numCols);
                    this.convertToColumnMajor(A);
                    this.maxAbs = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(A);
                    this.setupPivotInfo();
                    for (var j: number = 0; j < this.minLength; j++) {
                      if (j > 0) {
                        this.updateNorms(j);
                      }
                      this.swapColumns(j);
                      if (!this.householderPivot(j)) {
                        break;
                      }
                      this.updateA(j);
                      this.rank = j + 1;
                    }
                    return true;
                  }
                  private setupPivotInfo(): void {
                    for (var col: number = 0; col < this.numCols; col++) {
                      this.pivots[col] = col;
                      var norm: number = 0;
                      for (var row: number = 0; row < this.numRows; row++) {
                        var element: number = this.dataQR.get(row, col);
                        norm += element * element;
                      }
                      this.normsCol[col] = norm;
                    }
                  }
                  private updateNorms(j: number): void {
                    var foundNegative: boolean = false;
                    for (var col: number = j; col < this.numCols; col++) {
                      var e: number = this.dataQR.get(j - 1, col);
                      this.normsCol[col] -= e * e;
                      if (this.normsCol[col] < 0) {
                        foundNegative = true;
                        break;
                      }
                    }
                    if (foundNegative) {
                      for (var col: number = j; col < this.numCols; col++) {
                        var actual: number = 0;
                        for (var i: number = j; i < this.numRows; i++) {
                          var v: number = this.dataQR.get(i, col);
                          actual += v * v;
                        }
                        this.normsCol[col] = actual;
                      }
                    }
                  }
                  private swapColumns(j: number): void {
                    var largestIndex: number = j;
                    var largestNorm: number = this.normsCol[j];
                    for (var col: number = j + 1; col < this.numCols; col++) {
                      var n: number = this.normsCol[col];
                      if (n > largestNorm) {
                        largestNorm = n;
                        largestIndex = col;
                      }
                    }
                    var val: number = 0;
                    for (var k: number = 0; k < this.dataQR.rows(); k++) {
                      val = this.dataQR.get(k, j);
                      this.dataQR.set(k, j, this.dataQR.get(k, largestIndex));
                      this.dataQR.set(k, largestIndex, val);
                    }
                    var tempN: number = this.normsCol[j];
                    this.normsCol[j] = this.normsCol[largestIndex];
                    this.normsCol[largestIndex] = tempN;
                    var tempP: number = this.pivots[j];
                    this.pivots[j] = this.pivots[largestIndex];
                    this.pivots[largestIndex] = tempP;
                  }
                  public householderPivot(j: number): boolean {
                    var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMaxArray(this.dataQR, j, j, this.numRows - j);
                    if (max <= 0) {
                      return false;
                    } else {
                      this.tau = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4argArray(j, this.numRows, this.dataQR, j, max);
                      var u_0: number = this.dataQR.get(j, j) + this.tau;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements4argArray(j + 1, this.numRows, this.dataQR, j, u_0);
                      this.gamma = u_0 / this.tau;
                      this.tau *= max;
                      this.dataQR.set(j, j, -this.tau);
                      if (Math.abs(this.tau) <= this.singularThreshold) {
                        return false;
                      }
                    }
                    this.gammas[j] = this.gamma;
                    return true;
                  }
                  public getRank(): number {
                    return this.rank;
                  }
                  public getPivots(): Int32Array {
                    return this.pivots;
                  }
                  public getPivotMatrix(P: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (P == null) {
                      P = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.numCols, this.numCols);
                    } else {
                      if (P.numRows != this.numCols) {
                        throw new Error("Number of rows must be " + this.numCols);
                      } else {
                        if (P.numCols != this.numCols) {
                          throw new Error("Number of columns must be " + this.numCols);
                        } else {
                          P.zero();
                        }
                      }
                    }
                    for (var i: number = 0; i < this.numCols; i++) {
                      P.set(this.pivots[i], i, 1);
                    }
                    return P;
                  }
                }
                export class SymmetricQrAlgorithm {
                  private helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                  private Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private eigenvalues: Float64Array;
                  private exceptionalThresh: number = 15;
                  private maxIterations: number = this.exceptionalThresh * 15;
                  private fastEigenvalues: boolean;
                  private followingScript: boolean;
                  constructor(helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper) {
                    this.helper = helper;
                  }
                  public setMaxIterations(maxIterations: number): void {
                    this.maxIterations = maxIterations;
                  }
                  public getQ(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.Q;
                  }
                  public setQ(q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    this.Q = q;
                  }
                  public setFastEigenvalues(fastEigenvalues: boolean): void {
                    this.fastEigenvalues = fastEigenvalues;
                  }
                  public getEigenvalue(index: number): number {
                    return this.helper.diag[index];
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.helper.N;
                  }
                  public process(sideLength: number, diag: Float64Array, off: Float64Array, eigenvalues: Float64Array): boolean {
                    if (diag != null) {
                      this.helper.init(diag, off, sideLength);
                    }
                    if (this.Q == null) {
                      this.Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.helper.N);
                    }
                    this.helper.setQ(this.Q);
                    this.followingScript = true;
                    this.eigenvalues = eigenvalues;
                    this.fastEigenvalues = false;
                    return this._process();
                  }
                  public process3arg(sideLength: number, diag: Float64Array, off: Float64Array): boolean {
                    if (diag != null) {
                      this.helper.init(diag, off, sideLength);
                    }
                    this.followingScript = false;
                    this.eigenvalues = null;
                    return this._process();
                  }
                  private _process(): boolean {
                    while (this.helper.x2 >= 0){
                      if (this.helper.steps > this.maxIterations) {
                        return false;
                      }
                      if (this.helper.x1 == this.helper.x2) {
                        this.helper.resetSteps();
                        if (!this.helper.nextSplit()) {
                          break;
                        }
                      } else {
                        if (this.fastEigenvalues && this.helper.x2 - this.helper.x1 == 1) {
                          this.helper.resetSteps();
                          this.helper.eigenvalue2by2(this.helper.x1);
                          this.helper.setSubmatrix(this.helper.x2, this.helper.x2);
                        } else {
                          if (this.helper.steps - this.helper.lastExceptional > this.exceptionalThresh) {
                            this.helper.exceptionalShift();
                          } else {
                            this.performStep();
                          }
                        }
                      }
                      this.helper.incrementSteps();
                    }
                    return true;
                  }
                  public performStep(): void {
                    for (var i: number = this.helper.x2 - 1; i >= this.helper.x1; i--) {
                      if (this.helper.isZero(i)) {
                        this.helper.splits[this.helper.numSplits++] = i;
                        this.helper.x1 = i + 1;
                        return;
                      }
                    }
                    var lambda: number;
                    if (this.followingScript) {
                      if (this.helper.steps > 10) {
                        this.followingScript = false;
                        return;
                      } else {
                        lambda = this.eigenvalues[this.helper.x2];
                      }
                    } else {
                      lambda = this.helper.computeShift();
                    }
                    this.helper.performImplicitSingleStep(lambda, false);
                  }
                }
                export class BidiagonalDecompositionRow_D64 implements org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F> {
                  private UBV: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private m: number;
                  private n: number;
                  private min: number;
                  private gammasU: Float64Array;
                  private gammasV: Float64Array;
                  private b: Float64Array;
                  private u: Float64Array;
                  constructor(numElements: number) {
                    this.UBV = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numElements, 1);
                    this.gammasU = new Float64Array(numElements);
                    this.gammasV = new Float64Array(numElements);
                    this.b = new Float64Array(numElements);
                    this.u = new Float64Array(numElements);
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.init(A);
                    return this._decompose();
                  }
                  public init(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    this.UBV = A;
                    this.m = this.UBV.numRows;
                    this.n = this.UBV.numCols;
                    this.min = Math.min(this.m, this.n);
                    var max: number = Math.max(this.m, this.n);
                    if (this.b.length < max + 1) {
                      this.b = new Float64Array(max + 1);
                      this.u = new Float64Array(max + 1);
                    }
                    if (this.gammasU.length < this.m) {
                      this.gammasU = new Float64Array(this.m);
                    }
                    if (this.gammasV.length < this.n) {
                      this.gammasV = new Float64Array(this.n);
                    }
                  }
                  public getUBV(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.UBV;
                  }
                  public getDiagonal(diag: Float64Array, off: Float64Array): void {
                    diag[0] = this.UBV.getValueAtIndex(0);
                    for (var i: number = 1; i < this.n; i++) {
                      diag[i] = this.UBV.get(i, i);
                      off[i - 1] = this.UBV.get(i - 1, i);
                    }
                  }
                  public getB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    B = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                    B.set(0, 0, this.UBV.get(0, 0));
                    for (var i: number = 1; i < this.min; i++) {
                      B.set(i, i, this.UBV.get(i, i));
                      B.set(i - 1, i, this.UBV.get(i - 1, i));
                    }
                    if (this.n > this.m) {
                      B.set(this.min - 1, this.min, this.UBV.get(this.min - 1, this.min));
                    }
                    return B;
                  }
                  public static handleB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    var w: number = n > m ? min + 1 : min;
                    if (compact) {
                      if (B == null) {
                        B = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(min, w);
                      } else {
                        B.reshapeBoolean(min, w, false);
                        B.zero();
                      }
                    } else {
                      if (B == null) {
                        B = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, n);
                      } else {
                        B.reshapeBoolean(m, n, false);
                        B.zero();
                      }
                    }
                    return B;
                  }
                  public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    U = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, transpose, compact, this.m, this.n, this.min);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(U);
                    for (var i: number = 0; i < this.m; i++) {
                      this.u[i] = 0;
                    }
                    for (var j: number = this.min - 1; j >= 0; j--) {
                      this.u[j] = 1;
                      for (var i: number = j + 1; i < this.m; i++) {
                        this.u[i] = this.UBV.get(i, j);
                      }
                      if (transpose) {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(U, this.u, this.gammasU[j], j, j, this.m);
                      } else {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(U, this.u, this.gammasU[j], j, j, this.m, this.b);
                      }
                    }
                    return U;
                  }
                  public static handleU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (compact) {
                      if (transpose) {
                        if (U == null) {
                          U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(min, m);
                        } else {
                          U.reshapeBoolean(min, m, false);
                        }
                      } else {
                        if (U == null) {
                          U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, min);
                        } else {
                          U.reshapeBoolean(m, min, false);
                        }
                      }
                    } else {
                      if (U == null) {
                        U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, m);
                      } else {
                        U.reshapeBoolean(m, m, false);
                      }
                    }
                    return U;
                  }
                  public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    V = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleV(V, transpose, compact, this.m, this.n, this.min);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(V);
                    for (var j: number = this.min - 1; j >= 0; j--) {
                      this.u[j + 1] = 1;
                      for (var i: number = j + 2; i < this.n; i++) {
                        this.u[i] = this.UBV.get(j, i);
                      }
                      if (transpose) {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(V, this.u, this.gammasV[j], j + 1, j + 1, this.n);
                      } else {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(V, this.u, this.gammasV[j], j + 1, j + 1, this.n, this.b);
                      }
                    }
                    return V;
                  }
                  public static handleV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    var w: number = n > m ? min + 1 : min;
                    if (compact) {
                      if (transpose) {
                        if (V == null) {
                          V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(w, n);
                        } else {
                          V.reshapeBoolean(w, n, false);
                        }
                      } else {
                        if (V == null) {
                          V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(n, w);
                        } else {
                          V.reshapeBoolean(n, w, false);
                        }
                      }
                    } else {
                      if (V == null) {
                        V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(n, n);
                      } else {
                        V.reshapeBoolean(n, n, false);
                      }
                    }
                    return V;
                  }
                  private _decompose(): boolean {
                    for (var k: number = 0; k < this.min; k++) {
                      this.computeU(k);
                      this.computeV(k);
                    }
                    return true;
                  }
                  public computeU(k: number): void {
                    var b: Float64Array = this.UBV.data;
                    var max: number = 0;
                    for (var i: number = k; i < this.m; i++) {
                      var val: number = this.u[i] = b[i * this.n + k];
                      val = Math.abs(val);
                      if (val > max) {
                        max = val;
                      }
                    }
                    if (max > 0) {
                      var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4arg(k, this.m, this.u, max);
                      var nu: number = this.u[k] + tau;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Bcol(k + 1, this.m, this.n, this.u, b, k, nu);
                      this.u[k] = 1.0;
                      var gamma: number = nu / tau;
                      this.gammasU[k] = gamma;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.UBV, this.u, gamma, k + 1, k, this.m, this.b);
                      b[k * this.n + k] = -tau * max;
                    } else {
                      this.gammasU[k] = 0;
                    }
                  }
                  public computeV(k: number): void {
                    var b: Float64Array = this.UBV.data;
                    var row: number = k * this.n;
                    var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMax(b, row + k + 1, this.n - k - 1);
                    if (max > 0) {
                      var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k + 1, this.n, b, row, max);
                      var nu: number = b[row + k + 1] + tau;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Brow(k + 2, this.n, this.u, b, row, nu);
                      this.u[k + 1] = 1.0;
                      var gamma: number = nu / tau;
                      this.gammasV[k] = gamma;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.UBV, this.u, gamma, k + 1, k + 1, this.n);
                      b[row + k + 1] = -tau * max;
                    } else {
                      this.gammasV[k] = 0;
                    }
                  }
                  public getGammasU(): Float64Array {
                    return this.gammasU;
                  }
                  public getGammasV(): Float64Array {
                    return this.gammasV;
                  }
                  public inputModified(): boolean {
                    return true;
                  }
                }
                export interface BidiagonalDecomposition<T extends org.kevoree.modeling.util.maths.matrix.DenseMatrix64F> {
                  getB(B: T, compact: boolean): T;
                  getU(U: T, transpose: boolean, compact: boolean): T;
                  getV(V: T, transpose: boolean, compact: boolean): T;
                  getDiagonal(diag: Float64Array, off: Float64Array): void;
                  decompose(orig: T): boolean;
                  inputModified(): boolean;
                }
                export class WatchedDoubleStepQRDecomposition_D64 {
                  public hessenberg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64;
                  public algValue: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue;
                  public algVector: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector;
                  public H: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public computeVectors: boolean;
                  constructor(computeVectors: boolean) {
                    this.hessenberg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64(10);
                    this.algValue = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue();
                    this.algVector = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector();
                    this.computeVectors = computeVectors;
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    if (!this.hessenberg.decompose(A)) {
                      return false;
                    }
                    this.H = this.hessenberg.getH(null);
                    this.algValue.getImplicitQR().createR = false;
                    if (!this.algValue.process(this.H)) {
                      return false;
                    }
                    this.algValue.getImplicitQR().createR = true;
                    if (this.computeVectors) {
                      return this.algVector.process(this.algValue.getImplicitQR(), this.H, this.hessenberg.getQ(null));
                    } else {
                      return true;
                    }
                  }
                  public inputModified(): boolean {
                    return this.hessenberg.inputModified();
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.algValue.getEigenvalues().length;
                  }
                  public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                    return this.algValue.getEigenvalues()[index];
                  }
                  public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.algVector.getEigenvectors()[index];
                  }
                }
                export class SymmetricQREigenHelper {
                  public rand: java.util.Random = new java.util.Random();
                  public steps: number;
                  public numExceptional: number;
                  public lastExceptional: number;
                  public eigenSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                  public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public N: number;
                  public diag: Float64Array;
                  public off: Float64Array;
                  public x1: number;
                  public x2: number;
                  public splits: Int32Array;
                  public numSplits: number;
                  private bulge: number;
                  private c: number;
                  private s: number;
                  private c2: number;
                  private s2: number;
                  private cs: number;
                  constructor() {
                    this.splits = new Int32Array(1);
                  }
                  public setQ(q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    this.Q = q;
                  }
                  public incrementSteps(): void {
                    this.steps++;
                  }
                  public init(diag: Float64Array, off: Float64Array, numCols: number): void {
                    this.reset(numCols);
                    this.diag = diag;
                    this.off = off;
                  }
                  public swapDiag(diag: Float64Array): Float64Array {
                    var ret: Float64Array = this.diag;
                    this.diag = diag;
                    return ret;
                  }
                  public swapOff(off: Float64Array): Float64Array {
                    var ret: Float64Array = this.off;
                    this.off = off;
                    return ret;
                  }
                  public reset(N: number): void {
                    this.N = N;
                    this.diag = null;
                    this.off = null;
                    if (this.splits.length < N) {
                      this.splits = new Int32Array(N);
                    }
                    this.numSplits = 0;
                    this.x1 = 0;
                    this.x2 = N - 1;
                    this.steps = this.numExceptional = this.lastExceptional = 0;
                    this.Q = null;
                  }
                  public copyDiag(ret: Float64Array): Float64Array {
                    if (ret == null || ret.length < this.N) {
                      ret = new Float64Array(this.N);
                    }
                    java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                    return ret;
                  }
                  public copyOff(ret: Float64Array): Float64Array {
                    if (ret == null || ret.length < this.N - 1) {
                      ret = new Float64Array(this.N - 1);
                    }
                    java.lang.System.arraycopy(this.off, 0, ret, 0, this.N - 1);
                    return ret;
                  }
                  public copyEigenvalues(ret: Float64Array): Float64Array {
                    if (ret == null || ret.length < this.N) {
                      ret = new Float64Array(this.N);
                    }
                    java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                    return ret;
                  }
                  public setSubmatrix(x1: number, x2: number): void {
                    this.x1 = x1;
                    this.x2 = x2;
                  }
                  public isZero(index: number): boolean {
                    var bottom: number = Math.abs(this.diag[index]) + Math.abs(this.diag[index + 1]);
                    return (Math.abs(this.off[index]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS);
                  }
                  public performImplicitSingleStep(lambda: number, byAngle: boolean): void {
                    if (this.x2 - this.x1 == 1) {
                      this.createBulge2by2(this.x1, lambda, byAngle);
                    } else {
                      this.createBulge(this.x1, lambda, byAngle);
                      for (var i: number = this.x1; i < this.x2 - 2 && this.bulge != 0.0; i++) {
                        this.removeBulge(i);
                      }
                      if (this.bulge != 0.0) {
                        this.removeBulgeEnd(this.x2 - 2);
                      }
                    }
                  }
                  public updateQ(m: number, n: number, c: number, s: number): void {
                    var rowA: number = m * this.N;
                    var rowB: number = n * this.N;
                    var endA: number = rowA + this.N;
                    while (rowA < endA){
                      var a: number = this.Q.data[rowA];
                      var b: number = this.Q.data[rowB];
                      this.Q.data[rowA++] = c * a + s * b;
                      this.Q.data[rowB++] = -s * a + c * b;
                    }
                  }
                  public createBulge(x1: number, p: number, byAngle: boolean): void {
                    var a11: number = this.diag[x1];
                    var a22: number = this.diag[x1 + 1];
                    var a12: number = this.off[x1];
                    var a23: number = this.off[x1 + 1];
                    if (byAngle) {
                      this.c = Math.cos(p);
                      this.s = Math.sin(p);
                      this.c2 = this.c * this.c;
                      this.s2 = this.s * this.s;
                      this.cs = this.c * this.s;
                    } else {
                      this.computeRotation(a11 - p, a12);
                    }
                    this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                    this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                    this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                    this.off[x1 + 1] = this.c * a23;
                    this.bulge = this.s * a23;
                    if (this.Q != null) {
                      this.updateQ(x1, x1 + 1, this.c, this.s);
                    }
                  }
                  public createBulge2by2(x1: number, p: number, byAngle: boolean): void {
                    var a11: number = this.diag[x1];
                    var a22: number = this.diag[x1 + 1];
                    var a12: number = this.off[x1];
                    if (byAngle) {
                      this.c = Math.cos(p);
                      this.s = Math.sin(p);
                      this.c2 = this.c * this.c;
                      this.s2 = this.s * this.s;
                      this.cs = this.c * this.s;
                    } else {
                      this.computeRotation(a11 - p, a12);
                    }
                    this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                    this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                    this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                    if (this.Q != null) {
                      this.updateQ(x1, x1 + 1, this.c, this.s);
                    }
                  }
                  private computeRotation(run: number, rise: number): void {
                    if (Math.abs(rise) > Math.abs(run)) {
                      var k: number = run / rise;
                      var bottom: number = 1.0 + k * k;
                      var bottom_sq: number = Math.sqrt(bottom);
                      this.s2 = 1.0 / bottom;
                      this.c2 = k * k / bottom;
                      this.cs = k / bottom;
                      this.s = 1.0 / bottom_sq;
                      this.c = k / bottom_sq;
                    } else {
                      var t: number = rise / run;
                      var bottom: number = 1.0 + t * t;
                      var bottom_sq: number = Math.sqrt(bottom);
                      this.c2 = 1.0 / bottom;
                      this.s2 = t * t / bottom;
                      this.cs = t / bottom;
                      this.c = 1.0 / bottom_sq;
                      this.s = t / bottom_sq;
                    }
                  }
                  public removeBulge(x1: number): void {
                    var a22: number = this.diag[x1 + 1];
                    var a33: number = this.diag[x1 + 2];
                    var a12: number = this.off[x1];
                    var a23: number = this.off[x1 + 1];
                    var a34: number = this.off[x1 + 2];
                    this.computeRotation(a12, this.bulge);
                    this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                    this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                    this.off[x1] = this.c * a12 + this.s * this.bulge;
                    this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                    this.off[x1 + 2] = this.c * a34;
                    this.bulge = this.s * a34;
                    if (this.Q != null) {
                      this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                    }
                  }
                  public removeBulgeEnd(x1: number): void {
                    var a22: number = this.diag[x1 + 1];
                    var a12: number = this.off[x1];
                    var a23: number = this.off[x1 + 1];
                    var a33: number = this.diag[x1 + 2];
                    this.computeRotation(a12, this.bulge);
                    this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                    this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                    this.off[x1] = this.c * a12 + this.s * this.bulge;
                    this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                    if (this.Q != null) {
                      this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                    }
                  }
                  public eigenvalue2by2(x1: number): void {
                    var a: number = this.diag[x1];
                    var b: number = this.off[x1];
                    var c: number = this.diag[x1 + 1];
                    var absA: number = Math.abs(a);
                    var absB: number = Math.abs(b);
                    var absC: number = Math.abs(c);
                    var scale: number = absA > absB ? absA : absB;
                    if (absC > scale) {
                      scale = absC;
                    }
                    if (scale == 0) {
                      this.off[x1] = 0;
                      this.diag[x1] = 0;
                      this.diag[x1 + 1] = 0;
                      return;
                    }
                    a /= scale;
                    b /= scale;
                    c /= scale;
                    this.eigenSmall.symm2x2_fast(a, b, c);
                    this.off[x1] = 0;
                    this.diag[x1] = scale * this.eigenSmall.value0.real;
                    this.diag[x1 + 1] = scale * this.eigenSmall.value1.real;
                  }
                  public exceptionalShift(): void {
                    this.numExceptional++;
                    var mag: number = 0.05 * this.numExceptional;
                    if (mag > 1.0) {
                      mag = 1.0;
                    }
                    var theta: number = 2.0 * (this.rand.nextDouble() - 0.5) * mag;
                    this.performImplicitSingleStep(theta, true);
                    this.lastExceptional = this.steps;
                  }
                  public nextSplit(): boolean {
                    if (this.numSplits == 0) {
                      return false;
                    }
                    this.x2 = this.splits[--this.numSplits];
                    if (this.numSplits > 0) {
                      this.x1 = this.splits[this.numSplits - 1] + 1;
                    } else {
                      this.x1 = 0;
                    }
                    return true;
                  }
                  public computeShift(): number {
                    if (this.x2 - this.x1 >= 1) {
                      return this.computeWilkinsonShift();
                    } else {
                      return this.diag[this.x2];
                    }
                  }
                  public computeWilkinsonShift(): number {
                    var a: number = this.diag[this.x2 - 1];
                    var b: number = this.off[this.x2 - 1];
                    var c: number = this.diag[this.x2];
                    var absA: number = Math.abs(a);
                    var absB: number = Math.abs(b);
                    var absC: number = Math.abs(c);
                    var scale: number = absA > absB ? absA : absB;
                    if (absC > scale) {
                      scale = absC;
                    }
                    if (scale == 0) {
                      throw new Error("this should never happen");
                    }
                    a /= scale;
                    b /= scale;
                    c /= scale;
                    this.eigenSmall.symm2x2_fast(a, b, c);
                    var diff0: number = Math.abs(this.eigenSmall.value0.real - c);
                    var diff1: number = Math.abs(this.eigenSmall.value1.real - c);
                    if (diff0 < diff1) {
                      return scale * this.eigenSmall.value0.real;
                    } else {
                      return scale * this.eigenSmall.value1.real;
                    }
                  }
                  public getMatrixSize(): number {
                    return this.N;
                  }
                  public resetSteps(): void {
                    this.steps = 0;
                    this.lastExceptional = 0;
                  }
                }
                export class HessenbergSimilarDecomposition_D64 {
                  private QH: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private N: number;
                  private gammas: Float64Array;
                  private b: Float64Array;
                  private u: Float64Array;
                  constructor(initialSize: number) {
                    this.gammas = new Float64Array(initialSize);
                    this.b = new Float64Array(initialSize);
                    this.u = new Float64Array(initialSize);
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    if (A.numRows != A.numCols) {
                      throw new Error("A must be square.");
                    }
                    if (A.numRows <= 0) {
                      return false;
                    }
                    this.QH = A;
                    this.N = A.numCols;
                    if (this.b.length < this.N) {
                      this.b = new Float64Array(this.N);
                      this.gammas = new Float64Array(this.N);
                      this.u = new Float64Array(this.N);
                    }
                    return this._decompose();
                  }
                  public inputModified(): boolean {
                    return true;
                  }
                  public getQH(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.QH;
                  }
                  public getH(H: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (H == null) {
                      H = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                    } else {
                      H.zero();
                    }
                    java.lang.System.arraycopy(this.QH.data, 0, H.data, 0, this.N);
                    for (var i: number = 1; i < this.N; i++) {
                      for (var j: number = i - 1; j < this.N; j++) {
                        H.set(i, j, this.QH.get(i, j));
                      }
                    }
                    return H;
                  }
                  public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (Q == null) {
                      Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                      for (var i: number = 0; i < this.N; i++) {
                        Q.data[i * this.N + i] = 1;
                      }
                    } else {
                      if (this.N != Q.numRows || this.N != Q.numCols) {
                        throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                      } else {
                        org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                      }
                    }
                    for (var j: number = this.N - 2; j >= 0; j--) {
                      this.u[j + 1] = 1;
                      for (var i: number = j + 2; i < this.N; i++) {
                        this.u[i] = this.QH.get(i, j);
                      }
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.u, this.gammas[j], j + 1, j + 1, this.N, this.b);
                    }
                    return Q;
                  }
                  private _decompose(): boolean {
                    var h: Float64Array = this.QH.data;
                    for (var k: number = 0; k < this.N - 2; k++) {
                      var max: number = 0;
                      for (var i: number = k + 1; i < this.N; i++) {
                        var val: number = this.u[i] = h[i * this.N + k];
                        val = Math.abs(val);
                        if (val > max) {
                          max = val;
                        }
                      }
                      if (max > 0) {
                        var tau: number = 0;
                        for (var i: number = k + 1; i < this.N; i++) {
                          var val: number = this.u[i] /= max;
                          tau += val * val;
                        }
                        tau = Math.sqrt(tau);
                        if (this.u[k + 1] < 0) {
                          tau = -tau;
                        }
                        var nu: number = this.u[k + 1] + tau;
                        this.u[k + 1] = 1.0;
                        for (var i: number = k + 2; i < this.N; i++) {
                          h[i * this.N + k] = this.u[i] /= nu;
                        }
                        var gamma: number = nu / tau;
                        this.gammas[k] = gamma;
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.QH, this.u, gamma, k + 1, k + 1, this.N, this.b);
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.QH, this.u, gamma, 0, k + 1, this.N);
                        h[(k + 1) * this.N + k] = -tau * max;
                      } else {
                        this.gammas[k] = 0;
                      }
                    }
                    return true;
                  }
                  public getGammas(): Float64Array {
                    return this.gammas;
                  }
                }
                export class QrHelperFunctions_D64 {
                  public static findMax(u: Float64Array, startU: number, length: number): number {
                    var max: number = -1;
                    var index: number = startU;
                    var stopIndex: number = startU + length;
                    for (; index < stopIndex; index++) {
                      var val: number = u[index];
                      val = (val < 0.0) ? -val : val;
                      if (val > max) {
                        max = val;
                      }
                    }
                    return max;
                  }
                  public static findMaxArray(u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                    var max: number = -1;
                    var index: number = startU;
                    var stopIndex: number = startU + length;
                    for (; index < stopIndex; index++) {
                      var val: number = u.get(index, col);
                      val = (val < 0.0) ? -val : val;
                      if (val > max) {
                        max = val;
                      }
                    }
                    return max;
                  }
                  public static divideElements4arg(j: number, numRows: number, u: Float64Array, u_0: number): void {
                    for (var i: number = j; i < numRows; i++) {
                      u[i] /= u_0;
                    }
                  }
                  public static divideElements4argArray(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, u_0: number): void {
                    for (var i: number = j; i < numRows; i++) {
                      u.set(i, col, u.get(i, col) / u_0);
                    }
                  }
                  public static divideElements(j: number, numRows: number, u: Float64Array, startU: number, u_0: number): void {
                    for (var i: number = j; i < numRows; i++) {
                      u[i + startU] /= u_0;
                    }
                  }
                  public static divideElements_Brow(j: number, numRows: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                    for (var i: number = j; i < numRows; i++) {
                      u[i] = b[i + startB] /= u_0;
                    }
                  }
                  public static divideElements_Bcol(j: number, numRows: number, numCols: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                    var indexB: number = j * numCols + startB;
                    for (var i: number = j; i < numRows; i++) {
                      b[indexB] = u[i] /= u_0;
                      indexB += numCols;
                    }
                  }
                  public static computeTauAndDivide(j: number, numRows: number, u: Float64Array, startU: number, max: number): number {
                    var tau: number = 0;
                    for (var i: number = j; i < numRows; i++) {
                      var d: number = u[startU + i] /= max;
                      tau += d * d;
                    }
                    tau = Math.sqrt(tau);
                    if (u[startU + j] < 0) {
                      tau = -tau;
                    }
                    return tau;
                  }
                  public static computeTauAndDivide4arg(j: number, numRows: number, u: Float64Array, max: number): number {
                    var tau: number = 0;
                    for (var i: number = j; i < numRows; i++) {
                      var d: number = u[i] /= max;
                      tau += d * d;
                    }
                    tau = Math.sqrt(tau);
                    if (u[j] < 0) {
                      tau = -tau;
                    }
                    return tau;
                  }
                  public static computeTauAndDivide4argArray(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, max: number): number {
                    var tau: number = 0;
                    for (var i: number = j; i < numRows; i++) {
                      u.set(i, col, u.get(i, col) / max);
                      var d: number = u.get(i, col);
                      tau += d * d;
                    }
                    tau = Math.sqrt(tau);
                    if (u.get(j, col) < 0) {
                      tau = -tau;
                    }
                    return tau;
                  }
                  public static rank1UpdateMultR(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] = u[w0] * A.data[w0 * A.numCols + i];
                    }
                    for (var k: number = w0 + 1; k < w1; k++) {
                      var indexA: number = k * A.numCols + colA0;
                      var valU: number = u[k];
                      for (var i: number = colA0; i < A.numCols; i++) {
                        _temp[i] += valU * A.data[indexA++];
                      }
                    }
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] *= gamma;
                    }
                    for (var i: number = w0; i < w1; i++) {
                      var valU: number = u[i];
                      var indexA: number = i * A.numCols + colA0;
                      for (var j: number = colA0; j < A.numCols; j++) {
                        A.data[indexA++] -= valU * _temp[j];
                      }
                    }
                  }
                  public static rank1UpdateMultRArray(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                    }
                    for (var k: number = w0 + 1; k < w1; k++) {
                      var indexA: number = k * A.numCols + colA0;
                      var valU: number = u.get(k, col);
                      for (var i: number = colA0; i < A.numCols; i++) {
                        _temp[i] += valU * A.data[indexA++];
                      }
                    }
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] *= gamma;
                    }
                    for (var i: number = w0; i < w1; i++) {
                      var valU: number = u.get(i, col);
                      var indexA: number = i * A.numCols + colA0;
                      for (var j: number = colA0; j < A.numCols; j++) {
                        A.data[indexA++] -= valU * _temp[j];
                      }
                    }
                  }
                  public static rank1UpdateMultR8param(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, offsetU: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] = u[w0 + offsetU] * A.data[w0 * A.numCols + i];
                    }
                    for (var k: number = w0 + 1; k < w1; k++) {
                      var indexA: number = k * A.numCols + colA0;
                      var valU: number = u[k + offsetU];
                      for (var i: number = colA0; i < A.numCols; i++) {
                        _temp[i] += valU * A.data[indexA++];
                      }
                    }
                    for (var i: number = colA0; i < A.numCols; i++) {
                      _temp[i] *= gamma;
                    }
                    for (var i: number = w0; i < w1; i++) {
                      var valU: number = u[i + offsetU];
                      var indexA: number = i * A.numCols + colA0;
                      for (var j: number = colA0; j < A.numCols; j++) {
                        A.data[indexA++] -= valU * _temp[j];
                      }
                    }
                  }
                  public static rank1UpdateMultL(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number): void {
                    for (var i: number = colA0; i < A.numRows; i++) {
                      var startIndex: number = i * A.numCols + w0;
                      var sum: number = 0;
                      var rowIndex: number = startIndex;
                      for (var j: number = w0; j < w1; j++) {
                        sum += A.data[rowIndex++] * u[j];
                      }
                      sum = -gamma * sum;
                      rowIndex = startIndex;
                      for (var j: number = w0; j < w1; j++) {
                        A.data[rowIndex++] += sum * u[j];
                      }
                    }
                  }
                }
                export class WatchedDoubleStepQREigenvector {
                  public implicit: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                  public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public eigenvectors: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                  public eigenvectorTemp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public solver: org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64;
                  public origEigenvalues: org.kevoree.modeling.util.maths.matrix.Complex64F[];
                  public N: number;
                  public splits: Int32Array;
                  public numSplits: number;
                  public x1: number;
                  public x2: number;
                  public indexVal: number;
                  public onscript: boolean;
                  public process(implicit: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, Q_h: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.implicit = implicit;
                    if (this.N != A.numRows) {
                      this.N = A.numRows;
                      this.Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                      this.splits = new Int32Array(this.N);
                      this.origEigenvalues = new Array<org.kevoree.modeling.util.maths.matrix.Complex64F>(this.N);
                      this.eigenvectors = new Array<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F>(this.N);
                      this.eigenvectorTemp = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                      this.solver = new org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64(new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64());
                    } else {
                      this.eigenvectors = new Array<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F>(this.N);
                    }
                    java.lang.System.arraycopy(implicit.eigenvalues, 0, this.origEigenvalues, 0, this.N);
                    implicit.setup(A);
                    implicit.setQ(this.Q);
                    this.numSplits = 0;
                    this.onscript = true;
                    if (!this.findQandR()) {
                      return false;
                    }
                    return this.extractVectors(Q_h);
                  }
                  public extractVectors(Q_h: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    org.kevoree.modeling.util.maths.matrix.CommonOps.memset(this.eigenvectorTemp.data, 0);
                    var triangular: boolean = true;
                    for (var i: number = 0; i < this.N; i++) {
                      var c: org.kevoree.modeling.util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                      if (triangular && !c.isReal()) {
                        triangular = false;
                      }
                      if (c.isReal() && this.eigenvectors[this.N - i - 1] == null) {
                        this.solveEigenvectorDuplicateEigenvalue(c.real, i, triangular);
                      }
                    }
                    if (Q_h != null) {
                      var temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                      for (var i: number = 0; i < this.N; i++) {
                        var v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.eigenvectors[i];
                        if (v != null) {
                          org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q_h, v, temp);
                          this.eigenvectors[i] = temp;
                          temp = v;
                        }
                      }
                    }
                    return true;
                  }
                  private solveEigenvectorDuplicateEigenvalue(real: number, first: number, isTriangle: boolean): void {
                    var scale: number = Math.abs(real);
                    if (scale == 0) {
                      scale = 1;
                    }
                    this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                    this.eigenvectorTemp.zero();
                    if (first > 0) {
                      if (isTriangle) {
                        this.solveUsingTriangle(real, first, this.eigenvectorTemp);
                      } else {
                        this.solveWithLU(real, first, this.eigenvectorTemp);
                      }
                    }
                    this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                    for (var i: number = first; i < this.N; i++) {
                      var c: org.kevoree.modeling.util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                      if (c.isReal() && Math.abs(c.real - real) / scale < 100.0 * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS) {
                        this.eigenvectorTemp.data[i] = 1;
                        var v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                        org.kevoree.modeling.util.maths.matrix.CommonOps.multTransA(this.Q, this.eigenvectorTemp, v);
                        this.eigenvectors[this.N - i - 1] = v;
                        org.kevoree.modeling.util.maths.matrix.CommonOps.normalizeF(v);
                        this.eigenvectorTemp.data[i] = 0;
                      }
                    }
                  }
                  private solveUsingTriangle(real: number, index: number, r: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    for (var i: number = 0; i < index; i++) {
                      this.implicit.A.add(i, i, -real);
                    }
                    org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.changeSign(r);
                    org.kevoree.modeling.util.maths.matrix.solvers.TriangularSolver.solveU(this.implicit.A.data, r.data, this.implicit.A.numRows, 0, index);
                    for (var i: number = 0; i < index; i++) {
                      this.implicit.A.add(i, i, real);
                    }
                  }
                  private solveWithLU(real: number, index: number, r: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    var A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(index, index);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.extract6M(this.implicit.A, 0, index, 0, index, A, 0, 0);
                    for (var i: number = 0; i < index; i++) {
                      A.add(i, i, -real);
                    }
                    r.reshapeBoolean(index, 1, false);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                    org.kevoree.modeling.util.maths.matrix.CommonOps.changeSign(r);
                    if (!this.solver.setA(A)) {
                      throw new Error("Solve failed");
                    }
                    this.solver.solve(r, r);
                  }
                  public findQandR(): boolean {
                    org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(this.Q);
                    this.x1 = 0;
                    this.x2 = this.N - 1;
                    this.indexVal = 0;
                    while (this.indexVal < this.N){
                      if (!this.findNextEigenvalue()) {
                        return false;
                      }
                    }
                    return true;
                  }
                  private findNextEigenvalue(): boolean {
                    var foundEigen: boolean = false;
                    while (!foundEigen && this.implicit.steps < this.implicit.maxIterations){
                      this.implicit.incrementSteps();
                      if (this.x2 < this.x1) {
                        this.moveToNextSplit();
                      } else {
                        if (this.x2 - this.x1 == 0) {
                          this.implicit.addEigenAt(this.x1);
                          this.x2--;
                          this.indexVal++;
                          foundEigen = true;
                        } else {
                          if (this.x2 - this.x1 == 1 && !this.implicit.isReal2x2(this.x1, this.x2)) {
                            this.implicit.addComputedEigen2x2(this.x1, this.x2);
                            this.x2 -= 2;
                            this.indexVal += 2;
                            foundEigen = true;
                          } else {
                            if (this.implicit.steps - this.implicit.lastExceptional > this.implicit.exceptionalThreshold) {
                              this.implicit.exceptionalShift(this.x1, this.x2);
                              this.implicit.lastExceptional = this.implicit.steps;
                            } else {
                              if (this.implicit.isZero(this.x2, this.x2 - 1)) {
                                this.implicit.addEigenAt(this.x2);
                                foundEigen = true;
                                this.x2--;
                                this.indexVal++;
                              } else {
                                this.checkSplitPerformImplicit();
                              }
                            }
                          }
                        }
                      }
                    }
                    return foundEigen;
                  }
                  private checkSplitPerformImplicit(): void {
                    for (var i: number = this.x2; i > this.x1; i--) {
                      if (this.implicit.isZero(i, i - 1)) {
                        this.x1 = i;
                        this.splits[this.numSplits++] = i - 1;
                        return;
                      }
                    }
                    if (this.onscript) {
                      if (this.implicit.steps > this.implicit.exceptionalThreshold / 2) {
                        this.onscript = false;
                      } else {
                        var a: org.kevoree.modeling.util.maths.matrix.Complex64F = this.origEigenvalues[this.indexVal];
                        if (a.isReal()) {
                          this.implicit.performImplicitSingleStep(this.x1, this.x2, a.getReal());
                        } else {
                          if (this.x2 < this.N - 2) {
                            this.implicit.performImplicitDoubleStep(this.x1, this.x2, a.real, a.imaginary);
                          } else {
                            this.onscript = false;
                          }
                        }
                      }
                    } else {
                      if (this.x2 - this.x1 >= 1 && this.x2 < this.N - 2) {
                        this.implicit.implicitDoubleStep(this.x1, this.x2);
                      } else {
                        this.implicit.performImplicitSingleStep(this.x1, this.x2, this.implicit.A.get(this.x2, this.x2));
                      }
                    }
                  }
                  private moveToNextSplit(): void {
                    if (this.numSplits <= 0) {
                      throw new Error("bad");
                    }
                    this.x2 = this.splits[--this.numSplits];
                    if (this.numSplits > 0) {
                      this.x1 = this.splits[this.numSplits - 1] + 1;
                    } else {
                      this.x1 = 0;
                    }
                  }
                  public getQ(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.Q;
                  }
                  public getImplicit(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                    return this.implicit;
                  }
                  public getEigenvectors(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                    return this.eigenvectors;
                  }
                  public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                    return this.implicit.eigenvalues;
                  }
                }
                export class TridiagonalDecompositionHouseholder_D64 {
                  private QT: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private N: number;
                  private w: Float64Array;
                  private gammas: Float64Array;
                  private b: Float64Array;
                  constructor() {
                    this.N = 1;
                    this.w = new Float64Array(this.N);
                    this.b = new Float64Array(this.N);
                    this.gammas = new Float64Array(this.N);
                  }
                  public getQT(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    return this.QT;
                  }
                  public getDiagonal(diag: Float64Array, off: Float64Array): void {
                    for (var i: number = 0; i < this.N; i++) {
                      diag[i] = this.QT.data[i * this.N + i];
                      if (i + 1 < this.N) {
                        off[i] = this.QT.data[i * this.N + i + 1];
                      }
                    }
                  }
                  public getT(T: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (T == null) {
                      T = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                    } else {
                      if (this.N != T.numRows || this.N != T.numCols) {
                        throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                      } else {
                        T.zero();
                      }
                    }
                    T.data[0] = this.QT.data[0];
                    for (var i: number = 1; i < this.N; i++) {
                      T.set(i, i, this.QT.get(i, i));
                      var a: number = this.QT.get(i - 1, i);
                      T.set(i - 1, i, a);
                      T.set(i, i - 1, a);
                    }
                    if (this.N > 1) {
                      T.data[(this.N - 1) * this.N + this.N - 1] = this.QT.data[(this.N - 1) * this.N + this.N - 1];
                      T.data[(this.N - 1) * this.N + this.N - 2] = this.QT.data[(this.N - 2) * this.N + this.N - 1];
                    }
                    return T;
                  }
                  public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transposed: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (Q == null) {
                      Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.N);
                    } else {
                      if (this.N != Q.numRows || this.N != Q.numCols) {
                        throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                      } else {
                        org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                      }
                    }
                    for (var i: number = 0; i < this.N; i++) {
                      this.w[i] = 0;
                    }
                    if (transposed) {
                      for (var j: number = this.N - 2; j >= 0; j--) {
                        this.w[j + 1] = 1;
                        for (var i: number = j + 2; i < this.N; i++) {
                          this.w[i] = this.QT.data[j * this.N + i];
                        }
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N);
                      }
                    } else {
                      for (var j: number = this.N - 2; j >= 0; j--) {
                        this.w[j + 1] = 1;
                        for (var i: number = j + 2; i < this.N; i++) {
                          this.w[i] = this.QT.get(j, i);
                        }
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N, this.b);
                      }
                    }
                    return Q;
                  }
                  public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.init(A);
                    for (var k: number = 1; k < this.N; k++) {
                      this.similarTransform(k);
                    }
                    return true;
                  }
                  private similarTransform(k: number): void {
                    var t: Float64Array = this.QT.data;
                    var max: number = 0;
                    var rowU: number = (k - 1) * this.N;
                    for (var i: number = k; i < this.N; i++) {
                      var val: number = Math.abs(t[rowU + i]);
                      if (val > max) {
                        max = val;
                      }
                    }
                    if (max > 0) {
                      var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k, this.N, t, rowU, max);
                      var nu: number = t[rowU + k] + tau;
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements(k + 1, this.N, t, rowU, nu);
                      t[rowU + k] = 1.0;
                      var gamma: number = nu / tau;
                      this.gammas[k] = gamma;
                      this.householderSymmetric(k, gamma);
                      t[rowU + k] = -tau * max;
                    } else {
                      this.gammas[k] = 0;
                    }
                  }
                  public householderSymmetric(row: number, gamma: number): void {
                    var startU: number = (row - 1) * this.N;
                    for (var i: number = row; i < this.N; i++) {
                      var total: number = 0;
                      for (var j: number = row; j < i; j++) {
                        total += this.QT.data[j * this.N + i] * this.QT.data[startU + j];
                      }
                      for (var j: number = i; j < this.N; j++) {
                        total += this.QT.data[i * this.N + j] * this.QT.data[startU + j];
                      }
                      this.w[i] = -gamma * total;
                    }
                    var alpha: number = 0;
                    for (var i: number = row; i < this.N; i++) {
                      alpha += this.QT.data[startU + i] * this.w[i];
                    }
                    alpha *= -0.5 * gamma;
                    for (var i: number = row; i < this.N; i++) {
                      this.w[i] += alpha * this.QT.data[startU + i];
                    }
                    for (var i: number = row; i < this.N; i++) {
                      var ww: number = this.w[i];
                      var uu: number = this.QT.data[startU + i];
                      var rowA: number = i * this.N;
                      for (var j: number = i; j < this.N; j++) {
                        this.QT.data[rowA + j] += ww * this.QT.data[startU + j] + this.w[j] * uu;
                      }
                    }
                  }
                  public init(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    if (A.numRows != A.numCols) {
                      throw new Error("Must be square");
                    }
                    if (A.numCols != this.N) {
                      this.N = A.numCols;
                      if (this.w.length < this.N) {
                        this.w = new Float64Array(this.N);
                        this.gammas = new Float64Array(this.N);
                        this.b = new Float64Array(this.N);
                      }
                    }
                    this.QT = A;
                  }
                  public inputModified(): boolean {
                    return true;
                  }
                }
                export class SwitchingEigenDecomposition {
                  private tol: number;
                  public symmetricAlg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64;
                  public generalAlg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64;
                  public symmetric: boolean;
                  public computeVectors: boolean;
                  public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                  constructor(matrixSize: number, computeVectors: boolean, tol: number) {
                    var decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64();
                    this.symmetricAlg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64(decomp, computeVectors);
                    this.generalAlg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64(computeVectors);
                    this.computeVectors = computeVectors;
                    this.tol = tol;
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.symmetric ? this.symmetricAlg.getNumberOfEigenvalues() : this.generalAlg.getNumberOfEigenvalues();
                  }
                  public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                    return this.symmetric ? this.symmetricAlg.getEigenvalue(index) : this.generalAlg.getEigenvalue(index);
                  }
                  public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                    if (!this.computeVectors) {
                      throw new Error("Configured to not compute eignevectors");
                    }
                    return this.symmetric ? this.symmetricAlg.getEigenVector(index) : this.generalAlg.getEigenVector(index);
                  }
                  public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.A.setMatrix(orig);
                    this.symmetric = org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isSymmetricDouble(this.A, this.tol);
                    return this.symmetric ? this.symmetricAlg.decompose(this.A) : this.generalAlg.decompose(this.A);
                  }
                  public inputModified(): boolean {
                    return false;
                  }
                }
                export class WatchedDoubleStepQREigen {
                  private rand: java.util.Random = new java.util.Random();
                  private N: number;
                  public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  private gamma: number;
                  private _temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public numStepsFind: Int32Array;
                  public steps: number;
                  public eigenvalues: org.kevoree.modeling.util.maths.matrix.Complex64F[];
                  public numEigen: number;
                  private valueSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                  private temp: Float64Array = new Float64Array(9);
                  private printHumps: boolean = false;
                  public checkHessenberg: boolean = false;
                  private checkOrthogonal: boolean = false;
                  private checkUncountable: boolean = false;
                  private useStandardEq: boolean = false;
                  private useCareful2x2: boolean = true;
                  private normalize: boolean = true;
                  public lastExceptional: number;
                  public numExceptional: number;
                  public exceptionalThreshold: number = 20;
                  public maxIterations: number = this.exceptionalThreshold * 20;
                  public createR: boolean = true;
                  public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                  public incrementSteps(): void {
                    this.steps++;
                  }
                  public setQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    this.Q = Q;
                  }
                  private addEigenvalue(v: number): void {
                    this.numStepsFind[this.numEigen] = this.steps;
                    this.eigenvalues[this.numEigen].setValues(v, 0);
                    this.numEigen++;
                    this.steps = 0;
                    this.lastExceptional = 0;
                  }
                  private addEigenvalue2arg(v: number, i: number): void {
                    this.numStepsFind[this.numEigen] = this.steps;
                    this.eigenvalues[this.numEigen].setValues(v, i);
                    this.numEigen++;
                    this.steps = 0;
                    this.lastExceptional = 0;
                  }
                  public setChecks(hessenberg: boolean, orthogonal: boolean, uncountable: boolean): void {
                    this.checkHessenberg = hessenberg;
                    this.checkOrthogonal = orthogonal;
                    this.checkUncountable = uncountable;
                  }
                  public isZero(x1: number, x2: number): boolean {
                    var target: number = Math.abs(this.A.get(x1, x2));
                    var above: number = Math.abs(this.A.get(x1 - 1, x2));
                    var right: number = Math.abs(this.A.get(x1, x2 + 1));
                    return target <= 0.5 * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS * (above + right);
                  }
                  public setup(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    if (A.numRows != A.numCols) {
                      throw new Error("Must be square");
                    }
                    if (this.N != A.numRows) {
                      this.N = A.numRows;
                      this.A = A.copy();
                      this.u = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                      this._temp = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                      this.numStepsFind = new Int32Array(A.numRows);
                    } else {
                      this.A.setMatrix(A);
                    }
                    for (var i: number = 2; i < this.N; i++) {
                      for (var j: number = 0; j < i - 1; j++) {
                        this.A.set(i, j, 0);
                      }
                    }
                    this.eigenvalues = new Array<org.kevoree.modeling.util.maths.matrix.Complex64F>(A.numRows);
                    for (var i: number = 0; i < this.eigenvalues.length; i++) {
                      this.eigenvalues[i] = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                    }
                    this.numEigen = 0;
                    this.lastExceptional = 0;
                    this.numExceptional = 0;
                    this.steps = 0;
                  }
                  public exceptionalShift(x1: number, x2: number): void {
                    if (this.printHumps) {
                      console.log("Performing exceptional implicit double step");
                    }
                    var val: number = Math.abs(this.A.get(x2, x2));
                    if (val == 0) {
                      val = 1;
                    }
                    this.numExceptional++;
                    var p: number = 1 - Math.pow(0.1, this.numExceptional);
                    val *= p + 2.0 * (1.0 - p) * (this.rand.nextDouble() - 0.5);
                    if (this.rand.nextBoolean()) {
                      val = -val;
                    }
                    this.performImplicitSingleStep(x1, x2, val);
                    this.lastExceptional = this.steps;
                  }
                  public implicitDoubleStep(x1: number, x2: number): void {
                    if (this.printHumps) {
                      console.log("Performing implicit double step");
                    }
                    var z11: number = this.A.get(x2 - 1, x2 - 1);
                    var z12: number = this.A.get(x2 - 1, x2);
                    var z21: number = this.A.get(x2, x2 - 1);
                    var z22: number = this.A.get(x2, x2);
                    var a11: number = this.A.get(x1, x1);
                    var a21: number = this.A.get(x1 + 1, x1);
                    var a12: number = this.A.get(x1, x1 + 1);
                    var a22: number = this.A.get(x1 + 1, x1 + 1);
                    var a32: number = this.A.get(x1 + 2, x1 + 1);
                    if (this.normalize) {
                      this.temp[0] = a11;
                      this.temp[1] = a21;
                      this.temp[2] = a12;
                      this.temp[3] = a22;
                      this.temp[4] = a32;
                      this.temp[5] = z11;
                      this.temp[6] = z22;
                      this.temp[7] = z12;
                      this.temp[8] = z21;
                      var max: number = Math.abs(this.temp[0]);
                      for (var j: number = 1; j < this.temp.length; j++) {
                        if (Math.abs(this.temp[j]) > max) {
                          max = Math.abs(this.temp[j]);
                        }
                      }
                      a11 /= max;
                      a21 /= max;
                      a12 /= max;
                      a22 /= max;
                      a32 /= max;
                      z11 /= max;
                      z22 /= max;
                      z12 /= max;
                      z21 /= max;
                    }
                    var b11: number, b21: number, b31: number;
                    if (this.useStandardEq) {
                      b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) / a21 + a12;
                      b21 = a11 + a22 - z11 - z22;
                      b31 = a32;
                    } else {
                      b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) + a12 * a21;
                      b21 = (a11 + a22 - z11 - z22) * a21;
                      b31 = a32 * a21;
                    }
                    this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                  }
                  public performImplicitDoubleStep(x1: number, x2: number, real: number, img: number): void {
                    var a11: number = this.A.get(x1, x1);
                    var a21: number = this.A.get(x1 + 1, x1);
                    var a12: number = this.A.get(x1, x1 + 1);
                    var a22: number = this.A.get(x1 + 1, x1 + 1);
                    var a32: number = this.A.get(x1 + 2, x1 + 1);
                    var p_plus_t: number = 2.0 * real;
                    var p_times_t: number = real * real + img * img;
                    var b11: number, b21: number, b31: number;
                    if (this.useStandardEq) {
                      b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) / a21 + a12;
                      b21 = a11 + a22 - p_plus_t;
                      b31 = a32;
                    } else {
                      b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) + a12 * a21;
                      b21 = (a11 + a22 - p_plus_t) * a21;
                      b31 = a32 * a21;
                    }
                    this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                  }
                  private performImplicitDoubleStep5arg(x1: number, x2: number, b11: number, b21: number, b31: number): void {
                    if (!this.bulgeDoubleStepQn6arg(x1, b11, b21, b31, 0, false)) {
                      return;
                    }
                    if (this.Q != null) {
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 3, this._temp.data);
                    }
                    for (var i: number = x1; i < x2 - 2; i++) {
                      if (this.bulgeDoubleStepQn(i) && this.Q != null) {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 4, this._temp.data);
                      }
                    }
                    if (x2 - 2 >= 0 && this.bulgeSingleStepQn(x2 - 2) && this.Q != null) {
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x2 - 1, x2 + 1, this._temp.data);
                    }
                  }
                  public performImplicitSingleStep(x1: number, x2: number, eigenvalue: number): void {
                    if (!this.createBulgeSingleStep(x1, eigenvalue)) {
                      return;
                    }
                    if (this.Q != null) {
                      org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 2, this._temp.data);
                    }
                    for (var i: number = x1; i < x2 - 1; i++) {
                      if (this.bulgeSingleStepQn(i) && this.Q != null) {
                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 3, this._temp.data);
                      }
                    }
                  }
                  public createBulgeSingleStep(x1: number, eigenvalue: number): boolean {
                    var b11: number = this.A.get(x1, x1) - eigenvalue;
                    var b21: number = this.A.get(x1 + 1, x1);
                    var threshold: number = Math.abs(this.A.get(x1, x1)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                    return this.bulgeSingleStepQn5arg(x1, b11, b21, threshold, false);
                  }
                  public bulgeDoubleStepQn(i: number): boolean {
                    var a11: number = this.A.get(i + 1, i);
                    var a21: number = this.A.get(i + 2, i);
                    var a31: number = this.A.get(i + 3, i);
                    var threshold: number = Math.abs(this.A.get(i, i)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                    return this.bulgeDoubleStepQn6arg(i + 1, a11, a21, a31, threshold, true);
                  }
                  public bulgeDoubleStepQn6arg(i: number, a11: number, a21: number, a31: number, threshold: number, set: boolean): boolean {
                    var max: number;
                    if (this.normalize) {
                      var absA11: number = Math.abs(a11);
                      var absA21: number = Math.abs(a21);
                      var absA31: number = Math.abs(a31);
                      max = absA11 > absA21 ? absA11 : absA21;
                      if (absA31 > max) {
                        max = absA31;
                      }
                      if (max <= threshold) {
                        if (set) {
                          this.A.set(i, i - 1, 0);
                          this.A.set(i + 1, i - 1, 0);
                          this.A.set(i + 2, i - 1, 0);
                        }
                        return false;
                      }
                      a11 /= max;
                      a21 /= max;
                      a31 /= max;
                    } else {
                      max = 1;
                    }
                    var tau: number = Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31);
                    if (a11 < 0) {
                      tau = -tau;
                    }
                    var div: number = a11 + tau;
                    this.u.set(i, 0, 1);
                    this.u.set(i + 1, 0, a21 / div);
                    this.u.set(i + 2, 0, a31 / div);
                    this.gamma = div / tau;
                    org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 3, this._temp.data);
                    if (set) {
                      this.A.set(i, i - 1, -max * tau);
                      this.A.set(i + 1, i - 1, 0);
                      this.A.set(i + 2, i - 1, 0);
                    }
                    org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 3);
                    return true;
                  }
                  public bulgeSingleStepQn(i: number): boolean {
                    var a11: number = this.A.get(i + 1, i);
                    var a21: number = this.A.get(i + 2, i);
                    var threshold: number = Math.abs(this.A.get(i, i)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                    return this.bulgeSingleStepQn5arg(i + 1, a11, a21, threshold, true);
                  }
                  public bulgeSingleStepQn5arg(i: number, a11: number, a21: number, threshold: number, set: boolean): boolean {
                    var max: number;
                    if (this.normalize) {
                      max = Math.abs(a11);
                      if (max < Math.abs(a21)) {
                        max = Math.abs(a21);
                      }
                      if (max <= threshold) {
                        if (set) {
                          this.A.set(i, i - 1, 0);
                          this.A.set(i + 1, i - 1, 0);
                        }
                        return false;
                      }
                      a11 /= max;
                      a21 /= max;
                    } else {
                      max = 1;
                    }
                    var tau: number = Math.sqrt(a11 * a11 + a21 * a21);
                    if (a11 < 0) {
                      tau = -tau;
                    }
                    var div: number = a11 + tau;
                    this.u.set(i, 0, 1);
                    this.u.set(i + 1, 0, a21 / div);
                    this.gamma = div / tau;
                    org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 2, this._temp.data);
                    if (set) {
                      this.A.set(i, i - 1, -max * tau);
                      this.A.set(i + 1, i - 1, 0);
                    }
                    org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 2);
                    return true;
                  }
                  public eigen2by2_scale(a11: number, a12: number, a21: number, a22: number): void {
                    var abs11: number = Math.abs(a11);
                    var abs22: number = Math.abs(a22);
                    var abs12: number = Math.abs(a12);
                    var abs21: number = Math.abs(a21);
                    var max: number = abs11 > abs22 ? abs11 : abs22;
                    if (max < abs12) {
                      max = abs12;
                    }
                    if (max < abs21) {
                      max = abs21;
                    }
                    if (max == 0) {
                      this.valueSmall.value0.real = 0;
                      this.valueSmall.value0.imaginary = 0;
                      this.valueSmall.value1.real = 0;
                      this.valueSmall.value1.imaginary = 0;
                    } else {
                      a12 /= max;
                      a21 /= max;
                      a11 /= max;
                      a22 /= max;
                      if (this.useCareful2x2) {
                        this.valueSmall.value2x2(a11, a12, a21, a22);
                      } else {
                        this.valueSmall.value2x2_fast(a11, a12, a21, a22);
                      }
                      this.valueSmall.value0.real *= max;
                      this.valueSmall.value0.imaginary *= max;
                      this.valueSmall.value1.real *= max;
                      this.valueSmall.value1.imaginary *= max;
                    }
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.numEigen;
                  }
                  public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                    return this.eigenvalues;
                  }
                  public addComputedEigen2x2(x1: number, x2: number): void {
                    this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                    if (this.checkUncountable && (org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.valueSmall.value0.real) || org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.valueSmall.value1.real))) {
                      throw new Error("Uncountable");
                    }
                    this.addEigenvalue2arg(this.valueSmall.value0.real, this.valueSmall.value0.imaginary);
                    this.addEigenvalue2arg(this.valueSmall.value1.real, this.valueSmall.value1.imaginary);
                  }
                  public isReal2x2(x1: number, x2: number): boolean {
                    this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                    return this.valueSmall.value0.isReal();
                  }
                  public addEigenAt(x1: number): void {
                    this.addEigenvalue(this.A.get(x1, x1));
                  }
                  public printSteps(): void {
                    for (var i: number = 0; i < this.N; i++) {
                      console.log("Step[" + i + "] = " + this.numStepsFind[i]);
                    }
                  }
                }
                export class WatchedDoubleStepQREigenvalue {
                  public implicitQR: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                  public splits: Int32Array;
                  public numSplits: number;
                  public x1: number;
                  public x2: number;
                  constructor() {
                    this.implicitQR = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen();
                  }
                  public setup(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                    this.implicitQR.setup(A);
                    this.implicitQR.setQ(null);
                    this.splits = new Int32Array(A.numRows);
                    this.numSplits = 0;
                  }
                  public process(origA: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                    this.setup(origA);
                    this.x1 = 0;
                    this.x2 = origA.numRows - 1;
                    while (this.implicitQR.numEigen < origA.numRows){
                      if (this.implicitQR.steps > this.implicitQR.maxIterations) {
                        return false;
                      }
                      this.implicitQR.incrementSteps();
                      if (this.x2 < this.x1) {
                        this.moveToNextSplit();
                      } else {
                        if (this.x2 - this.x1 == 0) {
                          this.implicitQR.addEigenAt(this.x1);
                          this.x2--;
                        } else {
                          if (this.x2 - this.x1 == 1) {
                            this.implicitQR.addComputedEigen2x2(this.x1, this.x2);
                            this.x2 -= 2;
                          } else {
                            if (this.implicitQR.steps - this.implicitQR.lastExceptional > this.implicitQR.exceptionalThreshold) {
                              if (org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.implicitQR.A.get(this.x2, this.x2))) {
                                return false;
                              }
                              this.implicitQR.exceptionalShift(this.x1, this.x2);
                            } else {
                              if (this.implicitQR.isZero(this.x2, this.x2 - 1)) {
                                this.implicitQR.addEigenAt(this.x2);
                                this.x2--;
                              } else {
                                this.performIteration();
                              }
                            }
                          }
                        }
                      }
                    }
                    return true;
                  }
                  private moveToNextSplit(): void {
                    if (this.numSplits <= 0) {
                      throw new Error("bad");
                    }
                    this.x2 = this.splits[--this.numSplits];
                    if (this.numSplits > 0) {
                      this.x1 = this.splits[this.numSplits - 1] + 1;
                    } else {
                      this.x1 = 0;
                    }
                  }
                  private performIteration(): void {
                    var changed: boolean = false;
                    for (var i: number = this.x2; i > this.x1; i--) {
                      if (this.implicitQR.isZero(i, i - 1)) {
                        this.x1 = i;
                        this.splits[this.numSplits++] = i - 1;
                        changed = true;
                        break;
                      }
                    }
                    if (!changed) {
                      this.implicitQR.implicitDoubleStep(this.x1, this.x2);
                    }
                  }
                  public getNumberOfEigenvalues(): number {
                    return this.implicitQR.getNumberOfEigenvalues();
                  }
                  public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                    return this.implicitQR.getEigenvalues();
                  }
                  public getImplicitQR(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                    return this.implicitQR;
                  }
                }
              }
              export class TriangularSolver {
                public static solveU2arr(U: Float64Array, b: Float64Array, n: number): void {
                  for (var i: number = n - 1; i >= 0; i--) {
                    var sum: number = b[i];
                    var indexU: number = i * n + i + 1;
                    for (var j: number = i + 1; j < n; j++) {
                      sum -= U[indexU++] * b[j];
                    }
                    b[i] = sum / U[i * n + i];
                  }
                }
                public static solveU(U: Float64Array, b: Float64Array, sideLength: number, minRow: number, maxRow: number): void {
                  for (var i: number = maxRow - 1; i >= minRow; i--) {
                    var sum: number = b[i];
                    var indexU: number = i * sideLength + i + 1;
                    for (var j: number = i + 1; j < maxRow; j++) {
                      sum -= U[indexU++] * b[j];
                    }
                    b[i] = sum / U[i * sideLength + i];
                  }
                }
              }
              export class SimpleSVD<T extends org.kevoree.modeling.util.maths.matrix.SimpleMatrix> {
                private svd: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64;
                private U: T;
                private W: T;
                private V: T;
                private mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public tol: number;
                private static swapRowOrCol(M: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tran: boolean, i: number, bigIndex: number): void {
                  var tmp: number;
                  if (tran) {
                    for (var col: number = 0; col < M.numCols; col++) {
                      tmp = M.get(i, col);
                      M.set(i, col, M.get(bigIndex, col));
                      M.set(bigIndex, col, tmp);
                    }
                  } else {
                    for (var row: number = 0; row < M.numRows; row++) {
                      tmp = M.get(row, i);
                      M.set(row, i, M.get(row, bigIndex));
                      M.set(row, bigIndex, tmp);
                    }
                  }
                }
                public static singularThreshold(svd: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64): number {
                  var largest: number = 0;
                  var w: Float64Array = svd.getSingularValues();
                  var N: number = svd.numberOfSingularValues();
                  for (var j: number = 0; j < N; j++) {
                    if (w[j] > largest) {
                      largest = w[j];
                    }
                  }
                  var M: number = Math.max(svd.getNumCols(), svd.getNumRows());
                  return M * largest * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                }
                public static descendingOrder(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tranU: boolean, W: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tranV: boolean): void {
                  var numSingular: number = Math.min(W.numRows, W.numCols);
                  for (var i: number = 0; i < numSingular; i++) {
                    var bigValue: number = -1;
                    var bigIndex: number = -1;
                    for (var j: number = i; j < numSingular; j++) {
                      var v: number = W.get(j, j);
                      if (v > bigValue) {
                        bigValue = v;
                        bigIndex = j;
                      }
                    }
                    if (bigIndex == i) {
                      continue;
                    }
                    if (bigIndex == -1) {
                      break;
                    }
                    var tmp: number = W.get(i, i);
                    W.set(i, i, bigValue);
                    W.set(bigIndex, bigIndex, tmp);
                    if (V != null) {
                      org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(V, tranV, i, bigIndex);
                    }
                    if (U != null) {
                      org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(U, tranU, i, bigIndex);
                    }
                  }
                }
                constructor(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean) {
                  this.mat = mat;
                  this.svd = new org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64(compact, true, true, false);
                  if (!this.svd.decompose(mat)) {
                    throw new Error("Decomposition failed");
                  }
                  this.U = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getU(null, false));
                  this.W = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getW(null));
                  this.V = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getV(null, false));
                  org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.descendingOrder(this.U.getMatrix(), false, this.W.getMatrix(), this.V.getMatrix(), false);
                  this.tol = org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.singularThreshold(this.svd);
                }
                public getU(): T {
                  return this.U;
                }
                public getW(): T {
                  return this.W;
                }
                public getV(): T {
                  return this.V;
                }
              }
              export class SvdImplicitQrAlgorithm {
                public rand: java.util.Random = new java.util.Random();
                public Ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public Vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                public totalSteps: number;
                public maxValue: number;
                public N: number;
                public eigenSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                public numExceptional: number;
                public nextExceptional: number;
                public diag: Float64Array;
                public off: Float64Array;
                public bulge: number;
                public x1: number;
                public x2: number;
                public steps: number;
                public splits: Int32Array;
                public numSplits: number;
                private exceptionalThresh: number = 15;
                private maxIterations: number = this.exceptionalThresh * 100;
                public followScript: boolean;
                private static giveUpOnKnown: number = 10;
                private values: Float64Array;
                private fastValues: boolean = false;
                private findingZeros: boolean;
                public c: number;
                public s: number;
                constructor() {}
                public getUt(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  return this.Ut;
                }
                public setUt(ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  this.Ut = ut;
                }
                public getVt(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                  return this.Vt;
                }
                public setVt(vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                  this.Vt = vt;
                }
                public setMatrix(numRows: number, numCols: number, diag: Float64Array, off: Float64Array): void {
                  this.initParam(numRows, numCols);
                  this.diag = diag;
                  this.off = off;
                  this.maxValue = Math.abs(diag[0]);
                  for (var i: number = 1; i < this.N; i++) {
                    var a: number = Math.abs(diag[i]);
                    var b: number = Math.abs(off[i - 1]);
                    if (a > this.maxValue) {
                      this.maxValue = Math.abs(a);
                    }
                    if (b > this.maxValue) {
                      this.maxValue = Math.abs(b);
                    }
                  }
                }
                public swapDiag(diag: Float64Array): Float64Array {
                  var ret: Float64Array = this.diag;
                  this.diag = diag;
                  return ret;
                }
                public swapOff(off: Float64Array): Float64Array {
                  var ret: Float64Array = this.off;
                  this.off = off;
                  return ret;
                }
                public setMaxValue(maxValue: number): void {
                  this.maxValue = maxValue;
                }
                public initParam(M: number, N: number): void {
                  if (N > M) {
                    throw new Error("Must be a square or tall matrix");
                  }
                  this.N = N;
                  if (this.splits == null || this.splits.length < N) {
                    this.splits = new Int32Array(N);
                  }
                  this.x1 = 0;
                  this.x2 = this.N - 1;
                  this.steps = 0;
                  this.totalSteps = 0;
                  this.numSplits = 0;
                  this.numExceptional = 0;
                  this.nextExceptional = this.exceptionalThresh;
                }
                public process(): boolean {
                  this.followScript = false;
                  this.findingZeros = true;
                  return this._process();
                }
                public processValues(values: Float64Array): boolean {
                  this.followScript = true;
                  this.values = values;
                  this.findingZeros = false;
                  return this._process();
                }
                public _process(): boolean {
                  if (this.maxValue == 0) {
                    return true;
                  }
                  while (this.x2 >= 0){
                    if (this.steps > this.maxIterations) {
                      return false;
                    }
                    if (this.x1 == this.x2) {
                      this.resetSteps();
                      if (!this.nextSplit()) {
                        break;
                      }
                    } else {
                      if (this.fastValues && this.x2 - this.x1 == 1) {
                        this.resetSteps();
                        this.eigenBB_2x2(this.x1);
                        this.setSubmatrix(this.x2, this.x2);
                      } else {
                        if (this.steps >= this.nextExceptional) {
                          this.exceptionShift();
                        } else {
                          if (!this.checkForAndHandleZeros()) {
                            if (this.followScript) {
                              this.performScriptedStep();
                            } else {
                              this.performDynamicStep();
                            }
                          }
                        }
                      }
                    }
                  }
                  return true;
                }
                private performDynamicStep(): void {
                  if (this.findingZeros) {
                    if (this.steps > 6) {
                      this.findingZeros = false;
                    } else {
                      var scale: number = this.computeBulgeScale();
                      this.performImplicitSingleStep(scale, 0, false);
                    }
                  } else {
                    var scale: number = this.computeBulgeScale();
                    var lambda: number = this.selectWilkinsonShift(scale);
                    this.performImplicitSingleStep(scale, lambda, false);
                  }
                }
                private performScriptedStep(): void {
                  var scale: number = this.computeBulgeScale();
                  if (this.steps > org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm.giveUpOnKnown) {
                    this.followScript = false;
                  } else {
                    var s: number = this.values[this.x2] / scale;
                    this.performImplicitSingleStep(scale, s * s, false);
                  }
                }
                public incrementSteps(): void {
                  this.steps++;
                  this.totalSteps++;
                }
                public isOffZero(i: number): boolean {
                  var bottom: number = Math.abs(this.diag[i]) + Math.abs(this.diag[i + 1]);
                  return Math.abs(this.off[i]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                }
                public isDiagonalZero(i: number): boolean {
                  var bottom: number = Math.abs(this.diag[i + 1]) + Math.abs(this.off[i]);
                  return Math.abs(this.diag[i]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                }
                public resetSteps(): void {
                  this.steps = 0;
                  this.nextExceptional = this.exceptionalThresh;
                  this.numExceptional = 0;
                }
                public nextSplit(): boolean {
                  if (this.numSplits == 0) {
                    return false;
                  }
                  this.x2 = this.splits[--this.numSplits];
                  if (this.numSplits > 0) {
                    this.x1 = this.splits[this.numSplits - 1] + 1;
                  } else {
                    this.x1 = 0;
                  }
                  return true;
                }
                public performImplicitSingleStep(scale: number, lambda: number, byAngle: boolean): void {
                  this.createBulge(this.x1, lambda, scale, byAngle);
                  for (var i: number = this.x1; i < this.x2 - 1 && this.bulge != 0.0; i++) {
                    this.removeBulgeLeft(i, true);
                    if (this.bulge == 0) {
                      break;
                    }
                    this.removeBulgeRight(i);
                  }
                  if (this.bulge != 0) {
                    this.removeBulgeLeft(this.x2 - 1, false);
                  }
                  this.incrementSteps();
                }
                public updateRotator(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, m: number, n: number, c: number, s: number): void {
                  var rowA: number = m * Q.numCols;
                  var rowB: number = n * Q.numCols;
                  var endA: number = rowA + Q.numCols;
                  for (; rowA != endA; rowA++) {
                    var a: number = Q.getValueAtIndex(rowA);
                    var b: number = Q.getValueAtIndex(rowB);
                    Q.setValueAtIndex(rowA, c * a + s * b);
                    Q.setValueAtIndex(rowB, -s * a + c * b);
                    rowB++;
                  }
                }
                private computeBulgeScale(): number {
                  var b11: number = this.diag[this.x1];
                  var b12: number = this.off[this.x1];
                  return Math.max(Math.abs(b11), Math.abs(b12));
                }
                public createBulge(x1: number, p: number, scale: number, byAngle: boolean): void {
                  var b11: number = this.diag[x1];
                  var b12: number = this.off[x1];
                  var b22: number = this.diag[x1 + 1];
                  if (byAngle) {
                    this.c = Math.cos(p);
                    this.s = Math.sin(p);
                  } else {
                    var u1: number = (b11 / scale) * (b11 / scale) - p;
                    var u2: number = (b12 / scale) * (b11 / scale);
                    var gamma: number = Math.sqrt(u1 * u1 + u2 * u2);
                    this.c = u1 / gamma;
                    this.s = u2 / gamma;
                  }
                  this.diag[x1] = b11 * this.c + b12 * this.s;
                  this.off[x1] = b12 * this.c - b11 * this.s;
                  this.diag[x1 + 1] = b22 * this.c;
                  this.bulge = b22 * this.s;
                  if (this.Vt != null) {
                    this.updateRotator(this.Vt, x1, x1 + 1, this.c, this.s);
                  }
                }
                public computeRotator(rise: number, run: number): void {
                  if (Math.abs(rise) < Math.abs(run)) {
                    var k: number = rise / run;
                    var bottom: number = Math.sqrt(1.0 + k * k);
                    this.s = 1.0 / bottom;
                    this.c = k / bottom;
                  } else {
                    var t: number = run / rise;
                    var bottom: number = Math.sqrt(1.0 + t * t);
                    this.c = 1.0 / bottom;
                    this.s = t / bottom;
                  }
                }
                public removeBulgeLeft(x1: number, notLast: boolean): void {
                  var b11: number = this.diag[x1];
                  var b12: number = this.off[x1];
                  var b22: number = this.diag[x1 + 1];
                  this.computeRotator(b11, this.bulge);
                  this.diag[x1] = this.c * b11 + this.s * this.bulge;
                  this.off[x1] = this.c * b12 + this.s * b22;
                  this.diag[x1 + 1] = this.c * b22 - this.s * b12;
                  if (notLast) {
                    var b23: number = this.off[x1 + 1];
                    this.bulge = this.s * b23;
                    this.off[x1 + 1] = this.c * b23;
                  }
                  if (this.Ut != null) {
                    this.updateRotator(this.Ut, x1, x1 + 1, this.c, this.s);
                  }
                }
                public removeBulgeRight(x1: number): void {
                  var b12: number = this.off[x1];
                  var b22: number = this.diag[x1 + 1];
                  var b23: number = this.off[x1 + 1];
                  this.computeRotator(b12, this.bulge);
                  this.off[x1] = b12 * this.c + this.bulge * this.s;
                  this.diag[x1 + 1] = b22 * this.c + b23 * this.s;
                  this.off[x1 + 1] = -b22 * this.s + b23 * this.c;
                  var b33: number = this.diag[x1 + 2];
                  this.diag[x1 + 2] = b33 * this.c;
                  this.bulge = b33 * this.s;
                  if (this.Vt != null) {
                    this.updateRotator(this.Vt, x1 + 1, x1 + 2, this.c, this.s);
                  }
                }
                public setSubmatrix(x1: number, x2: number): void {
                  this.x1 = x1;
                  this.x2 = x2;
                }
                public selectWilkinsonShift(scale: number): number {
                  var a11: number, a22: number;
                  if (this.x2 - this.x1 > 1) {
                    var d1: number = this.diag[this.x2 - 1] / scale;
                    var o1: number = this.off[this.x2 - 2] / scale;
                    var d2: number = this.diag[this.x2] / scale;
                    var o2: number = this.off[this.x2 - 1] / scale;
                    a11 = o1 * o1 + d1 * d1;
                    a22 = o2 * o2 + d2 * d2;
                    this.eigenSmall.symm2x2_fast(a11, o2 * d1, a22);
                  } else {
                    var a: number = this.diag[this.x2 - 1] / scale;
                    var b: number = this.off[this.x2 - 1] / scale;
                    var c: number = this.diag[this.x2] / scale;
                    a11 = a * a;
                    a22 = b * b + c * c;
                    this.eigenSmall.symm2x2_fast(a11, a * b, a22);
                  }
                  var diff0: number = Math.abs(this.eigenSmall.value0.real - a22);
                  var diff1: number = Math.abs(this.eigenSmall.value1.real - a22);
                  return diff0 < diff1 ? this.eigenSmall.value0.real : this.eigenSmall.value1.real;
                }
                public static signum(d: number): number {
                  if (d < 0) {
                    return -1.0;
                  }
                  if (d > 0) {
                    return 1.0;
                  }
                  return 0.0;
                }
                public eigenBB_2x2(x1: number): void {
                  var b11: number = this.diag[x1];
                  var b12: number = this.off[x1];
                  var b22: number = this.diag[x1 + 1];
                  var absA: number = Math.abs(b11);
                  var absB: number = Math.abs(b12);
                  var absC: number = Math.abs(b22);
                  var scale: number = absA > absB ? absA : absB;
                  if (absC > scale) {
                    scale = absC;
                  }
                  if (scale == 0) {
                    return;
                  }
                  b11 /= scale;
                  b12 /= scale;
                  b22 /= scale;
                  this.eigenSmall.symm2x2_fast(b11 * b11, b11 * b12, b12 * b12 + b22 * b22);
                  this.off[x1] = 0;
                  this.diag[x1] = scale * Math.sqrt(this.eigenSmall.value0.real);
                  var sgn: number = org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm.signum(this.eigenSmall.value1.real);
                  this.diag[x1 + 1] = sgn * scale * Math.sqrt(Math.abs(this.eigenSmall.value1.real));
                }
                public checkForAndHandleZeros(): boolean {
                  for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                    if (this.isOffZero(i)) {
                      this.resetSteps();
                      this.splits[this.numSplits++] = i;
                      this.x1 = i + 1;
                      return true;
                    }
                  }
                  for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                    if (this.isDiagonalZero(i)) {
                      this.pushRight(i);
                      this.resetSteps();
                      this.splits[this.numSplits++] = i;
                      this.x1 = i + 1;
                      return true;
                    }
                  }
                  return false;
                }
                private pushRight(row: number): void {
                  if (this.isOffZero(row)) {
                    return;
                  }
                  this.rotatorPushRight(row);
                  var end: number = this.N - 2 - row;
                  for (var i: number = 0; i < end && this.bulge != 0; i++) {
                    this.rotatorPushRight2(row, i + 2);
                  }
                }
                private rotatorPushRight(m: number): void {
                  var b11: number = this.off[m];
                  var b21: number = this.diag[m + 1];
                  this.computeRotator(b21, -b11);
                  this.off[m] = 0;
                  this.diag[m + 1] = b21 * this.c - b11 * this.s;
                  if (m + 2 < this.N) {
                    var b22: number = this.off[m + 1];
                    this.off[m + 1] = b22 * this.c;
                    this.bulge = b22 * this.s;
                  } else {
                    this.bulge = 0;
                  }
                  if (this.Ut != null) {
                    this.updateRotator(this.Ut, m, m + 1, this.c, this.s);
                  }
                }
                private rotatorPushRight2(m: number, offset: number): void {
                  var b11: number = this.bulge;
                  var b12: number = this.diag[m + offset];
                  this.computeRotator(b12, -b11);
                  this.diag[m + offset] = b12 * this.c - b11 * this.s;
                  if (m + offset < this.N - 1) {
                    var b22: number = this.off[m + offset];
                    this.off[m + offset] = b22 * this.c;
                    this.bulge = b22 * this.s;
                  }
                  if (this.Ut != null) {
                    this.updateRotator(this.Ut, m, m + offset, this.c, this.s);
                  }
                }
                public exceptionShift(): void {
                  this.numExceptional++;
                  var mag: number = 0.05 * this.numExceptional;
                  if (mag > 1.0) {
                    mag = 1.0;
                  }
                  var angle: number = 2.0 * Math.PI * (this.rand.nextDouble() - 0.5) * mag;
                  this.performImplicitSingleStep(0, angle, true);
                  this.nextExceptional = this.steps + this.exceptionalThresh;
                }
                public getNumberOfSingularValues(): number {
                  return this.N;
                }
                public getSingularValue(index: number): number {
                  return this.diag[index];
                }
                public setFastValues(b: boolean): void {
                  this.fastValues = b;
                }
                public getSingularValues(): Float64Array {
                  return this.diag;
                }
                public getDiag(): Float64Array {
                  return this.diag;
                }
                public getOff(): Float64Array {
                  return this.off;
                }
                public getMaxValue(): number {
                  return this.maxValue;
                }
              }
            }
            export class MatrixFeatures {
              public static isVector(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                return (mat.getNumCols() == 1 || mat.getNumRows() == 1);
              }
              public static isSymmetricDouble(m: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                if (m.numCols != m.numRows) {
                  return false;
                }
                var max: number = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(m);
                for (var i: number = 0; i < m.numRows; i++) {
                  for (var j: number = 0; j < i; j++) {
                    var a: number = m.get(i, j) / max;
                    var b: number = m.get(j, i) / max;
                    var diff: number = Math.abs(a - b);
                    if (!(diff <= tol)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              public static isIdentical(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                  return false;
                }
                if (tol < 0) {
                  throw new Error("Tolerance must be greater than or equal to zero.");
                }
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  var valA: number = a.getValueAtIndex(i);
                  var valB: number = b.getValueAtIndex(i);
                  var diff: number = Math.abs(valA - valB);
                  if (tol >= diff) {
                    continue;
                  }
                  return false;
                }
                return true;
              }
            }
            export class MatrixMatrixMult {
              public static multTransA_smallMV(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                for (var i: number = 0; i < A.numCols; i++) {
                  var total: number = 0.0;
                  var indexA: number = i;
                  for (var j: number = 0; j < A.numRows; j++) {
                    total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                    indexA += A.numCols;
                  }
                  C.setValueAtIndex(cIndex++, total);
                }
              }
              public static multTransA_reorderMV(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (A.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.fill(C, 0);
                  return;
                }
                var B_val: number = B.getValueAtIndex(0);
                for (var i: number = 0; i < A.numCols; i++) {
                  C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                }
                var indexA: number = A.numCols;
                for (var i: number = 1; i < A.numRows; i++) {
                  B_val = B.getValueAtIndex(i);
                  for (var j: number = 0; j < A.numCols; j++) {
                    C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                  }
                }
              }
              public static multTransA_reorderMM(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (a.numCols == 0 || a.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.fill(c, 0);
                  return;
                }
                var valA: number;
                for (var i: number = 0; i < a.numCols; i++) {
                  var indexC_start: number = i * c.numCols;
                  valA = a.getValueAtIndex(i);
                  var indexB: number = 0;
                  var end: number = indexB + b.numCols;
                  var indexC: number = indexC_start;
                  while (indexB < end){
                    c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                  }
                  for (var k: number = 1; k < a.numRows; k++) {
                    valA = a.get(k, i);
                    end = indexB + b.numCols;
                    indexC = indexC_start;
                    while (indexB < end){
                      c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                    }
                  }
                }
              }
              public static multTransA_smallMM(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                for (var i: number = 0; i < a.numCols; i++) {
                  for (var j: number = 0; j < b.numCols; j++) {
                    var indexA: number = i;
                    var indexB: number = j;
                    var end: number = indexB + b.numRows * b.numCols;
                    var total: number = 0;
                    for (; indexB < end; indexB += b.numCols) {
                      total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                      indexA += a.numCols;
                    }
                    c.setValueAtIndex(cIndex++, total);
                  }
                }
              }
              public static multTransA(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (b.numCols == 1) {
                  if (a.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorderMV(a, b, c);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_smallMV(a, b, c);
                  }
                } else {
                  if (a.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH || b.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorderMM(a, b, c);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_smallMM(a, b, c);
                  }
                }
              }
              public static mult_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (a.numCols == 0 || a.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                  return;
                }
                var valA: number;
                var indexCbase: number = 0;
                var endOfKLoop: number = b.numRows * b.numCols;
                for (var i: number = 0; i < a.numRows; i++) {
                  var indexA: number = i * a.numCols;
                  var indexB: number = 0;
                  var indexC: number = indexCbase;
                  var end: number = indexB + b.numCols;
                  valA = a.getValueAtIndex(indexA++);
                  while (indexB < end){
                    c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                  }
                  while (indexB != endOfKLoop){
                    indexC = indexCbase;
                    end = indexB + b.numCols;
                    valA = a.getValueAtIndex(indexA++);
                    while (indexB < end){
                      c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                    }
                  }
                  indexCbase += c.numCols;
                }
              }
              public static mult_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var aIndexStart: number = 0;
                var cIndex: number = 0;
                for (var i: number = 0; i < a.numRows; i++) {
                  for (var j: number = 0; j < b.numCols; j++) {
                    var total: number = 0;
                    var indexA: number = aIndexStart;
                    var indexB: number = j;
                    var end: number = indexA + b.numRows;
                    while (indexA < end){
                      total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                      indexB += b.numCols;
                    }
                    c.setValueAtIndex(cIndex++, total);
                  }
                  aIndexStart += a.numCols;
                }
              }
              public static multTransA_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (a.numCols == 0 || a.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                  return;
                }
                var valA: number;
                for (var i: number = 0; i < a.numCols; i++) {
                  var indexC_start: number = i * c.numCols;
                  valA = a.getValueAtIndex(i);
                  var indexB: number = 0;
                  var end: number = indexB + b.numCols;
                  var indexC: number = indexC_start;
                  while (indexB < end){
                    c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                  }
                  for (var k: number = 1; k < a.numRows; k++) {
                    valA = a.get(k, i);
                    end = indexB + b.numCols;
                    indexC = indexC_start;
                    while (indexB < end){
                      c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                    }
                  }
                }
              }
              public static multTransA_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                for (var i: number = 0; i < a.numCols; i++) {
                  for (var j: number = 0; j < b.numCols; j++) {
                    var indexA: number = i;
                    var indexB: number = j;
                    var end: number = indexB + b.numRows * b.numCols;
                    var total: number = 0.0;
                    for (; indexB < end; indexB += b.numCols) {
                      total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                      indexA += a.numCols;
                    }
                    c.setValueAtIndex(cIndex++, total);
                  }
                }
              }
              public static multTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                var aIndexStart: number = 0;
                for (var xA: number = 0; xA < a.numRows; xA++) {
                  var end: number = aIndexStart + b.numCols;
                  var indexB: number = 0;
                  for (var xB: number = 0; xB < b.numRows; xB++) {
                    var indexA: number = aIndexStart;
                    var total: number = 0;
                    while (indexA < end){
                      total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                    }
                    c.setValueAtIndex(cIndex++, total);
                  }
                  aIndexStart += a.numCols;
                }
              }
              public static multAlphaTransA_reorder(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (a.numCols == 0 || a.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                  return;
                }
                var valA: number;
                for (var i: number = 0; i < a.numCols; i++) {
                  var indexC_start: number = i * c.numCols;
                  valA = alpha * a.getValueAtIndex(i);
                  var indexB: number = 0;
                  var end: number = indexB + b.numCols;
                  var indexC: number = indexC_start;
                  while (indexB < end){
                    c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                  }
                  for (var k: number = 1; k < a.numRows; k++) {
                    valA = alpha * a.get(k, i);
                    end = indexB + b.numCols;
                    indexC = indexC_start;
                    while (indexB < end){
                      c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                    }
                  }
                }
              }
              public static multAlphaTransA_small(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                for (var i: number = 0; i < a.numCols; i++) {
                  for (var j: number = 0; j < b.numCols; j++) {
                    var indexA: number = i;
                    var indexB: number = j;
                    var end: number = indexB + b.numRows * b.numCols;
                    var total: number = 0;
                    for (; indexB < end; indexB += b.numCols) {
                      total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                      indexA += a.numCols;
                    }
                    c.plus(cIndex++, alpha * total);
                  }
                }
              }
              public static multAdd_reorderalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (a.numCols == 0 || a.numRows == 0) {
                  return;
                }
                var valA: number;
                var indexCbase: number = 0;
                var endOfKLoop: number = b.numRows * b.numCols;
                for (var i: number = 0; i < a.numRows; i++) {
                  var indexA: number = i * a.numCols;
                  var indexB: number = 0;
                  var indexC: number = indexCbase;
                  var end: number = indexB + b.numCols;
                  valA = alpha * a.getValueAtIndex(indexA++);
                  while (indexB < end){
                    c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                  }
                  while (indexB != endOfKLoop){
                    indexC = indexCbase;
                    end = indexB + b.numCols;
                    valA = alpha * a.getValueAtIndex(indexA++);
                    while (indexB < end){
                      c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                    }
                  }
                  indexCbase += c.numCols;
                }
              }
              public static multAdd_smallalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var aIndexStart: number = 0;
                var cIndex: number = 0;
                for (var i: number = 0; i < a.numRows; i++) {
                  for (var j: number = 0; j < b.numCols; j++) {
                    var total: number = 0;
                    var indexA: number = aIndexStart;
                    var indexB: number = j;
                    var end: number = indexA + b.numRows;
                    while (indexA < end){
                      total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                      indexB += b.numCols;
                    }
                    c.plus(cIndex++, alpha * total);
                  }
                  aIndexStart += a.numCols;
                }
              }
            }
            export class DenseMatrix64F {
              public numRows: number;
              public numCols: number;
              public data: Float64Array;
              public static MULT_COLUMN_SWITCH: number = 15;
              constructor(numRows: number, numCols: number) {
                this.data = new Float64Array(numRows * numCols);
                this.numRows = numRows;
                this.numCols = numCols;
                for (var i: number = 0; i < numCols * numRows; i++) {
                  this.data[i] = 0;
                }
              }
              public constructorDenseMatrix(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                var result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(orig.numRows, orig.numCols);
                java.lang.System.arraycopy(orig.data, 0, result.data, 0, orig.getNumElements());
                return result;
              }
              public static setIdentity(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                var index: number = 0;
                for (var i: number = 0; i < width; i++) {
                  mat.data[index] = 1;
                  index += mat.numCols + 1;
                }
              }
              public static widentity(width: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                for (var i: number = 0; i < width; i++) {
                  ret.cset(i, i, 1.0);
                }
                return ret;
              }
              public static identity(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                var small: number = numRows < numCols ? numRows : numCols;
                for (var i: number = 0; i < small; i++) {
                  ret.cset(i, i, 1.0);
                }
                return ret;
              }
              public zero(): void {
                java.util.Arrays.fill(this.data, 0, this.getNumElements(), 0.0);
              }
              public copy(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                return this.constructorDenseMatrix(this);
              }
              public static fill(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, value: number): void {
                java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
              }
              public reshapeBoolean(numRows: number, numCols: number, saveValues: boolean): void {
                if (this.data.length < numRows * numCols) {
                  var d: Float64Array = new Float64Array(numRows * numCols);
                  if (saveValues) {
                    java.lang.System.arraycopy(this.data, 0, d, 0, this.getNumElements());
                  }
                  this.data = d;
                }
                this.numRows = numRows;
                this.numCols = numCols;
              }
              public cset(row: number, col: number, value: number): void {
                this.data[row * this.numCols + col] = value;
              }
              public add(row: number, col: number, value: number): void {
                this.data[row * this.numCols + col] += value;
              }
              public plus(index: number, val: number): number {
                return this.data[index] += val;
              }
              public scale(value: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                for (var i: number = 0; i < this.data.length; i++) {
                  this.data[i] *= value;
                }
                return this;
              }
              public minus(index: number, val: number): number {
                return this.data[index] -= val;
              }
              public times(index: number, val: number): number {
                return this.data[index] *= val;
              }
              public div(index: number, val: number): number {
                return this.data[index] /= val;
              }
              public reshape(numRows: number, numCols: number): void {
                this.reshapeBoolean(numRows, numCols, false);
              }
              public getNumRows(): number {
                return this.numRows;
              }
              public getNumCols(): number {
                return this.numCols;
              }
              public getData(): Float64Array {
                return this.data;
              }
              public get(row: number, col: number): number {
                return this.data[row * this.numCols + col];
              }
              public getNumElements(): number {
                return this.numRows * this.numCols;
              }
              public getIndex(row: number, col: number): number {
                return row * this.numCols + col;
              }
              public getValueAtIndex(index: number): number {
                return this.data[index];
              }
              public setValueAtIndex(index: number, val: number): number {
                return this.data[index] = val;
              }
              public setNumRows(numRows: number): void {
                this.numRows = numRows;
              }
              public setNumCols(numCols: number): void {
                this.numCols = numCols;
              }
              public setData(data: Float64Array): void {
                this.data = data;
              }
              public setMatrix(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                this.reshape(b.numRows, b.numCols);
                var dataLength: number = b.getNumElements();
                java.lang.System.arraycopy(b.data, 0, this.data, 0, dataLength);
              }
              public set(row: number, col: number, value: number): void {
                this.data[row * this.numCols + col] = value;
              }
            }
            export class Complex64F {
              public real: number;
              public imaginary: number;
              constructor() {}
              public getReal(): number {
                return this.real;
              }
              public getMagnitude(): number {
                return Math.sqrt(this.real * this.real + this.imaginary * this.imaginary);
              }
              public getMagnitude2(): number {
                return this.real * this.real + this.imaginary * this.imaginary;
              }
              public setReal(real: number): void {
                this.real = real;
              }
              public setValues(real: number, imaginary: number): void {
                this.real = real;
                this.imaginary = imaginary;
              }
              public isReal(): boolean {
                return this.imaginary == 0.0;
              }
              public toString(): string {
                if (this.imaginary == 0) {
                  return "" + this.real;
                } else {
                  return this.real + " " + this.imaginary + "i";
                }
              }
              public times(a: org.kevoree.modeling.util.maths.matrix.Complex64F): org.kevoree.modeling.util.maths.matrix.Complex64F {
                var ret: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                org.kevoree.modeling.util.maths.matrix.ComplexMath64F.multiply(this, a, ret);
                return ret;
              }
            }
            export class MatrixVectorMult {
              public static mult(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (A.numCols == 0) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(C, 0);
                  return;
                }
                var indexA: number = 0;
                var cIndex: number = 0;
                var b0: number = B.getValueAtIndex(0);
                for (var i: number = 0; i < A.numRows; i++) {
                  var total: number = A.getValueAtIndex(indexA++) * b0;
                  for (var j: number = 1; j < A.numCols; j++) {
                    total += A.getValueAtIndex(indexA++) * B.getValueAtIndex(j);
                  }
                  C.setValueAtIndex(cIndex++, total);
                }
              }
              public static multTransA_small(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var cIndex: number = 0;
                for (var i: number = 0; i < A.numCols; i++) {
                  var total: number = 0;
                  var indexA: number = i;
                  for (var j: number = 0; j < A.numRows; j++) {
                    total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                    indexA += A.numCols;
                  }
                  C.setValueAtIndex(cIndex++, total);
                }
              }
              public static multTransA_reorder(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (A.numRows == 0) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(C, 0);
                  return;
                }
                var B_val: number = B.getValueAtIndex(0);
                for (var i: number = 0; i < A.numCols; i++) {
                  C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                }
                var indexA: number = A.numCols;
                for (var i: number = 1; i < A.numRows; i++) {
                  B_val = B.getValueAtIndex(i);
                  for (var j: number = 0; j < A.numCols; j++) {
                    C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                  }
                }
              }
            }
            export class TransposeAlgs {
              public static square(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var index: number = 1;
                var indexEnd: number = mat.numCols;
                for (var i: number = 0; i < mat.numRows; i++) {
                  var indexOther: number = (i + 1) * mat.numCols + i;
                  for (; index < indexEnd; index++) {
                    var val: number = mat.data[index];
                    mat.data[index] = mat.data[indexOther];
                    mat.data[indexOther] = val;
                    indexOther += mat.numCols;
                  }
                  index += i + 2;
                  indexEnd += mat.numCols;
                }
              }
              public static block(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, blockLength: number): void {
                for (var i: number = 0; i < A.numRows; i += blockLength) {
                  var blockHeight: number = Math.min(blockLength, A.numRows - i);
                  var indexSrc: number = i * A.numCols;
                  var indexDst: number = i;
                  for (var j: number = 0; j < A.numCols; j += blockLength) {
                    var blockWidth: number = Math.min(blockLength, A.numCols - j);
                    var indexSrcEnd: number = indexSrc + blockWidth;
                    for (; indexSrc < indexSrcEnd; indexSrc++) {
                      var rowSrc: number = indexSrc;
                      var rowDst: number = indexDst;
                      var end: number = rowDst + blockHeight;
                      for (; rowDst < end; rowSrc += A.numCols) {
                        A_tran.data[rowDst++] = A.data[rowSrc];
                      }
                      indexDst += A_tran.numCols;
                    }
                  }
                }
              }
              public static standard(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var index: number = 0;
                for (var i: number = 0; i < A_tran.numRows; i++) {
                  var index2: number = i;
                  var end: number = index + A_tran.numCols;
                  while (index < end){
                    A_tran.data[index++] = A.data[index2];
                    index2 += A.numCols;
                  }
                }
              }
            }
            export class CommonOps {
              public static BLOCK_WIDTH: number = 60;
              public static TRANSPOSE_SWITCH: number = 375;
              public static MULT_COLUMN_SWITCH: number = 15;
              public static EPS: number = Math.pow(2, -52);
              public static mult(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (b.numCols == 1) {
                  org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                } else {
                  if (b.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH) {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_reorder(a, b, c);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_small(a, b, c);
                  }
                }
              }
              public static memset(data: Float64Array, val: number): void {
                for (var i: number = 0; i < data.length; i++) {
                  data[i] = val;
                }
              }
              public static multAddalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (b.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH) {
                  org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_reorderalpha(alpha, a, b, c);
                } else {
                  org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_smallalpha(alpha, a, b, c);
                }
              }
              public static multAlphaBetaTransA(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number): void {
                c.scale(beta);
                if (a.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH || b.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH) {
                  org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAlphaTransA_reorder(alpha, a, b, c);
                } else {
                  org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAlphaTransA_small(alpha, a, b, c);
                }
              }
              public static multTransA(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (b.numCols == 1) {
                  if (a.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH) {
                    org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_reorder(a, b, c);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_small(a, b, c);
                  }
                } else {
                  if (a.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH || b.numCols >= org.kevoree.modeling.util.maths.matrix.CommonOps.MULT_COLUMN_SWITCH) {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorder(a, b, c);
                  } else {
                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_small(a, b, c);
                  }
                }
              }
              public static multTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (b.numRows == 1) {
                  org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                } else {
                  org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransB(a, b, c);
                }
              }
              public static subvector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, rowA: number, colA: number, length: number, row: boolean, offsetV: number, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (row) {
                  for (var i: number = 0; i < length; i++) {
                    v.setValueAtIndex(offsetV + i, A.get(rowA, colA + i));
                  }
                } else {
                  for (var i: number = 0; i < length; i++) {
                    v.setValueAtIndex(offsetV + i, A.get(rowA + i, colA));
                  }
                }
              }
              public static abs(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                for (var i: number = 0; i < matrix.numRows(); i++) {
                  for (var j: number = 0; j < matrix.numCols(); j++) {
                    matrix.setValue2D(i, j, Math.abs(matrix.getValue2D(i, j)));
                  }
                }
                return matrix;
              }
              public static trace(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var N: number = Math.min(a.numRows, a.numCols);
                var sum: number = 0;
                var index: number = 0;
                for (var i: number = 0; i < N; i++) {
                  sum += a.getValueAtIndex(index);
                  index += 1 + a.numCols;
                }
                return sum;
              }
              public static transposeMatrix(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                if (A_tran == null) {
                  A_tran = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numCols, A.numRows);
                } else {
                  if (A.numRows != A_tran.numCols || A.numCols != A_tran.numRows) {
                    throw new Error("Incompatible matrix dimensions");
                  }
                }
                if (A.numRows > org.kevoree.modeling.util.maths.matrix.CommonOps.TRANSPOSE_SWITCH && A.numCols > org.kevoree.modeling.util.maths.matrix.CommonOps.TRANSPOSE_SWITCH) {
                  org.kevoree.modeling.util.maths.matrix.TransposeAlgs.block(A, A_tran, org.kevoree.modeling.util.maths.matrix.CommonOps.BLOCK_WIDTH);
                } else {
                  org.kevoree.modeling.util.maths.matrix.TransposeAlgs.standard(A, A_tran);
                }
                return A_tran;
              }
              public static transpose(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                if (mat.numCols == mat.numRows) {
                  org.kevoree.modeling.util.maths.matrix.TransposeAlgs.square(mat);
                } else {
                  var b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(mat.numCols, mat.numRows);
                  org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(mat, b);
                  mat.setMatrix(b);
                }
              }
              public static det(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var numCol: number = mat.getNumCols();
                var numRow: number = mat.getNumRows();
                if (numCol != numRow) {
                  throw new Error("Must be a square matrix.");
                } else {
                  if (numCol <= 1) {
                    return mat.getValueAtIndex(0);
                  } else {
                    var alg: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64();
                    if (!alg.decompose(mat)) {
                      return 0.0;
                    }
                    return alg.computeDeterminant();
                  }
                }
              }
              public static invert(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                var alg: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64();
                var solver: org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64(alg);
                if (solver.modifiesA()) {
                  mat = mat.copy();
                }
                if (!solver.setA(mat)) {
                  return false;
                }
                solver.invert(result);
                return true;
              }
              public static copyMatrix(matA: org.kevoree.modeling.util.maths.structure.KArray2D, ejmlmatA: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                for (var i: number = 0; i < matA.rows(); i++) {
                  for (var j: number = 0; j < matA.columns(); j++) {
                    ejmlmatA.setValue2D(i, j, matA.get(i, j));
                  }
                }
              }
              public static copyMatrixDense(matA: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D, ejmlmatA: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                for (var i: number = 0; i < matA.rows(); i++) {
                  for (var j: number = 0; j < matA.columns(); j++) {
                    ejmlmatA.set(i, j, matA.get(i, j));
                  }
                }
              }
              public static extractImpl(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcX0: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number, numRows: number, numCols: number): void {
                for (var y: number = 0; y < numRows; y++) {
                  var indexSrc: number = src.getIndex(y + srcY0, srcX0);
                  var indexDst: number = dst.getIndex(y + dstY0, dstX0);
                  java.lang.System.arraycopy(src.data, indexSrc, dst.data, indexDst, numCols);
                }
              }
              public static extractInsert(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                var w: number = srcX1 - srcX0;
                var h: number = srcY1 - srcY0;
                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
              }
              public static insert(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dest: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, destY0: number, destX0: number): void {
                org.kevoree.modeling.util.maths.matrix.CommonOps.extractInsert(src, 0, src.getNumRows(), 0, src.getNumCols(), dest, destY0, destX0);
              }
              public static extract4Int(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                if (srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.numRows) {
                  throw new Error("srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.getNumRows");
                }
                if (srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.numCols) {
                  throw new Error("srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.getNumCols");
                }
                var w: number = srcX1 - srcX0;
                var h: number = srcY1 - srcY0;
                var dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(h, w);
                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, 0, 0, h, w);
                return dst;
              }
              public static columnsToVector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[]): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                if (v == null || v.length < A.numCols) {
                  ret = new Array<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F>(A.numCols);
                } else {
                  ret = v;
                }
                for (var i: number = 0; i < ret.length; i++) {
                  if (ret[i] == null) {
                    ret[i] = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                  } else {
                    ret[i].reshapeBoolean(A.numRows, 1, false);
                  }
                  var u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = ret[i];
                  for (var j: number = 0; j < A.numRows; j++) {
                    u.set(j, 0, A.get(j, i));
                  }
                }
                return ret;
              }
              public static rowsToVector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[]): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                if (v == null || v.length < A.numRows) {
                  ret = new Array<org.kevoree.modeling.util.maths.matrix.DenseMatrix64F>(A.numRows);
                } else {
                  ret = v;
                }
                for (var i: number = 0; i < ret.length; i++) {
                  if (ret[i] == null) {
                    ret[i] = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numCols, 1);
                  } else {
                    ret[i].reshapeBoolean(A.numCols, 1, false);
                  }
                  var u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = ret[i];
                  for (var j: number = 0; j < A.numCols; j++) {
                    u.set(j, 0, A.get(i, j));
                  }
                }
                return ret;
              }
              public static setIdentity(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                var index: number = 0;
                for (var i: number = 0; i < width; i++) {
                  mat.data[index] = 1;
                  index += mat.numCols + 1;
                }
              }
              public static identity1D(width: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                for (var i: number = 0; i < width; i++) {
                  ret.set(i, i, 1.0);
                }
                return ret;
              }
              public static identity(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                var small: number = numRows < numCols ? numRows : numCols;
                for (var i: number = 0; i < small; i++) {
                  ret.set(i, i, 1.0);
                }
                return ret;
              }
              public static diag(diagEl: Float64Array): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                return org.kevoree.modeling.util.maths.matrix.CommonOps.diagMatrix(null, diagEl.length, diagEl);
              }
              public static diagMatrix(ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, width: number, diagEl: Float64Array): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                if (ret == null) {
                  ret = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                } else {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.fill(ret, 0);
                }
                for (var i: number = 0; i < width; i++) {
                  ret.set(i, i, diagEl[i]);
                }
                return ret;
              }
              public static kron(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var numColsC: number = A.numCols * B.numCols;
                var numRowsC: number = A.numRows * B.numRows;
                for (var i: number = 0; i < A.numRows; i++) {
                  for (var j: number = 0; j < A.numCols; j++) {
                    var a: number = A.get(i, j);
                    for (var rowB: number = 0; rowB < B.numRows; rowB++) {
                      for (var colB: number = 0; colB < B.numCols; colB++) {
                        var val: number = a * B.get(rowB, colB);
                        C.set(i * B.numRows + rowB, j * B.numCols + colB, val);
                      }
                    }
                  }
                }
              }
              public static extractDiag(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var N: number = Math.min(src.numRows, src.numCols);
                if (!org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isVector(dst)) {
                  throw new Error("Expected a vector for dst.");
                }
                for (var i: number = 0; i < N; i++) {
                  dst.setValueAtIndex(i, src.get(i, i));
                }
              }
              public static extractRow(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, row: number, out: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                if (out == null) {
                  out = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, a.numCols);
                }
                java.lang.System.arraycopy(a.data, a.getIndex(row, 0), out.data, 0, a.numCols);
                return out;
              }
              public static extractColumn(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, column: number, out: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                if (out == null) {
                  out = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(a.numRows, 1);
                }
                var index: number = column;
                for (var i: number = 0; i < a.numRows; i++) {
                  out.data[i] = a.data[index];
                  index += a.numCols;
                }
                return out;
              }
              public static elementMax(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var size: number = a.getNumElements();
                var max: number = a.getValueAtIndex(0);
                for (var i: number = 1; i < size; i++) {
                  var val: number = a.getValueAtIndex(i);
                  if (val >= max) {
                    max = val;
                  }
                }
                return max;
              }
              public static elementMaxAbs(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var size: number = a.getNumElements();
                var max: number = 0;
                for (var i: number = 0; i < size; i++) {
                  var val: number = Math.abs(a.getValueAtIndex(i));
                  if (val > max) {
                    max = val;
                  }
                }
                return max;
              }
              public static elementMult(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  c.setValueAtIndex(i, a.getValueAtIndex(i) * b.getValueAtIndex(i));
                }
              }
              public static elementSum(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var total: number = 0;
                var size: number = mat.getNumElements();
                for (var i: number = 0; i < size; i++) {
                  total += mat.getValueAtIndex(i);
                }
                return total;
              }
              public static addEquals(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  a.plus(i, b.getValueAtIndex(i));
                }
              }
              public static addEqualsbeta(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  a.plus(i, beta * b.getValueAtIndex(i));
                }
              }
              public static add(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  c.setValueAtIndex(i, a.getValueAtIndex(i) + b.getValueAtIndex(i));
                }
              }
              public static subtract3mat(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var length: number = a.getNumElements();
                for (var i: number = 0; i < length; i++) {
                  c.data[i] = a.data[i] - b.data[i];
                }
              }
              public static scale(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var size: number = a.getNumElements();
                for (var i: number = 0; i < size; i++) {
                  a.data[i] *= alpha;
                }
              }
              public static changeSign(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var size: number = a.getNumElements();
                for (var i: number = 0; i < size; i++) {
                  a.data[i] = -a.data[i];
                }
              }
              public static fill(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, value: number): void {
                java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
              }
              public static normalizeF(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                var val: number = org.kevoree.modeling.util.maths.matrix.CommonOps.normF(A);
                if (val == 0) {
                  return;
                }
                var size: number = A.getNumElements();
                for (var i: number = 0; i < size; i++) {
                  A.div(i, val);
                }
              }
              public static normF(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                var total: number = 0;
                var scale: number = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(a);
                if (scale == 0.0) {
                  return 0.0;
                }
                var size: number = a.getNumElements();
                for (var i: number = 0; i < size; i++) {
                  var val: number = a.getValueAtIndex(i) / scale;
                  total += val * val;
                }
                return scale * Math.sqrt(total);
              }
              public static extract6M(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                var w: number = srcX1 - srcX0;
                var h: number = srcY1 - srcY0;
                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
              }
              public static multAlphaBeta(alpha: number, matrix: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, matrix1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, matrix2: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number): void {
                matrix2.scale(beta);
                org.kevoree.modeling.util.maths.matrix.CommonOps.multAddalpha(alpha, matrix, matrix1, matrix2);
              }
            }
            export class SimpleMatrix {
              public mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
              public getMatrix(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                return this.mat;
              }
              public setValue2D(row: number, col: number, value: number): void {
                this.mat.set(row, col, value);
              }
              public setValue1D(index: number, value: number): void {
                this.mat.setValueAtIndex(index, value);
              }
              public getValue2D(row: number, col: number): number {
                return this.mat.get(row, col);
              }
              public getValue1D(index: number): number {
                return this.mat.data[index];
              }
              public getIndex(row: number, col: number): number {
                return row * this.mat.numCols + col;
              }
              public mult(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, b.getMatrix().numCols);
                org.kevoree.modeling.util.maths.matrix.CommonOps.mult(this.mat, b.getMatrix(), ret.getMatrix());
                return ret;
              }
              public scale(val: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                org.kevoree.modeling.util.maths.matrix.CommonOps.scale(val, ret.getMatrix());
                return ret;
              }
              public plus(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                org.kevoree.modeling.util.maths.matrix.CommonOps.addEquals(ret.getMatrix(), b.getMatrix());
                return ret;
              }
              public copy(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                ret.getMatrix().setMatrix(this.getMatrix());
                return ret;
              }
              public numRows(): number {
                return this.mat.numRows;
              }
              public numCols(): number {
                return this.mat.numCols;
              }
              public getNumElements(): number {
                return this.mat.getNumElements();
              }
              public extractDiag(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var N: number = Math.min(this.mat.numCols, this.mat.numRows);
                var diag: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(N, 1);
                org.kevoree.modeling.util.maths.matrix.CommonOps.extractDiag(this.mat, diag.getMatrix());
                return diag;
              }
              public isIdentical(a: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, tol: number): boolean {
                return org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isIdentical(this.mat, a.getMatrix(), tol);
              }
              public trace(): number {
                return org.kevoree.modeling.util.maths.matrix.CommonOps.trace(this.mat);
              }
              public elementMaxAbs(): number {
                return org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(this.mat);
              }
              public elementSum(): number {
                return org.kevoree.modeling.util.maths.matrix.CommonOps.elementSum(this.mat);
              }
              public elementMult(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                org.kevoree.modeling.util.maths.matrix.CommonOps.elementMult(this.mat, b.getMatrix(), c.getMatrix());
                return c;
              }
              public isInBounds(row: number, col: number): boolean {
                return row >= 0 && col >= 0 && row < this.mat.numRows && col < this.mat.numCols;
              }
              public printDimensions(): void {
                console.log("[rows = " + this.numRows() + " , cols = " + this.numCols() + " ]");
              }
              public transpose(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numCols, this.mat.numRows);
                org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.mat, ret.getMatrix());
                return ret;
              }
              constructor(numRows: number, numCols: number) {
                this.mat = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
              }
              public static wrap(internalMat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(internalMat.numRows, internalMat.numCols);
                ret.mat = internalMat;
                return ret;
              }
              public static identity(width: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(width, width);
                org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(ret.mat);
                return ret;
              }
              public minus(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                org.kevoree.modeling.util.maths.matrix.CommonOps.subtract3mat(this.getMatrix(), b.getMatrix(), ret.getMatrix());
                return ret;
              }
              public invert(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                org.kevoree.modeling.util.maths.matrix.CommonOps.invert(this.mat, ret.getMatrix());
                return ret;
              }
              public determinant(): number {
                var ret: number = org.kevoree.modeling.util.maths.matrix.CommonOps.det(this.mat);
                return ret;
              }
              public createMatrix(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var sm: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(numRows, numCols);
                return sm;
              }
              public extractVector(extractRow: boolean, element: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var length: number = extractRow ? this.mat.numCols : this.mat.numRows;
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = extractRow ? this.createMatrix(1, length) : this.createMatrix(length, 1);
                if (extractRow) {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.mat, element, 0, length, true, 0, ret.getMatrix());
                } else {
                  org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.mat, 0, element, length, false, 0, ret.getMatrix());
                }
                return ret;
              }
              public eig(): org.kevoree.modeling.util.maths.matrix.solvers.SimpleEVD<any> {
                return new org.kevoree.modeling.util.maths.matrix.solvers.SimpleEVD<any>(this.mat);
              }
              public svd(compact: boolean): org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> {
                return new org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any>(this.mat, compact);
              }
              public combine(insertRow: number, insertCol: number, B: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                var maxRow: number = insertRow + B.numRows();
                var maxCol: number = insertCol + B.numCols();
                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                if (maxRow > this.mat.numRows || maxCol > this.mat.numCols) {
                  var M: number = Math.max(maxRow, this.mat.numRows);
                  var N: number = Math.max(maxCol, this.mat.numCols);
                  ret = this.createMatrix(M, N);
                  ret.insertIntoThis(0, 0, this);
                } else {
                  ret = this.copy();
                }
                ret.insertIntoThis(insertRow, insertCol, B);
                return ret;
              }
              public insertIntoThis(insertRow: number, insertCol: number, B: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                org.kevoree.modeling.util.maths.matrix.CommonOps.insert(B.getMatrix(), this.mat, insertRow, insertCol);
              }
            }
          }
          export class Correlations {
            public static pearson(x: Float64Array, y: Float64Array): number {
              var meanX: number = 0.0, meanY: number = 0.0;
              for (var i: number = 0; i < x.length; i++) {
                meanX += x[i];
                meanY += y[i];
              }
              meanX /= x.length;
              meanY /= x.length;
              var sumXY: number = 0.0;
              var sumX2: number = 0.0;
              var sumY2: number = 0.0;
              for (var i: number = 0; i < x.length; i++) {
                sumXY += ((x[i] - meanX) * (y[i] - meanY));
                sumX2 += (x[i] - meanX) * (x[i] - meanX);
                sumY2 += (y[i] - meanY) * (y[i] - meanY);
              }
              return (sumXY / (Math.sqrt(sumX2) * Math.sqrt(sumY2)));
            }
          }
          export class Ranking {
            public static wilsonRank(positive: number, negative: number, confidence: number): number {
              var n: number = positive + negative;
              if (n == 0) {
                return 0.0;
              }
              var z: number = org.kevoree.modeling.util.maths.Distribution.inverseNormalCDF(1.0 - confidence / 2.0);
              var p_hat: number = (1.0 * positive) / n;
              return (p_hat + z * z / (2.0 * n) - z * Math.sqrt((p_hat * (1.0 - p_hat) + z * z / (4.0 * n)) / n)) / (1.0 + z * z / n);
            }
          }
        }
        export class Checker {
          public static isDefined(param: any): boolean {
             return param != undefined && param != null;
          }
        }
        export class Base64 {
           private static encodeArray = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];
           private static decodeArray = {"A":0, "B":1, "C":2, "D":3, "E":4, "F":5, "G":6, "H":7, "I":8, "J":9, "K":10, "L":11, "M":12, "N":13, "O":14, "P":15, "Q":16, "R":17, "S":18, "T":19, "U":20, "V":21, "W":22, "X":23, "Y":24, "Z":25, "a":26, "b":27, "c":28, "d":29, "e":30, "f":31, "g":32, "h":33, "i":34, "j":35, "k":36, "l":37, "m":38, "n":39, "o":40, "p":41, "q":42, "r":43, "s":44, "t":45, "u":46, "v":47, "w":48, "x":49, "y":50, "z":51, "0":52, "1":53, "2":54, "3":55, "4":56, "5":57, "6":58, "7":59, "8":60, "9":61, "+":62, "/":63};
           private static powTwo = {0:1,1:2,2:4,3:8,4:16,5:32,6:64,7:128,8:256,9:512,10:1024,11:2048,12:4096,13:8192,14:16384,15:32768,16:65536,17:131072,18:262144,19:524288,20:1048576,21:2097152,22:4194304,23:8388608,24:16777216,25:33554432,26:67108864,27:134217728,28:268435456,29:536870912,30:1073741824,31:2147483648,32:4294967296,33:8589934592,34:17179869184,35:34359738368,36:68719476736,37:137438953472,38:274877906944,39:549755813888,40:1099511627776,41:2199023255552,42:4398046511104,43:8796093022208,44:17592186044416,45:35184372088832,46:70368744177664,47:140737488355328,48:281474976710656,49:562949953421312,50:1125899906842624,51:2251799813685248,52:4503599627370496,53:9007199254740992};
           public static encodeLong(l:number) {
           var result = "";
           var tmp = l;
           if(l < 0) {
           tmp = -tmp;
           }
           for (var i = 47; i >= 5; i -= 6) {
           if (!(result === "" && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
           result += Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F];
           }
           }
           result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
           return result;
           }
           public static encodeLongToBuffer(l:number, buffer:java.lang.StringBuilder) {
           var empty=true;
           var tmp = l;
           if(l < 0) {
           tmp = -tmp;
           }
           for (var i = 47; i >= 5; i -= 6) {
           if (!(empty && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
           empty = false;
           buffer.append(Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F]);
           }
           }
           buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
           }
           public static encodeInt(l:number) {
           var result = "";
           var tmp = l;
           if(l < 0) {
           tmp = -tmp;
           }
           for (var i = 29; i >= 5; i -= 6) {
           if (!(result === "" && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
           result += Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F];
           }
           }
           result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
           return result;
           }
           public static encodeIntToBuffer(l:number, buffer:java.lang.StringBuilder) {
           var empty=true;
           var tmp = l;
           if(l < 0) {
           tmp = -tmp;
           }
           for (var i = 29; i >= 5; i -= 6) {
           if (!(empty && ((tmp / Base64.powTwo[i]) & 0x3F) == 0)) {
           empty = false;
           buffer.append(Base64.encodeArray[(tmp / Base64.powTwo[i]) & 0x3F]);
           }
           }
           buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
           }
           public static decodeToLong(s: string) {
           return Base64.decodeToLongWithBounds(s, 0, s.length);
           }
           public static decodeToLongWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
           var result = 0;
           result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
           for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
           result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Base64.powTwo[(6 * i)-1];
           }
           if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
           result = -result;
           }
           return result;
           }
           public static decodeToInt(s: string) {
           return Base64.decodeToIntWithBounds(s, 0, s.length);
           }
           public static decodeToIntWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
           var result = 0;
           result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
           for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
           result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Base64.powTwo[(6 * i)-1];
           }
           if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
           result = -result;
           }
           return result;
           }
           public static encodeDouble(d : number) {
           var result = "";
           var floatArr = new Float64Array(1);
           var bytes = new Uint8Array(floatArr.buffer);
           floatArr[0] = d;
           var exponent = (((bytes[7] & 0x7f) * 16) | (bytes[6] / 16)) - 0x3ff;
           var signAndExp = (((bytes[7] / 128) & 0x1) * 2048) + (exponent + 1023);
           //encode sign + exp
           result += Base64.encodeArray[(signAndExp / 64) & 0x3F];
           result += Base64.encodeArray[signAndExp & 0x3F];
           result += Base64.encodeArray[bytes[6] & 0x0F];
           result += Base64.encodeArray[(bytes[5] / 4) & 0x3F];
           result += Base64.encodeArray[((bytes[5] & 0x3) * 16) | (bytes[4] / 16)];
           result += Base64.encodeArray[((bytes[4] & 0x0F) * 4) | (bytes[3] / 64)];
           result += Base64.encodeArray[(bytes[3] & 0x3F)];
           result += Base64.encodeArray[(bytes[2] / 4) & 0x3F];
           result += Base64.encodeArray[((bytes[2] & 0x3) * 16) | (bytes[1] / 16)];
           result += Base64.encodeArray[((bytes[1] & 0x0F) * 4) | (bytes[0] / 64)];
           result += Base64.encodeArray[(bytes[0] & 0x3F)];
           var i = result.length-1;
           while(i >= 3 && result.charAt(i) == 'A') {
           i--;
           }
           return result.substr(0,i+1);
           }
           public static encodeDoubleToBuffer(d : number, buffer : java.lang.StringBuilder) {
           var result = "";
           var floatArr = new Float64Array(1);
           var bytes = new Uint8Array(floatArr.buffer);
           floatArr[0] = d;
           var exponent = (((bytes[7] & 0x7f) * 16) | bytes[6] / 16) - 0x3ff;
           var signAndExp = (((bytes[7] / 128 ) & 0x1) * 2048) + (exponent + 1023);
           //encode sign + exp
           result += Base64.encodeArray[(signAndExp / 64) & 0x3F];
           result += Base64.encodeArray[signAndExp & 0x3F];
           result += Base64.encodeArray[bytes[6] & 0x0F];
           result += Base64.encodeArray[(bytes[5] / 4) & 0x3F];
           result += Base64.encodeArray[((bytes[5] & 0x3) * 16) | (bytes[4] / 16)];
           result += Base64.encodeArray[((bytes[4] & 0x0F) * 4) | (bytes[3] / 64)];
           result += Base64.encodeArray[(bytes[3] & 0x3F)];
           result += Base64.encodeArray[(bytes[2] / 4) & 0x3F];
           result += Base64.encodeArray[((bytes[2] & 0x3) * 16) | (bytes[1] / 16)];
           result += Base64.encodeArray[((bytes[1] & 0x0F) * 4) | (bytes[0] / 64)];
           result += Base64.encodeArray[(bytes[0] & 0x3F)];
           var i = result.length-1;
           while(i >= 3 && result.charAt(i) == 'A') {
           i--;
           }
           buffer.append(result.substr(0,i+1));
           }
           public static decodeToDouble(s: string) {
           return Base64.decodeToDoubleWithBounds(s, 0, s.length);
           }
           public static decodeToDoubleWithBounds(s : string, offsetBegin : number, offsetEnd : number) {
           var signAndExp = ((Base64.decodeArray[s.charAt(offsetBegin)] & 0xFF) * 64) + (Base64.decodeArray[s.charAt(offsetBegin + 1)] & 0xFF);
           var sign = ((signAndExp & 0x800) != 0 ? -1 : 1);
           var exp = signAndExp & 0x7FF;
           //Mantisse
           var mantissaBits = 0;
           for (var i = 2; i < (offsetEnd - offsetBegin); i++) {
           mantissaBits += (Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF) * Base64.powTwo[48 - (6 * (i-2))];
           }
           return (exp != 0) ? sign * Math.pow(2, exp - 1023) * (1 + (mantissaBits / Math.pow(2, 52))) : sign * Math.pow(2, -1022) * (0 + (mantissaBits / Math.pow(2, 52)));
           }
           public static encodeBoolArray(boolArr : Array<boolean>) {
           var result = "";
           var tmpVal = 0;
           for (var i = 0; i < boolArr.length; i++) {
           tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Base64.powTwo[i % 6]);
           if (i % 6 == 5 || i == (boolArr.length - 1)) {
           result += Base64.encodeArray[tmpVal];
           tmpVal = 0;
           }
           }
           return result;
           }
           public static encodeBoolArrayToBuffer(boolArr : Array<boolean>, buffer : java.lang.StringBuilder) {
           var tmpVal = 0;
           for (var i = 0; i < boolArr.length; i++) {
           tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Base64.powTwo[i % 6]);
           if (i % 6 == 5 || i == boolArr.length - 1) {
           buffer.append(Base64.encodeArray[tmpVal]);
           tmpVal = 0;
           }
           }
           }
           public static decodeBoolArray(s : string, arraySize : number) {
           return Base64.decodeToBoolArrayWithBounds(s, 0, s.length, arraySize);
           }
           public static decodeToBoolArrayWithBounds(s : string, offsetBegin : number, offsetEnd : number, arraySize : number) {
           var resultTmp: any[] = [];
           for (var i = 0; i < (offsetEnd - offsetBegin); i++) {
           var bitarray = Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF;
           for (var bit_i = 0; bit_i < 6; bit_i++) {
           if ((6 * i) + bit_i < arraySize) {
           resultTmp[(6 * i) + bit_i] = (bitarray & (1 * Base64.powTwo[bit_i])) != 0;
           } else {
           break;
           }
           }
           }
           return resultTmp;
           }


           public static encodeString(s : string) {
           var result = "";
           var sLength = s.length;
           var currentSourceChar: number;
           var currentEncodedChar = 0;
           var freeBitsInCurrentChar = 6;

           for(var charIdx = 0; charIdx < sLength; charIdx++) {
             currentSourceChar = s.charCodeAt(charIdx);
             if(freeBitsInCurrentChar == 6) {
               result += Base64.encodeArray[(currentSourceChar / 4) & 0x3F];
               currentEncodedChar = (currentSourceChar & 0x3) * 16;
               freeBitsInCurrentChar = 4;
             } else if(freeBitsInCurrentChar == 4) {
               result += Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 16) & 0xF)) & 0x3F];
               currentEncodedChar = (currentSourceChar & 0xF) * 4;
               freeBitsInCurrentChar = 2;
             } else if(freeBitsInCurrentChar == 2) {
               result += Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 64) & 0x3)) & 0x3F];
               result += Base64.encodeArray[currentSourceChar & 0x3F];
               freeBitsInCurrentChar = 6;
             }
           }

           if(freeBitsInCurrentChar != 6) {
             result += Base64.encodeArray[currentEncodedChar];
           }
           return result;
           }
           public static encodeStringToBuffer(s : string, buffer : java.lang.StringBuilder) {
           var sLength = s.length;
           var currentSourceChar: number;
           var currentEncodedChar = 0;
           var freeBitsInCurrentChar = 6;

           for(var charIdx = 0; charIdx < sLength; charIdx++) {
             currentSourceChar = s.charCodeAt(charIdx);
             if(freeBitsInCurrentChar == 6) {
               buffer.append(Base64.encodeArray[(currentSourceChar / 4) & 0x3F]);
               currentEncodedChar = (currentSourceChar & 0x3) * 16;
               freeBitsInCurrentChar = 4;
             } else if(freeBitsInCurrentChar == 4) {
               buffer.append(Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 16) & 0xF)) & 0x3F]);
               currentEncodedChar = (currentSourceChar & 0xF) * 4;
               freeBitsInCurrentChar = 2;
             } else if(freeBitsInCurrentChar == 2) {
               buffer.append(Base64.encodeArray[(currentEncodedChar | ((currentSourceChar / 64) & 0x3)) & 0x3F]);
               buffer.append(Base64.encodeArray[currentSourceChar & 0x3F]);
               freeBitsInCurrentChar = 6;
             }
           }

           if(freeBitsInCurrentChar != 6) {
             buffer.append(Base64.encodeArray[currentEncodedChar]);
           }
           }
           public static decodeString(s : string) {
           return Base64.decodeToStringWithBounds(s, 0, s.length);
           }
           public static decodeToStringWithBounds(s : string, offsetBegin : number, offsetEnd : number) {
           var result = "";
           var currentSourceChar: number;
           var currentDecodedChar = 0;
           var freeBitsInCurrentChar = 8;

           for(var charIdx = offsetBegin; charIdx < offsetEnd; charIdx++) {
            currentSourceChar = Base64.decodeArray[s.charAt(charIdx)];
            if(freeBitsInCurrentChar == 8) {
              currentDecodedChar = currentSourceChar * 4;
              freeBitsInCurrentChar = 2;
            } else if(freeBitsInCurrentChar == 2) {
              result += String.fromCharCode(currentDecodedChar | (currentSourceChar / 16));
              currentDecodedChar = (currentSourceChar & 0xF) * 16;
              freeBitsInCurrentChar = 4;
            } else if(freeBitsInCurrentChar == 4) {
              result += String.fromCharCode(currentDecodedChar | (currentSourceChar / 4));
              currentDecodedChar = (currentSourceChar & 0x3) * 64;
              freeBitsInCurrentChar = 6;
            } else if(freeBitsInCurrentChar == 6) {
              result += String.fromCharCode(currentDecodedChar | currentSourceChar);
              freeBitsInCurrentChar = 8;
            }
           }
           return result;
          }
        }
        export class PrimitiveHelper {
          public static startsWith(src: string, prefix: string): boolean {
             return src.slice(0, prefix.length) == prefix
          }
          public static endsWith(src: string, prefix: string): boolean {
             return src.slice(-prefix.length) == prefix;
          }
          public static matches(src: string, regex: string): boolean {
             if (regex == null) { return false; } else { var m = src.match(regex); return m != null && m.length > 0; }
          }
          public static equals(src: string, other: string): boolean {
             return src === other
          }
          public static parseInt(val: string): number {
             return parseInt(val);
          }
          public static parseLong(val: string): number {
             return +val;
          }
          public static parseDouble(val: string): number {
             return parseFloat(val);
          }
          public static parseShort(val: string): number {
             return +val;
          }
          public static parseBoolean(val: string): boolean {
             return val === "true";
          }
          public static SHORT_MIN_VALUE(): number {
            return -0x8000;
          }
          public static SHORT_MAX_VALUE(): number {
            return 0x7FFF;
          }
          public static isNaN(val: number): boolean {
             return isNaN(val);
          }
          public static DOUBLE_MIN_VALUE(): number {
             return Number.MIN_VALUE;
          }
          public static DOUBLE_MAX_VALUE(): number {
             return Number.MAX_VALUE;
          }
          public static stringHash(target: string): number {
             var hash = 0;
             if (target.length == 0) return hash;
             for (var i = 0; i < target.length; i++) {
             var charC = target.charCodeAt(i);
             hash = ((hash << 5) - hash) + charC;
             hash = hash & hash; // Convert to 32bit integer
             }
             return hash;
          }
        }
      }
      export class KContentKey {
        public static NULL_KEY: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME]);
        public static GLOBAL_UNIVERSE_KEY: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]);
        public universe: number;
        public time: number;
        public obj: number;
        public static toString(keys: Float64Array, keyIndex: number): string {
          var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
          var offset: number = keyIndex * 3;
          if (keys[offset] != org.kevoree.modeling.KConfig.NULL_LONG) {
            org.kevoree.modeling.util.Base64.encodeLongToBuffer(keys[offset], buffer);
          }
          buffer.append(org.kevoree.modeling.KConfig.KEY_SEP);
          if (keys[offset + 1] != org.kevoree.modeling.KConfig.NULL_LONG) {
            org.kevoree.modeling.util.Base64.encodeLongToBuffer(keys[offset + 1], buffer);
          }
          buffer.append(org.kevoree.modeling.KConfig.KEY_SEP);
          if (keys[offset + 2] != org.kevoree.modeling.KConfig.NULL_LONG) {
            org.kevoree.modeling.util.Base64.encodeLongToBuffer(keys[offset + 2], buffer);
          }
          return buffer.toString();
        }
        constructor(p_universeID: number, p_timeID: number, p_objID: number) {
          this.universe = p_universeID;
          this.time = p_timeID;
          this.obj = p_objID;
        }
        public static createObject(p_universeID: number, p_quantaID: number, p_objectID: number): org.kevoree.modeling.KContentKey {
          return new org.kevoree.modeling.KContentKey(p_universeID, p_quantaID, p_objectID);
        }
        public static createGlobalUniverseTree(): org.kevoree.modeling.KContentKey {
          return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
        }
        public static createRootUniverseTree(): org.kevoree.modeling.KContentKey {
          return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME);
        }
        public static createLastPrefix(): org.kevoree.modeling.KContentKey {
          return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
        }
        public static create(payload: string): org.kevoree.modeling.KContentKey {
          if (payload == null || payload.length == 0) {
            return null;
          } else {
            var key: org.kevoree.modeling.KContentKey = new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
            var maxRead: number = payload.length;
            var indexStartElem: number = -1;
            var indexElem: number = 0;
            var partIndex: number = 0;
            for (var i: number = 0; i < maxRead; i++) {
              if (payload.charAt(i) == org.kevoree.modeling.KConfig.KEY_SEP) {
                if (indexStartElem != -1) {
                  try {
                    switch (partIndex) {
                      case 0:
                      key.universe = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                      break;
                      case 1:
                      key.time = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                      break;
                      case 2:
                      key.obj = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                      break;
                      default:
                      break;
                    }
                  } catch ($ex$) {
                    if ($ex$ instanceof Error) {
                      var e: Error = <Error>$ex$;
                      console.error(e['stack']);
                    } else {
                      throw $ex$;
                    }
                  }
                }
                indexStartElem = -1;
                indexElem = indexElem + 1;
                partIndex++;
              } else {
                if (indexStartElem == -1) {
                  indexStartElem = i;
                }
              }
            }
            if (indexStartElem != -1) {
              try {
                switch (partIndex) {
                  case 0:
                  key.universe = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                  break;
                  case 1:
                  key.time = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                  break;
                  case 2:
                  key.obj = org.kevoree.modeling.util.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                  break;
                  default:
                  break;
                }
              } catch ($ex$) {
                if ($ex$ instanceof Error) {
                  var e: Error = <Error>$ex$;
                  console.error(e['stack']);
                } else {
                  throw $ex$;
                }
              }
            }
            return key;
          }
        }
        public equals(param: any): boolean {
          if (param instanceof org.kevoree.modeling.KContentKey) {
            var remote: org.kevoree.modeling.KContentKey = <org.kevoree.modeling.KContentKey>param;
            return remote.universe == this.universe && remote.time == this.time && remote.obj == this.obj;
          } else {
            return false;
          }
        }
      }
      export interface KObjectIndex extends org.kevoree.modeling.KObject {
        getIndex(key: string): number;
        setIndex(key: string, value: number): void;
        values(): Float64Array;
      }
      export namespace defer {
        export interface KDefer {
          waitResult(): org.kevoree.modeling.KCallback<any>;
          then(cb: org.kevoree.modeling.KCallback<any[]>): void;
        }
        export namespace impl {
          export class Defer implements org.kevoree.modeling.defer.KDefer {
            private _end: org.kevoree.modeling.KCallback<any[]>;
            private _nbExpectedResult: number = 0;
            private _nbRecResult: number = 0;
            private _results: any[] = null;
            private _resultSize: number = 0;
            public waitResult(): org.kevoree.modeling.KCallback<any> {
              return this.informEndOrRegister(-1, null, null);
            }
            public then(cb: org.kevoree.modeling.KCallback<any[]>): void {
              this.informEndOrRegister(-1, null, cb);
            }
            private informEndOrRegister(p_indexToInsert: number, p_result: any, p_end: org.kevoree.modeling.KCallback<any[]>): org.kevoree.modeling.KCallback<any> {
              if (p_end == null) {
                if (p_indexToInsert == -1) {
                  var toInsert: number = this._nbExpectedResult;
                  this._nbExpectedResult++;
                  if (this._results == null || this._resultSize < this._nbExpectedResult) {
                    var newResultSize: number = (this._nbExpectedResult == 0 ? 1 : this._nbExpectedResult << 1);
                    var newResults: any[] = new Array<any>(newResultSize);
                    if (this._results != null) {
                      java.lang.System.arraycopy(this._results, 0, newResults, 0, this._resultSize);
                    }
                    this._resultSize = newResultSize;
                    this._results = newResults;
                  }
                  return (o : any) => {
                    this.informEndOrRegister(toInsert, o, null);
                  };
                } else {
                  this._results[p_indexToInsert] = p_result;
                  this._nbRecResult++;
                  if (this._end != null && (this._nbExpectedResult == this._nbRecResult)) {
                    var finalResults: any[] = this._results;
                    if (this._resultSize != this._nbExpectedResult) {
                      var newResults: any[] = new Array<any>(this._resultSize);
                      java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                      finalResults = newResults;
                    }
                    this._end(finalResults);
                  }
                }
              } else {
                this._end = p_end;
                if (this._nbExpectedResult == this._nbRecResult) {
                  var finalResults: any[] = this._results;
                  if (this._resultSize != this._nbExpectedResult) {
                    var newResults: any[] = new Array<any>(this._nbExpectedResult);
                    java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                    finalResults = newResults;
                  }
                  this._end(finalResults);
                }
              }
              return null;
            }
          }
        }
      }
      export interface KPreparedLookup {
        addLookupOperation(universe: number, time: number, uuid: number): void;
        flatLookup(): Float64Array;
      }
      export namespace abs {
        export abstract class AbstractKView implements org.kevoree.modeling.KView {
          public _time: number;
          public _universe: number;
          public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
          constructor(p_universe: number, _time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
            this._universe = p_universe;
            this._time = _time;
            this._manager = p_manager;
          }
          public now(): number {
            return this._time;
          }
          public universe(): number {
            return this._universe;
          }
          public model(): org.kevoree.modeling.KModel<any> {
            return this._manager.model();
          }
          public select(query: string, cb: org.kevoree.modeling.KCallback<any[]>): void {
            if (org.kevoree.modeling.util.Checker.isDefined(cb)) {
              if (query == null || query.length == 0) {
                cb(new Array<org.kevoree.modeling.KObject>(0));
              } else {
                org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().eval(query, new Array<org.kevoree.modeling.KObject>(0), this, cb);
              }
            }
          }
          public lookup(kid: number, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
            this._manager.lookup(this._universe, this._time, kid, cb);
          }
          public lookupAll(keys: Float64Array, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.lookupAllObjects(this._universe, this._time, keys, cb);
          }
          public create(clazz: org.kevoree.modeling.meta.KMetaClass): org.kevoree.modeling.KObject {
            return this._manager.model().create(clazz, this._universe, this._time);
          }
          public createByName(metaClassName: string): org.kevoree.modeling.KObject {
            return this.create(this._manager.model().metaModel().metaClassByName(metaClassName));
          }
          public json(): org.kevoree.modeling.format.KModelFormat {
            return new org.kevoree.modeling.format.json.JsonFormat(this._universe, this._time, this._manager);
          }
          public equals(obj: any): boolean {
            if (!org.kevoree.modeling.util.Checker.isDefined(obj)) {
              return false;
            }
            if (!(obj instanceof org.kevoree.modeling.abs.AbstractKView)) {
              return false;
            } else {
              var casted: org.kevoree.modeling.abs.AbstractKView = <org.kevoree.modeling.abs.AbstractKView>obj;
              return casted._time == this._time && casted._universe == this._universe;
            }
          }
        }
        export class AbstractKObjectInfer extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.modeling.KObjectInfer {
          constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
            super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
          }
          public genericTrain(dependencies: org.kevoree.modeling.KObject[], expectedOutputs: any[], callback: org.kevoree.modeling.KCallback<any>): void {
            var all_dependencies: org.kevoree.modeling.KObject[][] = [[]];
            all_dependencies[0] = dependencies;
            var all_expectedOutputs: any[][] = null;
            if (expectedOutputs != null) {
              all_expectedOutputs = [[]];
              all_expectedOutputs[0] = expectedOutputs;
            }
            this.genericTrainAll(all_dependencies, all_expectedOutputs, callback);
          }
          public genericTrainAll(p_dependencies: org.kevoree.modeling.KObject[][], p_outputs: any[][], callback: org.kevoree.modeling.KCallback<any>): void {
            if (p_dependencies == null) {
              throw new Error("Dependencies are mandatory for KObjectInfer");
            }
            var selfObject: org.kevoree.modeling.KObjectInfer = this;
            var selfView: org.kevoree.modeling.KView = selfObject.manager().model().universe(this._universe).time(this._time);
            var waiter: org.kevoree.modeling.defer.KDefer = this.manager().model().defer();
            for (var i: number = 0; i < p_dependencies.length; i++) {
              if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                throw new Error("Bad number of arguments for allDependencies");
              }
              var loopDependencies: org.kevoree.modeling.KObject[] = p_dependencies[i];
              for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                var loopInput: org.kevoree.modeling.meta.KMetaInferInput = this._metaClass.inputs()[j];
                if (org.kevoree.modeling.util.PrimitiveHelper.equals(loopInput.metaName(), "this") || org.kevoree.modeling.util.PrimitiveHelper.equals(loopInput.metaName(), "self")) {
                  loopInput.extractor().exec([selfObject], selfView, waiter.waitResult());
                } else {
                  var dependency: org.kevoree.modeling.meta.KMetaDependency = this._metaClass.dependencies().dependencyByName(loopInput.metaName());
                  if (dependency != null) {
                    loopInput.extractor().exec([loopDependencies[dependency.index()]], selfView, waiter.waitResult());
                  } else {
                    throw new Error("Bad API definition, " + loopInput.metaName() + " isn't defined as a dependency");
                  }
                }
              }
            }
            waiter.then((results : any[]) => {
              var extractedInputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
              var k: number = 0;
              for (var i: number = 0; i < p_dependencies.length; i++) {
                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                  var extracted: any[] = <any[]>results[k];
                  if (extracted != null && extracted.length > 0) {
                    extractedInputs.set(i, j, <number>extracted[0]);
                  }
                  k++;
                }
              }
              var extractedOutputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, this._metaClass.outputs().length);
              for (var i: number = 0; i < p_dependencies.length; i++) {
                for (var j: number = 0; j < this._metaClass.outputs().length; j++) {
                  var metaInferOutput: org.kevoree.modeling.meta.KMetaInferOutput = this._metaClass.outputs()[j];
                  var currentOutputObject: any = null;
                  if (p_outputs != null) {
                    currentOutputObject = p_outputs[i][j];
                  }
                  extractedOutputs.set(i, j, this.internalConvertOutput(currentOutputObject, metaInferOutput));
                }
              }
              this._metaClass.inferAlg().train(extractedInputs, extractedOutputs, selfObject, this._manager);
              if (callback != null) {
                callback(null);
              }
            });
          }
          public genericInfer(dependencies: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any[]>): void {
            var all_dependencies: org.kevoree.modeling.KObject[][] = [[]];
            all_dependencies[0] = dependencies;
            this.genericInferAll(all_dependencies, (objects : any[][]) => {
              if (objects != null && objects.length > 0) {
                callback(objects[0]);
              } else {
                callback(null);
              }
            });
          }
          public genericInferAll(p_dependencies: org.kevoree.modeling.KObject[][], callback: org.kevoree.modeling.KCallback<any[][]>): void {
            if (p_dependencies == null) {
              throw new Error("Bad number of arguments for allDependencies");
            }
            var selfObject: org.kevoree.modeling.KObjectInfer = this;
            var selfView: org.kevoree.modeling.KView = selfObject.manager().model().universe(this._universe).time(this._time);
            var waiter: org.kevoree.modeling.defer.KDefer = this.manager().model().defer();
            for (var i: number = 0; i < p_dependencies.length; i++) {
              if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                throw new Error("Bad number of arguments for allDependencies");
              }
              var loopDependencies: org.kevoree.modeling.KObject[] = p_dependencies[i];
              for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                var loopInput: org.kevoree.modeling.meta.KMetaInferInput = this._metaClass.inputs()[j];
                if (org.kevoree.modeling.util.PrimitiveHelper.equals(loopInput.metaName(), "this") || org.kevoree.modeling.util.PrimitiveHelper.equals(loopInput.metaName(), "self")) {
                  loopInput.extractor().exec([selfObject], selfView, waiter.waitResult());
                } else {
                  var dependency: org.kevoree.modeling.meta.KMetaDependency = this._metaClass.dependencies().dependencyByName(loopInput.metaName());
                  if (dependency != null) {
                    loopInput.extractor().exec([loopDependencies[dependency.index()]], selfView, waiter.waitResult());
                  } else {
                    throw new Error("Bad API definition, " + loopInput.metaName() + " isn't defined as a dependency");
                  }
                }
              }
            }
            waiter.then((results : any[]) => {
              var extractedInputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
              var k: number = 0;
              for (var i: number = 0; i < p_dependencies.length; i++) {
                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                  var extracted: any[] = <any[]>results[k];
                  if (extracted != null && extracted.length > 0) {
                    extractedInputs.set(i, j, <number>extracted[0]);
                  }
                  k++;
                }
              }
              var extractedOutputs: org.kevoree.modeling.util.maths.structure.KArray2D = this._metaClass.inferAlg().infer(extractedInputs, selfObject, this._manager);
              var result: any[][] = [[]];
              for (var i: number = 0; i < extractedOutputs.rows(); i++) {
                result[i] = new Array<any>(extractedOutputs.columns());
                for (var j: number = 0; j < extractedOutputs.columns(); j++) {
                  result[i][j] = this.internalReverseOutput(extractedOutputs.get(i, j), this._metaClass.outputs()[j]);
                }
              }
              callback(result);
            });
          }
          public resetLearning(): void {
            throw new Error("Not Implemented Yet!");
          }
          private internalConvertOutput(output: any, metaOutput: org.kevoree.modeling.meta.KMetaInferOutput): number {
            if (output == null) {
              return 0;
            }
            var typeId: number = metaOutput.attributeTypeId();
            switch (typeId) {
              case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
              if (<boolean>output) {
                return 1.0;
              } else {
                return 0.0;
              }
              case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
              return <number>output;
              case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
              return <number>output;
              case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
              return <number>output;
              case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
              return <number>output;
              case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
              throw new Error("String are not managed yet");
              default:
              if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                var metaEnum: org.kevoree.modeling.meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                if (output instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                  return <number>(<org.kevoree.modeling.meta.impl.MetaLiteral>output).index();
                } else {
                  var literal: org.kevoree.modeling.meta.KMeta = metaEnum.literalByName(output.toString());
                  if (literal != null) {
                    return <number>literal.index();
                  }
                }
              }
              return 0;
            }
          }
          private internalReverseOutput(inferred: number, metaOutput: org.kevoree.modeling.meta.KMetaInferOutput): any {
            var typeId: number = metaOutput.attributeTypeId();
            switch (typeId) {
              case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
              if (inferred >= 0.5) {
                return true;
              } else {
                return false;
              }
              case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
              return inferred;
              case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
              return <number>inferred;
              case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
              return inferred;
              case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
              return inferred;
              case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
              throw new Error("String are not managed yet");
              default:
              if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                var ceiledInferred: number = this.math_ceil(inferred);
                var metaEnum: org.kevoree.modeling.meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                return metaEnum.literal(ceiledInferred);
              }
              return null;
            }
          }
          private math_ceil(toCeilValue: number): number {
             return Math.round(toCeilValue);
          }
        }
        export class AbstractDataType implements org.kevoree.modeling.KType {
          private _name: string;
          private _id: number;
          constructor(p_name: string, p_id: number) {
            this._name = p_name;
            this._id = p_id;
          }
          public name(): string {
            return this._name;
          }
          public id(): number {
            return this._id;
          }
        }
        export class AbstractKModelContext implements org.kevoree.modeling.KModelContext {
          public static ORIGIN_TIME: number = 0;
          public static MAX_TIME: number = 1;
          public static ORIGIN_UNIVERSE: number = 2;
          public static MAX_UNIVERSE: number = 3;
          public static NB_ELEM: number = 4;
          private _callbacks: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.KCallback<any>[]>;
          private _bounds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
          private _origin: org.kevoree.modeling.KModel<any>;
          constructor(p_origin: org.kevoree.modeling.KModel<any>) {
            this._origin = p_origin;
            this._bounds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
            this._callbacks = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.KCallback<any>[]>();
          }
          public set(p_originTime: number, p_maxTime: number, p_originUniverse: number, p_maxUniverse: number): void {
            var newBounds: Float64Array = new Float64Array([p_originTime, p_maxTime, p_originUniverse, p_maxUniverse]);
            this._bounds.set(newBounds);
            var currentStateListeners: org.kevoree.modeling.KCallback<any>[] = this._callbacks.get();
            if (currentStateListeners != null) {
              for (var i: number = 0; i < currentStateListeners.length; i++) {
                if (currentStateListeners[i] != null) {
                  currentStateListeners[i](newBounds);
                }
              }
            }
          }
          public originTime(): number {
            return this._bounds.get()[org.kevoree.modeling.abs.AbstractKModelContext.ORIGIN_TIME];
          }
          public originUniverse(): number {
            return this._bounds.get()[org.kevoree.modeling.abs.AbstractKModelContext.ORIGIN_UNIVERSE];
          }
          public maxTime(): number {
            return this._bounds.get()[org.kevoree.modeling.abs.AbstractKModelContext.MAX_TIME];
          }
          public maxUniverse(): number {
            return this._bounds.get()[org.kevoree.modeling.abs.AbstractKModelContext.MAX_UNIVERSE];
          }
          public listen(new_callback: org.kevoree.modeling.KCallback<Float64Array>): void {
            var previous: org.kevoree.modeling.KCallback<any>[];
            var next: org.kevoree.modeling.KCallback<any>[];
            do {
              previous = this._callbacks.get();
              var previousSize: number = 0;
              if (previous != null) {
                previousSize = previous.length;
              }
              next = new Array<org.kevoree.modeling.KCallback<any>>(previousSize + 1);
              if (previous != null && previousSize > 0) {
                java.lang.System.arraycopy(previous, 0, next, 0, previousSize);
              }
              next[previousSize] = new_callback;
            } while (!this._callbacks.compareAndSet(previous, next))
          }
          public model(): org.kevoree.modeling.KModel<any> {
            return this._origin;
          }
        }
        export abstract class AbstractKUniverse<A extends org.kevoree.modeling.KView, B extends org.kevoree.modeling.KUniverse<any, any>> implements org.kevoree.modeling.KUniverse<A, B> {
          public _universe: number;
          public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
          constructor(p_key: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
            this._universe = p_key;
            this._manager = p_manager;
          }
          public key(): number {
            return this._universe;
          }
          public time(timePoint: number): A {
            if (timePoint <= org.kevoree.modeling.KConfig.END_OF_TIME && timePoint >= org.kevoree.modeling.KConfig.BEGINNING_OF_TIME) {
              return this.internal_create(timePoint);
            } else {
              throw new Error("The selected Time " + timePoint + " is out of the range of KMF managed time");
            }
          }
          public abstract internal_create(timePoint: number): A;
          public equals(obj: any): boolean {
            if (!(obj instanceof org.kevoree.modeling.abs.AbstractKUniverse)) {
              return false;
            } else {
              var casted: org.kevoree.modeling.abs.AbstractKUniverse<any, any> = <org.kevoree.modeling.abs.AbstractKUniverse<any, any>>obj;
              return casted._universe == this._universe;
            }
          }
          public diverge(): B {
            var casted: org.kevoree.modeling.abs.AbstractKModel<any> = <org.kevoree.modeling.abs.AbstractKModel<any>>this._manager.model();
            var nextKey: number = this._manager.nextUniverseKey();
            var newUniverse: B = <B>casted.internalCreateUniverse(nextKey);
            this._manager.initUniverse(nextKey, this._universe);
            return newUniverse;
          }
          public lookupAllTimes(uuid: number, times: Float64Array, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.lookupAllTimes(this._universe, times, uuid, cb);
          }
          public createListener(): org.kevoree.modeling.KListener {
            return this._manager.createListener(this._universe);
          }
        }
        export abstract class AbstractKObject implements org.kevoree.modeling.KObject {
          public _uuid: number;
          public _time: number;
          public _universe: number;
          public _metaClass: org.kevoree.modeling.meta.KMetaClass;
          public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
          private static OUT_OF_CACHE_MSG: string = "Out of cache Error";
          public _previousResolveds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
          public static UNIVERSE_PREVIOUS_INDEX: number = 0;
          public static TIME_PREVIOUS_INDEX: number = 1;
          constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number) {
            this._universe = p_universe;
            this._time = p_time;
            this._uuid = p_uuid;
            this._metaClass = p_metaClass;
            this._manager = p_manager;
            this._previousResolveds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
            var initResolved: Float64Array = new Float64Array([p_actualUniverse, p_actualTime]);
            this._previousResolveds.set(initResolved);
          }
          public previousResolved(): java.util.concurrent.atomic.AtomicReference<Float64Array> {
            return this._previousResolveds;
          }
          public timeDephasing(): number {
            return this._time - this._previousResolveds.get()[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX];
          }
          public uuid(): number {
            return this._uuid;
          }
          public metaClass(): org.kevoree.modeling.meta.KMetaClass {
            return this._metaClass;
          }
          public now(): number {
            return this._time;
          }
          public universe(): number {
            return this._universe;
          }
          public detach(callback: org.kevoree.modeling.KCallback<any>): void {
            var selfPointer: org.kevoree.modeling.KObject = this;
            var rawPayload: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (rawPayload == null) {
              if (callback != null) {
                callback(new Error(org.kevoree.modeling.abs.AbstractKObject.OUT_OF_CACHE_MSG));
              }
            } else {
              var collector: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
              var metaElements: org.kevoree.modeling.meta.KMeta[] = this._metaClass.metaElements();
              for (var i: number = 0; i < metaElements.length; i++) {
                if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                  var inboundsKeys: Float64Array = rawPayload.getLongArray(metaElements[i].index(), this._metaClass);
                  for (var j: number = 0; j < inboundsKeys.length; j++) {
                    collector.put(inboundsKeys[j], inboundsKeys[j]);
                  }
                  rawPayload.clearLongArray(metaElements[i].index(), this._metaClass);
                }
              }
              var flatCollected: Float64Array = new Float64Array(collector.size());
              var indexI: Int32Array = new Int32Array(1);
              indexI[0] = 0;
              collector.each((key : number, value : number) => {
                flatCollected[indexI[0]] = value;
                indexI[0]++;
              });
              this._manager.lookupAllObjects(this._universe, this._time, flatCollected, (resolved : org.kevoree.modeling.KObject[]) => {
                for (var i: number = 0; i < resolved.length; i++) {
                  if (resolved[i] != null) {
                    var linkedReferences: org.kevoree.modeling.meta.KMetaRelation[] = resolved[i].referencesWith(selfPointer);
                    for (var j: number = 0; j < linkedReferences.length; j++) {
                      (<org.kevoree.modeling.abs.AbstractKObject>resolved[i]).internal_remove(linkedReferences[j], selfPointer, false);
                    }
                  }
                }
                if (callback != null) {
                  callback(null);
                }
              });
            }
          }
          public select(query: string, cb: org.kevoree.modeling.KCallback<any[]>): void {
            if (!org.kevoree.modeling.util.Checker.isDefined(query)) {
              cb(new Array<org.kevoree.modeling.KObject>(0));
            } else {
              var singleRoot: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(1);
              singleRoot[0] = this;
              org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().eval(query, singleRoot, this._manager.model().universe(this._universe).time(this._time), cb);
            }
          }
          public get(p_attribute: org.kevoree.modeling.meta.KMetaAttribute): any {
            var transposed: org.kevoree.modeling.meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
            if (transposed == null) {
              throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
              return transposed.strategy().extrapolate(this, transposed, this._manager);
            }
          }
          public getByName(attributeName: string): any {
            var transposed: org.kevoree.modeling.meta.KMetaAttribute = this._metaClass.attribute(attributeName);
            if (transposed != null) {
              return transposed.strategy().extrapolate(this, transposed, this._manager);
            } else {
              return null;
            }
          }
          public set(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): void {
            var transposed: org.kevoree.modeling.meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
            if (transposed == null) {
              throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
              transposed.strategy().mutate(this, transposed, payload, this._manager);
            }
          }
          public setByName(attributeName: string, payload: any): void {
            var transposed: org.kevoree.modeling.meta.KMetaAttribute = this._metaClass.attribute(attributeName);
            if (transposed != null) {
              transposed.strategy().mutate(this, transposed, payload, this._manager);
            } else {
              throw new Error("Bad API usage, " + attributeName + " not found on object");
            }
          }
          public addByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this._metaClass.reference(relationName);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + relationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_add(metaReference, objToAdd, true);
          }
          public add(p_metaReference: org.kevoree.modeling.meta.KMetaRelation, objToAdd: org.kevoree.modeling.KObject): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_add(metaReference, objToAdd, true);
          }
          private internal_add(p_metaReference: org.kevoree.modeling.meta.KMetaRelation, p_param: org.kevoree.modeling.KObject, p_setOpposite: boolean): void {
            if (p_param == null) {
              throw new Error("Bad KMF usage, the objToAdd param should not be null in the add method of reference named " + p_metaReference.metaName() + " part of " + this.metaClass().metaName());
            }
            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw != null) {
              if (p_metaReference.maxBound() < 0 || (p_metaReference.maxBound() > raw.getLongArraySize(p_metaReference.index(), this._metaClass))) {
                if (raw.addLongToArray(p_metaReference.index(), p_param.uuid(), this._metaClass)) {
                  if (p_setOpposite) {
                    (<org.kevoree.modeling.abs.AbstractKObject>p_param).internal_add(p_param.metaClass().reference(p_metaReference.oppositeName()), this, false);
                  }
                }
              } else {
                throw new Error("MaxBound constraint violated on relation " + p_metaReference.metaName() + " from metaClass " + this._metaClass.metaName());
              }
            }
          }
          public enforceTimepoint(): void {
            this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
          }
          public removeByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this._metaClass.reference(relationName);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + relationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_remove(metaReference, objToAdd, true);
          }
          public remove(p_metaReference: org.kevoree.modeling.meta.KMetaRelation, objToRemove: org.kevoree.modeling.KObject): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_remove(metaReference, objToRemove, true);
          }
          private internal_remove(p_metaReference: org.kevoree.modeling.meta.KMetaRelation, objToRemove: org.kevoree.modeling.KObject, p_setOpposite: boolean): void {
            var payload: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (payload != null) {
              if (payload.removeLongToArray(p_metaReference.index(), objToRemove.uuid(), this._metaClass)) {
                if (p_setOpposite) {
                  (<org.kevoree.modeling.abs.AbstractKObject>objToRemove).internal_remove(objToRemove.metaClass().reference(p_metaReference.oppositeName()), this, false);
                }
              }
            }
          }
          public addAllByName(p_metaRelationName: string, objsToAdd: org.kevoree.modeling.KObject[]): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this._metaClass.reference(p_metaRelationName);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            }
            for (var i: number = 0; i < objsToAdd.length; i++) {
              this.internal_add(metaReference, objsToAdd[i], true);
            }
          }
          public addAll(p_metaRelation: org.kevoree.modeling.meta.KMetaRelation, objsToAdd: org.kevoree.modeling.KObject[]): void {
            var transposedRelation: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaRelation);
            if (transposedRelation == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaRelation.metaName() + " is not part of " + this.metaClass().metaName());
            }
            for (var i: number = 0; i < objsToAdd.length; i++) {
              this.internal_add(transposedRelation, objsToAdd[i], true);
            }
          }
          public removeAllByName(p_metaRelationName: string, callback: org.kevoree.modeling.KCallback<any>): void {
            var metaReference: org.kevoree.modeling.meta.KMetaRelation = this._metaClass.reference(p_metaRelationName);
            if (metaReference == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            }
            this.internal_removeAll(metaReference, callback);
          }
          public removeAll(p_metaRelation: org.kevoree.modeling.meta.KMetaRelation, callback: org.kevoree.modeling.KCallback<any>): void {
            var transposedRelation: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaRelation);
            if (transposedRelation == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaRelation.metaName() + " is not part of " + this.metaClass().metaName());
            }
            this.internal_removeAll(transposedRelation, callback);
          }
          private internal_removeAll(p_metaRelation: org.kevoree.modeling.meta.KMetaRelation, callback: org.kevoree.modeling.KCallback<any>): void {
            var selfPointer: org.kevoree.modeling.KObject = this;
            var currentChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            this._manager.lookupAllObjects(this._universe, this._time, currentChunk.getLongArray(p_metaRelation.index(), this._metaClass), (previousObjs : org.kevoree.modeling.KObject[]) => {
              for (var i: number = 0; i < previousObjs.length; i++) {
                if (previousObjs[i] != null) {
                  var oppositeRelation: org.kevoree.modeling.meta.KMetaRelation = previousObjs[i].metaClass().reference(p_metaRelation.oppositeName());
                  (<org.kevoree.modeling.abs.AbstractKObject>previousObjs[i]).internal_remove(oppositeRelation, selfPointer, false);
                }
              }
              currentChunk.clearLongArray(p_metaRelation.index(), this._metaClass);
              if (callback != null) {
                callback(null);
              }
            });
          }
          public size(p_metaReference: org.kevoree.modeling.meta.KMetaRelation): number {
            var transposed: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (transposed == null) {
              throw new Error("Bad KMF usage, the attribute named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
              if (raw != null) {
                var ref: any = raw.getPrimitiveType(transposed.index(), this._metaClass);
                if (ref == null) {
                  return 0;
                } else {
                  try {
                    var castedRefArray: Float64Array = <Float64Array>ref;
                    return castedRefArray.length;
                  } catch ($ex$) {
                    if ($ex$ instanceof Error) {
                      var e: Error = <Error>$ex$;
                      console.error(e['stack']);
                      return 0;
                    } else {
                      throw $ex$;
                    }
                  }
                }
              } else {
                return 0;
              }
            }
          }
          public getRelationByName(p_metaRelationName: string, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            var transposed: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(this._metaClass.reference(p_metaRelationName));
            if (transposed == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaRelationName + " is not part of " + this.metaClass().metaName());
            } else {
              this.internal_getRelation(transposed, cb);
            }
          }
          public getRelation(p_metaReference: org.kevoree.modeling.meta.KMetaRelation, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            var transposed: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(p_metaReference);
            if (transposed == null) {
              throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
            } else {
              this.internal_getRelation(transposed, cb);
            }
          }
          private internal_getRelation(p_transposedRelation: org.kevoree.modeling.meta.KMetaRelation, cb: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw == null) {
              cb(new Array<org.kevoree.modeling.KObject>(0));
            } else {
              var o: Float64Array = raw.getLongArray(p_transposedRelation.index(), this._metaClass);
              if (o == null) {
                cb(new Array<org.kevoree.modeling.KObject>(0));
              } else {
                this._manager.lookupAllObjects(this._universe, this._time, o, cb);
              }
            }
          }
          public getRelationValuesByName(p_refName: string): Float64Array {
            var transposed: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(this.metaClass().reference(p_refName));
            if (transposed == null) {
              throw new Error("Bad KMF usage, the reference named " + p_refName + " is not part of " + this.metaClass().metaName());
            } else {
              return this.internal_getRefValues(transposed);
            }
          }
          public getRelationValues(metaRelation: org.kevoree.modeling.meta.KMetaRelation): Float64Array {
            var transposed: org.kevoree.modeling.meta.KMetaRelation = this.internal_transpose_ref(metaRelation);
            if (transposed == null) {
              throw new Error("Bad KMF usage, the reference named " + metaRelation + " is not part of " + this.metaClass().metaName());
            } else {
              return this.internal_getRefValues(transposed);
            }
          }
          private internal_getRefValues(transposedReference: org.kevoree.modeling.meta.KMetaRelation): Float64Array {
            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw == null) {
              return new Float64Array(0);
            } else {
              var o: Float64Array = raw.getLongArray(transposedReference.index(), this._metaClass);
              if (o == null) {
                return new Float64Array(0);
              } else {
                return o;
              }
            }
          }
          public visitAttributes(visitor: org.kevoree.modeling.traversal.visitor.KModelAttributeVisitor): void {
            if (!org.kevoree.modeling.util.Checker.isDefined(visitor)) {
              return;
            }
            var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
            for (var i: number = 0; i < metaElements.length; i++) {
              if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                visitor.visit(metaAttribute, this.get(metaAttribute));
              }
            }
          }
          public visit(p_visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, cb: org.kevoree.modeling.KCallback<any>): void {
            this.internal_visit(p_visitor, cb, new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null), new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null));
          }
          private internal_visit(visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, end: org.kevoree.modeling.KCallback<any>, visited: org.kevoree.modeling.memory.chunk.KLongLongMap, traversed: org.kevoree.modeling.memory.chunk.KLongLongMap): void {
            if (!org.kevoree.modeling.util.Checker.isDefined(visitor)) {
              return;
            }
            if (traversed != null) {
              traversed.put(this._uuid, this._uuid);
            }
            var toResolveIds: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
            var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
            for (var i: number = 0; i < metaElements.length; i++) {
              if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                var reference: org.kevoree.modeling.meta.KMetaRelation = <org.kevoree.modeling.meta.KMetaRelation>metaElements[i];
                var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                if (raw != null) {
                  var idArr: Float64Array = raw.getLongArray(reference.index(), this._metaClass);
                  if (idArr != null) {
                    try {
                      for (var k: number = 0; k < idArr.length; k++) {
                        if (traversed == null || !traversed.contains(idArr[k])) {
                          toResolveIds.put(idArr[k], idArr[k]);
                        }
                      }
                    } catch ($ex$) {
                      if ($ex$ instanceof Error) {
                        var e: Error = <Error>$ex$;
                        console.error(e['stack']);
                      } else {
                        throw $ex$;
                      }
                    }
                  }
                }
              }
            }
            if (toResolveIds.size() == 0) {
              if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                end(null);
              }
            } else {
              var trimmed: Float64Array = new Float64Array(toResolveIds.size());
              var inserted: Int32Array = new Int32Array([0]);
              toResolveIds.each((key : number, value : number) => {
                trimmed[inserted[0]] = value;
                inserted[0]++;
              });
              this._manager.lookupAllObjects(this._universe, this._time, trimmed, (resolvedArr : org.kevoree.modeling.KObject[]) => {
                var nextDeep: java.util.List<org.kevoree.modeling.KObject> = new java.util.ArrayList<org.kevoree.modeling.KObject>();
                for (var i: number = 0; i < resolvedArr.length; i++) {
                  var resolved: org.kevoree.modeling.KObject = resolvedArr[i];
                  var result: org.kevoree.modeling.traversal.visitor.KVisitResult = org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE;
                  if (resolved != null) {
                    if (visitor != null && (visited == null || !visited.contains(resolved.uuid()))) {
                      result = visitor.visit(resolved);
                    }
                    if (visited != null) {
                      visited.put(resolved.uuid(), resolved.uuid());
                    }
                  }
                  if (result != null && result.equals(org.kevoree.modeling.traversal.visitor.KVisitResult.STOP)) {
                    if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                      end(null);
                    }
                  } else {
                    if (!org.kevoree.modeling.util.Checker.isDefined(result)) {
                      result = org.kevoree.modeling.traversal.visitor.KVisitResult.STOP;
                    }
                    if (resolved != null && result.equals(org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE)) {
                      if (traversed == null || !traversed.contains(resolved.uuid())) {
                        nextDeep.add(resolved);
                      }
                    }
                  }
                }
                if (!nextDeep.isEmpty()) {
                  var index: Int32Array = new Int32Array(1);
                  index[0] = 0;
                  var next: java.util.List<org.kevoree.modeling.KCallback<Error>> = new java.util.ArrayList<org.kevoree.modeling.KCallback<Error>>();
                  next.add((throwable : Error) => {
                    index[0] = index[0] + 1;
                    if (index[0] == nextDeep.size()) {
                      if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                        end(null);
                      }
                    } else {
                      var abstractKObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>nextDeep.get(index[0]);
                      abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                    }
                  });
                  var abstractKObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>nextDeep.get(index[0]);
                  abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                } else {
                  if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                    end(null);
                  }
                }
              });
            }
          }
          public toJSON(): string {
            var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
            builder.append("{\"universe\":");
            builder.append(this._universe);
            builder.append(",\"time\":");
            builder.append(this._time);
            builder.append(",\"uuid\":");
            builder.append(this._uuid);
            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            if (raw != null) {
              builder.append(",\"data\":");
              builder.append(raw.toJSON(this._manager.model().metaModel()));
            }
            builder.append("}");
            return builder.toString();
          }
          public toString(): string {
            return this.toJSON();
          }
          public equals(obj: any): boolean {
            if (!(obj instanceof org.kevoree.modeling.abs.AbstractKObject)) {
              return false;
            } else {
              var casted: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>obj;
              return casted._uuid == this._uuid && casted._time == this._time && casted._universe == this._universe;
            }
          }
          public hashCode(): number {
            return <number>(this._universe ^ this._time ^ this._uuid);
          }
          public jump(p_time: number, p_callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
            this._manager.lookup(this._universe, p_time, this._uuid, p_callback);
          }
          public internal_transpose_ref(p: org.kevoree.modeling.meta.KMetaRelation): org.kevoree.modeling.meta.KMetaRelation {
            if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
              return null;
            } else {
              return <org.kevoree.modeling.meta.KMetaRelation>this._metaClass.metaByName(p.metaName());
            }
          }
          public internal_transpose_att(p: org.kevoree.modeling.meta.KMetaAttribute): org.kevoree.modeling.meta.KMetaAttribute {
            if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
              return null;
            } else {
              return <org.kevoree.modeling.meta.KMetaAttribute>this._metaClass.metaByName(p.metaName());
            }
          }
          public internal_transpose_op(p: org.kevoree.modeling.meta.KMetaOperation): org.kevoree.modeling.meta.KMetaOperation {
            if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
              return null;
            } else {
              return <org.kevoree.modeling.meta.KMetaOperation>this._metaClass.metaByName(p.metaName());
            }
          }
          public traversal(): org.kevoree.modeling.traversal.KTraversal {
            var singleRoot: org.kevoree.modeling.KObject[] = new Array<org.kevoree.modeling.KObject>(1);
            singleRoot[0] = this;
            return new org.kevoree.modeling.traversal.impl.Traversal(singleRoot);
          }
          public referencesWith(o: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMetaRelation[] {
            if (org.kevoree.modeling.util.Checker.isDefined(o)) {
              var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
              if (raw != null) {
                var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
                var selected: java.util.List<org.kevoree.modeling.meta.KMetaRelation> = new java.util.ArrayList<org.kevoree.modeling.meta.KMetaRelation>();
                for (var i: number = 0; i < metaElements.length; i++) {
                  if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.RELATION) {
                    var rawI: Float64Array = raw.getLongArray((metaElements[i].index()), this._metaClass);
                    if (rawI != null) {
                      var oUUID: number = o.uuid();
                      for (var h: number = 0; h < rawI.length; h++) {
                        if (rawI[h] == oUUID) {
                          selected.add(<org.kevoree.modeling.meta.KMetaRelation>metaElements[i]);
                          break;
                        }
                      }
                    }
                  }
                }
                return selected.toArray(new Array<org.kevoree.modeling.meta.KMetaRelation>(selected.size()));
              } else {
                return new Array<org.kevoree.modeling.meta.KMetaRelation>(0);
              }
            } else {
              return new Array<org.kevoree.modeling.meta.KMetaRelation>(0);
            }
          }
          public invokeOperation(p_operation: org.kevoree.modeling.meta.KMetaOperation, p_params: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, cb: org.kevoree.modeling.KCallback<any>): void {
            this._manager.operationManager().invoke(this, p_operation, p_params, strategy, cb);
          }
          public invokeOperationByName(operationName: string, p_params: any[], strategy: org.kevoree.modeling.operation.KOperationStrategy, cb: org.kevoree.modeling.KCallback<any>): void {
            var metaOp: org.kevoree.modeling.meta.KMetaOperation = this._metaClass.operation(operationName);
            if (metaOp == null) {
              throw new Error("Operation not founded with name " + operationName + " in the metaClass " + this._metaClass.metaName());
            }
            this._manager.operationManager().invoke(this, metaOp, p_params, strategy, cb);
          }
          public manager(): org.kevoree.modeling.memory.manager.KDataManager {
            return this._manager;
          }
          private internal_times(start: number, end: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void {
            this._manager.resolveTimes(this._universe, this._uuid, start, end, cb);
          }
          public allTimes(cb: org.kevoree.modeling.KCallback<Float64Array>): void {
            this.internal_times(org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME, cb);
          }
          public timesBefore(endOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void {
            this.internal_times(org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, endOfSearch, cb);
          }
          public timesAfter(beginningOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void {
            this.internal_times(beginningOfSearch, org.kevoree.modeling.KConfig.END_OF_TIME, cb);
          }
          public timesBetween(beginningOfSearch: number, endOfSearch: number, cb: org.kevoree.modeling.KCallback<Float64Array>): void {
            this.internal_times(beginningOfSearch, endOfSearch, cb);
          }
          public compare(target: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMeta[] {
            if (target.metaClass().index() != this.metaClass().index()) {
              throw new Error("Bad API usage, the object should be compare to a similar one (" + this.metaClass().metaName() + "/" + target.metaClass().metaName() + ")");
            }
            var elems: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
            var result: org.kevoree.modeling.meta.KMeta[] = new Array<org.kevoree.modeling.meta.KMeta>(elems.length);
            var current: number = 0;
            for (var i: number = 0; i < elems.length; i++) {
              var meta: org.kevoree.modeling.meta.KMeta = elems[i];
              if (meta.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                var attribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>meta;
                var currentAttV: any = this.get(attribute);
                var targetAttV: any = target.get(attribute);
                if (currentAttV == null && targetAttV != null) {
                  result[current] = attribute;
                  current++;
                } else {
                  if (currentAttV != null && targetAttV == null) {
                    result[current] = attribute;
                    current++;
                  } else {
                    if (currentAttV != null && targetAttV != null) {
                      switch (attribute.attributeTypeId()) {
                        case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                        var castedCurrentBool: boolean = <boolean>currentAttV;
                        var castedTargetBool: boolean = <boolean>targetAttV;
                        if (castedCurrentBool != castedTargetBool) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                        var castedCurrentDouble: number = <number>currentAttV;
                        var castedTargetDouble: number = <number>targetAttV;
                        if (castedCurrentDouble != castedTargetDouble) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                        var castedCurrentDoubleZ: number = <number>currentAttV;
                        var castedTargetDoubleZ: number = <number>targetAttV;
                        if (castedCurrentDoubleZ != castedTargetDoubleZ) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                        var castedCurrentInt: number = <number>currentAttV;
                        var castedTargetInt: number = <number>targetAttV;
                        if (castedCurrentInt != castedTargetInt) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                        var castedCurrentLong: number = <number>currentAttV;
                        var castedTargetLong: number = <number>targetAttV;
                        if (castedCurrentLong != castedTargetLong) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                        var castedCurrentString: string = <string>currentAttV;
                        var castedTargetString: string = <string>targetAttV;
                        if (!org.kevoree.modeling.util.PrimitiveHelper.equals(castedCurrentString, castedTargetString)) {
                          result[current] = attribute;
                          current++;
                        }
                        break;
                        default:
                        if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                          var castedCurrentEnum: org.kevoree.modeling.meta.KLiteral = <org.kevoree.modeling.meta.KLiteral>currentAttV;
                          var castedTargetEnum: org.kevoree.modeling.meta.KLiteral = <org.kevoree.modeling.meta.KLiteral>targetAttV;
                          if (castedCurrentEnum.index() != castedTargetEnum.index()) {
                            result[current] = attribute;
                            current++;
                          }
                        }
                        break;
                      }
                    }
                  }
                }
              }
            }
            var trimmed: org.kevoree.modeling.meta.KMeta[] = new Array<org.kevoree.modeling.meta.KMeta>(current);
            java.lang.System.arraycopy(result, 0, trimmed, 0, current);
            return trimmed;
          }
        }
        export class AbstractKObjectIndex extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.modeling.KObjectIndex {
          constructor(p_universe: number, p_time: number, p_uuid: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number) {
            super(p_universe, p_time, p_uuid, org.kevoree.modeling.meta.impl.MetaClassIndex.INSTANCE, p_manager, p_actualUniverse, p_actualTime);
          }
          public getIndex(key: string): number {
            var chunk: org.kevoree.modeling.memory.chunk.KObjectIndexChunk = <org.kevoree.modeling.memory.chunk.KObjectIndexChunk>this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            return chunk.get(key);
          }
          public setIndex(key: string, value: number): void {
            var chunk: org.kevoree.modeling.memory.chunk.KObjectIndexChunk = <org.kevoree.modeling.memory.chunk.KObjectIndexChunk>this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            chunk.put(key, value);
          }
          public values(): Float64Array {
            var chunk: org.kevoree.modeling.memory.chunk.KObjectIndexChunk = <org.kevoree.modeling.memory.chunk.KObjectIndexChunk>this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
            var result: Float64Array = new Float64Array(chunk.size());
            var i: Int32Array = new Int32Array([0]);
            chunk.each((key : string, value : number) => {
              if (value != org.kevoree.modeling.KConfig.NULL_LONG) {
                result[i[0]] = value;
                i[0]++;
              }
            });
            if (result.length == i[0]) {
              return result;
            } else {
              var trimmedResult: Float64Array = new Float64Array(i[0]);
              java.lang.System.arraycopy(result, 0, trimmedResult, 0, i[0]);
              return trimmedResult;
            }
          }
        }
        export abstract class AbstractKModel<A extends org.kevoree.modeling.KUniverse<any, any>> implements org.kevoree.modeling.KModel<A> {
          public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
          private _key: number;
          constructor(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
            this._manager = p_manager;
            this._manager.setModel(this);
            this._key = this._manager.nextModelKey();
          }
          public abstract metaModel(): org.kevoree.modeling.meta.KMetaModel;
          public connect(cb: org.kevoree.modeling.KCallback<any>): void {
            this._manager.connect(cb);
          }
          public disconnect(cb: org.kevoree.modeling.KCallback<any>): void {
            this._manager.close(cb);
          }
          public manager(): org.kevoree.modeling.memory.manager.KDataManager {
            return this._manager;
          }
          public newUniverse(): A {
            var nextKey: number = this._manager.nextUniverseKey();
            var newDimension: A = this.internalCreateUniverse(nextKey);
            this._manager.initUniverse(nextKey, nextKey);
            return newDimension;
          }
          public abstract internalCreateUniverse(universe: number): A;
          public abstract internalCreateObject(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject;
          public createProxy(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
            return this.internalCreateObject(universe, time, uuid, clazz, previousUniverse, previousTime);
          }
          public universe(key: number): A {
            var newDimension: A = this.internalCreateUniverse(key);
            this._manager.initUniverse(key, key);
            return newDimension;
          }
          public save(callback: org.kevoree.modeling.KCallback<any>): void {
            this._manager.save(callback);
          }
          public setOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, operation: org.kevoree.modeling.KOperation<any, any>): void {
            this._manager.operationManager().register(metaOperation, operation);
          }
          public setOperationByName(metaClassName: string, metaOperationName: string, operation: org.kevoree.modeling.KOperation<any, any>): void {
            var tempMC: org.kevoree.modeling.meta.KMetaClass = this._manager.model().metaModel().metaClassByName(metaClassName);
            if (tempMC != null) {
              var tempMO: org.kevoree.modeling.meta.KMetaOperation = tempMC.operation(metaOperationName);
              if (tempMO != null) {
                this._manager.operationManager().register(tempMO, operation);
              } else {
                throw new Error("MetaOperation not found with name " + metaOperationName + " on MetaClass " + metaClassName);
              }
            } else {
              throw new Error("MetaClass not found with name " + metaClassName);
            }
          }
          public defer(): org.kevoree.modeling.defer.KDefer {
            return new org.kevoree.modeling.defer.impl.Defer();
          }
          public key(): number {
            return this._key;
          }
          public create(clazz: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number): org.kevoree.modeling.KObject {
            if (!org.kevoree.modeling.util.Checker.isDefined(clazz)) {
              return null;
            }
            var newObj: org.kevoree.modeling.KObject = this.internalCreateObject(universe, time, this._manager.nextObjectKey(), clazz, universe, time);
            if (newObj != null) {
              this._manager.initKObject(newObj);
            }
            return newObj;
          }
          public createByName(metaClassName: string, universe: number, time: number): org.kevoree.modeling.KObject {
            return this.create(this._manager.model().metaModel().metaClassByName(metaClassName), universe, time);
          }
          public lookup(p_universe: number, p_time: number, p_uuid: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
            this._manager.lookup(p_universe, p_time, p_uuid, callback);
          }
          public lookupAllObjects(p_universe: number, p_time: number, p_uuids: Float64Array, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.lookupAllObjects(p_universe, p_time, p_uuids, callback);
          }
          public lookupAllTimes(p_universe: number, p_times: Float64Array, p_uuids: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.lookupAllTimes(p_universe, p_times, p_uuids, callback);
          }
          public createPreparedLookup(p_size: number): org.kevoree.modeling.KPreparedLookup {
            return this._manager.createPreparedLookup(p_size);
          }
          public lookupPrepared(p_prepared: org.kevoree.modeling.KPreparedLookup, p_callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.lookupPrepared(p_prepared, p_callback);
          }
          public createListener(universe: number): org.kevoree.modeling.KListener {
            return this._manager.createListener(universe);
          }
          public createModelContext(): org.kevoree.modeling.KModelContext {
            return new org.kevoree.modeling.abs.AbstractKModelContext(this);
          }
          public createTraversal(startingElements: org.kevoree.modeling.KObject[]): org.kevoree.modeling.traversal.KTraversal {
            return new org.kevoree.modeling.traversal.impl.Traversal(startingElements);
          }
          public createReusableTraversal(): org.kevoree.modeling.traversal.KTraversal {
            return new org.kevoree.modeling.traversal.impl.Traversal(null);
          }
          public find(metaClass: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number, attributes: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
            this.findByName(metaClass.metaName(), universe, time, attributes, callback);
          }
          public findByName(indexName: string, universe: number, time: number, attributes: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject>): void {
            if (!org.kevoree.modeling.util.Checker.isDefined(attributes)) {
              if (org.kevoree.modeling.util.Checker.isDefined(callback)) {
                callback(null);
              }
            } else {
              this._manager.index(universe, time, indexName, (kObjectIndex : org.kevoree.modeling.KObjectIndex) => {
                var concat: string = "";
                var params: org.kevoree.modeling.memory.chunk.KStringMap<string> = this.buildParams(attributes);
                if (params.size() == 0) {
                  concat = attributes;
                } else {
                  var currentClass: org.kevoree.modeling.meta.KMetaClass = this.metaModel().metaClassByName(indexName);
                  if (currentClass == null) {
                    concat = attributes;
                  } else {
                    var elems: org.kevoree.modeling.meta.KMeta[] = currentClass.metaElements();
                    for (var i: number = 0; i < elems.length; i++) {
                      if (elems[i] != null && elems[i].metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE) && (<org.kevoree.modeling.meta.KMetaAttribute>elems[i]).key()) {
                        var lvalue: string = params.get(elems[i].metaName());
                        if (lvalue != null) {
                          concat += lvalue;
                        }
                      }
                    }
                  }
                }
                var objectUUID: number = kObjectIndex.getIndex(concat);
                if (objectUUID == org.kevoree.modeling.KConfig.NULL_LONG) {
                  if (org.kevoree.modeling.util.Checker.isDefined(callback)) {
                    callback(null);
                  }
                } else {
                  this._manager.lookup(universe, time, objectUUID, callback);
                }
              });
            }
          }
          private buildParams(p_paramString: string): org.kevoree.modeling.memory.chunk.KStringMap<string> {
            var params: org.kevoree.modeling.memory.chunk.KStringMap<string> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<string>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
            var iParam: number = 0;
            var lastStart: number = iParam;
            while (iParam < p_paramString.length){
              if (p_paramString.charAt(iParam) == org.kevoree.modeling.traversal.query.impl.QueryEngine.VALS_SEP) {
                var p: string = p_paramString.substring(lastStart, iParam).trim();
                if (!org.kevoree.modeling.util.PrimitiveHelper.equals(p, "")) {
                  var pArray: string[] = p.split(org.kevoree.modeling.traversal.query.impl.QueryEngine.VAL_SEP);
                  if (pArray.length > 1) {
                    params.put(pArray[0].trim(), pArray[1].trim());
                  }
                }
                lastStart = iParam + 1;
              }
              iParam = iParam + 1;
            }
            var lastParam: string = p_paramString.substring(lastStart, iParam).trim();
            if (!org.kevoree.modeling.util.PrimitiveHelper.equals(lastParam, "")) {
              var pArray: string[] = lastParam.split(org.kevoree.modeling.traversal.query.impl.QueryEngine.VAL_SEP);
              if (pArray.length > 1) {
                params.put(pArray[0].trim(), pArray[1].trim());
              }
            }
            return params;
          }
          public indexByName(universe: number, time: number, indexName: string, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObjectIndex>): void {
            this._manager.index(universe, time, indexName, callback);
          }
          public findAll(metaClass: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this.findAllByName(metaClass.metaName(), universe, time, callback);
          }
          public findAllByName(indexName: string, universe: number, time: number, callback: org.kevoree.modeling.KCallback<org.kevoree.modeling.KObject[]>): void {
            this._manager.index(universe, time, indexName, (index : org.kevoree.modeling.KObjectIndex) => {
              if (index == null) {
                if (callback != null) {
                  callback(new Array<org.kevoree.modeling.KObject>(0));
                }
              } else {
                this._manager.lookupAllObjects(universe, time, index.values(), callback);
              }
            });
          }
        }
      }
    }
  }
}
