export module java {
    export module lang {
        export class System {
            static gc() {
            }

            static arraycopy(src:any[] | Float64Array | Int32Array, srcPos:number, dest:any[] | Float64Array | Int32Array, destPos:number, numElements:number):void {
                for (var i = 0; i < numElements; i++) {
                    dest[destPos + i] = src[srcPos + i];
                }
            }
        }
        export interface Runnable {
            run(): void;
        }
        export class StringBuilder {
            private _buffer:string = '';
            public length = 0;

            append(val:any):StringBuilder {
                this._buffer = this._buffer + val;
                length = this._buffer.length;
                return this;
            }

            toString():string {
                return this._buffer;
            }
        }
    }
    export module util {
        export module concurrent {
            export module atomic {
                export class AtomicIntegerArray {
                    _internal:Int32Array;

                    constructor(p:Int32Array) {
                        this._internal = p;
                    }

                    set(index:number, newVal:number) {
                        this._internal[index] = newVal;
                    }

                    get(index:number) {
                        return this._internal[index];
                    }

                    getAndSet(index:number, newVal:number) {
                        var temp = this._internal[index];
                        this._internal[index] = newVal;
                        return temp;
                    }

                    compareAndSet(index:number, expect:number, update:number):boolean {
                        if (this._internal[index] == expect) {
                            this._internal[index] = update;
                            return true;
                        } else {
                            return false;
                        }
                    }

                }

                export class AtomicReference<A> {
                    _internal:A = null;

                    compareAndSet(expect:A, update:A):boolean {
                        if (this._internal == expect) {
                            this._internal = update;
                            return true;
                        } else {
                            return false;
                        }
                    }

                    get():A {
                        return this._internal
                    }

                    set(newRef:A) {
                        this._internal = newRef;
                    }

                    getAndSet(newVal:A):A {
                        var temp = this._internal;
                        this._internal = newVal;
                        return temp;
                    }
                }

                export class AtomicLong {
                    _internal = 0;

                    constructor(init:number) {
                        this._internal = init;
                    }

                    compareAndSet(expect:number, update:number):boolean {
                        if (this._internal == expect) {
                            this._internal = update;
                            return true;
                        } else {
                            return false;
                        }
                    }

                    get():number {
                        return this._internal;
                    }

                    incrementAndGet():number {
                        this._internal++;
                        return this._internal;
                    }

                    decrementAndGet():number {
                        this._internal--;
                        return this._internal;
                    }
                }

                export class AtomicInteger {
                    _internal = 0;

                    constructor(init:number) {
                        this._internal = init;
                    }

                    compareAndSet(expect:number, update:number):boolean {
                        if (this._internal == expect) {
                            this._internal = update;
                            return true;
                        } else {
                            return false;
                        }
                    }

                    get():number {
                        return this._internal;
                    }

                    set(newVal:number) {
                        this._internal = newVal
                    }

                    getAndSet(newVal:number):number {
                        var temp = this._internal;
                        this._internal = newVal;
                        return temp;
                    }

                    incrementAndGet():number {
                        this._internal++;
                        return this._internal;
                    }

                    decrementAndGet():number {
                        this._internal--;
                        return this._internal;
                    }

                    getAndIncrement():number {
                        var temp = this._internal;
                        this._internal++;
                        return temp;
                    }

                    getAndDecrement():number {
                        var temp = this._internal;
                        this._internal--;
                        return temp;
                    }
                }
            }
        }

        export class Random {
            public nextInt(max?:number):number {
                if (typeof max === 'undefined') {
                    max = Math.pow(2, 32);
                }
                return Math.floor(Math.random() * max);
            }

            public nextDouble():number {
                return Math.random();
            }

            public nextBoolean():boolean {
                return Math.random() >= 0.5;
            }
        }

        export class Arrays {
            public static fill(data:any, begin:number, nbElem:number, param:number):void {
                var max = begin + nbElem;
                for (var i = begin; i < max; i++) {
                    data[i] = param;
                }
            }
        }

        export class Collections {

            public static reverse<A>(p:List<A>):void {
                var temp = new List<A>();
                for (var i = 0; i < p.size(); i++) {
                    temp.add(p.get(i));
                }
                p.clear();
                for (var i = temp.size() - 1; i >= 0; i--) {
                    p.add(temp.get(i));
                }
            }

            public static sort<A>(p:List<A>):void {
                p.sort();
            }
        }

        export interface Collection<T> {
            add(val:T): void
            addAll(vals:Collection<T>): void
            remove(val:T): void
            clear(): void
            isEmpty(): boolean
            size(): number
            contains(val:T): boolean
            toArray(a:Array<T>): T[]
        }

        export class XArray {
            length:number;

            constructor() {
                Array.apply(this, arguments);
                return new Array();
            }

            pop():any {
                return "";
            }

            push(val:any):number {
                return 0;
            }

            splice(newS:any, arrL:any):void {
            }

            indexOf(val:any):number {
                return 0;
            }

            shift():any {
                return "";
            }

            sort():void {
            }
        }

        XArray.prototype = new Array();

        export class List<T> extends XArray implements Collection<T> {

            addAll(vals:Collection<T>) {
                var tempArray = vals.toArray(null);
                for (var i = 0; i < tempArray.length; i++) {
                    this.push(tempArray[i]);
                }
            }

            clear() {
                this.length = 0;
            }

            poll():T {
                return this.shift();
            }

            remove(val:T) {

            }

            toArray(a:Array<T>):T[] {
                return <T[]><any>this;
            }

            size():number {
                return this.length;
            }

            add(val:T):void {
                this.push(val);
            }

            get(index:number):T {
                return this[index];
            }

            contains(val:T):boolean {
                return this.indexOf(val) != -1;
            }

            isEmpty():boolean {
                return this.length == 0;
            }
        }

        export class ArrayList<T> extends List<T> {
        }

        export class LinkedList<T> extends List<T> {
        }

        export class Stack<T> {
            content = new Array();

            pop():T {
                return this.content.pop();
            }

            push(t:T):void {
                this.content.push(t);
            }

            isEmpty():boolean {
                return this.content.length == 0;
            }

            peek():T {
                return this.content.slice(-1)[0];
            }

        }

        export class Map<K, V> {

            get(key:K):V {
                return this[<any>key];
            }

            put(key:K, value:V):V {
                var previous_val = this[<any>key];
                this[<any>key] = value;
                return previous_val;
            }

            containsKey(key:K):boolean {
                return this.hasOwnProperty(<any>key);
            }

            remove(key:K):V {
                var tmp = this[<any>key];
                delete this[<any>key];
                return tmp;
            }

            keySet():Set<K> {
                var result = new HashSet<K>();
                for (var p in this) {
                    if (this.hasOwnProperty(p)) {
                        result.add(p);
                    }
                }
                return result;
            }

            isEmpty():boolean {
                return Object.keys(this).length == 0;
            }

            values():Set<V> {
                var result = new HashSet<V>();
                for (var p in this) {
                    if (this.hasOwnProperty(p)) {
                        result.add(this[p]);
                    }
                }
                return result;
            }

            clear():void {
                for (var p in this) {
                    if (this.hasOwnProperty(p)) {
                        delete this[p];
                    }
                }
            }

        }

        export class HashMap<K, V> extends Map<K, V> {
        }

        export class Set<T> implements Collection<T> {

            add(val:T) {
                this[<any>val] = val;
            }

            clear() {
                for (var p in this) {
                    if (this.hasOwnProperty(p)) {
                        delete this[p];
                    }
                }
            }

            contains(val:T):boolean {
                return this.hasOwnProperty(<any>val);
            }

            addAll(vals:Collection<T>) {
                var tempArray = vals.toArray(null);
                for (var i = 0; i < tempArray.length; i++) {
                    this[<any>tempArray[i]] = tempArray[i];
                }
            }

            remove(val:T) {
                delete this[<any>val];
            }

            size():number {
                return Object.keys(this).length;
            }

            isEmpty():boolean {
                return this.size() == 0;
            }

            toArray(a:Array<T>):T[] {
                for (var ik in this) {
                    a.push(this[ik]);
                }
                return a;
            }
        }

        export class HashSet<T> extends Set<T> {
        }
    }
}

export module org {
    export module kevoree {
        export module modeling {
            export class KActionType {

                public static CALL: KActionType = new KActionType();
                public static CALL_RESPONSE: KActionType = new KActionType();
                public static SET: KActionType = new KActionType();
                public static ADD: KActionType = new KActionType();
                public static REMOVE: KActionType = new KActionType();
                public static NEW: KActionType = new KActionType();
                public equals(other: any): boolean {
                    return this == other;
                }
                public static _KActionTypeVALUES : KActionType[] = [
                    KActionType.CALL
                    ,KActionType.CALL_RESPONSE
                    ,KActionType.SET
                    ,KActionType.ADD
                    ,KActionType.REMOVE
                    ,KActionType.NEW
                ];
                public static values():KActionType[]{
                    return KActionType._KActionTypeVALUES;
                }
            }

            export interface KCallback<A> {

                (a: A): void;

            }

            export class KConfig {

                public static CAS_MAX_TRY: number = 1000;
                public static CALLBACK_HISTORY: number = 1000;
                public static LONG_SIZE: number = 53;
                public static PREFIX_SIZE: number = 16;
                public static BEGINNING_OF_TIME: number = -0x001FFFFFFFFFFFFE;
                public static END_OF_TIME: number = 0x001FFFFFFFFFFFFE;
                public static NULL_LONG: number = 0x001FFFFFFFFFFFFF;
                public static KEY_PREFIX_MASK: number = 0x0000001FFFFFFFFF;
                public static KEY_SEP: string = '|';
                public static CACHE_INIT_SIZE: number = 16;
                public static CACHE_LOAD_FACTOR: number = (<number>75 / <number>100);
            }

            export class KContentKey {

                public static NULL_KEY: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME]);
                public static GLOBAL_UNIVERSE_KEY: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]);
                public universe: number;
                public time: number;
                public obj: number;
                public static toString(keys: Float64Array, keyIndex: number): string {
                    var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                    var offset: number = keyIndex * 3;
                    if (keys[offset] != org.kevoree.modeling.KConfig.NULL_LONG) {
                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(keys[offset], buffer);
                    }
                    buffer.append(org.kevoree.modeling.KConfig.KEY_SEP);
                    if (keys[offset + 1] != org.kevoree.modeling.KConfig.NULL_LONG) {
                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(keys[offset + 1], buffer);
                    }
                    buffer.append(org.kevoree.modeling.KConfig.KEY_SEP);
                    if (keys[offset + 2] != org.kevoree.modeling.KConfig.NULL_LONG) {
                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(keys[offset + 2], buffer);
                    }
                    return buffer.toString();
                }

                constructor(p_universeID: number, p_timeID: number, p_objID: number) {
                    this.universe = p_universeID;
                    this.time = p_timeID;
                    this.obj = p_objID;
                }

                public static createObject(p_universeID: number, p_quantaID: number, p_objectID: number): org.kevoree.modeling.KContentKey {
                    return new org.kevoree.modeling.KContentKey(p_universeID, p_quantaID, p_objectID);
                }

                public static createGlobalUniverseTree(): org.kevoree.modeling.KContentKey {
                    return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                }

                public static createRootUniverseTree(): org.kevoree.modeling.KContentKey {
                    return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME);
                }

                public static createLastPrefix(): org.kevoree.modeling.KContentKey {
                    return new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                }

                public static create(payload: string): org.kevoree.modeling.KContentKey {
                    if (payload == null || payload.length == 0) {
                        return null;
                    } else {
                        var key: org.kevoree.modeling.KContentKey = new org.kevoree.modeling.KContentKey(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                        var maxRead: number = payload.length;
                        var indexStartElem: number = -1;
                        var indexElem: number = 0;
                        var partIndex: number = 0;
                        for (var i: number = 0; i < maxRead; i++) {
                            if (payload.charAt(i) == org.kevoree.modeling.KConfig.KEY_SEP) {
                                if (indexStartElem != -1) {
                                    try {
                                        switch (partIndex) {
                                            case 0:
                                            key.universe = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                            break;
                                            case 1:
                                            key.time = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                            break;
                                            case 2:
                                            key.obj = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, i);
                                            break;
                                            default:
                                            break;
                                        }
                                    } catch ($ex$) {
                                        if ($ex$ instanceof Error) {
                                            var e: Error = <Error>$ex$;
                                            console.error(e['stack']);;
                                        } else {
                                            throw $ex$;
                                        }
                                    }
                                }
                                indexStartElem = -1;
                                indexElem = indexElem + 1;
                                partIndex++;
                            } else {
                                if (indexStartElem == -1) {
                                    indexStartElem = i;
                                }
                            }
                        }
                        if (indexStartElem != -1) {
                            try {
                                switch (partIndex) {
                                    case 0:
                                    key.universe = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                                    break;
                                    case 1:
                                    key.time = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                                    break;
                                    case 2:
                                    key.obj = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, indexStartElem, maxRead);
                                    break;
                                    default:
                                    break;
                                }
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    console.error(e['stack']);;
                                } else {
                                    throw $ex$;
                                }
                            }
                        }
                        return key;
                    }
                }

                public equals(param: any): boolean {
                    if (param instanceof org.kevoree.modeling.KContentKey) {
                        var remote: org.kevoree.modeling.KContentKey = <org.kevoree.modeling.KContentKey>param;
                        return remote.universe == this.universe && remote.time == this.time && remote.obj == this.obj;
                    } else {
                        return false;
                    }
                }

            }

            export interface KListener {

                universe(): number;

                listenObjects(): Float64Array;

                listen(obj: org.kevoree.modeling.KObject): void;

                delete(): void;

                then(updatedObjects: org.kevoree.modeling.KCallback<any>): void;

            }

            export interface KModel<A extends org.kevoree.modeling.KUniverse<any, any>> {

                key(): number;

                newUniverse(): A;

                universe(key: number): A;

                manager(): org.kevoree.modeling.memory.manager.KDataManager;

                setClassOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, operation: org.kevoree.modeling.KOperation<any, any>): void;

                setInstanceOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, target: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.KOperation<any, any>): void;

                metaModel(): org.kevoree.modeling.meta.KMetaModel;

                defer(): org.kevoree.modeling.defer.KDefer;

                save(cb: org.kevoree.modeling.KCallback<any>): void;

                connect(cb: org.kevoree.modeling.KCallback<any>): void;

                close(cb: org.kevoree.modeling.KCallback<any>): void;

                createByName(metaClassName: string, universe: number, time: number): org.kevoree.modeling.KObject;

                create(clazz: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number): org.kevoree.modeling.KObject;

                lookup(universe: number, time: number, uuid: number, cb: org.kevoree.modeling.KCallback<any>): void;

                lookupAll(universe: number, time: number, uuids: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void;

                createListener(universe: number): org.kevoree.modeling.KListener;

                createModelContext(): org.kevoree.modeling.KModelContext;

            }

            export interface KModelContext {

                set(originTime: number, maxTime: number, originUniverse: number, maxUniverse: number): void;

                originTime(): number;

                originUniverse(): number;

                maxTime(): number;

                maxUniverse(): number;

                listen(callback: org.kevoree.modeling.KCallback<any>): void;

                model(): org.kevoree.modeling.KModel<any>;

            }

            export interface KObject {

                universe(): number;

                now(): number;

                uuid(): number;

                metaClass(): org.kevoree.modeling.meta.KMetaClass;

                visitAttributes(visitor: org.kevoree.modeling.traversal.visitor.KModelAttributeVisitor): void;

                visit(visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, cb: org.kevoree.modeling.KCallback<any>): void;

                traversal(): org.kevoree.modeling.traversal.KTraversal;

                jump(time: number, callback: org.kevoree.modeling.KCallback<any>): void;

                select(query: string, cb: org.kevoree.modeling.KCallback<any>): void;

                delete(cb: org.kevoree.modeling.KCallback<any>): void;

                mutate(actionType: org.kevoree.modeling.KActionType, metaReference: org.kevoree.modeling.meta.KMetaReference, param: org.kevoree.modeling.KObject): void;

                ref(metaReference: org.kevoree.modeling.meta.KMetaReference, cb: org.kevoree.modeling.KCallback<any>): void;

                get(attribute: org.kevoree.modeling.meta.KMetaAttribute): any;

                getByName(atributeName: string): any;

                set(attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): void;

                setByName(atributeName: string, payload: any): void;

                getRefValuesByName(refName: string): Float64Array;

                addByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void;

                removeByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void;

                timeDephasing(): number;

                allTimes(cb: org.kevoree.modeling.KCallback<any>): void;

                timesBefore(endOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void;

                timesAfter(beginningOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void;

                timesBetween(beginningOfSearch: number, endOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void;

                toJSON(): string;

                equals(other: any): boolean;

                referencesWith(o: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMetaReference[];

                call(operation: org.kevoree.modeling.meta.KMetaOperation, params: any[], cb: org.kevoree.modeling.KCallback<any>): void;

                manager(): org.kevoree.modeling.memory.manager.KDataManager;

            }

            export interface KObjectInfer extends org.kevoree.modeling.KObject {

                genericTrain(dependencies: org.kevoree.modeling.KObject[], expectedOutputs: any[], callback: org.kevoree.modeling.KCallback<any>): void;

                genericTrainAll(trainingSet: org.kevoree.modeling.KObject[][], expectedResultSet: any[][], callback: org.kevoree.modeling.KCallback<any>): void;

                genericInfer(features: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any>): void;

                genericInferAll(features: org.kevoree.modeling.KObject[][], callback: org.kevoree.modeling.KCallback<any>): void;

                resetLearning(): void;

            }

            export interface KOperation<SourceObject extends org.kevoree.modeling.KObject, ResultType> {

                (source: SourceObject, params: any[], result: org.kevoree.modeling.KCallback<any>): void;

            }

            export interface KType {

                name(): string;

                isEnum(): boolean;

                id(): number;

            }

            export interface KUniverse<A extends org.kevoree.modeling.KView, B extends org.kevoree.modeling.KUniverse<any, any>> {

                key(): number;

                time(timePoint: number): A;

                diverge(): B;

                equals(other: any): boolean;

                lookupAllTimes(uuid: number, times: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void;

                createListener(): org.kevoree.modeling.KListener;

            }

            export interface KView {

                createByName(metaClassName: string): org.kevoree.modeling.KObject;

                create(clazz: org.kevoree.modeling.meta.KMetaClass): org.kevoree.modeling.KObject;

                select(query: string, cb: org.kevoree.modeling.KCallback<any>): void;

                lookup(key: number, cb: org.kevoree.modeling.KCallback<any>): void;

                lookupAll(keys: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void;

                universe(): number;

                now(): number;

                json(): org.kevoree.modeling.format.KModelFormat;

                xmi(): org.kevoree.modeling.format.KModelFormat;

                equals(other: any): boolean;

                setRoot(elem: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<any>): void;

                getRoot(cb: org.kevoree.modeling.KCallback<any>): void;

            }

            export module abs {
                export class AbstractDataType implements org.kevoree.modeling.KType {

                    private _name: string;
                    private _isEnum: boolean;
                    private _id: number;
                    constructor(p_name: string, p_isEnum: boolean, p_id: number) {
                        this._name = p_name;
                        this._isEnum = p_isEnum;
                        this._id = p_id;
                    }

                    public name(): string {
                        return this._name;
                    }

                    public isEnum(): boolean {
                        return this._isEnum;
                    }

                    public id(): number {
                        return this._id;
                    }

                }

                export class AbstractKModel<A extends org.kevoree.modeling.KUniverse<any, any>> implements org.kevoree.modeling.KModel<any> {

                    public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                    private _key: number;
                    constructor(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                        this._manager = p_manager;
                        this._manager.setModel(this);
                        this._key = this._manager.nextModelKey();
                    }

                    public metaModel(): org.kevoree.modeling.meta.KMetaModel {
                        throw "Abstract method";
                    }

                    public connect(cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.connect(cb);
                    }

                    public close(cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.close(cb);
                    }

                    public manager(): org.kevoree.modeling.memory.manager.KDataManager {
                        return this._manager;
                    }

                    public newUniverse(): A {
                        var nextKey: number = this._manager.nextUniverseKey();
                        var newDimension: A = this.internalCreateUniverse(nextKey);
                        this._manager.initUniverse(nextKey, nextKey);
                        return newDimension;
                    }

                    public internalCreateUniverse(universe: number): A {
                        throw "Abstract method";
                    }

                    public internalCreateObject(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
                        throw "Abstract method";
                    }

                    public createProxy(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
                        return this.internalCreateObject(universe, time, uuid, clazz, previousUniverse, previousTime);
                    }

                    public universe(key: number): A {
                        var newDimension: A = this.internalCreateUniverse(key);
                        this._manager.initUniverse(key, key);
                        return newDimension;
                    }

                    public save(cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.save(cb);
                    }

                    public setClassOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, operation: org.kevoree.modeling.KOperation<any, any>): void {
                        this._manager.operationManager().registerOperation(metaOperation, operation, null);
                    }

                    public setInstanceOperation(metaOperation: org.kevoree.modeling.meta.KMetaOperation, target: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.KOperation<any, any>): void {
                        this._manager.operationManager().registerOperation(metaOperation, operation, target);
                    }

                    public defer(): org.kevoree.modeling.defer.KDefer {
                        return new org.kevoree.modeling.defer.impl.Defer();
                    }

                    public key(): number {
                        return this._key;
                    }

                    public create(clazz: org.kevoree.modeling.meta.KMetaClass, universe: number, time: number): org.kevoree.modeling.KObject {
                        if (!org.kevoree.modeling.util.Checker.isDefined(clazz)) {
                            return null;
                        }
                        var newObj: org.kevoree.modeling.KObject = this.internalCreateObject(universe, time, this._manager.nextObjectKey(), clazz, universe, time);
                        if (newObj != null) {
                            this._manager.initKObject(newObj);
                        }
                        return newObj;
                    }

                    public createByName(metaClassName: string, universe: number, time: number): org.kevoree.modeling.KObject {
                        return this.create(this._manager.model().metaModel().metaClassByName(metaClassName), universe, time);
                    }

                    public lookup(p_universe: number, p_time: number, p_uuid: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookup(p_universe, p_time, p_uuid, cb);
                    }

                    public lookupAll(p_universe: number, p_time: number, p_uuids: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookupAllObjects(p_universe, p_time, p_uuids, cb);
                    }

                    public createListener(universe: number): org.kevoree.modeling.KListener {
                        return this._manager.createListener(universe);
                    }

                    public createModelContext(): org.kevoree.modeling.KModelContext {
                        return new org.kevoree.modeling.abs.AbstractKModelContext(this);
                    }

                }

                export class AbstractKModelContext implements org.kevoree.modeling.KModelContext {

                    public static ORIGIN_TIME: number = 0;
                    public static MAX_TIME: number = 1;
                    public static ORIGIN_UNIVERSE: number = 2;
                    public static MAX_UNIVERSE: number = 3;
                    public static NB_ELEM: number = 4;
                    private _callbacks: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.KCallback<any>[]>;
                    private _bounds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
                    private _origin: org.kevoree.modeling.KModel<any>;
                    constructor(p_origin: org.kevoree.modeling.KModel<any>) {
                        this._origin = p_origin;
                        this._bounds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
                        this._callbacks = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.KCallback<any>[]>();
                    }

                    public set(p_originTime: number, p_maxTime: number, p_originUniverse: number, p_maxUniverse: number): void {
                        var newBounds: Float64Array = new Float64Array([p_originTime, p_maxTime, p_originUniverse, p_maxUniverse]);
                        this._bounds.set(newBounds);
                        var currentStateListeners: org.kevoree.modeling.KCallback<any>[] = this._callbacks.get();
                        if (currentStateListeners != null) {
                            for (var i: number = 0; i < currentStateListeners.length; i++) {
                                if (currentStateListeners[i] != null) {
                                    currentStateListeners[i](newBounds);
                                }
                            }
                        }
                    }

                    public originTime(): number {
                        return this._bounds.get()[AbstractKModelContext.ORIGIN_TIME];
                    }

                    public originUniverse(): number {
                        return this._bounds.get()[AbstractKModelContext.ORIGIN_UNIVERSE];
                    }

                    public maxTime(): number {
                        return this._bounds.get()[AbstractKModelContext.MAX_TIME];
                    }

                    public maxUniverse(): number {
                        return this._bounds.get()[AbstractKModelContext.MAX_UNIVERSE];
                    }

                    public listen(new_callback: org.kevoree.modeling.KCallback<any>): void {
                        var previous: org.kevoree.modeling.KCallback<any>[];
                        var next: org.kevoree.modeling.KCallback<any>[];
                        do {
                            previous = this._callbacks.get();
                            var previousSize: number = 0;
                            if (previous != null) {
                                previousSize = previous.length;
                            }
                            next = new Array();
                            if (previous != null && previousSize > 0) {
                                java.lang.System.arraycopy(previous, 0, next, 0, previousSize);
                            }
                            next[previousSize] = new_callback;
                        } while (!this._callbacks.compareAndSet(previous, next))
                    }

                    public model(): org.kevoree.modeling.KModel<any> {
                        return this._origin;
                    }

                }

                export class AbstractKObject implements org.kevoree.modeling.KObject {

                    public _uuid: number;
                    public _time: number;
                    public _universe: number;
                    public _metaClass: org.kevoree.modeling.meta.KMetaClass;
                    public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                    private static OUT_OF_CACHE_MSG: string = "Out of cache Error";
                    private _previousResolveds: java.util.concurrent.atomic.AtomicReference<Float64Array>;
                    public static UNIVERSE_PREVIOUS_INDEX: number = 0;
                    public static TIME_PREVIOUS_INDEX: number = 1;
                    constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_actualUniverse: number, p_actualTime: number) {
                        this._universe = p_universe;
                        this._time = p_time;
                        this._uuid = p_uuid;
                        this._metaClass = p_metaClass;
                        this._manager = p_manager;
                        this._previousResolveds = new java.util.concurrent.atomic.AtomicReference<Float64Array>();
                        var initResolved: Float64Array = new Float64Array([p_actualUniverse, p_actualTime]);
                        this._previousResolveds.set(initResolved);
                    }

                    public previousResolved(): java.util.concurrent.atomic.AtomicReference<Float64Array> {
                        return this._previousResolveds;
                    }

                    public timeDephasing(): number {
                        return this._time - this._previousResolveds.get()[AbstractKObject.TIME_PREVIOUS_INDEX];
                    }

                    public uuid(): number {
                        return this._uuid;
                    }

                    public metaClass(): org.kevoree.modeling.meta.KMetaClass {
                        return this._metaClass;
                    }

                    public now(): number {
                        return this._time;
                    }

                    public universe(): number {
                        return this._universe;
                    }

                    public delete(cb: org.kevoree.modeling.KCallback<any>): void {
                        var selfPointer: org.kevoree.modeling.KObject = this;
                        var rawPayload: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                        if (rawPayload == null) {
                            if (cb != null) {
                                cb(new Error(AbstractKObject.OUT_OF_CACHE_MSG));
                            }
                        } else {
                            var collector: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                            var metaElements: org.kevoree.modeling.meta.KMeta[] = this._metaClass.metaElements();
                            for (var i: number = 0; i < metaElements.length; i++) {
                                if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                    var inboundsKeys: Float64Array = rawPayload.getLongArray(metaElements[i].index(), this._metaClass);
                                    for (var j: number = 0; j < inboundsKeys.length; j++) {
                                        collector.put(inboundsKeys[j], inboundsKeys[j]);
                                    }
                                    rawPayload.clearLongArray(metaElements[i].index(), this._metaClass);
                                }
                            }
                            var flatCollected: Float64Array = new Float64Array(collector.size());
                            var indexI: Int32Array = new Int32Array(1);
                            indexI[0] = 0;
                            collector.each( (key : number, value : number) => {
                                flatCollected[indexI[0]] = value;
                                indexI[0]++;
                            });
                            this._manager.lookupAllObjects(this._universe, this._time, flatCollected,  (resolved : org.kevoree.modeling.KObject[]) => {
                                for (var i: number = 0; i < resolved.length; i++) {
                                    if (resolved[i] != null) {
                                        var linkedReferences: org.kevoree.modeling.meta.KMetaReference[] = resolved[i].referencesWith(selfPointer);
                                        for (var j: number = 0; j < linkedReferences.length; j++) {
                                            (<org.kevoree.modeling.abs.AbstractKObject>resolved[i]).internal_mutate(org.kevoree.modeling.KActionType.REMOVE, linkedReferences[j], selfPointer, false);
                                        }
                                    }
                                }
                                if (cb != null) {
                                    cb(null);
                                }
                            });
                        }
                    }

                    public select(query: string, cb: org.kevoree.modeling.KCallback<any>): void {
                        if (!org.kevoree.modeling.util.Checker.isDefined(query)) {
                            cb(new Array());
                        } else {
                            var singleRoot: org.kevoree.modeling.KObject[] = new Array();
                            singleRoot[0] = this;
                            org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().eval(query, singleRoot, cb);
                        }
                    }

                    public get(p_attribute: org.kevoree.modeling.meta.KMetaAttribute): any {
                        var transposed: org.kevoree.modeling.meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
                        if (transposed == null) {
                            throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
                        } else {
                            return transposed.strategy().extrapolate(this, transposed, this._manager);
                        }
                    }

                    public getByName(attributeName: string): any {
                        var transposed: org.kevoree.modeling.meta.KMetaAttribute = this._metaClass.attribute(attributeName);
                        if (transposed != null) {
                            return transposed.strategy().extrapolate(this, transposed, this._manager);
                        } else {
                            return null;
                        }
                    }

                    public set(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): void {
                        var transposed: org.kevoree.modeling.meta.KMetaAttribute = this.internal_transpose_att(p_attribute);
                        if (transposed == null) {
                            throw new Error("Bad KMF usage, the attribute named " + p_attribute.metaName() + " is not part of " + this.metaClass().metaName());
                        } else {
                            transposed.strategy().mutate(this, transposed, payload, this._manager);
                        }
                    }

                    public setByName(attributeName: string, payload: any): void {
                        var transposed: org.kevoree.modeling.meta.KMetaAttribute = this._metaClass.attribute(attributeName);
                        if (transposed != null) {
                            transposed.strategy().mutate(this, transposed, payload, this._manager);
                        }
                    }

                    public addByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void {
                        var transposed: org.kevoree.modeling.meta.KMetaReference = this._metaClass.reference(relationName);
                        if (transposed != null) {
                            this.mutate(org.kevoree.modeling.KActionType.ADD, transposed, objToAdd);
                        }
                    }

                    public removeByName(relationName: string, objToAdd: org.kevoree.modeling.KObject): void {
                        var transposed: org.kevoree.modeling.meta.KMetaReference = this._metaClass.reference(relationName);
                        if (transposed != null) {
                            this.mutate(org.kevoree.modeling.KActionType.REMOVE, transposed, objToAdd);
                        }
                    }

                    public mutate(actionType: org.kevoree.modeling.KActionType, metaReference: org.kevoree.modeling.meta.KMetaReference, param: org.kevoree.modeling.KObject): void {
                        this.internal_mutate(actionType, metaReference, param, true);
                    }

                    public internal_mutate(actionType: org.kevoree.modeling.KActionType, metaReferenceP: org.kevoree.modeling.meta.KMetaReference, param: org.kevoree.modeling.KObject, setOpposite: boolean): void {
                        var metaReference: org.kevoree.modeling.meta.KMetaReference = this.internal_transpose_ref(metaReferenceP);
                        if (metaReference == null) {
                            if (metaReferenceP == null) {
                                throw new Error("Bad KMF usage, the reference " + " is null in metaClass named " + this.metaClass().metaName());
                            } else {
                                throw new Error("Bad KMF usage, the reference named " + metaReferenceP.metaName() + " is not part of " + this.metaClass().metaName());
                            }
                        }
                        if (actionType.equals(org.kevoree.modeling.KActionType.ADD)) {
                            if (metaReference.single()) {
                                this.internal_mutate(org.kevoree.modeling.KActionType.SET, metaReference, param, setOpposite);
                            } else {
                                var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                                if (raw != null) {
                                    if (raw.addLongToArray(metaReference.index(), param.uuid(), this._metaClass)) {
                                        if (setOpposite) {
                                            (<org.kevoree.modeling.abs.AbstractKObject>param).internal_mutate(org.kevoree.modeling.KActionType.ADD, param.metaClass().reference(metaReference.oppositeName()), this, false);
                                        }
                                    }
                                }
                            }
                        } else {
                            if (actionType.equals(org.kevoree.modeling.KActionType.SET)) {
                                if (!metaReference.single()) {
                                    this.internal_mutate(org.kevoree.modeling.KActionType.ADD, metaReference, param, setOpposite);
                                } else {
                                    if (param == null) {
                                        this.internal_mutate(org.kevoree.modeling.KActionType.REMOVE, metaReference, null, setOpposite);
                                    } else {
                                        var payload: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                                        var previous: Float64Array = payload.getLongArray(metaReference.index(), this._metaClass);
                                        var singleValue: Float64Array = new Float64Array(1);
                                        singleValue[0] = param.uuid();
                                        payload.setPrimitiveType(metaReference.index(), singleValue, this._metaClass);
                                        if (setOpposite) {
                                            if (previous != null) {
                                                var self: org.kevoree.modeling.KObject = this;
                                                this._manager.lookupAllObjects(this._universe, this._time, previous,  (kObjects : org.kevoree.modeling.KObject[]) => {
                                                    for (var i: number = 0; i < kObjects.length; i++) {
                                                        (<org.kevoree.modeling.abs.AbstractKObject>kObjects[i]).internal_mutate(org.kevoree.modeling.KActionType.REMOVE, kObjects[i].metaClass().reference(metaReference.oppositeName()), self, false);
                                                    }
                                                    (<org.kevoree.modeling.abs.AbstractKObject>param).internal_mutate(org.kevoree.modeling.KActionType.ADD, param.metaClass().reference(metaReference.oppositeName()), self, false);
                                                });
                                            } else {
                                                (<org.kevoree.modeling.abs.AbstractKObject>param).internal_mutate(org.kevoree.modeling.KActionType.ADD, param.metaClass().reference(metaReference.oppositeName()), this, false);
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (actionType.equals(org.kevoree.modeling.KActionType.REMOVE)) {
                                    if (metaReference.single()) {
                                        var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                                        var previousKid: Float64Array = raw.getLongArray(metaReference.index(), this._metaClass);
                                        raw.setPrimitiveType(metaReference.index(), null, this._metaClass);
                                        if (setOpposite) {
                                            if (previousKid != null) {
                                                var self: org.kevoree.modeling.KObject = this;
                                                this._manager.lookupAllObjects(this._universe, this._time, previousKid,  (resolvedParams : org.kevoree.modeling.KObject[]) => {
                                                    if (resolvedParams != null) {
                                                        for (var dd: number = 0; dd < resolvedParams.length; dd++) {
                                                            if (resolvedParams[dd] != null) {
                                                                (<org.kevoree.modeling.abs.AbstractKObject>resolvedParams[dd]).internal_mutate(org.kevoree.modeling.KActionType.REMOVE, resolvedParams[dd].metaClass().reference(metaReference.oppositeName()), self, false);
                                                            }
                                                        }
                                                    }
                                                });
                                            }
                                        }
                                    } else {
                                        var payload: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.preciseChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                                        if (payload != null) {
                                            if (payload.removeLongToArray(metaReference.index(), param.uuid(), this._metaClass)) {
                                                if (setOpposite) {
                                                    (<org.kevoree.modeling.abs.AbstractKObject>param).internal_mutate(org.kevoree.modeling.KActionType.REMOVE, param.metaClass().reference(metaReference.oppositeName()), this, false);
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }

                    public size(p_metaReference: org.kevoree.modeling.meta.KMetaReference): number {
                        var transposed: org.kevoree.modeling.meta.KMetaReference = this.internal_transpose_ref(p_metaReference);
                        if (transposed == null) {
                            throw new Error("Bad KMF usage, the attribute named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
                        } else {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                            if (raw != null) {
                                var ref: any = raw.getPrimitiveType(transposed.index(), this._metaClass);
                                if (ref == null) {
                                    return 0;
                                } else {
                                    try {
                                        var castedRefArray: Float64Array = <Float64Array>ref;
                                        return castedRefArray.length;
                                    } catch ($ex$) {
                                        if ($ex$ instanceof Error) {
                                            var e: Error = <Error>$ex$;
                                            console.error(e['stack']);;
                                            return 0;
                                        } else {
                                            throw $ex$;
                                        }
                                    }
                                }
                            } else {
                                return 0;
                            }
                        }
                    }

                    public ref(p_metaReference: org.kevoree.modeling.meta.KMetaReference, cb: org.kevoree.modeling.KCallback<any>): void {
                        var transposed: org.kevoree.modeling.meta.KMetaReference = this.internal_transpose_ref(p_metaReference);
                        if (transposed == null) {
                            throw new Error("Bad KMF usage, the reference named " + p_metaReference.metaName() + " is not part of " + this.metaClass().metaName());
                        } else {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                            if (raw == null) {
                                cb(new Array());
                            } else {
                                var o: Float64Array = raw.getLongArray(transposed.index(), this._metaClass);
                                if (o == null) {
                                    cb(new Array());
                                } else {
                                    this._manager.lookupAllObjects(this._universe, this._time, o, cb);
                                }
                            }
                        }
                    }

                    public getRefValuesByName(p_refName: string): Float64Array {
                        var transposed: org.kevoree.modeling.meta.KMetaReference = this.internal_transpose_ref(this.metaClass().reference(p_refName));
                        if (transposed == null) {
                            throw new Error("Bad KMF usage, the reference named " + p_refName + " is not part of " + this.metaClass().metaName());
                        } else {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                            if (raw == null) {
                                return new Float64Array(0);
                            } else {
                                var o: Float64Array = raw.getLongArray(transposed.index(), this._metaClass);
                                if (o == null) {
                                    return new Float64Array(0);
                                } else {
                                    return o;
                                }
                            }
                        }
                    }

                    public visitAttributes(visitor: org.kevoree.modeling.traversal.visitor.KModelAttributeVisitor): void {
                        if (!org.kevoree.modeling.util.Checker.isDefined(visitor)) {
                            return;
                        }
                        var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
                        for (var i: number = 0; i < metaElements.length; i++) {
                            if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                                var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                                visitor(metaAttribute, this.get(metaAttribute));
                            }
                        }
                    }

                    public visit(p_visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, cb: org.kevoree.modeling.KCallback<any>): void {
                        this.internal_visit(p_visitor, cb, new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null), new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null));
                    }

                    private internal_visit(visitor: org.kevoree.modeling.traversal.visitor.KModelVisitor, end: org.kevoree.modeling.KCallback<any>, visited: org.kevoree.modeling.memory.chunk.KLongLongMap, traversed: org.kevoree.modeling.memory.chunk.KLongLongMap): void {
                        if (!org.kevoree.modeling.util.Checker.isDefined(visitor)) {
                            return;
                        }
                        if (traversed != null) {
                            traversed.put(this._uuid, this._uuid);
                        }
                        var toResolveIds: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                        var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
                        for (var i: number = 0; i < metaElements.length; i++) {
                            if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                var reference: org.kevoree.modeling.meta.KMetaReference = <org.kevoree.modeling.meta.KMetaReference>metaElements[i];
                                var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                                if (raw != null) {
                                    var idArr: Float64Array = raw.getLongArray(reference.index(), this._metaClass);
                                    if (idArr != null) {
                                        try {
                                            for (var k: number = 0; k < idArr.length; k++) {
                                                if (traversed == null || !traversed.contains(idArr[k])) {
                                                    toResolveIds.put(idArr[k], idArr[k]);
                                                }
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        if (toResolveIds.size() == 0) {
                            if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                                end(null);
                            }
                        } else {
                            var trimmed: Float64Array = new Float64Array(toResolveIds.size());
                            var inserted: Int32Array = new Int32Array([0]);
                            toResolveIds.each( (key : number, value : number) => {
                                trimmed[inserted[0]] = value;
                                inserted[0]++;
                            });
                            this._manager.lookupAllObjects(this._universe, this._time, trimmed,  (resolvedArr : org.kevoree.modeling.KObject[]) => {
                                var nextDeep: java.util.List<org.kevoree.modeling.KObject> = new java.util.ArrayList<org.kevoree.modeling.KObject>();
                                for (var i: number = 0; i < resolvedArr.length; i++) {
                                    var resolved: org.kevoree.modeling.KObject = resolvedArr[i];
                                    var result: org.kevoree.modeling.traversal.visitor.KVisitResult = org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE;
                                    if (resolved != null) {
                                        if (visitor != null && (visited == null || !visited.contains(resolved.uuid()))) {
                                            result = visitor(resolved);
                                        }
                                        if (visited != null) {
                                            visited.put(resolved.uuid(), resolved.uuid());
                                        }
                                    }
                                    if (result != null && result.equals(org.kevoree.modeling.traversal.visitor.KVisitResult.STOP)) {
                                        if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                                            end(null);
                                        }
                                    } else {
                                        if (!org.kevoree.modeling.util.Checker.isDefined(result)) {
                                            result = org.kevoree.modeling.traversal.visitor.KVisitResult.STOP;
                                        }
                                        if (resolved != null && result.equals(org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE)) {
                                            if (traversed == null || !traversed.contains(resolved.uuid())) {
                                                nextDeep.add(resolved);
                                            }
                                        }
                                    }
                                }
                                if (!nextDeep.isEmpty()) {
                                    var index: Int32Array = new Int32Array(1);
                                    index[0] = 0;
                                    var next: java.util.List<org.kevoree.modeling.KCallback<any>> = new java.util.ArrayList<org.kevoree.modeling.KCallback<any>>();
                                    next.add( (throwable : Error) => {
                                        index[0] = index[0] + 1;
                                        if (index[0] == nextDeep.size()) {
                                            if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                                                end(null);
                                            }
                                        } else {
                                            var abstractKObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>nextDeep.get(index[0]);
                                            abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                                        }
                                    });
                                    var abstractKObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>nextDeep.get(index[0]);
                                    abstractKObject.internal_visit(visitor, next.get(0), visited, traversed);
                                } else {
                                    if (org.kevoree.modeling.util.Checker.isDefined(end)) {
                                        end(null);
                                    }
                                }
                            });
                        }
                    }

                    public toJSON(): string {
                        var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                        builder.append("{\"universe\":");
                        builder.append(this._universe);
                        builder.append(",\"time\":");
                        builder.append(this._time);
                        builder.append(",\"uuid\":");
                        builder.append(this._uuid);
                        var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                        if (raw != null) {
                            builder.append(",\"data\":");
                            builder.append(raw.toJSON(this._manager.model().metaModel()));
                        }
                        builder.append("}");
                        return builder.toString();
                    }

                    public toString(): string {
                        return this.toJSON();
                    }

                    public equals(obj: any): boolean {
                        if (!(obj instanceof org.kevoree.modeling.abs.AbstractKObject)) {
                            return false;
                        } else {
                            var casted: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>obj;
                            return casted._uuid == this._uuid && casted._time == this._time && casted._universe == this._universe;
                        }
                    }

                    public hashCode(): number {
                        return <number>(this._universe ^ this._time ^ this._uuid);
                    }

                    public jump(p_time: number, p_callback: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookup(this._universe, p_time, this._uuid, p_callback);
                    }

                    public internal_transpose_ref(p: org.kevoree.modeling.meta.KMetaReference): org.kevoree.modeling.meta.KMetaReference {
                        if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
                            return null;
                        } else {
                            return <org.kevoree.modeling.meta.KMetaReference>this.metaClass().metaByName(p.metaName());
                        }
                    }

                    public internal_transpose_att(p: org.kevoree.modeling.meta.KMetaAttribute): org.kevoree.modeling.meta.KMetaAttribute {
                        if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
                            return null;
                        } else {
                            return <org.kevoree.modeling.meta.KMetaAttribute>this.metaClass().metaByName(p.metaName());
                        }
                    }

                    public internal_transpose_op(p: org.kevoree.modeling.meta.KMetaOperation): org.kevoree.modeling.meta.KMetaOperation {
                        if (!org.kevoree.modeling.util.Checker.isDefined(p)) {
                            return null;
                        } else {
                            return <org.kevoree.modeling.meta.KMetaOperation>this.metaClass().metaByName(p.metaName());
                        }
                    }

                    public traversal(): org.kevoree.modeling.traversal.KTraversal {
                        var singleRoot: org.kevoree.modeling.KObject[] = new Array();
                        singleRoot[0] = this;
                        return new org.kevoree.modeling.traversal.impl.Traversal(singleRoot);
                    }

                    public referencesWith(o: org.kevoree.modeling.KObject): org.kevoree.modeling.meta.KMetaReference[] {
                        if (org.kevoree.modeling.util.Checker.isDefined(o)) {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = this._manager.closestChunk(this._universe, this._time, this._uuid, this._metaClass, this._previousResolveds);
                            if (raw != null) {
                                var metaElements: org.kevoree.modeling.meta.KMeta[] = this.metaClass().metaElements();
                                var selected: java.util.List<org.kevoree.modeling.meta.KMetaReference> = new java.util.ArrayList<org.kevoree.modeling.meta.KMetaReference>();
                                for (var i: number = 0; i < metaElements.length; i++) {
                                    if (metaElements[i] != null && metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                        var rawI: Float64Array = raw.getLongArray((metaElements[i].index()), this._metaClass);
                                        if (rawI != null) {
                                            var oUUID: number = o.uuid();
                                            for (var h: number = 0; h < rawI.length; h++) {
                                                if (rawI[h] == oUUID) {
                                                    selected.add(<org.kevoree.modeling.meta.KMetaReference>metaElements[i]);
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                                return selected.toArray(new Array());
                            } else {
                                return new Array();
                            }
                        } else {
                            return new Array();
                        }
                    }

                    public call(p_operation: org.kevoree.modeling.meta.KMetaOperation, p_params: any[], cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.operationManager().call(this, p_operation, p_params, cb);
                    }

                    public manager(): org.kevoree.modeling.memory.manager.KDataManager {
                        return this._manager;
                    }

                    private internal_times(start: number, end: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.resolveTimes(this._universe, this._uuid, start, end, cb);
                    }

                    public allTimes(cb: org.kevoree.modeling.KCallback<any>): void {
                        this.internal_times(org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, org.kevoree.modeling.KConfig.END_OF_TIME, cb);
                    }

                    public timesBefore(endOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this.internal_times(org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, endOfSearch, cb);
                    }

                    public timesAfter(beginningOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this.internal_times(beginningOfSearch, org.kevoree.modeling.KConfig.END_OF_TIME, cb);
                    }

                    public timesBetween(beginningOfSearch: number, endOfSearch: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this.internal_times(beginningOfSearch, endOfSearch, cb);
                    }

                }

                export class AbstractKObjectInfer extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.modeling.KObjectInfer {

                    constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                        super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
                    }

                    private dependenciesResolver(dependencies: org.kevoree.modeling.KObject[]): org.kevoree.modeling.traversal.KTraversalIndexResolver {
                        return  (indexName : string) => {
                            var dependency: org.kevoree.modeling.meta.KMetaDependency = this._metaClass.dependencies().dependencyByName(indexName);
                            if (dependency != null) {
                                var single: org.kevoree.modeling.KObject[] = new Array();
                                single[0] = dependencies[dependency.index()];
                                return single;
                            }
                            return null;
                        };
                    }

                    public genericTrain(dependencies: org.kevoree.modeling.KObject[], expectedOutputs: any[], callback: org.kevoree.modeling.KCallback<any>): void {
                        var all_dependencies: org.kevoree.modeling.KObject[][] = new Array(new Array());
                        all_dependencies[0] = dependencies;
                        var all_expectedOutputs: any[][] = null;
                        if (expectedOutputs != null) {
                            all_expectedOutputs = new Array(new Array());
                            all_expectedOutputs[0] = expectedOutputs;
                        }
                        this.genericTrainAll(all_dependencies, all_expectedOutputs, callback);
                    }

                    public genericTrainAll(p_dependencies: org.kevoree.modeling.KObject[][], p_outputs: any[][], callback: org.kevoree.modeling.KCallback<any>): void {
                        if (p_dependencies == null) {
                            throw new Error("Dependencies are mandatory for KObjectInfer");
                        }
                        var selfObject: org.kevoree.modeling.KObjectInfer = this;
                        var waiter: org.kevoree.modeling.defer.KDefer = this.manager().model().defer();
                        for (var i: number = 0; i < p_dependencies.length; i++) {
                            if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                                throw new Error("Bad number of arguments for allDependencies");
                            }
                            var resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver = this.dependenciesResolver(p_dependencies[i]);
                            for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                                this._metaClass.inputs()[j].extractor().exec(null, resolver, waiter.waitResult());
                            }
                        }
                        waiter.then( (results : any[]) => {
                            var extractedInputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
                            var k: number = 0;
                            for (var i: number = 0; i < p_dependencies.length; i++) {
                                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                                    var extracted: any[] = <any[]>results[k];
                                    if (extracted != null && extracted.length > 0) {
                                        extractedInputs.set(i, j, <number>extracted[0]);
                                    }
                                    k++;
                                }
                            }
                            var extractedOutputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, this._metaClass.inputs().length);
                            for (var i: number = 0; i < p_dependencies.length; i++) {
                                for (var j: number = 0; j < this._metaClass.outputs().length; j++) {
                                    var metaInferOutput: org.kevoree.modeling.meta.KMetaInferOutput = this._metaClass.outputs()[j];
                                    var currentOutputObject: any = null;
                                    if (p_outputs != null) {
                                        currentOutputObject = p_outputs[i][j];
                                    }
                                    extractedOutputs.set(i, j, this.internalConvertOutput(currentOutputObject, metaInferOutput));
                                }
                            }
                            this._metaClass.inferAlg().train(extractedInputs, extractedOutputs, selfObject, this._manager);
                            if (callback != null) {
                                callback(null);
                            }
                        });
                    }

                    public genericInfer(dependencies: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any>): void {
                        var all_dependencies: org.kevoree.modeling.KObject[][] = new Array(new Array());
                        all_dependencies[0] = dependencies;
                        this.genericInferAll(all_dependencies,  (objects : any[][]) => {
                            if (objects != null && objects.length > 0) {
                                callback(objects[0]);
                            } else {
                                callback(null);
                            }
                        });
                    }

                    public genericInferAll(p_dependencies: org.kevoree.modeling.KObject[][], callback: org.kevoree.modeling.KCallback<any>): void {
                        if (p_dependencies == null) {
                            throw new Error("Bad number of arguments for allDependencies");
                        }
                        var selfObject: org.kevoree.modeling.KObjectInfer = this;
                        var waiter: org.kevoree.modeling.defer.KDefer = this.manager().model().defer();
                        for (var i: number = 0; i < p_dependencies.length; i++) {
                            if (p_dependencies[i].length != this._metaClass.dependencies().allDependencies().length) {
                                throw new Error("Bad number of arguments for allDependencies");
                            }
                            var resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver = this.dependenciesResolver(p_dependencies[i]);
                            for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                                this._metaClass.inputs()[j].extractor().exec(null, resolver, waiter.waitResult());
                            }
                        }
                        waiter.then( (results : any[]) => {
                            var extractedInputs: org.kevoree.modeling.util.maths.structure.impl.NativeArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(p_dependencies.length, this._metaClass.inputs().length);
                            var k: number = 0;
                            for (var i: number = 0; i < p_dependencies.length; i++) {
                                for (var j: number = 0; j < this._metaClass.inputs().length; j++) {
                                    var extracted: any[] = <any[]>results[k];
                                    if (extracted != null && extracted.length > 0) {
                                        extractedInputs.set(i, j, <number>extracted[0]);
                                    }
                                    k++;
                                }
                            }
                            var extractedOutputs: org.kevoree.modeling.util.maths.structure.KArray2D = this._metaClass.inferAlg().infer(extractedInputs, selfObject, this._manager);
                            var result: any[][] = new Array(new Array());
                            for (var i: number = 0; i < extractedOutputs.nbRows(); i++) {
                                result[i] = new Array();
                                for (var j: number = 0; j < extractedOutputs.nbColumns(); j++) {
                                    result[i][j] = this.internalReverseOutput(extractedOutputs.get(i, j), this._metaClass.outputs()[j]);
                                }
                            }
                            callback(result);
                        });
                    }

                    public resetLearning(): void {
                        throw new Error("Not Implemented Yet!");
                    }

                    private internalConvertOutput(output: any, metaOutput: org.kevoree.modeling.meta.KMetaInferOutput): number {
                        if (output == null) {
                            return 0;
                        }
                        var typeId: number = metaOutput.attributeTypeId();
                        switch (typeId) {
                            case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                            if (<boolean>output) {
                                return 1.0;
                            } else {
                                return 0.0;
                            }
                            case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                            return <number>output;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                            return <number>output;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                            return <number>output;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                            return <number>output;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                            throw new Error("String are not managed yet");
                            default:
                            if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                                var metaEnum: org.kevoree.modeling.meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                                if (output instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                                    return <number>(<org.kevoree.modeling.meta.impl.MetaLiteral>output).index();
                                } else {
                                    var literal: org.kevoree.modeling.meta.KMeta = metaEnum.literalByName(output.toString());
                                    if (literal != null) {
                                        return <number>literal.index();
                                    }
                                }
                            }
                            return 0;
                        }
                    }

                    private internalReverseOutput(inferred: number, metaOutput: org.kevoree.modeling.meta.KMetaInferOutput): any {
                        var typeId: number = metaOutput.attributeTypeId();
                        switch (typeId) {
                            case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                            if (inferred >= 0.5) {
                                return true;
                            } else {
                                return false;
                            }
                            case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                            return inferred;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                            return <number>inferred;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                            return inferred;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                            return inferred;
                            case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                            throw new Error("String are not managed yet");
                            default:
                            if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaOutput.attributeTypeId())) {
                                var ceiledInferred: number = this.math_ceil(inferred);
                                var metaEnum: org.kevoree.modeling.meta.KMetaEnum = this._manager.model().metaModel().metaTypes()[metaOutput.attributeTypeId()];
                                return metaEnum.literal(ceiledInferred);
                            }
                            return null;
                        }
                    }

                    private math_ceil(toCeilValue: number): number {
                         return Math.round(toCeilValue);
                    }

                }

                export class AbstractKUniverse<A extends org.kevoree.modeling.KView, B extends org.kevoree.modeling.KUniverse<any, any>> implements org.kevoree.modeling.KUniverse<any, any> {

                    public _universe: number;
                    public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                    constructor(p_key: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                        this._universe = p_key;
                        this._manager = p_manager;
                    }

                    public key(): number {
                        return this._universe;
                    }

                    public time(timePoint: number): A {
                        if (timePoint <= org.kevoree.modeling.KConfig.END_OF_TIME && timePoint >= org.kevoree.modeling.KConfig.BEGINNING_OF_TIME) {
                            return this.internal_create(timePoint);
                        } else {
                            throw new Error("The selected Time " + timePoint + " is out of the range of KMF managed time");
                        }
                    }

                    public internal_create(timePoint: number): A {
                        throw "Abstract method";
                    }

                    public equals(obj: any): boolean {
                        if (!(obj instanceof org.kevoree.modeling.abs.AbstractKUniverse)) {
                            return false;
                        } else {
                            var casted: org.kevoree.modeling.abs.AbstractKUniverse<any, any> = <org.kevoree.modeling.abs.AbstractKUniverse<any, any>>obj;
                            return casted._universe == this._universe;
                        }
                    }

                    public diverge(): B {
                        var casted: org.kevoree.modeling.abs.AbstractKModel<any> = <org.kevoree.modeling.abs.AbstractKModel<any>>this._manager.model();
                        var nextKey: number = this._manager.nextUniverseKey();
                        var newUniverse: B = <B>casted.internalCreateUniverse(nextKey);
                        this._manager.initUniverse(nextKey, this._universe);
                        return newUniverse;
                    }

                    public lookupAllTimes(uuid: number, times: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookupAllTimes(this._universe, times, uuid, cb);
                    }

                    public createListener(): org.kevoree.modeling.KListener {
                        return this._manager.createListener(this._universe);
                    }

                }

                export class AbstractKView implements org.kevoree.modeling.KView {

                    public _time: number;
                    public _universe: number;
                    public _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                    constructor(p_universe: number, _time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                        this._universe = p_universe;
                        this._time = _time;
                        this._manager = p_manager;
                    }

                    public now(): number {
                        return this._time;
                    }

                    public universe(): number {
                        return this._universe;
                    }

                    public setRoot(elem: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.setRoot(elem, cb);
                    }

                    public getRoot(cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.getRoot(this._universe, this._time, cb);
                    }

                    public select(query: string, cb: org.kevoree.modeling.KCallback<any>): void {
                        if (org.kevoree.modeling.util.Checker.isDefined(cb)) {
                            if (query == null || query.length == 0) {
                                cb(new Array());
                            } else {
                                this._manager.getRoot(this._universe, this._time,  (rootObj : org.kevoree.modeling.KObject) => {
                                    if (rootObj == null) {
                                        cb(new Array());
                                    } else {
                                        var singleRoot: org.kevoree.modeling.KObject[] = new Array();
                                        singleRoot[0] = rootObj;
                                        org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().eval(query, singleRoot, cb);
                                    }
                                });
                            }
                        }
                    }

                    public lookup(kid: number, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookup(this._universe, this._time, kid, cb);
                    }

                    public lookupAll(keys: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void {
                        this._manager.lookupAllObjects(this._universe, this._time, keys, cb);
                    }

                    public create(clazz: org.kevoree.modeling.meta.KMetaClass): org.kevoree.modeling.KObject {
                        return this._manager.model().create(clazz, this._universe, this._time);
                    }

                    public createByName(metaClassName: string): org.kevoree.modeling.KObject {
                        return this.create(this._manager.model().metaModel().metaClassByName(metaClassName));
                    }

                    public json(): org.kevoree.modeling.format.KModelFormat {
                        return new org.kevoree.modeling.format.json.JsonFormat(this._universe, this._time, this._manager);
                    }

                    public xmi(): org.kevoree.modeling.format.KModelFormat {
                        return new org.kevoree.modeling.format.xmi.XmiFormat(this._universe, this._time, this._manager);
                    }

                    public equals(obj: any): boolean {
                        if (!org.kevoree.modeling.util.Checker.isDefined(obj)) {
                            return false;
                        }
                        if (!(obj instanceof org.kevoree.modeling.abs.AbstractKView)) {
                            return false;
                        } else {
                            var casted: org.kevoree.modeling.abs.AbstractKView = <org.kevoree.modeling.abs.AbstractKView>obj;
                            return casted._time == this._time && casted._universe == this._universe;
                        }
                    }

                }

            }
            export module cdn {
                export interface KContentDeliveryDriver {

                    get(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void;

                    atomicGetIncrement(key: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void;

                    put(keys: Float64Array, values: string[], error: org.kevoree.modeling.KCallback<any>, excludeListener: number): void;

                    remove(keys: Float64Array, error: org.kevoree.modeling.KCallback<any>): void;

                    connect(callback: org.kevoree.modeling.KCallback<any>): void;

                    close(callback: org.kevoree.modeling.KCallback<any>): void;

                    addUpdateListener(interceptor: org.kevoree.modeling.cdn.KContentUpdateListener): number;

                    removeUpdateListener(id: number): void;

                }

                export interface KContentUpdateListener {

                    (updatedKeys: Float64Array): void;

                }

                export module impl {
                    export class MemoryContentDeliveryDriver implements org.kevoree.modeling.cdn.KContentDeliveryDriver {

                        private backend: org.kevoree.modeling.memory.chunk.KStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        private additionalInterceptors: org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<any> = null;
                        public atomicGetIncrement(key: Float64Array, cb: org.kevoree.modeling.KCallback<any>): void {
                            var result: string = this.backend.get(org.kevoree.modeling.KContentKey.toString(key, 0));
                            var nextV: number;
                            var previousV: number;
                            if (result != null) {
                                try {
                                    previousV = org.kevoree.modeling.util.PrimitiveHelper.parseShort(result);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                        previousV = org.kevoree.modeling.util.PrimitiveHelper.SHORT_MIN_VALUE();
                                    } else {
                                        throw $ex$;
                                    }
                                }
                            } else {
                                previousV = 0;
                            }
                            if (previousV == org.kevoree.modeling.util.PrimitiveHelper.SHORT_MAX_VALUE()) {
                                nextV = org.kevoree.modeling.util.PrimitiveHelper.SHORT_MIN_VALUE();
                            } else {
                                nextV = <number>(previousV + 1);
                            }
                            this.backend.put(org.kevoree.modeling.KContentKey.toString(key, 0), "" + nextV);
                            cb(previousV);
                        }

                        public get(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void {
                            var nbKeys: number = keys.length / 3;
                            var values: string[] = new Array();
                            for (var i: number = 0; i < nbKeys; i++) {
                                values[i] = this.backend.get(org.kevoree.modeling.KContentKey.toString(keys, i));
                            }
                            if (callback != null) {
                                callback(values);
                            }
                        }

                        public put(p_keys: Float64Array, p_values: string[], p_callback: org.kevoree.modeling.KCallback<any>, excludeListener: number): void {
                            var nbKeys: number = p_keys.length / 3;
                            for (var i: number = 0; i < nbKeys; i++) {
                                this.backend.put(org.kevoree.modeling.KContentKey.toString(p_keys, i), p_values[i]);
                            }
                            if (this.additionalInterceptors != null) {
                                this.additionalInterceptors.each( (key : number, value : org.kevoree.modeling.cdn.KContentUpdateListener) => {
                                    if (value != null && key != excludeListener) {
                                        value(p_keys);
                                    }
                                });
                            }
                            if (p_callback != null) {
                                p_callback(null);
                            }
                        }

                        public remove(p_keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void {
                            var nbKeys: number = p_keys.length / 3;
                            for (var i: number = 0; i < nbKeys; i++) {
                                this.backend.remove(org.kevoree.modeling.KContentKey.toString(p_keys, i));
                            }
                            if (callback != null) {
                                callback(null);
                            }
                        }

                        public connect(callback: org.kevoree.modeling.KCallback<any>): void {
                            if (callback != null) {
                                callback(null);
                            }
                        }

                        public close(callback: org.kevoree.modeling.KCallback<any>): void {
                            this.backend.clear();
                            callback(null);
                        }

                        private nextListenerID(): number {
                             return Math.random();
                        }

                        public addUpdateListener(p_interceptor: org.kevoree.modeling.cdn.KContentUpdateListener): number {
                            if (this.additionalInterceptors == null) {
                                this.additionalInterceptors = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            }
                            var newID: number = this.nextListenerID();
                            this.additionalInterceptors.put(newID, p_interceptor);
                            return newID;
                        }

                        public removeUpdateListener(id: number): void {
                            if (this.additionalInterceptors != null) {
                                this.additionalInterceptors.remove(id);
                            }
                        }

                    }

                }
            }
            export module defer {
                export interface KDefer {

                    waitResult(): org.kevoree.modeling.KCallback<any>;

                    then(cb: org.kevoree.modeling.KCallback<any>): void;

                }

                export module impl {
                    export class Defer implements org.kevoree.modeling.defer.KDefer {

                        private _end: org.kevoree.modeling.KCallback<any>;
                        private _nbExpectedResult: number = 0;
                        private _nbRecResult: number = 0;
                        private _results: any[] = null;
                        private _resultSize: number = 0;
                        public waitResult(): org.kevoree.modeling.KCallback<any> {
                            return this.informEndOrRegister(-1, null, null);
                        }

                        public then(cb: org.kevoree.modeling.KCallback<any>): void {
                            this.informEndOrRegister(-1, null, cb);
                        }

                        private informEndOrRegister(p_indexToInsert: number, p_result: any, p_end: org.kevoree.modeling.KCallback<any>): org.kevoree.modeling.KCallback<any> {
                            if (p_end == null) {
                                if (p_indexToInsert == -1) {
                                    var toInsert: number = this._nbExpectedResult;
                                    this._nbExpectedResult++;
                                    if (this._results == null || this._resultSize < this._nbExpectedResult) {
                                        var newResultSize: number = (this._nbExpectedResult == 0 ? 1 : this._nbExpectedResult << 1);
                                        var newResults: any[] = new Array();
                                        if (this._results != null) {
                                            java.lang.System.arraycopy(this._results, 0, newResults, 0, this._resultSize);
                                        }
                                        this._resultSize = newResultSize;
                                        this._results = newResults;
                                    }
                                    return  (o : any) => {
                                        this.informEndOrRegister(toInsert, o, null);
                                    };
                                } else {
                                    this._results[p_indexToInsert] = p_result;
                                    this._nbRecResult++;
                                    if (this._end != null && (this._nbExpectedResult == this._nbRecResult)) {
                                        var finalResults: any[] = this._results;
                                        if (this._resultSize != this._nbExpectedResult) {
                                            var newResults: any[] = new Array();
                                            java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                                            finalResults = newResults;
                                        }
                                        this._end(finalResults);
                                    }
                                }
                            } else {
                                this._end = p_end;
                                if (this._nbExpectedResult == this._nbRecResult) {
                                    var finalResults: any[] = this._results;
                                    if (this._resultSize != this._nbExpectedResult) {
                                        var newResults: any[] = new Array();
                                        java.lang.System.arraycopy(this._results, 0, newResults, 0, this._nbExpectedResult);
                                        finalResults = newResults;
                                    }
                                    this._end(finalResults);
                                }
                            }
                            return null;
                        }

                    }

                }
            }
            export module extrapolation {
                export interface Extrapolation {

                    extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any;

                    mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void;

                }

                export module impl {
                    export class DiscreteExtrapolation implements org.kevoree.modeling.extrapolation.Extrapolation {

                        private static INSTANCE: org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation;
                        public static instance(): org.kevoree.modeling.extrapolation.Extrapolation {
                            if (DiscreteExtrapolation.INSTANCE == null) {
                                DiscreteExtrapolation.INSTANCE = new org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation();
                            }
                            return DiscreteExtrapolation.INSTANCE;
                        }

                        public extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any {
                            var payload: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            if (payload != null) {
                                if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                                    var metaEnum: org.kevoree.modeling.meta.KMetaEnum = (<org.kevoree.modeling.abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                                    return metaEnum.literal(<number>payload.getPrimitiveType(attribute.index(), current.metaClass()));
                                } else {
                                    return payload.getPrimitiveType(attribute.index(), current.metaClass());
                                }
                            } else {
                                return null;
                            }
                        }

                        public mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var internalPayload: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            if (internalPayload != null) {
                                if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(attribute.attributeTypeId())) {
                                    if (payload instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                                        internalPayload.setPrimitiveType(attribute.index(), (<org.kevoree.modeling.meta.KLiteral>payload).index(), current.metaClass());
                                    } else {
                                        var metaEnum: org.kevoree.modeling.meta.KMetaEnum = (<org.kevoree.modeling.abs.AbstractKObject>current)._manager.model().metaModel().metaTypes()[attribute.attributeTypeId()];
                                        var foundLiteral: org.kevoree.modeling.meta.KLiteral = metaEnum.literalByName(payload.toString());
                                        if (foundLiteral != null) {
                                            internalPayload.setPrimitiveType(attribute.index(), foundLiteral.index(), current.metaClass());
                                        }
                                    }
                                } else {
                                    if (payload == null) {
                                        internalPayload.setPrimitiveType(attribute.index(), null, current.metaClass());
                                    } else {
                                        internalPayload.setPrimitiveType(attribute.index(), this.convert(attribute, payload), current.metaClass());
                                    }
                                }
                            }
                        }

                        private convert(attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any): any {
                             return payload;
                        }

                    }

                    export class PolynomialExtrapolation implements org.kevoree.modeling.extrapolation.Extrapolation {

                        private static _maxDegree: number = 20;
                        private static DEGREE: number = 0;
                        private static NUMSAMPLES: number = 1;
                        private static STEP: number = 2;
                        private static LASTTIME: number = 3;
                        private static WEIGHTS: number = 4;
                        private static INSTANCE: org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation;
                        public extrapolate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): any {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            if (raw != null) {
                                var extrapolatedValue: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), current.now(), raw.time());
                                var attTypeId: number = attribute.attributeTypeId();
                                switch (attTypeId) {
                                    case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                                    return extrapolatedValue;
                                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                                    return extrapolatedValue;
                                    default:
                                    return null;
                                }
                            } else {
                                return null;
                            }
                        }

                        private extrapolateValue(segment: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaClass, index: number, time: number, timeOrigin: number): number {
                            if (segment.getDoubleArraySize(index, meta) == 0) {
                                return 0.0;
                            }
                            var result: number = 0;
                            var power: number = 1;
                            var inferSTEP: number = segment.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, meta);
                            if (inferSTEP == 0) {
                                return segment.getDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, meta);
                            }
                            var t: number = (time - timeOrigin) / inferSTEP;
                            var inferArraySize: number = segment.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, meta);
                            for (var j: number = 0; j <= inferArraySize; j++) {
                                result += segment.getDoubleArrayElem(index, (j + PolynomialExtrapolation.WEIGHTS), meta) * power;
                                power = power * t;
                            }
                            return result;
                        }

                        private maxErr(precision: number, degree: number): number {
                            return precision / Math.pow(2, degree + 0.5);
                        }

                        public insert(time: number, value: number, timeOrigin: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, precision: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                            if (raw.getDoubleArraySize(index, metaClass) == 0) {
                                this.initial_feed(time, value, raw, index, metaClass);
                                return true;
                            }
                            if (raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass) == 1) {
                                raw.setDoubleArrayElem(index, PolynomialExtrapolation.STEP, (time - timeOrigin), metaClass);
                            }
                            var deg: number = <number>raw.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, metaClass);
                            var num: number = <number>raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass);
                            var maxError: number = this.maxErr(precision, deg);
                            if (Math.abs(this.extrapolateValue(raw, metaClass, index, time, timeOrigin) - value) <= maxError) {
                                var nexNumSamples: number = raw.getDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, metaClass) + 1;
                                raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, nexNumSamples, metaClass);
                                raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                                return true;
                            }
                            var newMaxDegree: number = Math.min(num, PolynomialExtrapolation._maxDegree);
                            if (deg < newMaxDegree) {
                                deg++;
                                var ss: number = Math.min(deg * 2, num);
                                var times: Float64Array = new Float64Array(ss + 1);
                                var values: Float64Array = new Float64Array(ss + 1);
                                for (var i: number = 0; i < ss; i++) {
                                    times[i] = (<number>i * num * (raw.getDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, metaClass)) / (ss * raw.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, metaClass)));
                                    values[i] = this.internal_extrapolate(times[i], raw, index, metaClass);
                                }
                                times[ss] = (time - timeOrigin) / raw.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, metaClass);
                                values[ss] = value;
                                var pf: org.kevoree.modeling.util.maths.PolynomialFit = new org.kevoree.modeling.util.maths.PolynomialFit(deg);
                                pf.fit(times, values);
                                if (this.tempError(pf.getCoef(), times, values) <= maxError) {
                                    raw.extendDoubleArray(index, (raw.getDoubleArraySize(index, metaClass) + 1), metaClass);
                                    for (var i: number = 0; i < pf.getCoef().length; i++) {
                                        raw.setDoubleArrayElem(index, i + PolynomialExtrapolation.WEIGHTS, pf.getCoef()[i], metaClass);
                                    }
                                    raw.setDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, deg, metaClass);
                                    raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, num + 1, metaClass);
                                    raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, time - timeOrigin, metaClass);
                                    return true;
                                }
                            }
                            return false;
                        }

                        private tempError(computedWeights: Float64Array, times: Float64Array, values: Float64Array): number {
                            var maxErr: number = 0;
                            var temp: number;
                            for (var i: number = 0; i < times.length; i++) {
                                temp = Math.abs(values[i] - org.kevoree.modeling.util.maths.PolynomialFit.extrapolate(times[i], computedWeights));
                                if (temp > maxErr) {
                                    maxErr = temp;
                                }
                            }
                            return maxErr;
                        }

                        private internal_extrapolate(t: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                            var result: number = 0;
                            var power: number = 1;
                            if (raw.getDoubleArrayElem(index, PolynomialExtrapolation.STEP, metaClass) == 0) {
                                return raw.getDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, metaClass);
                            }
                            for (var j: number = 0; j <= raw.getDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, metaClass); j++) {
                                result += raw.getDoubleArrayElem(index, (j + PolynomialExtrapolation.WEIGHTS), metaClass) * power;
                                power = power * t;
                            }
                            return result;
                        }

                        private initial_feed(time: number, value: number, raw: org.kevoree.modeling.memory.chunk.KObjectChunk, index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                            raw.extendDoubleArray(index, PolynomialExtrapolation.WEIGHTS + 1, metaClass);
                            raw.setDoubleArrayElem(index, PolynomialExtrapolation.DEGREE, 0, metaClass);
                            raw.setDoubleArrayElem(index, PolynomialExtrapolation.NUMSAMPLES, 1, metaClass);
                            raw.setDoubleArrayElem(index, PolynomialExtrapolation.LASTTIME, 0, metaClass);
                            raw.setDoubleArrayElem(index, PolynomialExtrapolation.STEP, 0, metaClass);
                            raw.setDoubleArrayElem(index, PolynomialExtrapolation.WEIGHTS, value, metaClass);
                        }

                        public mutate(current: org.kevoree.modeling.KObject, attribute: org.kevoree.modeling.meta.KMetaAttribute, payload: any, dataManager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.closestChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            if (raw.getDoubleArraySize(attribute.index(), current.metaClass()) == 0) {
                                raw = dataManager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            }
                            if (!this.insert(current.now(), this.castNumber(payload), raw.time(), raw, attribute.index(), attribute.precision(), current.metaClass())) {
                                var prevTime: number = <number>raw.getDoubleArrayElem(attribute.index(), PolynomialExtrapolation.LASTTIME, current.metaClass()) + raw.time();
                                var val: number = this.extrapolateValue(raw, current.metaClass(), attribute.index(), prevTime, raw.time());
                                var newSegment: org.kevoree.modeling.memory.chunk.KObjectChunk = dataManager.preciseChunk(current.universe(), prevTime, current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                                this.insert(prevTime, val, prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                                this.insert(current.now(), this.castNumber(payload), prevTime, newSegment, attribute.index(), attribute.precision(), current.metaClass());
                            }
                        }

                        private castNumber(payload: any): number {
                             return +payload;
                        }

                        public static instance(): org.kevoree.modeling.extrapolation.Extrapolation {
                            if (PolynomialExtrapolation.INSTANCE == null) {
                                PolynomialExtrapolation.INSTANCE = new org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation();
                            }
                            return PolynomialExtrapolation.INSTANCE;
                        }

                    }

                }
            }
            export module format {
                export interface KModelFormat {

                    save(model: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<any>): void;

                    saveRoot(cb: org.kevoree.modeling.KCallback<any>): void;

                    load(payload: string, cb: org.kevoree.modeling.KCallback<any>): void;

                }

                export module json {
                    export class JsonFormat implements org.kevoree.modeling.format.KModelFormat {

                        public static KEY_META: string = "@class";
                        public static KEY_UUID: string = "@uuid";
                        public static KEY_ROOT: string = "@root";
                        private _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                        private _universe: number;
                        private _time: number;
                        private static NULL_PARAM_MSG: string = "one parameter is null";
                        constructor(p_universe: number, p_time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                            this._manager = p_manager;
                            this._universe = p_universe;
                            this._time = p_time;
                        }

                        public save(model: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<any>): void {
                            if (org.kevoree.modeling.util.Checker.isDefined(model) && org.kevoree.modeling.util.Checker.isDefined(cb)) {
                                org.kevoree.modeling.format.json.JsonModelSerializer.serialize(model, cb);
                            } else {
                                throw new Error(JsonFormat.NULL_PARAM_MSG);
                            }
                        }

                        public saveRoot(cb: org.kevoree.modeling.KCallback<any>): void {
                            if (org.kevoree.modeling.util.Checker.isDefined(cb)) {
                                this._manager.getRoot(this._universe, this._time,  (root : org.kevoree.modeling.KObject) => {
                                    if (root == null) {
                                        cb(null);
                                    } else {
                                        org.kevoree.modeling.format.json.JsonModelSerializer.serialize(root, cb);
                                    }
                                });
                            }
                        }

                        public load(payload: string, cb: org.kevoree.modeling.KCallback<any>): void {
                            if (org.kevoree.modeling.util.Checker.isDefined(payload)) {
                                org.kevoree.modeling.format.json.JsonModelLoader.load(this._manager, this._universe, this._time, payload, cb);
                            } else {
                                throw new Error(JsonFormat.NULL_PARAM_MSG);
                            }
                        }

                    }

                    export class JsonModelLoader {

                        public static load(manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, universe: number, time: number, payload: string, callback: org.kevoree.modeling.KCallback<any>): void {
                             if (payload == null) {
                             callback(null);
                             } else {
                             var toLoadObj = JSON.parse(payload);
                             var rootElem = [];
                             var mappedKeys: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1,-1,-1,null);
                             for(var i = 0; i < toLoadObj.length; i++) {
                             var elem = toLoadObj[i];
                             var kid = elem[org.kevoree.modeling.format.json.JsonFormat.KEY_UUID];
                             mappedKeys.put(<number>kid, manager.nextObjectKey());
                             }
                             for(var i = 0; i < toLoadObj.length; i++) {
                             var elemRaw = toLoadObj[i];
                             var elem2 = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(Object.keys(elemRaw).length, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                             for(var ik in elemRaw){ elem2[ik] = elemRaw[ik]; }
                             try {
                             org.kevoree.modeling.format.json.JsonModelLoader.loadObj(elem2, manager, universe, time, mappedKeys, rootElem);
                             } catch(e){ console.error(e); }
                             }
                             if (rootElem[0] != null) { manager.setRoot(rootElem[0], (throwable : Error) => { if (callback != null) { callback(throwable); }}); } else { if (callback != null) { callback(null); } }
                             }
                        }

                        private static loadObj(p_param: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, universe: number, time: number, p_mappedKeys: org.kevoree.modeling.memory.chunk.KLongLongMap, p_rootElem: org.kevoree.modeling.KObject[]): void {
                            var kid: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(p_param.get(org.kevoree.modeling.format.json.JsonFormat.KEY_UUID).toString());
                            var meta: string = p_param.get(org.kevoree.modeling.format.json.JsonFormat.KEY_META).toString();
                            var metaClass: org.kevoree.modeling.meta.KMetaClass = manager.model().metaModel().metaClassByName(meta);
                            var current: org.kevoree.modeling.KObject = (<org.kevoree.modeling.abs.AbstractKModel<any>>manager.model()).createProxy(universe, time, p_mappedKeys.get(kid), metaClass, universe, time);
                            manager.initKObject(current);
                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(current.universe(), current.now(), current.uuid(), current.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>current).previousResolved());
                            p_param.each( (metaKey : string, payload_content : any) => {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(metaKey, org.kevoree.modeling.format.json.JsonFormat.KEY_ROOT)) {
                                    p_rootElem[0] = current;
                                } else {
                                    var metaElement: org.kevoree.modeling.meta.KMeta = metaClass.metaByName(metaKey);
                                    if (payload_content != null) {
                                        if (metaElement != null && metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                                            var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElement;
                                            var metaAttId: number = metaAttribute.attributeTypeId();
                                            switch (metaAttId) {
                                                case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                                                var plainRawSet: string[] = <string[]>p_param.get(metaAttribute.metaName());
                                                var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                                                for (var l: number = 0; l < plainRawSet.length; l++) {
                                                    try {
                                                        convertedRaw[l] = org.kevoree.modeling.util.PrimitiveHelper.parseDouble(plainRawSet[l]);
                                                    } catch ($ex$) {
                                                        if ($ex$ instanceof Error) {
                                                            var e: Error = <Error>$ex$;
                                                            console.error(e['stack']);;
                                                        } else {
                                                            throw $ex$;
                                                        }
                                                    }
                                                }
                                                raw.setPrimitiveType(metaElement.index(), convertedRaw, current.metaClass());
                                                break;
                                                default:
                                                var converted: any = null;
                                                var rawPayload: string = p_param.get(metaElement.metaName()).toString();
                                                switch (metaAttId) {
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                                                    converted = org.kevoree.modeling.format.json.JsonString.unescape(rawPayload);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                                                    converted = org.kevoree.modeling.util.PrimitiveHelper.parseLong(rawPayload);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                                                    converted = org.kevoree.modeling.util.PrimitiveHelper.parseInt(rawPayload);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                                                    converted = org.kevoree.modeling.util.PrimitiveHelper.parseBoolean(rawPayload);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                                                    converted = org.kevoree.modeling.util.PrimitiveHelper.parseDouble(rawPayload);
                                                    break;
                                                }
                                                raw.setPrimitiveType(metaElement.index(), converted, current.metaClass());
                                                break;
                                            }
                                        } else {
                                            if (metaElement != null && metaElement.metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                try {
                                                    raw.setPrimitiveType(metaElement.index(), org.kevoree.modeling.format.json.JsonModelLoader.transposeArr(<java.util.ArrayList<string>>payload_content, p_mappedKeys), current.metaClass());
                                                } catch ($ex$) {
                                                    if ($ex$ instanceof Error) {
                                                        var e: Error = <Error>$ex$;
                                                        console.error(e['stack']);;
                                                    } else {
                                                        throw $ex$;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }

                        private static transposeArr(plainRawSet: java.util.ArrayList<string>, p_mappedKeys: org.kevoree.modeling.memory.chunk.KLongLongMap): Float64Array {
                            if (plainRawSet == null) {
                                return null;
                            }
                            var sizeOfL: number = org.kevoree.modeling.format.json.JsonModelLoader.sizeOfList(plainRawSet);
                            var convertedRaw: Float64Array = new Float64Array(sizeOfL);
                            for (var l: number = 0; l < sizeOfL; l++) {
                                try {
                                    var converted: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(org.kevoree.modeling.format.json.JsonModelLoader.getString(plainRawSet, l));
                                    if (p_mappedKeys.contains(converted)) {
                                        converted = p_mappedKeys.get(converted);
                                    }
                                    convertedRaw[l] = converted;
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                            }
                            return convertedRaw;
                        }

                        private static sizeOfList(plainRawSet: java.util.ArrayList<string>): number {
                             if(plainRawSet != null && plainRawSet != undefined){
                             if(plainRawSet.size != undefined){
                             return plainRawSet.size();
                             } else {
                             return plainRawSet.length;
                             }
                             }
                        }

                        private static getString(plainRawSet: java.util.ArrayList<string>, l: number): string {
                             if(plainRawSet.get != undefined){
                             return plainRawSet.get(l);
                             } else {
                             return plainRawSet[l];
                             }
                        }

                    }

                    export class JsonModelSerializer {

                        public static serialize(model: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void {
                            (<org.kevoree.modeling.abs.AbstractKObject>model)._manager.getRoot(model.universe(), model.now(),  (rootObj : org.kevoree.modeling.KObject) => {
                                var isRoot: boolean = false;
                                if (rootObj != null) {
                                    isRoot = rootObj.uuid() == model.uuid();
                                }
                                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                                builder.append("[\n");
                                org.kevoree.modeling.format.json.JsonModelSerializer.printJSON(model, builder, isRoot);
                                model.visit( (elem : org.kevoree.modeling.KObject) => {
                                    var isRoot2: boolean = false;
                                    if (rootObj != null) {
                                        isRoot2 = rootObj.uuid() == elem.uuid();
                                    }
                                    builder.append(",\n");
                                    try {
                                        org.kevoree.modeling.format.json.JsonModelSerializer.printJSON(elem, builder, isRoot2);
                                    } catch ($ex$) {
                                        if ($ex$ instanceof Error) {
                                            var e: Error = <Error>$ex$;
                                            console.error(e['stack']);;
                                            builder.append("{}");
                                        } else {
                                            throw $ex$;
                                        }
                                    }
                                    return org.kevoree.modeling.traversal.visitor.KVisitResult.CONTINUE;
                                },  (throwable : Error) => {
                                    builder.append("\n]\n");
                                    callback(builder.toString());
                                });
                            });
                        }

                        public static printJSON(elem: org.kevoree.modeling.KObject, builder: java.lang.StringBuilder, isRoot: boolean): void {
                            if (elem != null) {
                                var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = (<org.kevoree.modeling.abs.AbstractKObject>elem)._manager.closestChunk(elem.universe(), elem.now(), elem.uuid(), elem.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>elem).previousResolved());
                                if (raw != null) {
                                    builder.append(org.kevoree.modeling.format.json.JsonRaw.encode(raw, elem.uuid(), elem.metaClass(), isRoot));
                                }
                            }
                        }

                    }

                    export class JsonObjectReader {

                         private readObject:any;
                         public parseObject(payload:string):void {
                         this.readObject = JSON.parse(payload);
                         }
                         public get(name:string):any {
                         return this.readObject[name];
                         }
                         public getAsStringArray(name:string):string[] {
                         return <string[]> this.readObject[name];
                         }
                         public keys():string[] {
                         var keysArr = []
                         for (var key in this.readObject) {
                         keysArr.push(key);
                         }
                         return keysArr;
                         }
                    }

                    export class JsonRaw {

                        public static encode(raw: org.kevoree.modeling.memory.chunk.KObjectChunk, uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, isRoot: boolean): string {
                            var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                            builder.append("{\"@class\":\"");
                            builder.append(p_metaClass.metaName());
                            builder.append("\",\"@uuid\":");
                            builder.append(uuid);
                            if (isRoot) {
                                builder.append(",\"" + org.kevoree.modeling.format.json.JsonFormat.KEY_ROOT + "\":true");
                            }
                            var metaElements: org.kevoree.modeling.meta.KMeta[] = p_metaClass.metaElements();
                            for (var i: number = 0; i < metaElements.length; i++) {
                                var loopMeta: org.kevoree.modeling.meta.KMeta = metaElements[i];
                                if (loopMeta != null && loopMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                                    var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>loopMeta;
                                    var metaAttId: number = metaAttribute.attributeTypeId();
                                    if (metaAttId == org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                                        var inferAtt: Float64Array = raw.getDoubleArray(loopMeta.index(), p_metaClass);
                                        if (inferAtt != null) {
                                            builder.append(",\"");
                                            builder.append(loopMeta.metaName());
                                            builder.append("\":[");
                                            for (var j: number = 0; j < inferAtt.length; j++) {
                                                if (j != 0) {
                                                    builder.append(",");
                                                }
                                                builder.append(inferAtt[j]);
                                            }
                                            builder.append("]");
                                        }
                                    } else {
                                        var payload_res: any = raw.getPrimitiveType(loopMeta.index(), p_metaClass);
                                        if (payload_res != null) {
                                            builder.append(",\"");
                                            builder.append(loopMeta.metaName());
                                            builder.append("\":\"");
                                            if (metaAttId == org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID) {
                                                builder.append(org.kevoree.modeling.format.json.JsonString.encode(payload_res.toString()));
                                            } else {
                                                builder.append(payload_res.toString());
                                            }
                                            builder.append("\"");
                                        }
                                    }
                                } else {
                                    if (loopMeta != null && loopMeta.metaType().equals(org.kevoree.modeling.meta.MetaType.REFERENCE)) {
                                        var refPayload: Float64Array = raw.getLongArray(loopMeta.index(), p_metaClass);
                                        if (refPayload != null) {
                                            builder.append(",\"");
                                            builder.append(loopMeta.metaName());
                                            builder.append("\":[");
                                            for (var j: number = 0; j < refPayload.length; j++) {
                                                if (j != 0) {
                                                    builder.append(",");
                                                }
                                                builder.append(refPayload[j]);
                                            }
                                            builder.append("]");
                                        }
                                    }
                                }
                            }
                            builder.append("}");
                            return builder.toString();
                        }

                    }

                    export class JsonString {

                        private static ESCAPE_CHAR: string = '\\';
                        public static encodeBuffer(buffer: java.lang.StringBuilder, chain: string): void {
                            if (chain == null) {
                                return;
                            }
                            var i: number = 0;
                            while (i < chain.length){
                                var ch: string = chain.charAt(i);
                                if (ch == '"') {
                                    buffer.append(JsonString.ESCAPE_CHAR);
                                    buffer.append('"');
                                } else {
                                    if (ch == JsonString.ESCAPE_CHAR) {
                                        buffer.append(JsonString.ESCAPE_CHAR);
                                        buffer.append(JsonString.ESCAPE_CHAR);
                                    } else {
                                        if (ch == '\n') {
                                            buffer.append(JsonString.ESCAPE_CHAR);
                                            buffer.append('n');
                                        } else {
                                            if (ch == '\r') {
                                                buffer.append(JsonString.ESCAPE_CHAR);
                                                buffer.append('r');
                                            } else {
                                                if (ch == '\t') {
                                                    buffer.append(JsonString.ESCAPE_CHAR);
                                                    buffer.append('t');
                                                } else {
                                                    if (ch == '\u2028') {
                                                        buffer.append(JsonString.ESCAPE_CHAR);
                                                        buffer.append('u');
                                                        buffer.append('2');
                                                        buffer.append('0');
                                                        buffer.append('2');
                                                        buffer.append('8');
                                                    } else {
                                                        if (ch == '\u2029') {
                                                            buffer.append(JsonString.ESCAPE_CHAR);
                                                            buffer.append('u');
                                                            buffer.append('2');
                                                            buffer.append('0');
                                                            buffer.append('2');
                                                            buffer.append('9');
                                                        } else {
                                                            buffer.append(ch);
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                i = i + 1;
                            }
                        }

                        public static encode(p_chain: string): string {
                            var sb: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.format.json.JsonString.encodeBuffer(sb, p_chain);
                            return sb.toString();
                        }

                        public static unescape(p_src: string): string {
                            if (p_src == null) {
                                return null;
                            }
                            if (p_src.length == 0) {
                                return p_src;
                            }
                            var builder: java.lang.StringBuilder = null;
                            var i: number = 0;
                            while (i < p_src.length){
                                var current: string = p_src.charAt(i);
                                if (current == JsonString.ESCAPE_CHAR) {
                                    if (builder == null) {
                                        builder = new java.lang.StringBuilder();
                                        builder.append(p_src.substring(0, i));
                                    }
                                    i++;
                                    var current2: string = p_src.charAt(i);
                                    switch (current2) {
                                        case '"':
                                        builder.append('\"');
                                        break;
                                        case '\\':
                                        builder.append(current2);
                                        break;
                                        case '/':
                                        builder.append(current2);
                                        break;
                                        case 'b':
                                        builder.append('\b');
                                        break;
                                        case 'f':
                                        builder.append('\f');
                                        break;
                                        case 'n':
                                        builder.append('\n');
                                        break;
                                        case 'r':
                                        builder.append('\r');
                                        break;
                                        case 't':
                                        builder.append('\t');
                                        break;
                                        case '{':
                                        builder.append("\\{");
                                        break;
                                        case '}':
                                        builder.append("\\}");
                                        break;
                                        case '[':
                                        builder.append("\\[");
                                        break;
                                        case ']':
                                        builder.append("\\]");
                                        break;
                                        case ',':
                                        builder.append("\\,");
                                        break;
                                    }
                                } else {
                                    if (builder != null) {
                                        builder = builder.append(current);
                                    }
                                }
                                i++;
                            }
                            if (builder != null) {
                                return builder.toString();
                            } else {
                                return p_src;
                            }
                        }

                    }

                }
                export module xmi {
                    export class SerializationContext {

                        public ignoreGeneratedID: boolean = false;
                        public model: org.kevoree.modeling.KObject;
                        public finishCallback: org.kevoree.modeling.KCallback<any>;
                        public printer: java.lang.StringBuilder;
                        public attributesVisitor: org.kevoree.modeling.traversal.visitor.KModelAttributeVisitor;
                        public addressTable: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        public elementsCount: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        public packageList: java.util.ArrayList<string> = new java.util.ArrayList<string>();
                    }

                    export class XMILoadingContext {

                        public xmiReader: org.kevoree.modeling.format.xmi.XmlParser;
                        public loadedRoots: org.kevoree.modeling.KObject = null;
                        public resolvers: java.util.ArrayList<org.kevoree.modeling.format.xmi.XMIResolveCommand> = new java.util.ArrayList<org.kevoree.modeling.format.xmi.XMIResolveCommand>();
                        public map: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        public elementsCount: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        public successCallback: org.kevoree.modeling.KCallback<any>;
                    }

                    export class XMIModelLoader {

                        public static LOADER_XMI_LOCAL_NAME: string = "type";
                        public static LOADER_XMI_XSI: string = "xsi";
                        public static LOADER_XMI_NS_URI: string = "nsURI";
                        public static unescapeXml(src: string): string {
                            var builder: java.lang.StringBuilder = null;
                            var i: number = 0;
                            while (i < src.length){
                                var c: string = src.charAt(i);
                                if (c == '&') {
                                    if (builder == null) {
                                        builder = new java.lang.StringBuilder();
                                        builder.append(src.substring(0, i));
                                    }
                                    if (src.charAt(i + 1) == 'a') {
                                        if (src.charAt(i + 2) == 'm') {
                                            builder.append("&");
                                            i = i + 5;
                                        } else {
                                            if (src.charAt(i + 2) == 'p') {
                                                builder.append("'");
                                                i = i + 6;
                                            }
                                        }
                                    } else {
                                        if (src.charAt(i + 1) == 'q') {
                                            builder.append("\"");
                                            i = i + 6;
                                        } else {
                                            if (src.charAt(i + 1) == 'l') {
                                                builder.append("<");
                                                i = i + 4;
                                            } else {
                                                if (src.charAt(i + 1) == 'g') {
                                                    builder.append(">");
                                                    i = i + 4;
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    if (builder != null) {
                                        builder.append(c);
                                    }
                                    i++;
                                }
                            }
                            if (builder != null) {
                                return builder.toString();
                            } else {
                                return src;
                            }
                        }

                        public static load(manager: org.kevoree.modeling.memory.manager.KDataManager, universe: number, time: number, str: string, callback: org.kevoree.modeling.KCallback<any>): void {
                            var parser: org.kevoree.modeling.format.xmi.XmlParser = new org.kevoree.modeling.format.xmi.XmlParser(str);
                            if (!parser.hasNext()) {
                                callback(null);
                            } else {
                                var context: org.kevoree.modeling.format.xmi.XMILoadingContext = new org.kevoree.modeling.format.xmi.XMILoadingContext();
                                context.successCallback = callback;
                                context.xmiReader = parser;
                                org.kevoree.modeling.format.xmi.XMIModelLoader.deserialize(manager, universe, time, context);
                            }
                        }

                        private static deserialize(manager: org.kevoree.modeling.memory.manager.KDataManager, universe: number, time: number, context: org.kevoree.modeling.format.xmi.XMILoadingContext): void {
                            try {
                                var nsURI: string;
                                var reader: org.kevoree.modeling.format.xmi.XmlParser = context.xmiReader;
                                while (reader.hasNext()){
                                    var nextTag: org.kevoree.modeling.format.xmi.XmlToken = reader.next();
                                    if (nextTag.equals(org.kevoree.modeling.format.xmi.XmlToken.START_TAG)) {
                                        var localName: string = reader.getLocalName();
                                        if (localName != null) {
                                            var ns: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(reader.getAttributeCount(), org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                            for (var i: number = 0; i < reader.getAttributeCount() - 1; i++) {
                                                var attrLocalName: string = reader.getAttributeLocalName(i);
                                                var attrLocalValue: string = reader.getAttributeValue(i);
                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(attrLocalName, XMIModelLoader.LOADER_XMI_NS_URI)) {
                                                    nsURI = attrLocalValue;
                                                }
                                                ns.put(attrLocalName, attrLocalValue);
                                            }
                                            var xsiType: string = reader.getTagPrefix();
                                            var realTypeName: string = ns.get(xsiType);
                                            if (realTypeName == null) {
                                                realTypeName = xsiType;
                                            }
                                            context.loadedRoots = org.kevoree.modeling.format.xmi.XMIModelLoader.loadObject(manager, universe, time, context, "/", xsiType + "." + localName);
                                        }
                                    }
                                }
                                for (var i: number = 0; i < context.resolvers.size(); i++) {
                                    context.resolvers.get(i).run();
                                }
                                manager.setRoot(context.loadedRoots, null);
                                context.successCallback(null);
                            } catch ($ex$) {
                                if ($ex$ instanceof Error) {
                                    var e: Error = <Error>$ex$;
                                    context.successCallback(e);
                                } else {
                                    throw $ex$;
                                }
                            }
                        }

                        private static callFactory(manager: org.kevoree.modeling.memory.manager.KDataManager, universe: number, time: number, ctx: org.kevoree.modeling.format.xmi.XMILoadingContext, objectType: string): org.kevoree.modeling.KObject {
                            var modelElem: org.kevoree.modeling.KObject = null;
                            if (objectType != null) {
                                modelElem = manager.model().createByName(objectType, universe, time);
                                if (modelElem == null) {
                                    var xsiType: string = null;
                                    for (var i: number = 0; i < (ctx.xmiReader.getAttributeCount() - 1); i++) {
                                        var localName: string = ctx.xmiReader.getAttributeLocalName(i);
                                        var xsi: string = ctx.xmiReader.getAttributePrefix(i);
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(localName, XMIModelLoader.LOADER_XMI_LOCAL_NAME) && org.kevoree.modeling.util.PrimitiveHelper.equals(xsi, XMIModelLoader.LOADER_XMI_XSI)) {
                                            xsiType = ctx.xmiReader.getAttributeValue(i);
                                            break;
                                        }
                                    }
                                    if (xsiType != null) {
                                        var realTypeName: string = xsiType.substring(0, xsiType.lastIndexOf(":"));
                                        var realName: string = xsiType.substring(xsiType.lastIndexOf(":") + 1, xsiType.length);
                                        modelElem = manager.model().createByName(realTypeName + "." + realName, universe, time);
                                    }
                                }
                            } else {
                                modelElem = manager.model().createByName(ctx.xmiReader.getLocalName(), universe, time);
                            }
                            return modelElem;
                        }

                        private static loadObject(manager: org.kevoree.modeling.memory.manager.KDataManager, universe: number, time: number, ctx: org.kevoree.modeling.format.xmi.XMILoadingContext, xmiAddress: string, objectType: string): org.kevoree.modeling.KObject {
                            var elementTagName: string = ctx.xmiReader.getLocalName();
                            var modelElem: org.kevoree.modeling.KObject = org.kevoree.modeling.format.xmi.XMIModelLoader.callFactory(manager, universe, time, ctx, objectType);
                            if (modelElem == null) {
                                throw new Error("Could not create an object for local name " + elementTagName);
                            }
                            ctx.map.put(xmiAddress, modelElem);
                            for (var i: number = 0; i < ctx.xmiReader.getAttributeCount(); i++) {
                                var prefix: string = ctx.xmiReader.getAttributePrefix(i);
                                if (prefix == null || org.kevoree.modeling.util.PrimitiveHelper.equals(prefix, "")) {
                                    var attrName: string = ctx.xmiReader.getAttributeLocalName(i).trim();
                                    var valueAtt: string = ctx.xmiReader.getAttributeValue(i).trim();
                                    if (valueAtt != null) {
                                        var metaElement: org.kevoree.modeling.meta.KMeta = modelElem.metaClass().metaByName(attrName);
                                        if (metaElement != null && metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                                            modelElem.set(<org.kevoree.modeling.meta.KMetaAttribute>metaElement, org.kevoree.modeling.format.xmi.XMIModelLoader.unescapeXml(valueAtt));
                                        } else {
                                            if (metaElement != null && metaElement.metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                var referenceArray: string[] = valueAtt.split(" ");
                                                for (var j: number = 0; j < referenceArray.length; j++) {
                                                    var xmiRef: string = referenceArray[j];
                                                    var adjustedRef: string = (org.kevoree.modeling.util.PrimitiveHelper.startsWith(xmiRef, "#") ? xmiRef.substring(1) : xmiRef);
                                                    adjustedRef = adjustedRef.replace(".0", "");
                                                    var ref: org.kevoree.modeling.KObject = ctx.map.get(adjustedRef);
                                                    if (ref != null) {
                                                        modelElem.mutate(org.kevoree.modeling.KActionType.ADD, <org.kevoree.modeling.meta.KMetaReference>metaElement, ref);
                                                    } else {
                                                        ctx.resolvers.add(new org.kevoree.modeling.format.xmi.XMIResolveCommand(ctx, modelElem, org.kevoree.modeling.KActionType.ADD, attrName, adjustedRef));
                                                    }
                                                }
                                            } else {
                                            }
                                        }
                                    }
                                }
                            }
                            var done: boolean = false;
                            while (!done){
                                if (ctx.xmiReader.hasNext()) {
                                    var tok: org.kevoree.modeling.format.xmi.XmlToken = ctx.xmiReader.next();
                                    if (tok.equals(org.kevoree.modeling.format.xmi.XmlToken.START_TAG)) {
                                        var subElemName: string = ctx.xmiReader.getLocalName();
                                        var key: string = xmiAddress + "/@" + subElemName;
                                        var i: number = ctx.elementsCount.get(key);
                                        if (i == null) {
                                            i = 0;
                                            ctx.elementsCount.put(key, i);
                                        }
                                        var subElementId: string = xmiAddress + "/@" + subElemName + (i != 0 ? "." + i : "");
                                        var containedElement: org.kevoree.modeling.KObject = org.kevoree.modeling.format.xmi.XMIModelLoader.loadObject(manager, universe, time, ctx, subElementId, subElemName);
                                        modelElem.mutate(org.kevoree.modeling.KActionType.ADD, <org.kevoree.modeling.meta.KMetaReference>modelElem.metaClass().metaByName(subElemName), containedElement);
                                        ctx.elementsCount.put(xmiAddress + "/@" + subElemName, i + 1);
                                    } else {
                                        if (tok.equals(org.kevoree.modeling.format.xmi.XmlToken.END_TAG)) {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(ctx.xmiReader.getLocalName(), elementTagName)) {
                                                done = true;
                                            }
                                        }
                                    }
                                } else {
                                    done = true;
                                }
                            }
                            return modelElem;
                        }

                    }

                    export class XMIModelSerializer {

                        public static save(model: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void {
                            callback(null);
                        }

                    }

                    export class XMIResolveCommand {

                        private context: org.kevoree.modeling.format.xmi.XMILoadingContext;
                        private target: org.kevoree.modeling.KObject;
                        private mutatorType: org.kevoree.modeling.KActionType;
                        private refName: string;
                        private ref: string;
                        constructor(context: org.kevoree.modeling.format.xmi.XMILoadingContext, target: org.kevoree.modeling.KObject, mutatorType: org.kevoree.modeling.KActionType, refName: string, ref: string) {
                            this.context = context;
                            this.target = target;
                            this.mutatorType = mutatorType;
                            this.refName = refName;
                            this.ref = ref;
                        }

                        public run(): void {
                            var referencedElement: org.kevoree.modeling.KObject = this.context.map.get(this.ref);
                            if (referencedElement != null) {
                                this.target.mutate(this.mutatorType, <org.kevoree.modeling.meta.KMetaReference>this.target.metaClass().metaByName(this.refName), referencedElement);
                                return;
                            }
                            referencedElement = this.context.map.get("/");
                            if (referencedElement != null) {
                                this.target.mutate(this.mutatorType, <org.kevoree.modeling.meta.KMetaReference>this.target.metaClass().metaByName(this.refName), referencedElement);
                                return;
                            }
                            throw new Error("KMF Load error : reference " + this.ref + " not found in map when trying to  " + this.mutatorType + " " + this.refName + "  on " + this.target.metaClass().metaName() + "(uuid:" + this.target.uuid() + ")");
                        }

                    }

                    export class XmiFormat implements org.kevoree.modeling.format.KModelFormat {

                        private _manager: org.kevoree.modeling.memory.manager.KDataManager;
                        private _universe: number;
                        private _time: number;
                        constructor(p_universe: number, p_time: number, p_manager: org.kevoree.modeling.memory.manager.KDataManager) {
                            this._universe = p_universe;
                            this._time = p_time;
                            this._manager = p_manager;
                        }

                        public save(model: org.kevoree.modeling.KObject, cb: org.kevoree.modeling.KCallback<any>): void {
                            org.kevoree.modeling.format.xmi.XMIModelSerializer.save(model, cb);
                        }

                        public saveRoot(cb: org.kevoree.modeling.KCallback<any>): void {
                            this._manager.getRoot(this._universe, this._time,  (root : org.kevoree.modeling.KObject) => {
                                if (root == null) {
                                    if (cb != null) {
                                        cb(null);
                                    }
                                } else {
                                    org.kevoree.modeling.format.xmi.XMIModelSerializer.save(root, cb);
                                }
                            });
                        }

                        public load(payload: string, cb: org.kevoree.modeling.KCallback<any>): void {
                            org.kevoree.modeling.format.xmi.XMIModelLoader.load(this._manager, this._universe, this._time, payload, cb);
                        }

                    }

                    export class XmlParser {

                        private payload: string;
                        private current: number = 0;
                        private currentChar: string;
                        private tagName: string;
                        private tagPrefix: string;
                        private attributePrefix: string;
                        private readSingleton: boolean = false;
                        private attributesNames: java.util.ArrayList<string> = new java.util.ArrayList<string>();
                        private attributesPrefixes: java.util.ArrayList<string> = new java.util.ArrayList<string>();
                        private attributesValues: java.util.ArrayList<string> = new java.util.ArrayList<string>();
                        private attributeName: java.lang.StringBuilder = new java.lang.StringBuilder();
                        private attributeValue: java.lang.StringBuilder = new java.lang.StringBuilder();
                        constructor(str: string) {
                            this.payload = str;
                            this.currentChar = this.readChar();
                        }

                        public getTagPrefix(): string {
                            return this.tagPrefix;
                        }

                        public hasNext(): boolean {
                            this.read_lessThan();
                            return this.current < this.payload.length;
                        }

                        public getLocalName(): string {
                            return this.tagName;
                        }

                        public getAttributeCount(): number {
                            return this.attributesNames.size();
                        }

                        public getAttributeLocalName(i: number): string {
                            return this.attributesNames.get(i);
                        }

                        public getAttributePrefix(i: number): string {
                            return this.attributesPrefixes.get(i);
                        }

                        public getAttributeValue(i: number): string {
                            return this.attributesValues.get(i);
                        }

                        private readChar(): string {
                            if (this.current < this.payload.length) {
                                var re: string = this.payload.charAt(this.current);
                                this.current++;
                                return re;
                            }
                            return '\0';
                        }

                        public next(): org.kevoree.modeling.format.xmi.XmlToken {
                            if (this.readSingleton) {
                                this.readSingleton = false;
                                return org.kevoree.modeling.format.xmi.XmlToken.END_TAG;
                            }
                            if (!this.hasNext()) {
                                return org.kevoree.modeling.format.xmi.XmlToken.END_DOCUMENT;
                            }
                            this.attributesNames.clear();
                            this.attributesPrefixes.clear();
                            this.attributesValues.clear();
                            this.read_lessThan();
                            this.currentChar = this.readChar();
                            if (this.currentChar == '?') {
                                this.currentChar = this.readChar();
                                this.read_xmlHeader();
                                return org.kevoree.modeling.format.xmi.XmlToken.XML_HEADER;
                            } else {
                                if (this.currentChar == '!') {
                                    do {
                                        this.currentChar = this.readChar();
                                    } while (this.currentChar != '>')
                                    return org.kevoree.modeling.format.xmi.XmlToken.COMMENT;
                                } else {
                                    if (this.currentChar == '/') {
                                        this.currentChar = this.readChar();
                                        this.read_closingTag();
                                        return org.kevoree.modeling.format.xmi.XmlToken.END_TAG;
                                    } else {
                                        this.read_openTag();
                                        if (this.currentChar == '/') {
                                            this.read_upperThan();
                                            this.readSingleton = true;
                                        }
                                        return org.kevoree.modeling.format.xmi.XmlToken.START_TAG;
                                    }
                                }
                            }
                        }

                        private read_lessThan(): void {
                            while (this.currentChar != '<' && this.currentChar != '\0'){
                                this.currentChar = this.readChar();
                            }
                        }

                        private read_upperThan(): void {
                            while (this.currentChar != '>'){
                                this.currentChar = this.readChar();
                            }
                        }

                        private read_xmlHeader(): void {
                            this.read_tagName();
                            this.read_attributes();
                            this.read_upperThan();
                        }

                        private read_closingTag(): void {
                            this.read_tagName();
                            this.read_upperThan();
                        }

                        private read_openTag(): void {
                            this.read_tagName();
                            if (this.currentChar != '>' && this.currentChar != '/') {
                                this.read_attributes();
                            }
                        }

                        private read_tagName(): void {
                            this.tagName = "" + this.currentChar;
                            this.tagPrefix = null;
                            this.currentChar = this.readChar();
                            while (this.currentChar != ' ' && this.currentChar != '>' && this.currentChar != '/'){
                                if (this.currentChar == ':') {
                                    this.tagPrefix = this.tagName;
                                    this.tagName = "";
                                } else {
                                    this.tagName += this.currentChar;
                                }
                                this.currentChar = this.readChar();
                            }
                        }

                        private read_attributes(): void {
                            var end_of_tag: boolean = false;
                            while (this.currentChar == ' '){
                                this.currentChar = this.readChar();
                            }
                            while (!end_of_tag){
                                while (this.currentChar != '='){
                                    if (this.currentChar == ':') {
                                        this.attributePrefix = this.attributeName.toString();
                                        this.attributeName = new java.lang.StringBuilder();
                                    } else {
                                        this.attributeName.append(this.currentChar);
                                    }
                                    this.currentChar = this.readChar();
                                }
                                do {
                                    this.currentChar = this.readChar();
                                } while (this.currentChar != '"')
                                this.currentChar = this.readChar();
                                while (this.currentChar != '"'){
                                    this.attributeValue.append(this.currentChar);
                                    this.currentChar = this.readChar();
                                }
                                this.attributesNames.add(this.attributeName.toString());
                                this.attributesPrefixes.add(this.attributePrefix);
                                this.attributesValues.add(this.attributeValue.toString());
                                this.attributeName = new java.lang.StringBuilder();
                                this.attributePrefix = null;
                                this.attributeValue = new java.lang.StringBuilder();
                                do {
                                    this.currentChar = this.readChar();
                                    if (this.currentChar == '?' || this.currentChar == '/' || this.currentChar == '-' || this.currentChar == '>') {
                                        end_of_tag = true;
                                    }
                                } while (!end_of_tag && this.currentChar == ' ')
                            }
                        }

                    }

                    export class XmlToken {

                        public static XML_HEADER: XmlToken = new XmlToken();
                        public static END_DOCUMENT: XmlToken = new XmlToken();
                        public static START_TAG: XmlToken = new XmlToken();
                        public static END_TAG: XmlToken = new XmlToken();
                        public static COMMENT: XmlToken = new XmlToken();
                        public static SINGLETON_TAG: XmlToken = new XmlToken();
                        public equals(other: any): boolean {
                            return this == other;
                        }
                        public static _XmlTokenVALUES : XmlToken[] = [
                            XmlToken.XML_HEADER
                            ,XmlToken.END_DOCUMENT
                            ,XmlToken.START_TAG
                            ,XmlToken.END_TAG
                            ,XmlToken.COMMENT
                            ,XmlToken.SINGLETON_TAG
                        ];
                        public static values():XmlToken[]{
                            return XmlToken._XmlTokenVALUES;
                        }
                    }

                }
            }
            export module infer {
                export interface KInferAlg {

                    train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void;

                    infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D;

                }

                export class KInferAlgFactory {

                    public static build(name: string): org.kevoree.modeling.infer.KInferAlg {
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "BinaryPerceptron")) {
                            return new org.kevoree.modeling.infer.impl.BinaryPerceptronAlg();
                        }
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "LinearRegression")) {
                            return new org.kevoree.modeling.infer.impl.LinearRegressionAlg();
                        }
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "KMeanCluster")) {
                            return new org.kevoree.modeling.infer.impl.KMeanClusterAlg();
                        }
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "GaussianProfiler")) {
                            return new org.kevoree.modeling.infer.impl.GaussianProfiler();
                        }
                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(name, "GaussianClassifier")) {
                            return new org.kevoree.modeling.infer.impl.GaussianClassifierAlg();
                        }
                        return null;
                    }

                }

                export module impl {
                    export class BinaryPerceptronAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private iterations: number = 5;
                        private alpha: number = 1;
                        private rand: java.util.Random = new java.util.Random();
                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length + 1;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < size; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble() * 0.1, origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var iter: number = 0; iter < this.iterations; iter++) {
                                for (var row: number = 0; row < trainingSet.nbRows(); row++) {
                                    var h: number = this.sigmoid(trainingSet, row, state);
                                    var error: number = this.alpha * (expectedResultSet.get(row, 0) - h);
                                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                        state.add(j, error * trainingSet.get(row, j));
                                    }
                                    state.add(origin.metaClass().inputs().length, error);
                                }
                            }
                        }

                        private addUp(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
                            var res: number = 0;
                            for (var i: number = 0; i < features.nbColumns(); i++) {
                                res = res + state.get(i) * features.get(row, i);
                            }
                            res = res + state.get(features.nbColumns());
                            return res;
                        }

                        private sigmoid(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
                            return 1 / (1 + Math.exp(-this.addUp(features, row, state)));
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length + 1;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var inst: number = 0; inst < features.nbRows(); inst++) {
                                if (this.sigmoid(features, inst, state) >= 0.5) {
                                    result.set(inst, 0, 1.0);
                                } else {
                                    result.set(inst, 0, 0);
                                }
                            }
                            return result;
                        }

                    }

                    export class GaussianClassifierAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private static MIN: number = 0;
                        private static MAX: number = 1;
                        private static SUM: number = 2;
                        private static SUMSQUARE: number = 3;
                        private static NUMOFFIELDS: number = 4;
                        private getIndex(input: number, output: number, field: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            return output * (GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianClassifierAlg.NUMOFFIELDS * input + field;
                        }

                        private getCounter(output: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            return output * (GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianClassifierAlg.NUMOFFIELDS * meta.origin().inputs().length;
                        }

                        public getAvg(output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
                            var total: number = state.get(this.getCounter(output, meta));
                            if (total != 0) {
                                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                    avg[i] = state.get(this.getIndex(i, output, GaussianClassifierAlg.SUM, meta)) / total;
                                }
                            }
                            return avg;
                        }

                        public getVariance(output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, avg: Float64Array, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
                            var total: number = state.get(this.getCounter(output, meta));
                            if (total != 0) {
                                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                    variances[i] = state.get(this.getIndex(i, output, GaussianClassifierAlg.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                                }
                            }
                            return variances;
                        }

                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
                            var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * GaussianClassifierAlg.NUMOFFIELDS + 1);
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < size; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var i: number = 0; i < trainingSet.nbRows(); i++) {
                                var output: number = <number>expectedResultSet.get(i, 0);
                                for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                    if (state.get(this.getCounter(output, origin.metaClass().dependencies())) == 0) {
                                        state.set(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    } else {
                                        if (trainingSet.get(i, j) < state.get(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, output, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        if (trainingSet.get(i, j) > state.get(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, output, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        state.add(this.getIndex(j, output, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.add(this.getIndex(j, output, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    }
                                    if (state.get(this.getCounter(maxOutput, origin.metaClass().dependencies())) == 0) {
                                        state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    } else {
                                        if (trainingSet.get(i, j) < state.get(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        if (trainingSet.get(i, j) > state.get(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, maxOutput, GaussianClassifierAlg.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        state.add(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.add(this.getIndex(j, maxOutput, GaussianClassifierAlg.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    }
                                }
                                state.add(this.getCounter(output, origin.metaClass().dependencies()), 1);
                                state.add(this.getCounter(maxOutput, origin.metaClass().dependencies()), 1);
                            }
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var outType: number = origin.metaClass().outputs()[0].attributeTypeId();
                            var maxOutput: number = (origin.manager().model().metaModel().metaTypes()[outType]).literals().length;
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = (maxOutput + 1) * (origin.metaClass().inputs().length * GaussianClassifierAlg.NUMOFFIELDS + 1);
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.KArray1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var j: number = 0; j < features.nbRows(); j++) {
                                var maxprob: number = 0;
                                var prob: number = 0;
                                for (var output: number = 0; output < maxOutput; output++) {
                                    prob = this.getProba(features, j, output, state, origin.metaClass().dependencies());
                                    if (prob > maxprob) {
                                        maxprob = prob;
                                        result.set(j, 0, output);
                                    }
                                }
                            }
                            return result;
                        }

                        public getProba(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, output: number, state: org.kevoree.modeling.util.maths.structure.KArray1D, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            var prob: number = 0;
                            var avg: Float64Array = this.getAvg(output, state, meta);
                            var variance: Float64Array = this.getVariance(output, state, avg, meta);
                            prob = org.kevoree.modeling.util.maths.Distribution.gaussianArray(features, row, avg, variance);
                            return prob;
                        }

                        public getAllProba(features: Float64Array, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies, maxOutput: number): Float64Array {
                            var results: Float64Array = new Float64Array(maxOutput);
                            for (var i: number = 0; i < maxOutput; i++) {
                                var avg: Float64Array = this.getAvg(i, state, meta);
                                var variance: Float64Array = this.getVariance(i, state, avg, meta);
                                results[i] = org.kevoree.modeling.util.maths.Distribution.gaussian(features, avg, variance);
                            }
                            return results;
                        }

                    }

                    export class GaussianProfiler implements org.kevoree.modeling.infer.KInferAlg {

                        private static MIN: number = 0;
                        private static MAX: number = 1;
                        private static SUM: number = 2;
                        private static SUMSQUARE: number = 3;
                        private static NUMOFFIELDS: number = 4;
                        public maxTimeSlots: number = 24;
                        private getIndex(input: number, output: number, field: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            return output * (GaussianProfiler.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianProfiler.NUMOFFIELDS * input + field;
                        }

                        private getCounter(output: number, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            return output * (GaussianProfiler.NUMOFFIELDS * meta.origin().inputs().length + 1) + GaussianProfiler.NUMOFFIELDS * meta.origin().inputs().length;
                        }

                        public getAvg(output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var avg: Float64Array = new Float64Array(meta.origin().inputs().length);
                            var total: number = state.get(this.getCounter(output, meta));
                            if (total != 0) {
                                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                    avg[i] = state.get(this.getIndex(i, output, GaussianProfiler.SUM, meta)) / total;
                                }
                            }
                            return avg;
                        }

                        public getVariance(output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, avg: Float64Array, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var variances: Float64Array = new Float64Array(meta.origin().inputs().length);
                            var total: number = state.get(this.getCounter(output, meta));
                            if (total != 0) {
                                for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                    variances[i] = state.get(this.getIndex(i, output, GaussianProfiler.SUMSQUARE, meta)) / total - avg[i] * avg[i];
                                }
                            }
                            return variances;
                        }

                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResult: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * GaussianProfiler.NUMOFFIELDS + 1);
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < size; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var i: number = 0; i < trainingSet.nbRows(); i++) {
                                var output: number = <number>trainingSet.get(i, 0);
                                for (var j: number = 1; j < origin.metaClass().inputs().length; j++) {
                                    if (state.get(this.getCounter(output, origin.metaClass().dependencies())) == 0) {
                                        state.set(this.getIndex(j, output, GaussianProfiler.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianProfiler.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianProfiler.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, output, GaussianProfiler.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    } else {
                                        if (trainingSet.get(i, j) < state.get(this.getIndex(j, output, GaussianProfiler.MIN, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, output, GaussianProfiler.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        if (trainingSet.get(i, j) > state.get(this.getIndex(j, output, GaussianProfiler.MAX, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, output, GaussianProfiler.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        state.add(this.getIndex(j, output, GaussianProfiler.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.add(this.getIndex(j, output, GaussianProfiler.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    }
                                    if (state.get(this.getCounter(this.maxTimeSlots, origin.metaClass().dependencies())) == 0) {
                                        state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    } else {
                                        if (trainingSet.get(i, j) < state.get(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MIN, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MIN, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        if (trainingSet.get(i, j) > state.get(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MAX, origin.metaClass().dependencies()))) {
                                            state.set(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.MAX, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        }
                                        state.add(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.SUM, origin.metaClass().dependencies()), trainingSet.get(i, j));
                                        state.add(this.getIndex(j, this.maxTimeSlots, GaussianProfiler.SUMSQUARE, origin.metaClass().dependencies()), trainingSet.get(i, j) * trainingSet.get(i, j));
                                    }
                                }
                                state.add(this.getCounter(output, origin.metaClass().dependencies()), 1);
                                state.add(this.getCounter(this.maxTimeSlots, origin.metaClass().dependencies()), 1);
                            }
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = (this.maxTimeSlots + 1) * ((origin.metaClass().inputs().length - 1) * GaussianProfiler.NUMOFFIELDS + 1);
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var j: number = 0; j < features.nbRows(); j++) {
                                var output: number = <number>features.get(j, 0);
                                var values: Float64Array = new Float64Array(features.nbColumns() - 1);
                                for (var i: number = 0; i < features.nbColumns() - 1; i++) {
                                    values[i] = features.get(j, i + 1);
                                }
                                result.set(j, 0, this.getProba(values, output, state, origin.metaClass().dependencies()));
                            }
                            return result;
                        }

                        public getProba(features: Float64Array, output: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            var prob: number = 0;
                            var avg: Float64Array = this.getAvg(output, state, meta);
                            var variance: Float64Array = this.getVariance(output, state, avg, meta);
                            prob = org.kevoree.modeling.util.maths.Distribution.gaussian(features, avg, variance);
                            return prob;
                        }

                    }

                    export class KMeanClusterAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private k: number = 3;
                        private iterations: number = 100;
                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            if (trainingSet.nbRows() < this.k) {
                                throw new Error("training setPrimitiveType not enough");
                            }
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = this.k * origin.metaClass().inputs().length;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < this.k; i++) {
                                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                        ks.setDoubleArrayElem(dependenciesIndex, j + i * origin.metaClass().inputs().length, trainingSet.get(i, j), origin.metaClass());
                                    }
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var iter: number = 0; iter < this.iterations; iter++) {
                                var temporalClassification: number;
                                var centroids: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(this.k, origin.metaClass().inputs().length);
                                var counters: Int32Array = new Int32Array(this.k);
                                for (var i: number = 0; i < trainingSet.nbRows(); i++) {
                                    temporalClassification = this.classify(trainingSet, i, state);
                                    for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                        centroids.add(temporalClassification, j, trainingSet.get(i, j));
                                    }
                                    counters[temporalClassification]++;
                                }
                                for (var i: number = 0; i < this.k; i++) {
                                    if (counters[i] != 0) {
                                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                            state.set(j + i * origin.metaClass().inputs().length, centroids.get(i, j) / counters[i]);
                                        }
                                    } else {
                                        var rand: java.util.Random = new java.util.Random();
                                        var pos: number = rand.nextInt(trainingSet.nbRows());
                                        for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                            state.set(j + i * origin.metaClass().inputs().length, trainingSet.get(pos, j));
                                        }
                                    }
                                }
                            }
                        }

                        private classify(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
                            var maxdistance: number = -1;
                            var classNum: number = -1;
                            for (var i: number = 0; i < this.k; i++) {
                                var currentdist: number = 0;
                                for (var j: number = 0; j < features.nbColumns(); j++) {
                                    currentdist += (features.get(row, j) - state.get(i * features.nbColumns() + j)) * (features.get(row, j) - state.get(i * features.nbColumns() + j));
                                }
                                if (maxdistance < 0) {
                                    maxdistance = currentdist;
                                    classNum = i;
                                } else {
                                    if (currentdist < maxdistance) {
                                        maxdistance = currentdist;
                                        classNum = i;
                                    }
                                }
                            }
                            return classNum;
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = this.k * origin.metaClass().inputs().length;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var inst: number = 0; inst < features.nbRows(); inst++) {
                                result.set(inst, 0, this.classify(features, inst, state));
                            }
                            return result;
                        }

                    }

                    export class LinearRegressionAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private alpha: number = 0.005;
                        private gamma: number = 0.000;
                        private iterations: number = 10;
                        private static rand: java.util.Random = new java.util.Random();
                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length + 1;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < size; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, LinearRegressionAlg.rand.nextDouble(), origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var i: number = 0; i < this.iterations; i++) {
                                for (var row: number = 0; row < trainingSet.nbRows(); row++) {
                                    var h: number = this.estimate(trainingSet, row, state);
                                    var error: number = -this.alpha * (h - expectedResultSet.get(row, 0));
                                    for (var feature: number = 0; feature < origin.metaClass().inputs().length; feature++) {
                                        state.set(feature, state.get(feature) * (1 - this.alpha * this.gamma) + error * trainingSet.get(row, feature));
                                    }
                                    state.add(origin.metaClass().inputs().length, error);
                                }
                            }
                        }

                        private estimate(training: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
                            var result: number = 0;
                            for (var i: number = 0; i < training.nbColumns(); i++) {
                                result = result + training.get(row, i) * state.get(i);
                            }
                            result = result + state.get(training.nbColumns());
                            return result;
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length + 1;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var results: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var i: number = 0; i < features.nbRows(); i++) {
                                results.set(i, 0, this.estimate(features, i, state));
                            }
                            return results;
                        }

                    }

                    export class RecommendationAlg implements org.kevoree.modeling.infer.KInferAlg {

                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, currentInferObject: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            return new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, 1);
                        }

                    }

                    export class StatInferAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private static MIN: number = 0;
                        private static MAX: number = 1;
                        private static SUM: number = 2;
                        private static SUMSQuare: number = 3;
                        private static NUMOFFIELDS: number = 4;
                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(dependenciesIndex, StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1, origin.metaClass());
                                for (var i: number = 0; i < StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length + 1; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, 0, origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(StatInferAlg.NUMOFFIELDS * trainingSet.nbColumns() + 1, 0, dependenciesIndex, ks, origin.metaClass());
                            for (var i: number = 0; i < trainingSet.nbRows(); i++) {
                                for (var j: number = 0; j < origin.metaClass().inputs().length; j++) {
                                    if (state.get(StatInferAlg.NUMOFFIELDS * trainingSet.nbColumns()) == 0) {
                                        state.set(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        state.set(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        state.set(StatInferAlg.SUM + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        state.set(StatInferAlg.SUMSQuare + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                                    } else {
                                        if (trainingSet.get(i, j) < state.get(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS)) {
                                            state.set(StatInferAlg.MIN + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        }
                                        if (trainingSet.get(i, j) > state.get(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS)) {
                                            state.set(StatInferAlg.MAX + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        }
                                        state.add(StatInferAlg.SUM + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j));
                                        state.add(StatInferAlg.SUMSQuare + j * StatInferAlg.NUMOFFIELDS, trainingSet.get(i, j) * trainingSet.get(i, j));
                                    }
                                }
                                state.add(StatInferAlg.NUMOFFIELDS * origin.metaClass().inputs().length, 1);
                            }
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), (<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved());
                            var tempres: Float64Array = this.getAvgAll(ks, origin.metaClass().dependencies());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(1, tempres.length);
                            for (var i: number = 0; i < tempres.length; i++) {
                                result.set(0, i, tempres[i]);
                            }
                            return result;
                        }

                        public getAvgAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                            for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                result[i] = this.getAvg(i, ks, meta);
                            }
                            return result;
                        }

                        public getMinAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                            for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                result[i] = this.getMin(i, ks, meta);
                            }
                            return result;
                        }

                        public getMaxAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): Float64Array {
                            var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                            for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                result[i] = this.getMax(i, ks, meta);
                            }
                            return result;
                        }

                        public getVarianceAll(ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies, avgs: Float64Array): Float64Array {
                            var result: Float64Array = new Float64Array(meta.origin().inputs().length);
                            for (var i: number = 0; i < meta.origin().inputs().length; i++) {
                                result[i] = this.getVariance(i, ks, meta, avgs[i]);
                            }
                            return result;
                        }

                        public getAvg(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                                return 0;
                            }
                            var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                            if (count == 0) {
                                return 0;
                            }
                            return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.SUM, meta.origin()) / count;
                        }

                        public getMin(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                                return 0;
                            }
                            var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                            if (count == 0) {
                                return 0;
                            }
                            return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.MIN, meta.origin());
                        }

                        public getMax(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies): number {
                            if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                                return 0;
                            }
                            var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                            if (count == 0) {
                                return 0;
                            }
                            return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.MAX, meta.origin());
                        }

                        public getVariance(featureNum: number, ks: org.kevoree.modeling.memory.chunk.KObjectChunk, meta: org.kevoree.modeling.meta.KMetaDependencies, avg: number): number {
                            if (ks.getDoubleArraySize(meta.index(), meta.origin()) == 0) {
                                return 0;
                            }
                            var count: number = ks.getDoubleArrayElem(meta.index(), ks.getDoubleArraySize(meta.index(), meta.origin()) - 1, meta.origin());
                            if (count == 0) {
                                return 0;
                            }
                            return ks.getDoubleArrayElem(meta.index(), featureNum * StatInferAlg.NUMOFFIELDS + StatInferAlg.SUMSQuare, meta.origin()) / count - avg * avg;
                        }

                    }

                    export class WinnowAlg implements org.kevoree.modeling.infer.KInferAlg {

                        private alpha: number = 2;
                        private beta: number = 2;
                        private iterations: number = 1;
                        private rand: java.util.Random = new java.util.Random();
                        public train(trainingSet: org.kevoree.modeling.util.maths.structure.KArray2D, expectedResultSet: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): void {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.preciseChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved()));
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                ks.extendDoubleArray(origin.metaClass().dependencies().index(), size, origin.metaClass());
                                for (var i: number = 0; i < size; i++) {
                                    ks.setDoubleArrayElem(dependenciesIndex, i, this.rand.nextDouble(), origin.metaClass());
                                }
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            for (var iter: number = 0; iter < this.iterations; iter++) {
                                for (var inst: number = 0; inst < trainingSet.nbRows(); inst++) {
                                    if (this.calculate(trainingSet, inst, state) == expectedResultSet.get(inst, 0)) {
                                        continue;
                                    }
                                    if (expectedResultSet.get(inst, 0) == 0) {
                                        for (var i: number = 0; i < size; i++) {
                                            state.set(i, state.get(i) / this.beta);
                                        }
                                    } else {
                                        for (var i: number = 0; i < size; i++) {
                                            state.set(i, state.get(i) * this.alpha);
                                        }
                                    }
                                }
                            }
                        }

                        private calculate(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, state: org.kevoree.modeling.util.maths.structure.impl.Array1D): number {
                            var result: number = 0;
                            for (var i: number = 0; i < features.nbColumns(); i++) {
                                result += state.get(i) * features.get(row, i);
                            }
                            if (result >= features.nbColumns()) {
                                return 1.0;
                            } else {
                                return 0.0;
                            }
                        }

                        public infer(features: org.kevoree.modeling.util.maths.structure.KArray2D, origin: org.kevoree.modeling.KObject, manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.util.maths.structure.KArray2D {
                            var ks: org.kevoree.modeling.memory.chunk.KObjectChunk = manager.closestChunk(origin.universe(), origin.now(), origin.uuid(), origin.metaClass(), ((<org.kevoree.modeling.abs.AbstractKObject>origin).previousResolved()));
                            var dependenciesIndex: number = origin.metaClass().dependencies().index();
                            var size: number = origin.metaClass().inputs().length;
                            if (ks.getDoubleArraySize(dependenciesIndex, origin.metaClass()) == 0) {
                                return null;
                            }
                            var state: org.kevoree.modeling.util.maths.structure.impl.Array1D = new org.kevoree.modeling.util.maths.structure.impl.Array1D(size, 0, origin.metaClass().dependencies().index(), ks, origin.metaClass());
                            var result: org.kevoree.modeling.util.maths.structure.KArray2D = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(features.nbRows(), 1);
                            for (var inst: number = 0; inst < features.nbRows(); inst++) {
                                result.set(inst, 0, this.calculate(features, inst, state));
                            }
                            return result;
                        }

                    }

                }
            }
            export module memory {
                export interface KChunk {

                    serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string;

                    init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void;

                    counter(): number;

                    inc(): number;

                    dec(): number;

                    free(metaModel: org.kevoree.modeling.meta.KMetaModel): void;

                    type(): number;

                    space(): org.kevoree.modeling.memory.space.KChunkSpace;

                    getFlags(): number;

                    setFlags(bitsToEnable: number, bitsToDisable: number): void;

                    universe(): number;

                    time(): number;

                    obj(): number;

                }

                export class KChunkFlags {

                    public static DIRTY_BIT_INDEX: number = 0;
                    public static DIRTY_BIT: number = 1 << KChunkFlags.DIRTY_BIT_INDEX;
                    public static REMOVED_BIT_INDEX: number = 1;
                    public static REMOVED_BIT: number = 1 << KChunkFlags.REMOVED_BIT_INDEX;
                }

                export interface KOffHeapChunk extends org.kevoree.modeling.memory.KChunk {

                    memoryAddress(): number;

                    setMemoryAddress(address: number): void;

                }

                export module chunk {
                    export interface KIntMap<V> {

                        contains(key: number): boolean;

                        get(key: number): V;

                        put(key: number, value: V): void;

                        each(callback: org.kevoree.modeling.memory.chunk.KIntMapCallBack<any>): void;

                    }

                    export interface KIntMapCallBack<V> {

                        (key: number, value: V): void;

                    }

                    export interface KLongLongMap extends org.kevoree.modeling.memory.KChunk {

                        metaClassIndex(): number;

                        contains(key: number): boolean;

                        get(key: number): number;

                        put(key: number, value: number): void;

                        remove(key: number): void;

                        each(callback: org.kevoree.modeling.memory.chunk.KLongLongMapCallBack<any>): void;

                        size(): number;

                        clear(): void;

                    }

                    export interface KLongLongMapCallBack<V> {

                        (key: number, value: number): void;

                    }

                    export interface KLongLongTree extends org.kevoree.modeling.memory.chunk.KTree {

                        insert(key: number, value: number): void;

                        previousOrEqualValue(key: number): number;

                        lookupValue(key: number): number;

                    }

                    export interface KLongMap<V> {

                        contains(key: number): boolean;

                        get(key: number): V;

                        put(key: number, value: V): void;

                        each(callback: org.kevoree.modeling.memory.chunk.KLongMapCallBack<any>): void;

                        size(): number;

                        clear(): void;

                    }

                    export interface KLongMapCallBack<V> {

                        (key: number, value: V): void;

                    }

                    export interface KLongTree extends org.kevoree.modeling.memory.chunk.KTree {

                        insert(key: number): void;

                        previousOrEqual(key: number): number;

                        lookup(key: number): number;

                        range(startKey: number, endKey: number, walker: org.kevoree.modeling.memory.chunk.KTreeWalker): void;

                    }

                    export interface KObjectChunk extends org.kevoree.modeling.memory.KChunk {

                        clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;

                        metaClassIndex(): number;

                        toJSON(metaModel: org.kevoree.modeling.meta.KMetaModel): string;

                        setPrimitiveType(index: number, content: any, metaClass: org.kevoree.modeling.meta.KMetaClass): void;

                        getPrimitiveType(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): any;

                        getLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array;

                        getLongArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;

                        getLongArrayElem(index: number, refIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;

                        addLongToArray(index: number, newRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean;

                        removeLongToArray(index: number, previousRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean;

                        clearLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;

                        getDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array;

                        getDoubleArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;

                        getDoubleArrayElem(index: number, arrayIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number;

                        setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;

                        extendDoubleArray(index: number, newSize: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void;

                    }

                    export interface KStringMap<V> {

                        contains(key: string): boolean;

                        get(key: string): V;

                        put(key: string, value: V): void;

                        each(callback: org.kevoree.modeling.memory.chunk.KStringMapCallBack<any>): void;

                        size(): number;

                        clear(): void;

                        remove(key: string): void;

                    }

                    export interface KStringMapCallBack<V> {

                        (key: string, value: V): void;

                    }

                    export interface KTree extends org.kevoree.modeling.memory.KChunk {

                        size(): number;

                    }

                    export interface KTreeWalker {

                        (t: number): void;

                    }

                    export module impl {
                        export class AbstractArrayTree implements org.kevoree.modeling.memory.KChunk {

                            private static BLACK_LEFT: string = '{';
                            private static BLACK_RIGHT: string = '}';
                            private static RED_LEFT: string = '[';
                            private static RED_RIGHT: string = ']';
                            private static META_SIZE: number = 3;
                            private static LOAD_FACTOR: number = (<number>75 / <number>100);
                            public kvSize: number = 1;
                            private _threshold: number = 0;
                            private _root_index: number = -1;
                            private _size: number = 0;
                            private state: org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState;
                            private _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            private _flags: java.util.concurrent.atomic.AtomicLong;
                            private _counter: java.util.concurrent.atomic.AtomicInteger;
                            private _universe: number;
                            private _time: number;
                            private _obj: number;
                            constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._universe = p_universe;
                                this._time = p_time;
                                this._obj = p_obj;
                                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                                this._space = p_space;
                            }

                            public counter(): number {
                                return this._counter.get();
                            }

                            public inc(): number {
                                return this._counter.incrementAndGet();
                            }

                            public dec(): number {
                                return this._counter.decrementAndGet();
                            }

                            public universe(): number {
                                return this._universe;
                            }

                            public time(): number {
                                return this._time;
                            }

                            public obj(): number {
                                return this._obj;
                            }

                            public getFlags(): number {
                                return this._flags.get();
                            }

                            public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                                var val: number;
                                var nval: number;
                                do {
                                    val = this._flags.get();
                                    nval = val & ~bitsToDisable | bitsToEnable;
                                } while (!this._flags.compareAndSet(val, nval))
                            }

                            public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                                return this._space;
                            }

                            private allocate(capacity: number): void {
                                this.state = new org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState(new Int32Array(capacity * AbstractArrayTree.META_SIZE), new Float64Array(capacity * this.kvSize), new Array());
                                this._threshold = <number>(capacity * AbstractArrayTree.LOAD_FACTOR);
                            }

                            private reallocate(newCapacity: number): void {
                                this._threshold = <number>(newCapacity * AbstractArrayTree.LOAD_FACTOR);
                                var new_back_kv: Float64Array = new Float64Array(newCapacity * this.kvSize);
                                if (this.state != null && this.state._back_kv != null) {
                                    java.lang.System.arraycopy(this.state._back_kv, 0, new_back_kv, 0, this._size * this.kvSize);
                                }
                                var new_back_colors: boolean[] = new Array();
                                if (this.state != null && this.state._back_colors != null) {
                                    java.lang.System.arraycopy(this.state._back_colors, 0, new_back_colors, 0, this._size);
                                    for (var i: number = this._size; i < newCapacity; i++) {
                                        new_back_colors[i] = false;
                                    }
                                }
                                var new_back_meta: Int32Array = new Int32Array(newCapacity * AbstractArrayTree.META_SIZE);
                                if (this.state != null && this.state._back_meta != null) {
                                    java.lang.System.arraycopy(this.state._back_meta, 0, new_back_meta, 0, this._size * AbstractArrayTree.META_SIZE);
                                    for (var i: number = this._size * AbstractArrayTree.META_SIZE; i < newCapacity * AbstractArrayTree.META_SIZE; i++) {
                                        new_back_meta[i] = -1;
                                    }
                                }
                                this.state = new org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState(new_back_meta, new_back_kv, new_back_colors);
                            }

                            public size(): number {
                                return this._size;
                            }

                            public key(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                return this.state._back_kv[p_currentIndex * this.kvSize];
                            }

                            private setKey(p_currentIndex: number, p_paramIndex: number): void {
                                this.state._back_kv[p_currentIndex * this.kvSize] = p_paramIndex;
                            }

                            public value(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                return this.state._back_kv[(p_currentIndex * this.kvSize) + 1];
                            }

                            private setValue(p_currentIndex: number, p_paramIndex: number): void {
                                this.state._back_kv[(p_currentIndex * this.kvSize) + 1] = p_paramIndex;
                            }

                            private left(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                return this.state._back_meta[p_currentIndex * AbstractArrayTree.META_SIZE];
                            }

                            private setLeft(p_currentIndex: number, p_paramIndex: number): void {
                                this.state._back_meta[p_currentIndex * AbstractArrayTree.META_SIZE] = p_paramIndex;
                            }

                            private right(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                return this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 1];
                            }

                            private setRight(p_currentIndex: number, p_paramIndex: number): void {
                                this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 1] = p_paramIndex;
                            }

                            private parent(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                return this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 2];
                            }

                            private setParent(p_currentIndex: number, p_paramIndex: number): void {
                                this.state._back_meta[(p_currentIndex * AbstractArrayTree.META_SIZE) + 2] = p_paramIndex;
                            }

                            private color(p_currentIndex: number): boolean {
                                if (p_currentIndex == -1) {
                                    return true;
                                }
                                return this.state._back_colors[p_currentIndex];
                            }

                            private setColor(p_currentIndex: number, p_paramIndex: boolean): void {
                                this.state._back_colors[p_currentIndex] = p_paramIndex;
                            }

                            private grandParent(p_currentIndex: number): number {
                                if (p_currentIndex == -1) {
                                    return -1;
                                }
                                if (this.parent(p_currentIndex) != -1) {
                                    return this.parent(this.parent(p_currentIndex));
                                } else {
                                    return -1;
                                }
                            }

                            private sibling(p_currentIndex: number): number {
                                if (this.parent(p_currentIndex) == -1) {
                                    return -1;
                                } else {
                                    if (p_currentIndex == this.left(this.parent(p_currentIndex))) {
                                        return this.right(this.parent(p_currentIndex));
                                    } else {
                                        return this.left(this.parent(p_currentIndex));
                                    }
                                }
                            }

                            private uncle(p_currentIndex: number): number {
                                if (this.parent(p_currentIndex) != -1) {
                                    return this.sibling(this.parent(p_currentIndex));
                                } else {
                                    return -1;
                                }
                            }

                            private previous(p_index: number): number {
                                var p: number = p_index;
                                if (this.left(p) != -1) {
                                    p = this.left(p);
                                    while (this.right(p) != -1){
                                        p = this.right(p);
                                    }
                                    return p;
                                } else {
                                    if (this.parent(p) != -1) {
                                        if (p == this.right(this.parent(p))) {
                                            return this.parent(p);
                                        } else {
                                            while (this.parent(p) != -1 && p == this.left(this.parent(p))){
                                                p = this.parent(p);
                                            }
                                            return this.parent(p);
                                        }
                                    } else {
                                        return -1;
                                    }
                                }
                            }

                            private next(p_index: number): number {
                                var p: number = p_index;
                                if (this.right(p) != -1) {
                                    p = this.right(p);
                                    while (this.left(p) != -1){
                                        p = this.left(p);
                                    }
                                    return p;
                                } else {
                                    if (this.parent(p) != -1) {
                                        if (p == this.left(this.parent(p))) {
                                            return this.parent(p);
                                        } else {
                                            while (this.parent(p) != -1 && p == this.right(this.parent(p))){
                                                p = this.parent(p);
                                            }
                                            return this.parent(p);
                                        }
                                    } else {
                                        return -1;
                                    }
                                }
                            }

                            public lookup(p_key: number): number {
                                var n: number = this._root_index;
                                if (n == -1) {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                                while (n != -1){
                                    if (p_key == this.key(n)) {
                                        return this.key(n);
                                    } else {
                                        if (p_key < this.key(n)) {
                                            n = this.left(n);
                                        } else {
                                            n = this.right(n);
                                        }
                                    }
                                }
                                return n;
                            }

                            public range(startKey: number, endKey: number, walker: org.kevoree.modeling.memory.chunk.KTreeWalker): void {
                                var indexEnd: number = this.internal_previousOrEqual_index(endKey);
                                while (indexEnd != -1 && this.key(indexEnd) >= startKey){
                                    walker(this.key(indexEnd));
                                    indexEnd = this.previous(indexEnd);
                                }
                            }

                            public internal_previousOrEqual_index(p_key: number): number {
                                var p: number = this._root_index;
                                if (p == -1) {
                                    return p;
                                }
                                while (p != -1){
                                    if (p_key == this.key(p)) {
                                        return p;
                                    }
                                    if (p_key > this.key(p)) {
                                        if (this.right(p) != -1) {
                                            p = this.right(p);
                                        } else {
                                            return p;
                                        }
                                    } else {
                                        if (this.left(p) != -1) {
                                            p = this.left(p);
                                        } else {
                                            var parent: number = this.parent(p);
                                            var ch: number = p;
                                            while (parent != -1 && ch == this.left(parent)){
                                                ch = parent;
                                                parent = this.parent(parent);
                                            }
                                            return parent;
                                        }
                                    }
                                }
                                return -1;
                            }

                            private rotateLeft(n: number): void {
                                var r: number = this.right(n);
                                this.replaceNode(n, r);
                                this.setRight(n, this.left(r));
                                if (this.left(r) != -1) {
                                    this.setParent(this.left(r), n);
                                }
                                this.setLeft(r, n);
                                this.setParent(n, r);
                            }

                            private rotateRight(n: number): void {
                                var l: number = this.left(n);
                                this.replaceNode(n, l);
                                this.setLeft(n, this.right(l));
                                if (this.right(l) != -1) {
                                    this.setParent(this.right(l), n);
                                }
                                this.setRight(l, n);
                                this.setParent(n, l);
                            }

                            private replaceNode(oldn: number, newn: number): void {
                                if (this.parent(oldn) == -1) {
                                    this._root_index = newn;
                                } else {
                                    if (oldn == this.left(this.parent(oldn))) {
                                        this.setLeft(this.parent(oldn), newn);
                                    } else {
                                        this.setRight(this.parent(oldn), newn);
                                    }
                                }
                                if (newn != -1) {
                                    this.setParent(newn, this.parent(oldn));
                                }
                            }

                            private insertCase1(n: number): void {
                                if (this.parent(n) == -1) {
                                    this.setColor(n, true);
                                } else {
                                    this.insertCase2(n);
                                }
                            }

                            private insertCase2(n: number): void {
                                if (!this.color(this.parent(n))) {
                                    this.insertCase3(n);
                                }
                            }

                            private insertCase3(n: number): void {
                                if (!this.color(this.uncle(n))) {
                                    this.setColor(this.parent(n), true);
                                    this.setColor(this.uncle(n), true);
                                    this.setColor(this.grandParent(n), false);
                                    this.insertCase1(this.grandParent(n));
                                } else {
                                    this.insertCase4(n);
                                }
                            }

                            private insertCase4(n_n: number): void {
                                var n: number = n_n;
                                if (n == this.right(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                                    this.rotateLeft(this.parent(n));
                                    n = this.left(n);
                                } else {
                                    if (n == this.left(this.parent(n)) && this.parent(n) == this.right(this.grandParent(n))) {
                                        this.rotateRight(this.parent(n));
                                        n = this.right(n);
                                    }
                                }
                                this.insertCase5(n);
                            }

                            private insertCase5(n: number): void {
                                this.setColor(this.parent(n), true);
                                this.setColor(this.grandParent(n), false);
                                if (n == this.left(this.parent(n)) && this.parent(n) == this.left(this.grandParent(n))) {
                                    this.rotateRight(this.grandParent(n));
                                } else {
                                    this.rotateLeft(this.grandParent(n));
                                }
                            }

                            public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                                if (this._root_index == -1) {
                                    return "0";
                                }
                                var savedRoot: number = this._root_index;
                                var internalState: org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree.InternalState = this.state;
                                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                                var treeSize: number = 0;
                                for (var i: number = 0; i < internalState._back_meta.length / AbstractArrayTree.META_SIZE; i++) {
                                    var parentIndex: number = internalState._back_meta[(i * AbstractArrayTree.META_SIZE) + 2];
                                    if (parentIndex != -1 || i == savedRoot) {
                                        var isOnLeft: boolean = false;
                                        if (parentIndex != -1) {
                                            isOnLeft = internalState._back_meta[parentIndex * AbstractArrayTree.META_SIZE] == i;
                                        }
                                        if (!this.color(i)) {
                                            if (isOnLeft) {
                                                builder.append(AbstractArrayTree.BLACK_LEFT);
                                            } else {
                                                builder.append(AbstractArrayTree.BLACK_RIGHT);
                                            }
                                        } else {
                                            if (isOnLeft) {
                                                builder.append(AbstractArrayTree.RED_LEFT);
                                            } else {
                                                builder.append(AbstractArrayTree.RED_RIGHT);
                                            }
                                        }
                                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(internalState._back_kv[i * this.kvSize], builder);
                                        builder.append(',');
                                        if (parentIndex != -1) {
                                            org.kevoree.modeling.util.maths.Base64.encodeIntToBuffer(parentIndex, builder);
                                        }
                                        if (this.kvSize > 1) {
                                            builder.append(',');
                                            org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(internalState._back_kv[(i * this.kvSize) + 1], builder);
                                        }
                                        treeSize++;
                                    }
                                }
                                return org.kevoree.modeling.util.maths.Base64.encodeInt(treeSize) + "," + org.kevoree.modeling.util.maths.Base64.encodeInt(savedRoot) + builder.toString();
                            }

                            public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                                if (payload == null || payload.length == 0) {
                                    return;
                                }
                                var initPos: number = 0;
                                var cursor: number = 0;
                                while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                    cursor++;
                                }
                                if (payload.charAt(cursor) == ',') {
                                    this._size = org.kevoree.modeling.util.maths.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                                    cursor++;
                                    initPos = cursor;
                                }
                                while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                    cursor++;
                                }
                                this._root_index = org.kevoree.modeling.util.maths.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                                this.allocate(this._size);
                                for (var i: number = 0; i < this._size; i++) {
                                    var offsetI: number = i * AbstractArrayTree.META_SIZE;
                                    this.state._back_meta[offsetI] = -1;
                                    this.state._back_meta[offsetI + 1] = -1;
                                    this.state._back_meta[offsetI + 2] = -1;
                                }
                                var currentLoopIndex: number = 0;
                                while (cursor < payload.length){
                                    while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                        cursor++;
                                    }
                                    if (cursor < payload.length) {
                                        var elem: string = payload.charAt(cursor);
                                        var isOnLeft: boolean = false;
                                        if (elem == AbstractArrayTree.BLACK_LEFT || elem == AbstractArrayTree.RED_LEFT) {
                                            isOnLeft = true;
                                        }
                                        if (elem == AbstractArrayTree.BLACK_LEFT || elem == AbstractArrayTree.BLACK_RIGHT) {
                                            this.setColor(currentLoopIndex, false);
                                        } else {
                                            this.setColor(currentLoopIndex, true);
                                        }
                                        cursor++;
                                        var beginChunk: number = cursor;
                                        while (cursor < payload.length && payload.charAt(cursor) != ','){
                                            cursor++;
                                        }
                                        var loopKey: number = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                                        this.setKey(currentLoopIndex, loopKey);
                                        cursor++;
                                        beginChunk = cursor;
                                        while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                            cursor++;
                                        }
                                        if (cursor > beginChunk) {
                                            var parentRaw: number = org.kevoree.modeling.util.maths.Base64.decodeToIntWithBounds(payload, beginChunk, cursor);
                                            this.setParent(currentLoopIndex, parentRaw);
                                            if (isOnLeft) {
                                                this.setLeft(parentRaw, currentLoopIndex);
                                            } else {
                                                this.setRight(parentRaw, currentLoopIndex);
                                            }
                                        }
                                        if (cursor < payload.length && payload.charAt(cursor) == ',') {
                                            cursor++;
                                            beginChunk = cursor;
                                            while (cursor < payload.length && payload.charAt(cursor) != AbstractArrayTree.BLACK_LEFT && payload.charAt(cursor) != AbstractArrayTree.BLACK_RIGHT && payload.charAt(cursor) != AbstractArrayTree.RED_LEFT && payload.charAt(cursor) != AbstractArrayTree.RED_RIGHT){
                                                cursor++;
                                            }
                                            if (cursor > beginChunk) {
                                                var currentValue: number = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, beginChunk, cursor);
                                                this.setValue(currentLoopIndex, currentValue);
                                            }
                                        }
                                        currentLoopIndex++;
                                    }
                                }
                            }

                            public free(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                this.state = null;
                                this._size = 0;
                                this._threshold = 0;
                            }

                            public internal_insert(p_key: number, p_value: number): void {
                                if ((this._size + 1) > this._threshold) {
                                    var length: number = (this._size == 0 ? 1 : this._size << 1);
                                    this.reallocate(length);
                                }
                                var newIndex: number = this._size;
                                if (newIndex == 0) {
                                    this.setKey(newIndex, p_key);
                                    if (this.kvSize == 2) {
                                        this.setValue(newIndex, p_value);
                                    }
                                    this.setColor(newIndex, false);
                                    this.setLeft(newIndex, -1);
                                    this.setRight(newIndex, -1);
                                    this.setParent(newIndex, -1);
                                    this._root_index = newIndex;
                                    this._size = 1;
                                } else {
                                    var n: number = this._root_index;
                                    while (true){
                                        if (p_key == this.key(n)) {
                                            return;
                                        } else {
                                            if (p_key < this.key(n)) {
                                                if (this.left(n) == -1) {
                                                    this.setKey(newIndex, p_key);
                                                    if (this.kvSize == 2) {
                                                        this.setValue(newIndex, p_value);
                                                    }
                                                    this.setColor(newIndex, false);
                                                    this.setLeft(newIndex, -1);
                                                    this.setRight(newIndex, -1);
                                                    this.setParent(newIndex, -1);
                                                    this.setLeft(n, newIndex);
                                                    this._size++;
                                                    break;
                                                } else {
                                                    n = this.left(n);
                                                }
                                            } else {
                                                if (this.right(n) == -1) {
                                                    this.setKey(newIndex, p_key);
                                                    if (this.kvSize == 2) {
                                                        this.setValue(newIndex, p_value);
                                                    }
                                                    this.setColor(newIndex, false);
                                                    this.setLeft(newIndex, -1);
                                                    this.setRight(newIndex, -1);
                                                    this.setParent(newIndex, -1);
                                                    this.setRight(n, newIndex);
                                                    this._size++;
                                                    break;
                                                } else {
                                                    n = this.right(n);
                                                }
                                            }
                                        }
                                    }
                                    this.setParent(newIndex, n);
                                }
                                this.insertCase1(newIndex);
                                this.internal_set_dirty();
                            }

                            public internal_lookup_value(p_key: number): number {
                                var n: number = this._root_index;
                                if (n == -1) {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                                while (n != -1){
                                    if (p_key == this.key(n)) {
                                        return this.value(n);
                                    } else {
                                        if (p_key < this.key(n)) {
                                            n = this.left(n);
                                        } else {
                                            n = this.right(n);
                                        }
                                    }
                                }
                                return n;
                            }

                            private internal_set_dirty(): void {
                                if (this._space != null) {
                                    if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                        this._space.declareDirty(this);
                                        this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                    }
                                } else {
                                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                }
                            }

                            public type(): number {
                                throw "Abstract method";
                            }

                        }

                        export module AbstractArrayTree {
                            export class InternalState {

                                public _back_meta: Int32Array;
                                public _back_kv: Float64Array;
                                public _back_colors: boolean[];
                                constructor(_back_meta: Int32Array, _back_kv: Float64Array, _back_colors: boolean[]) {
                                    this._back_meta = _back_meta;
                                    this._back_kv = _back_kv;
                                    this._back_colors = _back_colors;
                                }

                            }


                        }
                        export class ArrayIntMap<V> implements org.kevoree.modeling.memory.chunk.KIntMap<any> {

                             constructor(initalCapacity: number, loadFactor : number) { }
                             public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];}} }
                             public get(key:number):V { return this[key]; }
                             public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                             public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
                             public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
                             public size():number { return Object.keys(this).length; }
                             public each(callback: (p : number, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
                        }

                        export class ArrayLongLongMap implements org.kevoree.modeling.memory.chunk.KLongLongMap {

                            public elementCount: number;
                            public droppedCount: number;
                            public state: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = null;
                            public threshold: number;
                            private initialCapacity: number = 16;
                            private static loadFactor: number = (<number>75 / <number>100);
                            private _flags: java.util.concurrent.atomic.AtomicLong;
                            private _counter: java.util.concurrent.atomic.AtomicInteger;
                            private _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            private _universe: number;
                            private _time: number;
                            private _obj: number;
                            private _metaClassIndex: number = -1;
                            constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._universe = p_universe;
                                this._time = p_time;
                                this._obj = p_obj;
                                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                                this._space = p_space;
                                this.elementCount = 0;
                                this.droppedCount = 0;
                                var newstate: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                                for (var i: number = 0; i < this.initialCapacity; i++) {
                                    newstate.elementNext[i] = -1;
                                    newstate.elementHash[i] = -1;
                                }
                                this.state = newstate;
                                this.threshold = <number>(newstate.elementDataSize * ArrayLongLongMap.loadFactor);
                            }

                            public counter(): number {
                                return this._counter.get();
                            }

                            public inc(): number {
                                return this._counter.incrementAndGet();
                            }

                            public dec(): number {
                                return this._counter.decrementAndGet();
                            }

                            public clear(): void {
                                if (this.elementCount > 0) {
                                    this.elementCount = 0;
                                    this.droppedCount = 0;
                                    var newstate: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(this.initialCapacity, new Float64Array(this.initialCapacity * 2), new Int32Array(this.initialCapacity), new Int32Array(this.initialCapacity));
                                    for (var i: number = 0; i < this.initialCapacity; i++) {
                                        newstate.elementNext[i] = -1;
                                        newstate.elementHash[i] = -1;
                                    }
                                    this.state = newstate;
                                    this.threshold = <number>(newstate.elementDataSize * ArrayLongLongMap.loadFactor);
                                }
                            }

                            public rehashCapacity(capacity: number): void {
                                var length: number = (capacity == 0 ? 1 : capacity << 1);
                                var newElementKV: Float64Array = new Float64Array(length * 2);
                                java.lang.System.arraycopy(this.state.elementKV, 0, newElementKV, 0, this.state.elementKV.length);
                                var newElementNext: Int32Array = new Int32Array(length);
                                var newElementHash: Int32Array = new Int32Array(length);
                                for (var i: number = 0; i < length; i++) {
                                    newElementNext[i] = -1;
                                    newElementHash[i] = -1;
                                }
                                for (var i: number = 0; i < this.state.elementNext.length; i++) {
                                    if (this.state.elementNext[i] != -1) {
                                        var index: number = (<number>this.state.elementKV[i * 2] & 0x7FFFFFFF) % length;
                                        var currentHashedIndex: number = newElementHash[index];
                                        if (currentHashedIndex != -1) {
                                            newElementNext[i] = currentHashedIndex;
                                        } else {
                                            newElementNext[i] = -2;
                                        }
                                        newElementHash[index] = i;
                                    }
                                }
                                this.state = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                                this.threshold = <number>(length * ArrayLongLongMap.loadFactor);
                            }

                            public each(callback: org.kevoree.modeling.memory.chunk.KLongLongMapCallBack<any>): void {
                                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                                    if (internalState.elementNext[i] != -1) {
                                        callback(internalState.elementKV[i * 2], internalState.elementKV[i * 2 + 1]);
                                    }
                                }
                            }

                            public metaClassIndex(): number {
                                return this._metaClassIndex;
                            }

                            public contains(key: number): boolean {
                                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                                if (this.state.elementDataSize == 0) {
                                    return false;
                                }
                                var hash: number = <number>(key);
                                var index: number = (hash & 0x7FFFFFFF) % internalState.elementDataSize;
                                var m: number = internalState.elementHash[index];
                                while (m >= 0){
                                    if (key == internalState.elementKV[m * 2]) {
                                        return true;
                                    }
                                    m = internalState.elementNext[m];
                                }
                                return false;
                            }

                            public get(key: number): number {
                                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                                if (this.state.elementDataSize == 0) {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                                var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                                var m: number = internalState.elementHash[index];
                                while (m >= 0){
                                    if (key == internalState.elementKV[m * 2]) {
                                        return internalState.elementKV[(m * 2) + 1];
                                    } else {
                                        m = internalState.elementNext[m];
                                    }
                                }
                                return org.kevoree.modeling.KConfig.NULL_LONG;
                            }

                            public put(key: number, value: number): void {
                                var entry: number = -1;
                                var index: number = -1;
                                var hash: number = <number>(key);
                                if (this.state.elementDataSize != 0) {
                                    index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                                    entry = this.findNonNullKeyEntry(key, index);
                                }
                                if (entry == -1) {
                                    if (++this.elementCount > this.threshold) {
                                        this.rehashCapacity(this.state.elementDataSize);
                                        index = (hash & 0x7FFFFFFF) % this.state.elementDataSize;
                                    }
                                    var newIndex: number = (this.elementCount + this.droppedCount - 1);
                                    this.state.elementKV[newIndex * 2] = key;
                                    this.state.elementKV[newIndex * 2 + 1] = value;
                                    var currentHashedIndex: number = this.state.elementHash[index];
                                    if (currentHashedIndex != -1) {
                                        this.state.elementNext[newIndex] = currentHashedIndex;
                                    } else {
                                        this.state.elementNext[newIndex] = -2;
                                    }
                                    this.state.elementHash[index] = newIndex;
                                } else {
                                    this.state.elementKV[entry + 1] = value;
                                }
                                this.internal_set_dirty();
                            }

                            public findNonNullKeyEntry(key: number, index: number): number {
                                var m: number = this.state.elementHash[index];
                                while (m >= 0){
                                    if (key == this.state.elementKV[m * 2]) {
                                        return m;
                                    }
                                    m = this.state.elementNext[m];
                                }
                                return -1;
                            }

                            public remove(key: number): void {
                                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                                if (this.state.elementDataSize == 0) {
                                    return;
                                }
                                var index: number = (<number>(key) & 0x7FFFFFFF) % internalState.elementDataSize;
                                var m: number = this.state.elementHash[index];
                                var last: number = -1;
                                while (m >= 0){
                                    if (key == this.state.elementKV[m * 2]) {
                                        break;
                                    }
                                    last = m;
                                    m = this.state.elementNext[m];
                                }
                                if (m == -1) {
                                    return;
                                }
                                if (last == -1) {
                                    if (this.state.elementNext[m] > 0) {
                                        this.state.elementHash[index] = m;
                                    } else {
                                        this.state.elementHash[index] = -1;
                                    }
                                } else {
                                    this.state.elementNext[last] = this.state.elementNext[m];
                                }
                                this.state.elementNext[m] = -1;
                                this.elementCount--;
                                this.droppedCount++;
                            }

                            public size(): number {
                                return this.elementCount;
                            }

                            public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                                this._metaClassIndex = metaClassIndex;
                                if (payload == null || payload.length == 0) {
                                    return;
                                }
                                var initPos: number = 0;
                                var cursor: number = 0;
                                while (cursor < payload.length && payload.charAt(cursor) != ',' && payload.charAt(cursor) != '/'){
                                    cursor++;
                                }
                                if (cursor >= payload.length) {
                                    return;
                                }
                                if (payload.charAt(cursor) == ',') {
                                    this._metaClassIndex = metaModel.metaClassByName(payload.substring(initPos, cursor)).index();
                                    cursor++;
                                    initPos = cursor;
                                }
                                while (cursor < payload.length && payload.charAt(cursor) != '/'){
                                    cursor++;
                                }
                                var nbElement: number = org.kevoree.modeling.util.maths.Base64.decodeToIntWithBounds(payload, initPos, cursor);
                                var length: number = (nbElement == 0 ? 1 : nbElement << 1);
                                var newElementKV: Float64Array = new Float64Array(length * 2);
                                var newElementNext: Int32Array = new Int32Array(length);
                                var newElementHash: Int32Array = new Int32Array(length);
                                for (var i: number = 0; i < length; i++) {
                                    newElementNext[i] = -1;
                                    newElementHash[i] = -1;
                                }
                                var temp_state: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState(length, newElementKV, newElementNext, newElementHash);
                                while (cursor < payload.length){
                                    cursor++;
                                    var beginChunk: number = cursor;
                                    while (cursor < payload.length && payload.charAt(cursor) != ':'){
                                        cursor++;
                                    }
                                    var middleChunk: number = cursor;
                                    while (cursor < payload.length && payload.charAt(cursor) != ','){
                                        cursor++;
                                    }
                                    var loopKey: number = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, beginChunk, middleChunk);
                                    var loopVal: number = org.kevoree.modeling.util.maths.Base64.decodeToLongWithBounds(payload, middleChunk + 1, cursor);
                                    var index: number = ((<number>(loopKey)) & 0x7FFFFFFF) % temp_state.elementDataSize;
                                    var newIndex: number = this.elementCount;
                                    temp_state.elementKV[newIndex * 2] = loopKey;
                                    temp_state.elementKV[newIndex * 2 + 1] = loopVal;
                                    var currentHashedIndex: number = temp_state.elementHash[index];
                                    if (currentHashedIndex != -1) {
                                        temp_state.elementNext[newIndex] = currentHashedIndex;
                                    } else {
                                        temp_state.elementNext[newIndex] = -2;
                                    }
                                    temp_state.elementHash[index] = newIndex;
                                    this.elementCount++;
                                }
                                this.elementCount = nbElement;
                                this.droppedCount = 0;
                                this.state = temp_state;
                                this.threshold = <number>(length * ArrayLongLongMap.loadFactor);
                            }

                            public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                                var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                                if (this._metaClassIndex != -1) {
                                    buffer.append(metaModel.metaClass(this._metaClassIndex).metaName());
                                    buffer.append(',');
                                }
                                org.kevoree.modeling.util.maths.Base64.encodeIntToBuffer(this.elementCount, buffer);
                                buffer.append('/');
                                var isFirst: boolean = true;
                                var internalState: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap.InternalState = this.state;
                                for (var i: number = 0; i < internalState.elementNext.length; i++) {
                                    if (internalState.elementNext[i] != -1) {
                                        var loopKey: number = internalState.elementKV[i * 2];
                                        var loopValue: number = internalState.elementKV[i * 2 + 1];
                                        if (!isFirst) {
                                            buffer.append(",");
                                        }
                                        isFirst = false;
                                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(loopKey, buffer);
                                        buffer.append(":");
                                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(loopValue, buffer);
                                    }
                                }
                                return buffer.toString();
                            }

                            public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                this.clear();
                            }

                            public type(): number {
                                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
                            }

                            public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                                return this._space;
                            }

                            private internal_set_dirty(): void {
                                if (this._space != null) {
                                    if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                        this._space.declareDirty(this);
                                        this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                    }
                                } else {
                                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                }
                            }

                            public getFlags(): number {
                                return this._flags.get();
                            }

                            public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                                var val: number;
                                var nval: number;
                                do {
                                    val = this._flags.get();
                                    nval = val & ~bitsToDisable | bitsToEnable;
                                } while (!this._flags.compareAndSet(val, nval))
                            }

                            public universe(): number {
                                return this._universe;
                            }

                            public time(): number {
                                return this._time;
                            }

                            public obj(): number {
                                return this._obj;
                            }

                        }

                        export module ArrayLongLongMap {
                            export class InternalState {

                                public elementDataSize: number;
                                public elementKV: Float64Array;
                                public elementNext: Int32Array;
                                public elementHash: Int32Array;
                                constructor(elementDataSize: number, elementKV: Float64Array, elementNext: Int32Array, elementHash: Int32Array) {
                                    this.elementDataSize = elementDataSize;
                                    this.elementKV = elementKV;
                                    this.elementNext = elementNext;
                                    this.elementHash = elementHash;
                                }

                            }


                        }
                        export class ArrayLongLongTree extends org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree implements org.kevoree.modeling.memory.chunk.KLongLongTree {

                            constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                super(p_universe, p_time, p_obj, p_space);
                                this.kvSize = 2;
                            }

                            public previousOrEqualValue(p_key: number): number {
                                var result: number = this.internal_previousOrEqual_index(p_key);
                                if (result != -1) {
                                    return this.value(result);
                                } else {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                            }

                            public lookupValue(p_key: number): number {
                                return this.internal_lookup_value(p_key);
                            }

                            public insert(p_key: number, p_value: number): void {
                                this.internal_insert(p_key, p_value);
                            }

                            public type(): number {
                                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_TREE;
                            }

                        }

                        export class ArrayLongMap<V> implements org.kevoree.modeling.memory.chunk.KLongMap<any> {

                             constructor(initalCapacity: number, loadFactor : number) { }
                             public clear():void { for(var p in this){if(this.hasOwnProperty(p)){delete this[p];} } }
                             public get(key:number):V { return this[key]; }
                             public put(key:number, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                             public contains(key:number):boolean { return this.hasOwnProperty(<any>key);}
                             public remove(key:number):V { var tmp = this[key]; delete this[key]; return tmp; }
                             public size():number { return Object.keys(this).length; }
                             public each(callback: (p : number, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(+p,this[p]); } } }
                        }

                        export class ArrayLongTree extends org.kevoree.modeling.memory.chunk.impl.AbstractArrayTree implements org.kevoree.modeling.memory.chunk.KLongTree {

                            constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                super(p_universe, p_time, p_obj, p_space);
                            }

                            public previousOrEqual(key: number): number {
                                var result: number = this.internal_previousOrEqual_index(key);
                                if (result != -1) {
                                    return this.key(result);
                                } else {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                            }

                            public insert(p_key: number): void {
                                this.internal_insert(p_key, p_key);
                            }

                            public type(): number {
                                return org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE;
                            }

                        }

                        export class ArrayStringMap<V> implements org.kevoree.modeling.memory.chunk.KStringMap<any> {

                             constructor(initalCapacity: number, loadFactor : number) { }
                             public clear():void { for(var p in this){ if(this.hasOwnProperty(p)){ delete this[p];} } }
                             public get(key:string):V { return this[key]; }
                             public put(key:string, pval : V):V { var previousVal = this[key];this[key] = pval;return previousVal;}
                             public contains(key:string):boolean { return this.hasOwnProperty(key);}
                             public remove(key:string):V { var tmp = this[key]; delete this[key]; return tmp; }
                             public size():number { return Object.keys(this).length; }
                             public each(callback: (p : string, p1 : V) => void): void { for(var p in this){ if(this.hasOwnProperty(p)){ callback(<string>p,this[p]); } } }
                        }

                        export class HeapObjectChunk implements org.kevoree.modeling.memory.chunk.KObjectChunk {

                            private _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            private _flags: java.util.concurrent.atomic.AtomicLong;
                            private _counter: java.util.concurrent.atomic.AtomicInteger;
                            private _universe: number;
                            private _time: number;
                            private _obj: number;
                            private raw: any[];
                            private _metaClassIndex: number = -1;
                            constructor(p_universe: number, p_time: number, p_obj: number, p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._universe = p_universe;
                                this._time = p_time;
                                this._obj = p_obj;
                                this._flags = new java.util.concurrent.atomic.AtomicLong(0);
                                this._counter = new java.util.concurrent.atomic.AtomicInteger(0);
                                this._space = p_space;
                            }

                            public space(): org.kevoree.modeling.memory.space.KChunkSpace {
                                return this._space;
                            }

                            public metaClassIndex(): number {
                                return this._metaClassIndex;
                            }

                            public serialize(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                                builder.append("{");
                                var isFirst: boolean = true;
                                var metaElements: org.kevoree.modeling.meta.KMeta[] = metaClass.metaElements();
                                if (this.raw != null && metaElements != null) {
                                    for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                                        if (this.raw[i] != null) {
                                            if (isFirst) {
                                                builder.append("\"");
                                                isFirst = false;
                                            } else {
                                                builder.append(",\"");
                                            }
                                            builder.append(metaElements[i].metaName());
                                            builder.append("\":");
                                            if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                                                var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                                                var metaAttId: number = metaAttribute.attributeTypeId();
                                                switch (metaAttId) {
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                                                    builder.append("\"");
                                                    builder.append(org.kevoree.modeling.format.json.JsonString.encode(<string>this.raw[i]));
                                                    builder.append("\"");
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                                                    builder.append("\"");
                                                    org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(<number>this.raw[i], builder);
                                                    builder.append("\"");
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                                                    this.doubleArrayToBuffer(builder, i, true);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                                                    if (<boolean>this.raw[i]) {
                                                        builder.append("1");
                                                    } else {
                                                        builder.append("0");
                                                    }
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                                                    builder.append("\"");
                                                    org.kevoree.modeling.util.maths.Base64.encodeDoubleToBuffer(<number>this.raw[i], builder);
                                                    builder.append("\"");
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                                                    builder.append("\"");
                                                    org.kevoree.modeling.util.maths.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                                    builder.append("\"");
                                                    break;
                                                    default:
                                                    if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                                                        org.kevoree.modeling.util.maths.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                                    }
                                                    break;
                                                }
                                            } else {
                                                if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                    this.longArrayToBuffer(builder, i, true);
                                                } else {
                                                    if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.INPUT || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.OUTPUT) {
                                                        this.doubleArrayToBuffer(builder, i, true);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                builder.append("}");
                                return builder.toString();
                            }

                            private doubleArrayToBuffer(builder: java.lang.StringBuilder, i: number, encoded: boolean): void {
                                builder.append("[");
                                var castedArr: Float64Array = <Float64Array>this.raw[i];
                                for (var j: number = 0; j < castedArr.length; j++) {
                                    if (j != 0) {
                                        builder.append(",");
                                    }
                                    if (encoded) {
                                        builder.append("\"");
                                        org.kevoree.modeling.util.maths.Base64.encodeDoubleToBuffer(castedArr[j], builder);
                                        builder.append("\"");
                                    } else {
                                        builder.append(castedArr[j]);
                                    }
                                }
                                builder.append("]");
                            }

                            private longArrayToBuffer(builder: java.lang.StringBuilder, i: number, encoded: boolean): void {
                                builder.append("[");
                                var castedArr: Float64Array = <Float64Array>this.raw[i];
                                for (var j: number = 0; j < castedArr.length; j++) {
                                    if (j != 0) {
                                        builder.append(",");
                                    }
                                    if (encoded) {
                                        builder.append("\"");
                                        org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(castedArr[j], builder);
                                        builder.append("\"");
                                    } else {
                                        builder.append(castedArr[j]);
                                    }
                                }
                                builder.append("]");
                            }

                            public init(payload: string, metaModel: org.kevoree.modeling.meta.KMetaModel, metaClassIndex: number): void {
                                if (this._metaClassIndex == -1) {
                                    this._metaClassIndex = metaClassIndex;
                                }
                                if (this._metaClassIndex == -1) {
                                    return;
                                }
                                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                                this.raw = new Array();
                                if (payload != null) {
                                    var objectReader: org.kevoree.modeling.format.json.JsonObjectReader = new org.kevoree.modeling.format.json.JsonObjectReader();
                                    objectReader.parseObject(payload);
                                    var metaKeys: string[] = objectReader.keys();
                                    for (var i: number = 0; i < metaKeys.length; i++) {
                                        var insideContent: any = objectReader.get(metaKeys[i]);
                                        var metaElement: org.kevoree.modeling.meta.KMeta = metaClass.metaByName(metaKeys[i]);
                                        if (insideContent != null) {
                                            if (metaElement != null && metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.ATTRIBUTE)) {
                                                var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElement;
                                                var converted: any = null;
                                                var metaAttId: number = metaAttribute.attributeTypeId();
                                                switch (metaAttId) {
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                                                    converted = org.kevoree.modeling.format.json.JsonString.unescape(<string>insideContent);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                                                    converted = org.kevoree.modeling.util.maths.Base64.decodeToLong(<string>insideContent);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                                                    converted = org.kevoree.modeling.util.maths.Base64.decodeToInt(<string>insideContent);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(insideContent.toString(), "1")) {
                                                        converted = true;
                                                    } else {
                                                        converted = false;
                                                    }
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                                                    converted = org.kevoree.modeling.util.maths.Base64.decodeToDouble(<string>insideContent);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                                                    var plainRawSet: string[] = objectReader.getAsStringArray(metaKeys[i]);
                                                    var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                                                    for (var l: number = 0; l < plainRawSet.length; l++) {
                                                        try {
                                                            convertedRaw[l] = org.kevoree.modeling.util.maths.Base64.decodeToDouble(plainRawSet[l]);
                                                        } catch ($ex$) {
                                                            if ($ex$ instanceof Error) {
                                                                var e: Error = <Error>$ex$;
                                                                console.error(e['stack']);;
                                                            } else {
                                                                throw $ex$;
                                                            }
                                                        }
                                                    }
                                                    converted = convertedRaw;
                                                    break;
                                                }
                                                this.raw[metaAttribute.index()] = converted;
                                            }
                                            if (metaElement != null && metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.REFERENCE)) {
                                                try {
                                                    var plainRawSet: string[] = objectReader.getAsStringArray(metaKeys[i]);
                                                    var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                                                    for (var l: number = 0; l < plainRawSet.length; l++) {
                                                        try {
                                                            convertedRaw[l] = org.kevoree.modeling.util.maths.Base64.decodeToLong(plainRawSet[l]);
                                                        } catch ($ex$) {
                                                            if ($ex$ instanceof Error) {
                                                                var e: Error = <Error>$ex$;
                                                                console.error(e['stack']);;
                                                            } else {
                                                                throw $ex$;
                                                            }
                                                        }
                                                    }
                                                    this.raw[metaElement.index()] = convertedRaw;
                                                } catch ($ex$) {
                                                    if ($ex$ instanceof Error) {
                                                        var e: Error = <Error>$ex$;
                                                        console.error(e['stack']);;
                                                    } else {
                                                        throw $ex$;
                                                    }
                                                }
                                            } else {
                                                if (metaElement != null && (metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.DEPENDENCIES) || metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.INPUT) || metaElement.metaType().equals(org.kevoree.modeling.meta.MetaType.OUTPUT))) {
                                                    try {
                                                        var plainRawSet: string[] = objectReader.getAsStringArray(metaKeys[i]);
                                                        var convertedRaw: Float64Array = new Float64Array(plainRawSet.length);
                                                        for (var l: number = 0; l < plainRawSet.length; l++) {
                                                            try {
                                                                convertedRaw[l] = org.kevoree.modeling.util.maths.Base64.decodeToDouble(plainRawSet[l]);
                                                            } catch ($ex$) {
                                                                if ($ex$ instanceof Error) {
                                                                    var e: Error = <Error>$ex$;
                                                                    console.error(e['stack']);;
                                                                } else {
                                                                    throw $ex$;
                                                                }
                                                            }
                                                        }
                                                        this.raw[metaElement.index()] = convertedRaw;
                                                    } catch ($ex$) {
                                                        if ($ex$ instanceof Error) {
                                                            var e: Error = <Error>$ex$;
                                                            console.error(e['stack']);;
                                                        } else {
                                                            throw $ex$;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            public counter(): number {
                                return this._counter.get();
                            }

                            public inc(): number {
                                return this._counter.incrementAndGet();
                            }

                            public dec(): number {
                                return this._counter.decrementAndGet();
                            }

                            public free(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                this.raw = null;
                            }

                            public type(): number {
                                return org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
                            }

                            public getPrimitiveType(index: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass): any {
                                if (this.raw != null) {
                                    return this.raw[index];
                                } else {
                                    return null;
                                }
                            }

                            public getLongArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                                var existing: Float64Array = <Float64Array>this.raw[index];
                                if (existing != null) {
                                    return existing.length;
                                }
                                return 0;
                            }

                            public getLongArrayElem(index: number, refIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                                var existing: Float64Array = <Float64Array>this.raw[index];
                                if (existing != null) {
                                    return existing[refIndex];
                                } else {
                                    return org.kevoree.modeling.KConfig.NULL_LONG;
                                }
                            }

                            public getLongArray(index: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                                if (this.raw != null) {
                                    var previousObj: any = this.raw[index];
                                    if (previousObj != null) {
                                        try {
                                            return <Float64Array>previousObj;
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                                this.raw[index] = null;
                                                return null;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    } else {
                                        return null;
                                    }
                                } else {
                                    return null;
                                }
                            }

                            public addLongToArray(index: number, newRef: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                                if (this.raw != null) {
                                    var previous: Float64Array = <Float64Array>this.raw[index];
                                    if (previous == null) {
                                        previous = new Float64Array(1);
                                        previous[0] = newRef;
                                    } else {
                                        for (var i: number = 0; i < previous.length; i++) {
                                            if (previous[i] == newRef) {
                                                return false;
                                            }
                                        }
                                        var incArray: Float64Array = new Float64Array(previous.length + 1);
                                        java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                                        incArray[previous.length] = newRef;
                                        previous = incArray;
                                    }
                                    this.raw[index] = previous;
                                    this.internal_set_dirty();
                                    return true;
                                }
                                return false;
                            }

                            public removeLongToArray(index: number, refToRemove: number, metaClass: org.kevoree.modeling.meta.KMetaClass): boolean {
                                if (this.raw != null) {
                                    var previous: Float64Array = <Float64Array>this.raw[index];
                                    if (previous != null) {
                                        var indexToRemove: number = -1;
                                        for (var i: number = 0; i < previous.length; i++) {
                                            if (previous[i] == refToRemove) {
                                                indexToRemove = i;
                                                break;
                                            }
                                        }
                                        if (indexToRemove != -1) {
                                            if ((previous.length - 1) == 0) {
                                                this.raw[index] = null;
                                            } else {
                                                var newArray: Float64Array = new Float64Array(previous.length - 1);
                                                java.lang.System.arraycopy(previous, 0, newArray, 0, indexToRemove);
                                                java.lang.System.arraycopy(previous, indexToRemove + 1, newArray, indexToRemove, previous.length - indexToRemove - 1);
                                                this.raw[index] = newArray;
                                            }
                                            this.internal_set_dirty();
                                            return true;
                                        }
                                    }
                                }
                                return false;
                            }

                            public clearLongArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                                this.raw[index] = null;
                            }

                            public getDoubleArray(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): Float64Array {
                                if (this.raw != null) {
                                    var previousObj: any = this.raw[index];
                                    if (previousObj != null) {
                                        try {
                                            return <Float64Array>previousObj;
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                                this.raw[index] = null;
                                                return null;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    } else {
                                        return null;
                                    }
                                } else {
                                    return null;
                                }
                            }

                            public getDoubleArraySize(index: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                                var previousObj: any = this.raw[index];
                                if (previousObj != null) {
                                    return (<Float64Array>previousObj).length;
                                }
                                return 0;
                            }

                            public getDoubleArrayElem(index: number, arrayIndex: number, metaClass: org.kevoree.modeling.meta.KMetaClass): number {
                                var res: Float64Array = this.getDoubleArray(index, metaClass);
                                if (org.kevoree.modeling.util.Checker.isDefined(res)) {
                                    return res[arrayIndex];
                                }
                                return 0;
                            }

                            public setDoubleArrayElem(index: number, arrayIndex: number, valueToInsert: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                                var res: Float64Array = this.getDoubleArray(index, metaClass);
                                if (org.kevoree.modeling.util.Checker.isDefined(res)) {
                                    res[arrayIndex] = valueToInsert;
                                    this.internal_set_dirty();
                                }
                            }

                            public extendDoubleArray(index: number, newSize: number, metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                                if (this.raw != null) {
                                    var previous: Float64Array = <Float64Array>this.raw[index];
                                    if (previous == null) {
                                        previous = new Float64Array(newSize);
                                    } else {
                                        var incArray: Float64Array = new Float64Array(newSize);
                                        java.lang.System.arraycopy(previous, 0, incArray, 0, previous.length);
                                        previous = incArray;
                                    }
                                    this.raw[index] = previous;
                                    this.internal_set_dirty();
                                }
                            }

                            public setPrimitiveType(index: number, content: any, p_metaClass: org.kevoree.modeling.meta.KMetaClass): void {
                                this.raw[index] = content;
                                this.internal_set_dirty();
                            }

                            public clone(p_universe: number, p_time: number, p_obj: number, p_metaClass: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                if (this.raw == null) {
                                    return new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                                } else {
                                    var cloned: any[] = new Array();
                                    java.lang.System.arraycopy(this.raw, 0, cloned, 0, this.raw.length);
                                    var clonedEntry: org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk = new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this._space);
                                    clonedEntry.raw = cloned;
                                    clonedEntry._metaClassIndex = this._metaClassIndex;
                                    clonedEntry.internal_set_dirty();
                                    return clonedEntry;
                                }
                            }

                            public toJSON(metaModel: org.kevoree.modeling.meta.KMetaModel): string {
                                var metaClass: org.kevoree.modeling.meta.KMetaClass = metaModel.metaClass(this._metaClassIndex);
                                var builder: java.lang.StringBuilder = new java.lang.StringBuilder();
                                builder.append("{");
                                var isFirst: boolean = true;
                                var metaElements: org.kevoree.modeling.meta.KMeta[] = metaClass.metaElements();
                                if (this.raw != null && metaElements != null) {
                                    for (var i: number = 0; i < this.raw.length && i < metaElements.length; i++) {
                                        if (this.raw[i] != null) {
                                            if (isFirst) {
                                                builder.append("\"");
                                                isFirst = false;
                                            } else {
                                                builder.append(",\"");
                                            }
                                            builder.append(metaElements[i].metaName());
                                            builder.append("\":");
                                            if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                                                var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[i];
                                                var metaAttId: number = metaAttribute.attributeTypeId();
                                                switch (metaAttId) {
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.STRING_ID:
                                                    builder.append("\"");
                                                    builder.append(org.kevoree.modeling.format.json.JsonString.encode(<string>this.raw[i]));
                                                    builder.append("\"");
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.LONG_ID:
                                                    builder.append(this.raw[i]);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID:
                                                    this.doubleArrayToBuffer(builder, i, false);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.BOOL_ID:
                                                    if (<boolean>this.raw[i]) {
                                                        builder.append("1");
                                                    } else {
                                                        builder.append("0");
                                                    }
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.DOUBLE_ID:
                                                    builder.append(this.raw[i]);
                                                    break;
                                                    case org.kevoree.modeling.meta.KPrimitiveTypes.INT_ID:
                                                    builder.append(this.raw[i]);
                                                    break;
                                                    default:
                                                    if (org.kevoree.modeling.meta.KPrimitiveTypes.isEnum(metaAttribute.attributeTypeId())) {
                                                        org.kevoree.modeling.util.maths.Base64.encodeIntToBuffer(<number>this.raw[i], builder);
                                                    }
                                                    break;
                                                }
                                            } else {
                                                if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                    this.longArrayToBuffer(builder, i, false);
                                                } else {
                                                    if (metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.DEPENDENCIES || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.INPUT || metaElements[i].metaType() == org.kevoree.modeling.meta.MetaType.OUTPUT) {
                                                        this.doubleArrayToBuffer(builder, i, false);
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                builder.append("}");
                                return builder.toString();
                            }

                            private internal_set_dirty(): void {
                                if (this._space != null) {
                                    if ((this._flags.get() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                        this._space.declareDirty(this);
                                        this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                    }
                                } else {
                                    this.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                }
                            }

                            public getFlags(): number {
                                return this._flags.get();
                            }

                            public setFlags(bitsToEnable: number, bitsToDisable: number): void {
                                var val: number;
                                var nval: number;
                                do {
                                    val = this._flags.get();
                                    nval = val & ~bitsToDisable | bitsToEnable;
                                } while (!this._flags.compareAndSet(val, nval))
                            }

                            public universe(): number {
                                return this._universe;
                            }

                            public time(): number {
                                return this._time;
                            }

                            public obj(): number {
                                return this._obj;
                            }

                        }

                    }
                }
                export module manager {
                    export class DataManagerBuilder {

                        private _driver: org.kevoree.modeling.cdn.KContentDeliveryDriver;
                        private _scheduler: org.kevoree.modeling.scheduler.KScheduler;
                        private _strategy: org.kevoree.modeling.memory.strategy.KMemoryStrategy;
                        public driver(): org.kevoree.modeling.cdn.KContentDeliveryDriver {
                            if (this._driver == null) {
                                this._driver = new org.kevoree.modeling.cdn.impl.MemoryContentDeliveryDriver();
                            }
                            return this._driver;
                        }

                        public scheduler(): org.kevoree.modeling.scheduler.KScheduler {
                            if (this._scheduler == null) {
                                this._scheduler = new org.kevoree.modeling.scheduler.impl.DirectScheduler();
                            }
                            return this._scheduler;
                        }

                        public strategy(): org.kevoree.modeling.memory.strategy.KMemoryStrategy {
                            if (this._strategy == null) {
                                this._strategy = new org.kevoree.modeling.memory.strategy.impl.HeapMemoryStrategy();
                            }
                            return this._strategy;
                        }

                        public static create(): org.kevoree.modeling.memory.manager.DataManagerBuilder {
                            return new org.kevoree.modeling.memory.manager.DataManagerBuilder();
                        }

                        public withContentDeliveryDriver(p_driver: org.kevoree.modeling.cdn.KContentDeliveryDriver): org.kevoree.modeling.memory.manager.DataManagerBuilder {
                            this._driver = p_driver;
                            return this;
                        }

                        public withScheduler(p_scheduler: org.kevoree.modeling.scheduler.KScheduler): org.kevoree.modeling.memory.manager.DataManagerBuilder {
                            this._scheduler = p_scheduler;
                            return this;
                        }

                        public withMemoryStrategy(p_strategy: org.kevoree.modeling.memory.strategy.KMemoryStrategy): org.kevoree.modeling.memory.manager.DataManagerBuilder {
                            this._strategy = p_strategy;
                            return this;
                        }

                        public build(): org.kevoree.modeling.memory.manager.internal.KInternalDataManager {
                            return new org.kevoree.modeling.memory.manager.impl.DataManager(this.driver(), this.scheduler(), this.strategy());
                        }

                        public static buildDefault(): org.kevoree.modeling.memory.manager.internal.KInternalDataManager {
                            return org.kevoree.modeling.memory.manager.DataManagerBuilder.create().build();
                        }

                    }

                    export interface KDataManager {

                        lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<any>): void;

                        lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void;

                        lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<any>): void;

                        save(callback: org.kevoree.modeling.KCallback<any>): void;

                        getRoot(universe: number, time: number, callback: org.kevoree.modeling.KCallback<any>): void;

                        setRoot(newRoot: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void;

                        model(): org.kevoree.modeling.KModel<any>;

                        connect(callback: org.kevoree.modeling.KCallback<any>): void;

                        close(callback: org.kevoree.modeling.KCallback<any>): void;

                    }

                    export module impl {
                        export class DataManager implements org.kevoree.modeling.memory.manager.KDataManager, org.kevoree.modeling.memory.manager.internal.KInternalDataManager {

                            private static UNIVERSE_NOT_CONNECTED_ERROR: string = "Please connect your createModel prior to create a universe or an object";
                            private _operationManager: org.kevoree.modeling.operation.KOperationManager;
                            private _db: org.kevoree.modeling.cdn.KContentDeliveryDriver;
                            private _scheduler: org.kevoree.modeling.scheduler.KScheduler;
                            private _listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager;
                            private _modelKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator;
                            private _resolver: org.kevoree.modeling.memory.resolver.KResolver;
                            private _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            private _spaceManager: org.kevoree.modeling.memory.space.KChunkSpaceManager;
                            private _objectKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator = null;
                            private _universeKeyCalculator: org.kevoree.modeling.memory.manager.impl.KeyCalculator = null;
                            private isConnected: boolean = false;
                            private prefix: number;
                            private _model: org.kevoree.modeling.KModel<any>;
                            private static UNIVERSE_INDEX: number = 0;
                            private static OBJ_INDEX: number = 1;
                            private static GLO_TREE_INDEX: number = 2;
                            private static zeroPrefix: number = 0;
                            private currentCdnListener: number = -1;
                            private static PREFIX_TO_SAVE_SIZE: number = 2;
                            private static KEY_SIZE: number = 3;
                            public setModel(p_model: org.kevoree.modeling.KModel<any>): void {
                                this._model = p_model;
                            }

                            constructor(p_cdn: org.kevoree.modeling.cdn.KContentDeliveryDriver, p_scheduler: org.kevoree.modeling.scheduler.KScheduler, p_factory: org.kevoree.modeling.memory.strategy.KMemoryStrategy) {
                                this._space = p_factory.newSpace();
                                this._spaceManager = p_factory.newSpaceManager(this._space);
                                this._resolver = new org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver(this._spaceManager, this);
                                this._listenerManager = new org.kevoree.modeling.memory.manager.impl.ListenerManager();
                                this._modelKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(DataManager.zeroPrefix, 0);
                                this._db = p_cdn;
                                this._scheduler = p_scheduler;
                                this.attachContentDeliveryDriver(new org.kevoree.modeling.cdn.impl.MemoryContentDeliveryDriver());
                                this._operationManager = new org.kevoree.modeling.operation.impl.HashOperationManager(this);
                            }

                            public model(): org.kevoree.modeling.KModel<any> {
                                return this._model;
                            }

                            public close(callback: org.kevoree.modeling.KCallback<any>): void {
                                this.isConnected = false;
                                if (this._db != null) {
                                    this._db.close(callback);
                                } else {
                                    callback(null);
                                }
                            }

                            public nextUniverseKey(): number {
                                if (this._universeKeyCalculator == null) {
                                    throw new Error(DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                                }
                                return this._universeKeyCalculator.nextKey();
                            }

                            public nextObjectKey(): number {
                                if (this._objectKeyCalculator == null) {
                                    throw new Error(DataManager.UNIVERSE_NOT_CONNECTED_ERROR);
                                }
                                return this._objectKeyCalculator.nextKey();
                            }

                            public nextModelKey(): number {
                                return this._modelKeyCalculator.nextKey();
                            }

                            public initUniverse(p_universe: number, p_parent: number): void {
                                var cached: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._space.get(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                                if (cached != null && !cached.contains(p_universe)) {
                                    cached.put(p_universe, p_parent);
                                }
                            }

                            public save(callback: org.kevoree.modeling.KCallback<any>): void {
                                var dirtyIterator: org.kevoree.modeling.memory.space.KChunkIterator = this._space.detachDirties();
                                if (dirtyIterator.size() == 0) {
                                    callback(null);
                                    return;
                                }
                                var toSaveKeys: Float64Array = new Float64Array((dirtyIterator.size() + DataManager.PREFIX_TO_SAVE_SIZE) * DataManager.KEY_SIZE);
                                var toSaveValues: string[] = new Array();
                                var i: number = 0;
                                var _mm: org.kevoree.modeling.meta.KMetaModel = this._model.metaModel();
                                while (dirtyIterator.hasNext()){
                                    var loopChunkKeys: Float64Array = dirtyIterator.next();
                                    var loopChunk: org.kevoree.modeling.memory.KChunk = this._spaceManager.getAndMark(loopChunkKeys[0], loopChunkKeys[1], loopChunkKeys[2]);
                                    if (loopChunk != null) {
                                        loopChunk.setFlags(0, org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT);
                                        toSaveKeys[i * DataManager.KEY_SIZE] = loopChunk.universe();
                                        toSaveKeys[i * DataManager.KEY_SIZE + 1] = loopChunk.time();
                                        toSaveKeys[i * DataManager.KEY_SIZE + 2] = loopChunk.obj();
                                        try {
                                            toSaveValues[i] = loopChunk.serialize(_mm);
                                            i++;
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                        this._spaceManager.unmarkMemoryElement(loopChunk);
                                    }
                                }
                                toSaveKeys[i * DataManager.KEY_SIZE] = org.kevoree.modeling.KConfig.BEGINNING_OF_TIME;
                                toSaveKeys[i * DataManager.KEY_SIZE + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                toSaveKeys[i * DataManager.KEY_SIZE + 2] = this._objectKeyCalculator.prefix();
                                toSaveValues[i] = "" + this._objectKeyCalculator.lastComputedIndex();
                                i++;
                                toSaveKeys[i * DataManager.KEY_SIZE] = org.kevoree.modeling.KConfig.END_OF_TIME;
                                toSaveKeys[i * DataManager.KEY_SIZE + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                toSaveKeys[i * DataManager.KEY_SIZE + 2] = this._universeKeyCalculator.prefix();
                                toSaveValues[i] = "" + this._universeKeyCalculator.lastComputedIndex();
                                this._db.put(toSaveKeys, toSaveValues, callback, this.currentCdnListener);
                            }

                            public initKObject(obj: org.kevoree.modeling.KObject): void {
                                this._resolver.indexObject(obj);
                            }

                            public preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                var resolvedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._resolver.preciseChunk(universe, time, uuid, metaClass, previousResolution);
                                if (resolvedChunk != null) {
                                    return resolvedChunk;
                                } else {
                                    throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                                }
                            }

                            public closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                var resolvedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._resolver.closestChunk(universe, time, uuid, metaClass, previousResolution);
                                if (resolvedChunk != null) {
                                    return resolvedChunk;
                                } else {
                                    throw new Error("Cache Miss, not implemented Yet " + universe + "," + time + "," + uuid);
                                }
                            }

                            public connect(connectCallback: org.kevoree.modeling.KCallback<any>): void {
                                if (this.isConnected) {
                                    if (connectCallback != null) {
                                        connectCallback(null);
                                    }
                                }
                                if (this._db == null) {
                                    if (connectCallback != null) {
                                        connectCallback(new Error("Please attach a KDataBase AND a KBroker first !"));
                                    }
                                } else {
                                    this._db.connect( (throwable : Error) => {
                                        if (throwable == null) {
                                            this._db.atomicGetIncrement(new Float64Array([org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]),  (newPrefix : number) => {
                                                this.prefix = newPrefix;
                                                var connectionKeys: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.BEGINNING_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, newPrefix, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.KConfig.NULL_LONG, newPrefix, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]);
                                                this._db.get(connectionKeys,  (strings : string[]) => {
                                                    if (strings.length == 3) {
                                                        var detected: Error = null;
                                                        try {
                                                            var uniIndexPayload: string = strings[DataManager.UNIVERSE_INDEX];
                                                            if (uniIndexPayload == null || org.kevoree.modeling.util.PrimitiveHelper.equals(uniIndexPayload, "")) {
                                                                uniIndexPayload = "0";
                                                            }
                                                            var objIndexPayload: string = strings[DataManager.OBJ_INDEX];
                                                            if (objIndexPayload == null || org.kevoree.modeling.util.PrimitiveHelper.equals(objIndexPayload, "")) {
                                                                objIndexPayload = "0";
                                                            }
                                                            var globalUniverseTreePayload: string = strings[DataManager.GLO_TREE_INDEX];
                                                            var globalUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.createAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP);
                                                            if (globalUniverseTreePayload != null) {
                                                                try {
                                                                    globalUniverseTree.init(globalUniverseTreePayload, this.model().metaModel(), -1);
                                                                } catch ($ex$) {
                                                                    if ($ex$ instanceof Error) {
                                                                        var e: Error = <Error>$ex$;
                                                                        console.error(e['stack']);;
                                                                    } else {
                                                                        throw $ex$;
                                                                    }
                                                                }
                                                            }
                                                            var newUniIndex: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(uniIndexPayload);
                                                            var newObjIndex: number = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objIndexPayload);
                                                            this._universeKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(this.prefix, newUniIndex);
                                                            this._objectKeyCalculator = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(this.prefix, newObjIndex);
                                                            this.isConnected = true;
                                                        } catch ($ex$) {
                                                            if ($ex$ instanceof Error) {
                                                                var e: Error = <Error>$ex$;
                                                                detected = e;
                                                            } else {
                                                                throw $ex$;
                                                            }
                                                        }
                                                        if (connectCallback != null) {
                                                            connectCallback(detected);
                                                        }
                                                    } else {
                                                        if (connectCallback != null) {
                                                            connectCallback(new Error("Error while connecting the KDataStore..."));
                                                        }
                                                    }
                                                });
                                            });
                                        } else {
                                            if (connectCallback != null) {
                                                connectCallback(throwable);
                                            }
                                        }
                                    });
                                }
                            }

                            public delete(p_universe: org.kevoree.modeling.KUniverse<any, any>, callback: org.kevoree.modeling.KCallback<any>): void {
                                throw new Error("Not implemented yet !");
                            }

                            public lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._scheduler.dispatch(this._resolver.lookup(universe, time, uuid, callback));
                            }

                            public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._scheduler.dispatch(this._resolver.lookupAllObjects(universe, time, uuids, callback));
                            }

                            public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._scheduler.dispatch(this._resolver.lookupAllTimes(universe, times, uuid, callback));
                            }

                            public getRoot(universe: number, time: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._resolver.getRoot(universe, time, callback);
                            }

                            public setRoot(newRoot: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._resolver.setRoot(newRoot, callback);
                            }

                            public cdn(): org.kevoree.modeling.cdn.KContentDeliveryDriver {
                                return this._db;
                            }

                            private attachContentDeliveryDriver(p_dataBase: org.kevoree.modeling.cdn.KContentDeliveryDriver): void {
                                this.currentCdnListener = this._db.addUpdateListener( (updatedKeys : Float64Array) => {
                                    var toLoadKeys: Float64Array = new Float64Array(updatedKeys.length);
                                    var toInsertNotifyKey: number = 0;
                                    var toNotifyKeys: Float64Array = new Float64Array(updatedKeys.length);
                                    var nbElements: number = updatedKeys.length / DataManager.KEY_SIZE;
                                    var toInsertKey: number = 0;
                                    for (var i: number = 0; i < nbElements; i++) {
                                        var currentChunk: org.kevoree.modeling.memory.KChunk = this._spaceManager.getAndMark(updatedKeys[i * 3], updatedKeys[i * 3 + 1], updatedKeys[i * 3 + 2]);
                                        if (currentChunk != null) {
                                            if ((currentChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                                toLoadKeys[toInsertKey * DataManager.KEY_SIZE] = updatedKeys[i * DataManager.KEY_SIZE];
                                                toLoadKeys[toInsertKey * DataManager.KEY_SIZE + 1] = updatedKeys[i * DataManager.KEY_SIZE + 1];
                                                toLoadKeys[toInsertKey * DataManager.KEY_SIZE + 2] = updatedKeys[i * DataManager.KEY_SIZE + 2];
                                                toInsertKey++;
                                            }
                                            this._spaceManager.unmarkMemoryElement(currentChunk);
                                        }
                                        if (this._listenerManager.isListened(updatedKeys[i * DataManager.KEY_SIZE + 2]) && updatedKeys[i * DataManager.KEY_SIZE] != org.kevoree.modeling.KConfig.NULL_LONG && updatedKeys[i * DataManager.KEY_SIZE + 1] != org.kevoree.modeling.KConfig.NULL_LONG && updatedKeys[i * DataManager.KEY_SIZE + 2] != org.kevoree.modeling.KConfig.NULL_LONG) {
                                            toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE] = updatedKeys[i * DataManager.KEY_SIZE];
                                            toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE + 1] = updatedKeys[i * DataManager.KEY_SIZE + 1];
                                            toNotifyKeys[toInsertNotifyKey * DataManager.KEY_SIZE + 2] = updatedKeys[i * DataManager.KEY_SIZE + 2];
                                            toInsertNotifyKey++;
                                        }
                                    }
                                    if (toInsertKey == 0 && toInsertNotifyKey == 0) {
                                        return;
                                    }
                                    var trimmedToLoad: Float64Array = new Float64Array(toInsertKey * 3);
                                    java.lang.System.arraycopy(toLoadKeys, 0, trimmedToLoad, 0, toInsertKey * 3);
                                    var trimmedToNotify: Float64Array = new Float64Array(toInsertNotifyKey * 3);
                                    java.lang.System.arraycopy(toNotifyKeys, 0, trimmedToNotify, 0, toInsertNotifyKey * 3);
                                    var mm: org.kevoree.modeling.meta.KMetaModel = this._model.metaModel();
                                    this._db.get(trimmedToLoad,  (payloads : string[]) => {
                                        for (var i: number = 0; i < payloads.length; i++) {
                                            if (payloads[i] != null) {
                                                var currentChunk: org.kevoree.modeling.memory.KChunk = this._spaceManager.getAndMark(trimmedToLoad[i * 3], trimmedToLoad[i * 3 + 1], trimmedToLoad[i * 3 + 2]);
                                                if (currentChunk != null) {
                                                    currentChunk.init(payloads[i], mm, -1);
                                                    this._spaceManager.unmarkMemoryElement(currentChunk);
                                                }
                                            }
                                        }
                                        this._resolver.lookupPreciseKeys(trimmedToNotify,  (updatedObjects : org.kevoree.modeling.KObject[]) => {
                                            this._listenerManager.dispatch(updatedObjects);
                                        }).run();
                                    });
                                });
                            }

                            public operationManager(): org.kevoree.modeling.operation.KOperationManager {
                                return this._operationManager;
                            }

                            public createListener(p_universe: number): org.kevoree.modeling.KListener {
                                return this._listenerManager.createListener(p_universe);
                            }

                            public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._resolver.resolveTimes(currentUniverse, currentUuid, startTime, endTime, callback);
                            }

                            public spaceSize(): number {
                                return this._space.size();
                            }

                            public printDebug(): void {
                                this._space.printDebug(this._model.metaModel());
                            }

                        }

                        export class HeapListener implements org.kevoree.modeling.KListener {

                            private _universe: number;
                            private _listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager;
                            private _id: number;
                            public cb: org.kevoree.modeling.KCallback<any>;
                            public listenerID(): number {
                                return this._id;
                            }

                            constructor(p_universe: number, p_listenerManager: org.kevoree.modeling.memory.manager.impl.ListenerManager, p_id: number) {
                                this._universe = p_universe;
                                this._listenerManager = p_listenerManager;
                                this._id = p_id;
                            }

                            public universe(): number {
                                return 0;
                            }

                            public listenObjects(): Float64Array {
                                return this._listenerManager._listener2Objects.get(this._id);
                            }

                            public listen(obj: org.kevoree.modeling.KObject): void {
                                this._listenerManager.manageRegistration(this._id, obj);
                            }

                            public delete(): void {
                                this._listenerManager.manageRegistration(this._id, null);
                            }

                            public then(p_cb: org.kevoree.modeling.KCallback<any>): void {
                                this.cb = p_cb;
                            }

                        }

                        export class KeyCalculator {

                             private _prefix: string;
                             private _currentIndex: number;
                            constructor(prefix: number, currentIndex: number) {
                                 this._prefix = "0x" + prefix.toString(org.kevoree.modeling.KConfig.PREFIX_SIZE);
                                 this._currentIndex = currentIndex;
                            }

                            public nextKey(): number {
                                 if (this._currentIndex == org.kevoree.modeling.KConfig.KEY_PREFIX_MASK) {
                                 throw new Error("Object Index could not be created because it exceeded the capacity of the current prefix. Ask for a new prefix.");
                                 }
                                 this._currentIndex++;
                                 var indexHex = this._currentIndex.toString(org.kevoree.modeling.KConfig.PREFIX_SIZE);
                                 var objectKey = parseInt(this._prefix + "000000000".substring(0,9-indexHex.length) + indexHex, org.kevoree.modeling.KConfig.PREFIX_SIZE);
                                 if (objectKey >= org.kevoree.modeling.KConfig.NULL_LONG) {
                                 throw new Error("Object Index exceeds teh maximum JavaScript number capacity. (2^"+org.kevoree.modeling.KConfig.LONG_SIZE+")");
                                 }
                                 return objectKey;
                            }

                            public lastComputedIndex(): number {
                                 return this._currentIndex;
                            }

                            public prefix(): number {
                                 return parseInt(this._prefix,org.kevoree.modeling.KConfig.PREFIX_SIZE);
                            }

                        }

                        export class ListenerManager {

                            private _keyGen: org.kevoree.modeling.memory.manager.impl.KeyCalculator;
                            public _listeners: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>;
                            public _listener2Objects: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>;
                            public _obj2Listener: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>;
                            constructor() {
                                this._keyGen = new org.kevoree.modeling.memory.manager.impl.KeyCalculator(<number>0, 0);
                                this._listeners = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                this._obj2Listener = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                this._listener2Objects = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            }

                            public clear(): void {
                                this._listeners.clear();
                                this._obj2Listener.clear();
                                this._listener2Objects.clear();
                            }

                            public createListener(p_universe: number): org.kevoree.modeling.KListener {
                                var newListener: org.kevoree.modeling.memory.manager.impl.HeapListener = new org.kevoree.modeling.memory.manager.impl.HeapListener(p_universe, this, this._keyGen.nextKey());
                                this._listeners.put(newListener.listenerID(), newListener);
                                return newListener;
                            }

                            public manageRegistration(listenerID: number, origin: org.kevoree.modeling.KObject): void {
                                if (origin != null) {
                                    if (!this._listener2Objects.contains(listenerID)) {
                                        var newRec: Float64Array = new Float64Array(1);
                                        newRec[0] = origin.uuid();
                                        this._listener2Objects.put(listenerID, newRec);
                                    } else {
                                        var previous: Float64Array = this._listener2Objects.get(listenerID);
                                        var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                                        java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                                        newArrayRec[previous.length] = origin.uuid();
                                        this._listener2Objects.put(listenerID, newArrayRec);
                                    }
                                    if (!this._obj2Listener.contains(origin.uuid())) {
                                        var newRec: Float64Array = new Float64Array(1);
                                        newRec[0] = listenerID;
                                        this._obj2Listener.put(origin.uuid(), newRec);
                                    } else {
                                        var previous: Float64Array = this._obj2Listener.get(origin.uuid());
                                        var newArrayRec: Float64Array = new Float64Array(previous.length + 1);
                                        java.lang.System.arraycopy(previous, 0, newArrayRec, 0, previous.length);
                                        newArrayRec[previous.length] = listenerID;
                                        this._obj2Listener.put(origin.uuid(), newArrayRec);
                                    }
                                } else {
                                    var objs: Float64Array = this._listener2Objects.get(listenerID);
                                    if (objs != null) {
                                        this._listener2Objects.remove(listenerID);
                                        for (var i: number = 0; i < objs.length; i++) {
                                            var registeredListener: Float64Array = this._obj2Listener.get(objs[i]);
                                            var foundIndex: number = -1;
                                            for (var j: number = 0; j < registeredListener.length; j++) {
                                                if (registeredListener[j] == listenerID) {
                                                    foundIndex = j;
                                                }
                                            }
                                            if (foundIndex != -1) {
                                                if (foundIndex == 0) {
                                                    var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                                                    java.lang.System.arraycopy(objs, foundIndex, registeredListener2, 0, registeredListener.length - 1);
                                                    this._obj2Listener.put(objs[i], registeredListener2);
                                                } else {
                                                    var registeredListener2: Float64Array = new Float64Array(registeredListener.length - 1);
                                                    java.lang.System.arraycopy(objs, 0, registeredListener2, 0, foundIndex - 1);
                                                    java.lang.System.arraycopy(objs, foundIndex + 1, registeredListener2, foundIndex, registeredListener.length - foundIndex - 1);
                                                    this._obj2Listener.put(objs[i], registeredListener2);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                            public isListened(obj: number): boolean {
                                var notifier: Float64Array = this._obj2Listener.get(obj);
                                if (notifier != null && notifier.length > 0) {
                                    return true;
                                }
                                return false;
                            }

                            public dispatch(objects: org.kevoree.modeling.KObject[]): void {
                                for (var i: number = 0; i < objects.length; i++) {
                                    if (objects[i] != null) {
                                        var notifier: Float64Array = this._obj2Listener.get(objects[i].uuid());
                                        if (notifier != null && notifier.length > 0) {
                                            for (var j: number = 0; j < notifier.length; j++) {
                                                var ll: org.kevoree.modeling.memory.manager.impl.HeapListener = this._listeners.get(notifier[j]);
                                                var cb: org.kevoree.modeling.KCallback<any> = ll.cb;
                                                if (cb != null) {
                                                    cb(objects[i]);
                                                }
                                            }
                                        }
                                    }
                                }
                            }

                        }

                    }
                    export module internal {
                        export interface KInternalDataManager extends org.kevoree.modeling.memory.manager.KDataManager {

                            createListener(universe: number): org.kevoree.modeling.KListener;

                            cdn(): org.kevoree.modeling.cdn.KContentDeliveryDriver;

                            preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;

                            closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;

                            initKObject(obj: org.kevoree.modeling.KObject): void;

                            initUniverse(universe: number, parent: number): void;

                            nextUniverseKey(): number;

                            nextObjectKey(): number;

                            nextModelKey(): number;

                            delete(universe: org.kevoree.modeling.KUniverse<any, any>, callback: org.kevoree.modeling.KCallback<any>): void;

                            operationManager(): org.kevoree.modeling.operation.KOperationManager;

                            setModel(model: org.kevoree.modeling.KModel<any>): void;

                            resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<any>): void;

                            spaceSize(): number;

                            printDebug(): void;

                        }

                    }
                }
                export module resolver {
                    export interface KResolver {

                        lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable;

                        lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable;

                        lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable;

                        lookupPreciseKeys(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable;

                        preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;

                        closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk;

                        indexObject(obj: org.kevoree.modeling.KObject): void;

                        typeFromKey(universe: number, time: number, uuid: number): number;

                        resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<any>): void;

                        getRoot(universe: number, time: number, callback: org.kevoree.modeling.KCallback<any>): void;

                        setRoot(newRoot: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void;

                        getRelatedKeys(uuid: number, previousResolution: Float64Array): Float64Array;

                    }

                    export module impl {
                        export class DistortedTimeResolver implements org.kevoree.modeling.memory.resolver.KResolver {

                            private static KEYS_SIZE: number = 3;
                            private _spaceManager: org.kevoree.modeling.memory.space.KChunkSpaceManager;
                            private _manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager;
                            constructor(p_cache: org.kevoree.modeling.memory.space.KChunkSpaceManager, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                                this._spaceManager = p_cache;
                                this._manager = p_manager;
                                this._spaceManager.setResolver(this);
                            }

                            public lookup(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable {
                                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                                return {run:function(){
                                    selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        if (theGlobalUniverseOrderElement != null) {
                                            selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid,  (theObjectUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                                if (theObjectUniverseOrderElement == null) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(null);
                                                } else {
                                                    var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>theObjectUniverseOrderElement, time, universe);
                                                    selfPointer.getOrLoadAndMark(closestUniverse, org.kevoree.modeling.KConfig.NULL_LONG, uuid,  (theObjectTimeTreeElement : org.kevoree.modeling.memory.KChunk) => {
                                                        if (theObjectTimeTreeElement == null) {
                                                            selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                            callback(null);
                                                        } else {
                                                            var closestTime: number = (<org.kevoree.modeling.memory.chunk.KLongTree>theObjectTimeTreeElement).previousOrEqual(time);
                                                            if (closestTime == org.kevoree.modeling.KConfig.NULL_LONG) {
                                                                selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                                                selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                                selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                                callback(null);
                                                                return;
                                                            }
                                                            selfPointer.getOrLoadAndMark(closestUniverse, closestTime, uuid,  (theObjectChunk : org.kevoree.modeling.memory.KChunk) => {
                                                                if (theObjectChunk == null) {
                                                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectTimeTreeElement);
                                                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                                    callback(null);
                                                                } else {
                                                                    var newProxy: org.kevoree.modeling.KObject = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuid, selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunk).metaClassIndex()), closestUniverse, closestTime);
                                                                    selfPointer._spaceManager.register(newProxy);
                                                                    callback(newProxy);
                                                                }
                                                            });
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
}                                };
                            }

                            public lookupAllObjects(universe: number, time: number, uuids: Float64Array, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable {
                                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                                return {run:function(){
                                    selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        if (theGlobalUniverseOrderElement != null) {
                                            var tempObjectUniverseKeys: Float64Array = new Float64Array(uuids.length * 3);
                                            for (var i: number = 0; i < uuids.length; i++) {
                                                tempObjectUniverseKeys[i * 3] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                tempObjectUniverseKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                tempObjectUniverseKeys[i * 3 + 2] = uuids[i];
                                            }
                                            selfPointer.getOrLoadAndMarkAll(tempObjectUniverseKeys,  (objectUniverseOrderElements : org.kevoree.modeling.memory.KChunk[]) => {
                                                if (objectUniverseOrderElements == null || objectUniverseOrderElements.length == 0) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(new Array());
                                                    return;
                                                }
                                                var tempObjectTimeTreeKeys: Float64Array = new Float64Array(uuids.length * 3);
                                                for (var i: number = 0; i < uuids.length; i++) {
                                                    var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>objectUniverseOrderElements[i], time, universe);
                                                    tempObjectTimeTreeKeys[i * 3] = closestUniverse;
                                                    tempObjectTimeTreeKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                    tempObjectTimeTreeKeys[i * 3 + 2] = uuids[i];
                                                }
                                                selfPointer.getOrLoadAndMarkAll(tempObjectTimeTreeKeys,  (objectTimeTreeElements : org.kevoree.modeling.memory.KChunk[]) => {
                                                    if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                                        selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                        selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                        callback(new Array());
                                                        return;
                                                    }
                                                    var tempObjectChunkKeys: Float64Array = new Float64Array(uuids.length * 3);
                                                    for (var i: number = 0; i < uuids.length; i++) {
                                                        var closestTime: number = (<org.kevoree.modeling.memory.chunk.KLongTree>objectTimeTreeElements[i]).previousOrEqual(time);
                                                        if (closestTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                                            tempObjectChunkKeys[i * 3] = tempObjectTimeTreeKeys[i * 3];
                                                            tempObjectChunkKeys[i * 3 + 1] = closestTime;
                                                            tempObjectChunkKeys[i * 3 + 2] = uuids[i];
                                                        } else {
                                                            java.lang.System.arraycopy(org.kevoree.modeling.KContentKey.NULL_KEY, 0, tempObjectChunkKeys, (i * 3), 3);
                                                        }
                                                    }
                                                    selfPointer.getOrLoadAndMarkAll(tempObjectChunkKeys,  (theObjectChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                                        if (theObjectChunks == null || theObjectChunks.length == 0) {
                                                            selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                                            selfPointer._spaceManager.unmarkAllMemoryElements(objectUniverseOrderElements);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                            callback(new Array());
                                                        } else {
                                                            var finalResult: org.kevoree.modeling.KObject[] = new Array();
                                                            for (var h: number = 0; h < theObjectChunks.length; h++) {
                                                                if (theObjectChunks[h] != null) {
                                                                    finalResult[h] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, time, uuids[h], selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>theObjectChunks[h]).metaClassIndex()), tempObjectTimeTreeKeys[h * 3], tempObjectChunkKeys[h * 3 + 1]);
                                                                } else {
                                                                    finalResult[h] = null;
                                                                }
                                                            }
                                                            selfPointer._spaceManager.registerAll(finalResult);
                                                            callback(finalResult);
                                                        }
                                                    });
                                                });
                                            });
                                        }
                                    });
}                                };
                            }

                            public lookupPreciseKeys(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable {
                                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                                return {run:function(){
                                    selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        if (theGlobalUniverseOrderElement != null) {
                                            var allOrderedKeys: Float64Array = new Float64Array(keys.length * 3);
                                            var insertIndex: number = 0;
                                            var nbKeys: number = keys.length / 3;
                                            for (var i: number = 0; i < nbKeys; i++) {
                                                allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3];
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3];
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3 + 1];
                                                insertIndex++;
                                                allOrderedKeys[insertIndex] = keys[i * 3 + 2];
                                                insertIndex++;
                                            }
                                            selfPointer.getOrLoadAndMarkAll(allOrderedKeys,  (kChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                                if (kChunks == null || kChunks.length == 0) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(new Array());
                                                    return;
                                                } else {
                                                    var finalResult: org.kevoree.modeling.KObject[] = new Array();
                                                    var insertIndex: number = 0;
                                                    var previousClassIndex: number = -1;
                                                    for (var h: number = 0; h < kChunks.length; h++) {
                                                        if (kChunks[h] != null && kChunks[h].type() == org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK) {
                                                            finalResult[insertIndex] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(kChunks[h].universe(), kChunks[h].time(), kChunks[h].obj(), selfPointer._manager.model().metaModel().metaClass(previousClassIndex), kChunks[h].universe(), kChunks[h].time());
                                                            insertIndex++;
                                                        } else {
                                                            if (kChunks[h] != null && kChunks[h].type() == org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP) {
                                                                var casted: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>kChunks[h];
                                                                previousClassIndex = casted.metaClassIndex();
                                                            }
                                                        }
                                                    }
                                                    selfPointer._spaceManager.registerAll(finalResult);
                                                    callback(finalResult);
                                                }
                                            });
                                        }
                                    });
}                                };
                            }

                            public lookupAllTimes(universe: number, times: Float64Array, uuid: number, callback: org.kevoree.modeling.KCallback<any>): java.lang.Runnable {
                                var selfPointer: org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver = this;
                                return {run:function(){
                                    selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        if (theGlobalUniverseOrderElement != null) {
                                            selfPointer.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid,  (theObjectUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                                if (theObjectUniverseOrderElement == null) {
                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                    callback(null);
                                                } else {
                                                    var closestUniverses: Float64Array = new Float64Array(times.length);
                                                    var closestUnikUniverse: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                                    var nbUniverseToload: number = 0;
                                                    for (var i: number = 0; i < times.length; i++) {
                                                        closestUniverses[i] = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>theObjectUniverseOrderElement, times[i], universe);
                                                        if (!closestUnikUniverse.contains(closestUniverses[i])) {
                                                            closestUnikUniverse.put(closestUniverses[i], nbUniverseToload);
                                                            nbUniverseToload++;
                                                        }
                                                    }
                                                    var toLoadUniverseKeys: Float64Array = new Float64Array(nbUniverseToload * 3);
                                                    closestUnikUniverse.each( (key : number, value : number) => {
                                                        var currentIndex: number = <number>(value * 3);
                                                        toLoadUniverseKeys[currentIndex] = value;
                                                        toLoadUniverseKeys[currentIndex + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                                        toLoadUniverseKeys[currentIndex + 2] = uuid;
                                                    });
                                                    selfPointer.getOrLoadAndMarkAll(toLoadUniverseKeys,  (objectTimeTreeElements : org.kevoree.modeling.memory.KChunk[]) => {
                                                        if (objectTimeTreeElements == null || objectTimeTreeElements.length == 0) {
                                                            selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                            selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                            callback(null);
                                                        } else {
                                                            var closestTimes: Float64Array = new Float64Array(times.length);
                                                            var closestUnikTimes: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                                            var reverseTimeUniverse: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                                            var nbTimesToload: number = 0;
                                                            for (var i: number = 0; i < times.length; i++) {
                                                                var alignedIndexOfUniverse: number = <number>closestUnikUniverse.get(closestUniverses[i]);
                                                                closestTimes[i] = (<org.kevoree.modeling.memory.chunk.KLongTree>objectTimeTreeElements[alignedIndexOfUniverse]).previousOrEqual(times[i]);
                                                                if (!closestUnikTimes.contains(closestTimes[i])) {
                                                                    closestUnikTimes.put(closestTimes[i], nbTimesToload);
                                                                    reverseTimeUniverse.put(closestTimes[i], closestUniverses[i]);
                                                                    nbTimesToload++;
                                                                }
                                                            }
                                                            var toLoadTimesKeys: Float64Array = new Float64Array(nbTimesToload * 3);
                                                            closestUnikTimes.each( (key : number, value : number) => {
                                                                var currentIndex: number = <number>(value * 3);
                                                                toLoadTimesKeys[currentIndex] = reverseTimeUniverse.get(key);
                                                                toLoadTimesKeys[currentIndex + 1] = key;
                                                                toLoadTimesKeys[currentIndex + 2] = uuid;
                                                            });
                                                            selfPointer.getOrLoadAndMarkAll(toLoadTimesKeys,  (objectChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                                                if (objectChunks == null || objectChunks.length == 0) {
                                                                    selfPointer._spaceManager.unmarkAllMemoryElements(objectTimeTreeElements);
                                                                    selfPointer._spaceManager.unmarkMemoryElement(theObjectUniverseOrderElement);
                                                                    selfPointer._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                                    callback(null);
                                                                } else {
                                                                    var result: org.kevoree.modeling.KObject[] = new Array();
                                                                    for (var i: number = 0; i < times.length; i++) {
                                                                        var resolvedUniverse: number = closestUniverses[i];
                                                                        var resolvedTime: number = closestTimes[i];
                                                                        var indexChunks: number = <number>closestUnikTimes.get(closestTimes[i]);
                                                                        if (indexChunks != -1 && resolvedUniverse != org.kevoree.modeling.KConfig.NULL_LONG && resolvedTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                                                            result[i] = (<org.kevoree.modeling.abs.AbstractKModel<any>>selfPointer._manager.model()).createProxy(universe, times[i], uuid, selfPointer._manager.model().metaModel().metaClass((<org.kevoree.modeling.memory.chunk.KObjectChunk>objectChunks[indexChunks]).metaClassIndex()), resolvedUniverse, resolvedTime);
                                                                        } else {
                                                                            result[i] = null;
                                                                        }
                                                                    }
                                                                    selfPointer._spaceManager.registerAll(result);
                                                                    callback(result);
                                                                }
                                                            });
                                                        }
                                                    });
                                                }
                                            });
                                        }
                                    });
}                                };
                            }

                            public preciseChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                return this.internal_chunk(universe, time, uuid, false, metaClass, previousResolution);
                            }

                            public closestChunk(universe: number, time: number, uuid: number, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                return this.internal_chunk(universe, time, uuid, true, metaClass, previousResolution);
                            }

                            private internal_chunk(universe: number, requestedTime: number, uuid: number, useClosest: boolean, metaClass: org.kevoree.modeling.meta.KMetaClass, previousResolution: java.util.concurrent.atomic.AtomicReference<Float64Array>): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                var time: number = requestedTime;
                                if (metaClass.temporalResolution() != 1) {
                                    time = time - (time % metaClass.temporalResolution());
                                }
                                var currentEntry: org.kevoree.modeling.memory.chunk.KObjectChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(universe, time, uuid);
                                if (currentEntry != null) {
                                    var previous: Float64Array;
                                    var current: Float64Array;
                                    var diff: boolean = false;
                                    do {
                                        previous = previousResolution.get();
                                        if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                                            current = new Float64Array([universe, time]);
                                            diff = true;
                                        } else {
                                            current = previous;
                                        }
                                    } while (!previousResolution.compareAndSet(previous, current))
                                    if (diff) {
                                        this._spaceManager.unmark(previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                                    } else {
                                        this._spaceManager.unmarkMemoryElement(currentEntry);
                                    }
                                    return currentEntry;
                                }
                                var objectUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid);
                                if (objectUniverseTree == null) {
                                    return null;
                                }
                                var globalUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG);
                                if (globalUniverseTree == null) {
                                    this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                    return null;
                                }
                                var resolvedUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(globalUniverseTree, objectUniverseTree, time, universe);
                                var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.getAndMark(resolvedUniverse, org.kevoree.modeling.KConfig.NULL_LONG, uuid);
                                if (timeTree == null) {
                                    this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                    this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                    return null;
                                }
                                var resolvedTime: number = timeTree.previousOrEqual(time);
                                if (resolvedTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                    var needTimeCopy: boolean = !useClosest && (resolvedTime != time);
                                    var needUniverseCopy: boolean = !useClosest && (resolvedUniverse != universe);
                                    currentEntry = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.getAndMark(resolvedUniverse, resolvedTime, uuid);
                                    if (currentEntry == null) {
                                        console.error("Desphasing marking not done yet !!!!");;
                                        this._spaceManager.unmarkMemoryElement(timeTree);
                                        this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                        this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                        return null;
                                    }
                                    if (!needTimeCopy && !needUniverseCopy) {
                                        var previous: Float64Array;
                                        var current: Float64Array;
                                        var diff: boolean = false;
                                        do {
                                            previous = previousResolution.get();
                                            if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != resolvedUniverse || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != resolvedTime) {
                                                current = new Float64Array([resolvedUniverse, resolvedTime]);
                                                diff = true;
                                            } else {
                                                current = previous;
                                            }
                                        } while (!previousResolution.compareAndSet(previous, current))
                                        if (diff) {
                                            this._spaceManager.unmark(previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid);
                                        } else {
                                            this._spaceManager.unmarkMemoryElement(currentEntry);
                                        }
                                        this._spaceManager.unmarkMemoryElement(timeTree);
                                        this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                        this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                        return currentEntry;
                                    } else {
                                        var previous: Float64Array;
                                        var current: Float64Array;
                                        var diff: boolean = false;
                                        do {
                                            previous = previousResolution.get();
                                            if (previous[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX] != universe || previous[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX] != time) {
                                                current = new Float64Array([universe, time]);
                                                diff = true;
                                            } else {
                                                current = previous;
                                            }
                                        } while (!previousResolution.compareAndSet(previous, current))
                                        if (diff) {
                                            var clonedChunk: org.kevoree.modeling.memory.chunk.KObjectChunk = this._spaceManager.cloneMarkAndUnmark(currentEntry, universe, time, uuid, this._manager.model().metaModel());
                                            if (!needUniverseCopy) {
                                                timeTree.insert(time);
                                            } else {
                                                var newTemporalTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.createAndMark(universe, org.kevoree.modeling.KConfig.NULL_LONG, uuid, org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE);
                                                newTemporalTree.insert(time);
                                                this._spaceManager.unmarkMemoryElement(timeTree);
                                                objectUniverseTree.put(universe, time);
                                            }
                                            this._spaceManager.unmarkMemoryElement(currentEntry);
                                            this._spaceManager.unmarkMemoryElement(timeTree);
                                            this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                            this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                            return clonedChunk;
                                        } else {
                                            console.error("Desphasing marking not done yet !!!!");;
                                            this._spaceManager.unmarkMemoryElement(currentEntry);
                                            this._spaceManager.unmarkMemoryElement(timeTree);
                                            this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                            this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                            return null;
                                        }
                                    }
                                } else {
                                    this._spaceManager.unmarkMemoryElement(timeTree);
                                    this._spaceManager.unmarkMemoryElement(globalUniverseTree);
                                    this._spaceManager.unmarkMemoryElement(objectUniverseTree);
                                    return null;
                                }
                            }

                            public indexObject(obj: org.kevoree.modeling.KObject): void {
                                var metaClassIndex: number = obj.metaClass().index();
                                var cacheEntry: org.kevoree.modeling.memory.chunk.KObjectChunk = <org.kevoree.modeling.memory.chunk.KObjectChunk>this._spaceManager.createAndMark(obj.universe(), obj.now(), obj.uuid(), org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK);
                                cacheEntry.init(null, this._manager.model().metaModel(), metaClassIndex);
                                cacheEntry.setFlags(org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT, 0);
                                cacheEntry.space().declareDirty(cacheEntry);
                                var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>this._spaceManager.createAndMark(obj.universe(), org.kevoree.modeling.KConfig.NULL_LONG, obj.uuid(), org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE);
                                timeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                                timeTree.insert(obj.now());
                                var universeTree: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.createAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, obj.uuid(), org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP);
                                universeTree.init(null, this._manager.model().metaModel(), metaClassIndex);
                                universeTree.put(obj.universe(), obj.now());
                                this._spaceManager.register(obj);
                            }

                            public typeFromKey(universe: number, time: number, uuid: number): number {
                                var isUniverseNotNull: boolean = universe != org.kevoree.modeling.KConfig.NULL_LONG;
                                var result: number;
                                if (org.kevoree.modeling.KConfig.END_OF_TIME == uuid) {
                                    if (isUniverseNotNull) {
                                        result = org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_TREE;
                                    } else {
                                        result = org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
                                    }
                                } else {
                                    var isTimeNotNull: boolean = time != org.kevoree.modeling.KConfig.NULL_LONG;
                                    var isObjNotNull: boolean = uuid != org.kevoree.modeling.KConfig.NULL_LONG;
                                    if (isUniverseNotNull && isTimeNotNull && isObjNotNull) {
                                        result = org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK;
                                    } else {
                                        if (isUniverseNotNull && !isTimeNotNull && isObjNotNull) {
                                            result = org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE;
                                        } else {
                                            result = org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP;
                                        }
                                    }
                                }
                                return result;
                            }

                            public getOrLoadAndMark(universe: number, time: number, uuid: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                if (universe == org.kevoree.modeling.KContentKey.NULL_KEY[0] && time == org.kevoree.modeling.KContentKey.NULL_KEY[1] && uuid == org.kevoree.modeling.KContentKey.NULL_KEY[2]) {
                                    callback(null);
                                    return;
                                }
                                var cached: org.kevoree.modeling.memory.KChunk = this._spaceManager.getAndMark(universe, time, uuid);
                                if (cached != null) {
                                    callback(cached);
                                } else {
                                    this.load(new Float64Array([universe, time, uuid]),  (loadedElements : org.kevoree.modeling.memory.KChunk[]) => {
                                        callback(loadedElements[0]);
                                    });
                                }
                            }

                            public getOrLoadAndMarkAll(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void {
                                var nbKeys: number = keys.length / DistortedTimeResolver.KEYS_SIZE;
                                var toLoadIndexes: boolean[] = new Array();
                                var nbElem: number = 0;
                                var result: org.kevoree.modeling.memory.KChunk[] = new Array();
                                for (var i: number = 0; i < nbKeys; i++) {
                                    if (keys[i * DistortedTimeResolver.KEYS_SIZE] == org.kevoree.modeling.KContentKey.NULL_KEY[0] && keys[i * DistortedTimeResolver.KEYS_SIZE + 1] == org.kevoree.modeling.KContentKey.NULL_KEY[1] && keys[i * DistortedTimeResolver.KEYS_SIZE + 2] == org.kevoree.modeling.KContentKey.NULL_KEY[2]) {
                                        toLoadIndexes[i] = false;
                                        result[i] = null;
                                    } else {
                                        result[i] = this._spaceManager.getAndMark(keys[i * DistortedTimeResolver.KEYS_SIZE], keys[i * DistortedTimeResolver.KEYS_SIZE + 1], keys[i * DistortedTimeResolver.KEYS_SIZE + 2]);
                                        if (result[i] == null) {
                                            toLoadIndexes[i] = true;
                                            nbElem++;
                                        } else {
                                            toLoadIndexes[i] = false;
                                        }
                                    }
                                }
                                if (nbElem == 0) {
                                    callback(result);
                                } else {
                                    var keysToLoad: Float64Array = new Float64Array(nbElem * 3);
                                    var lastInsertedIndex: number = 0;
                                    for (var i: number = 0; i < nbKeys; i++) {
                                        if (toLoadIndexes[i]) {
                                            keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE];
                                            lastInsertedIndex++;
                                            keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE + 1];
                                            lastInsertedIndex++;
                                            keysToLoad[lastInsertedIndex] = keys[i * DistortedTimeResolver.KEYS_SIZE + 2];
                                            lastInsertedIndex++;
                                        }
                                    }
                                    this.load(keysToLoad,  (loadedElements : org.kevoree.modeling.memory.KChunk[]) => {
                                        var currentIndexToMerge: number = 0;
                                        for (var i: number = 0; i < nbKeys; i++) {
                                            if (toLoadIndexes[i]) {
                                                result[i] = loadedElements[currentIndexToMerge];
                                                currentIndexToMerge++;
                                            }
                                        }
                                        callback(result);
                                    });
                                }
                            }

                            public getRoot(universe: number, time: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                var rootFixedKey: number = org.kevoree.modeling.KConfig.END_OF_TIME;
                                this.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                    if (theGlobalUniverseOrderElement == null) {
                                        callback(null);
                                        return;
                                    }
                                    this.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, rootFixedKey,  (rootGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        if (rootGlobalUniverseOrderElement == null) {
                                            this._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            callback(null);
                                            return;
                                        }
                                        var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>rootGlobalUniverseOrderElement, time, universe);
                                        this.getOrLoadAndMark(closestUniverse, org.kevoree.modeling.KConfig.NULL_LONG, rootFixedKey,  (theRootTimeTree : org.kevoree.modeling.memory.KChunk) => {
                                            var resolvedCurrentRootUUID: number = (<org.kevoree.modeling.memory.chunk.KLongLongTree>theRootTimeTree).previousOrEqualValue(time);
                                            this._spaceManager.unmarkMemoryElement(theRootTimeTree);
                                            this._spaceManager.unmarkMemoryElement(rootGlobalUniverseOrderElement);
                                            this._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            if (resolvedCurrentRootUUID == org.kevoree.modeling.KConfig.NULL_LONG) {
                                                callback(null);
                                            } else {
                                                this._manager.lookup(universe, time, resolvedCurrentRootUUID, callback);
                                            }
                                        });
                                    });
                                });
                            }

                            public setRoot(newRoot: org.kevoree.modeling.KObject, callback: org.kevoree.modeling.KCallback<any>): void {
                                var rootFixedKey: number = org.kevoree.modeling.KConfig.END_OF_TIME;
                                this.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG,  (theGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                    if (theGlobalUniverseOrderElement == null) {
                                        callback(null);
                                        return;
                                    }
                                    this.getOrLoadAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, rootFixedKey,  (rootGlobalUniverseOrderElement : org.kevoree.modeling.memory.KChunk) => {
                                        var rootGlobalUniverseOrder: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>rootGlobalUniverseOrderElement;
                                        if (rootGlobalUniverseOrderElement == null) {
                                            rootGlobalUniverseOrder = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.createAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP);
                                        }
                                        var closestUniverse: number = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.resolve_universe(<org.kevoree.modeling.memory.chunk.KLongLongMap>theGlobalUniverseOrderElement, <org.kevoree.modeling.memory.chunk.KLongLongMap>rootGlobalUniverseOrderElement, newRoot.now(), newRoot.universe());
                                        rootGlobalUniverseOrder.put(newRoot.universe(), newRoot.now());
                                        if (closestUniverse != newRoot.universe()) {
                                            var newTimeTree: org.kevoree.modeling.memory.chunk.KLongLongTree = <org.kevoree.modeling.memory.chunk.KLongLongTree>this._spaceManager.createAndMark(newRoot.universe(), org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_TREE);
                                            newTimeTree.insert(newRoot.now(), newRoot.uuid());
                                            this._spaceManager.unmarkMemoryElement(newTimeTree);
                                            this._spaceManager.unmarkMemoryElement(rootGlobalUniverseOrderElement);
                                            this._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                            if (callback != null) {
                                                callback(null);
                                            }
                                        } else {
                                            this.getOrLoadAndMark(closestUniverse, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME,  (resolvedRootTimeTree : org.kevoree.modeling.memory.KChunk) => {
                                                var initializedTree: org.kevoree.modeling.memory.chunk.KLongLongTree = <org.kevoree.modeling.memory.chunk.KLongLongTree>resolvedRootTimeTree;
                                                if (initializedTree == null) {
                                                    initializedTree = <org.kevoree.modeling.memory.chunk.KLongLongTree>this._spaceManager.createAndMark(closestUniverse, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.END_OF_TIME, org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_TREE);
                                                }
                                                initializedTree.insert(newRoot.now(), newRoot.uuid());
                                                this._spaceManager.unmarkMemoryElement(resolvedRootTimeTree);
                                                this._spaceManager.unmarkMemoryElement(rootGlobalUniverseOrderElement);
                                                this._spaceManager.unmarkMemoryElement(theGlobalUniverseOrderElement);
                                                if (callback != null) {
                                                    callback(null);
                                                }
                                            });
                                        }
                                    });
                                });
                            }

                            public resolveTimes(currentUniverse: number, currentUuid: number, startTime: number, endTime: number, callback: org.kevoree.modeling.KCallback<any>): void {
                                var keys: Float64Array = new Float64Array([org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, currentUuid]);
                                this.getOrLoadAndMarkAll(keys,  (kMemoryChunks : org.kevoree.modeling.memory.KChunk[]) => {
                                    if (kMemoryChunks == null || kMemoryChunks.length == 0) {
                                        callback(new Float64Array(0));
                                        return;
                                    }
                                    var collectedUniverse: Float64Array = org.kevoree.modeling.memory.resolver.impl.DistortedTimeResolver.universeSelectByRange(<org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[0], <org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[1], startTime, endTime, currentUniverse);
                                    var nbKeys: number = collectedUniverse.length * 3;
                                    var timeTreeKeys: Float64Array = new Float64Array(nbKeys);
                                    for (var i: number = 0; i < collectedUniverse.length; i++) {
                                        timeTreeKeys[i * 3] = collectedUniverse[i];
                                        timeTreeKeys[i * 3 + 1] = org.kevoree.modeling.KConfig.NULL_LONG;
                                        timeTreeKeys[i * 3 + 2] = currentUuid;
                                    }
                                    var objUniverse: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>kMemoryChunks[1];
                                    this.getOrLoadAndMarkAll(timeTreeKeys,  (timeTrees : org.kevoree.modeling.memory.KChunk[]) => {
                                        if (timeTrees == null || timeTrees.length == 0) {
                                            this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                                            callback(new Float64Array(0));
                                            return;
                                        }
                                        var collector: org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                        var previousDivergenceTime: number = endTime;
                                        for (var i: number = 0; i < collectedUniverse.length; i++) {
                                            var timeTree: org.kevoree.modeling.memory.chunk.KLongTree = <org.kevoree.modeling.memory.chunk.KLongTree>timeTrees[i];
                                            if (timeTree != null) {
                                                var currentDivergenceTime: number = objUniverse.get(collectedUniverse[i]);
                                                var finalPreviousDivergenceTime: number = previousDivergenceTime;
                                                timeTree.range(currentDivergenceTime, previousDivergenceTime,  (t : number) => {
                                                    if (collector.size() == 0) {
                                                        collector.put(collector.size(), t);
                                                    } else {
                                                        if (t != finalPreviousDivergenceTime) {
                                                            collector.put(collector.size(), t);
                                                        }
                                                    }
                                                });
                                                previousDivergenceTime = currentDivergenceTime;
                                            }
                                        }
                                        var orderedTime: Float64Array = new Float64Array(collector.size());
                                        for (var i: number = 0; i < collector.size(); i++) {
                                            orderedTime[i] = collector.get(i);
                                        }
                                        this._spaceManager.unmarkAllMemoryElements(timeTrees);
                                        this._spaceManager.unmarkAllMemoryElements(kMemoryChunks);
                                        callback(orderedTime);
                                    });
                                });
                            }

                            public static resolve_universe(globalTree: org.kevoree.modeling.memory.chunk.KLongLongMap, objUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap, timeToResolve: number, originUniverseId: number): number {
                                if (globalTree == null || objUniverseTree == null) {
                                    return originUniverseId;
                                }
                                var currentUniverse: number = originUniverseId;
                                var previousUniverse: number = org.kevoree.modeling.KConfig.NULL_LONG;
                                var divergenceTime: number = objUniverseTree.get(currentUniverse);
                                while (currentUniverse != previousUniverse){
                                    if (divergenceTime != org.kevoree.modeling.KConfig.NULL_LONG && divergenceTime <= timeToResolve) {
                                        return currentUniverse;
                                    }
                                    previousUniverse = currentUniverse;
                                    currentUniverse = globalTree.get(currentUniverse);
                                    divergenceTime = objUniverseTree.get(currentUniverse);
                                }
                                return originUniverseId;
                            }

                            public static universeSelectByRange(globalTree: org.kevoree.modeling.memory.chunk.KLongLongMap, objUniverseTree: org.kevoree.modeling.memory.chunk.KLongLongMap, rangeMin: number, rangeMax: number, originUniverseId: number): Float64Array {
                                var collected: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                var currentUniverse: number = originUniverseId;
                                var previousUniverse: number = org.kevoree.modeling.KConfig.NULL_LONG;
                                var divergenceTime: number = objUniverseTree.get(currentUniverse);
                                while (currentUniverse != previousUniverse){
                                    if (divergenceTime != org.kevoree.modeling.KConfig.NULL_LONG) {
                                        if (divergenceTime <= rangeMin) {
                                            collected.put(collected.size(), currentUniverse);
                                            break;
                                        } else {
                                            if (divergenceTime <= rangeMax) {
                                                collected.put(collected.size(), currentUniverse);
                                            }
                                        }
                                    }
                                    previousUniverse = currentUniverse;
                                    currentUniverse = globalTree.get(currentUniverse);
                                    divergenceTime = objUniverseTree.get(currentUniverse);
                                }
                                var trimmed: Float64Array = new Float64Array(collected.size());
                                for (var i: number = 0; i < collected.size(); i++) {
                                    trimmed[<number>i] = collected.get(i);
                                }
                                return trimmed;
                            }

                            private load(keys: Float64Array, callback: org.kevoree.modeling.KCallback<any>): void {
                                this._manager.cdn().get(keys,  (payloads : string[]) => {
                                    var results: org.kevoree.modeling.memory.KChunk[] = new Array();
                                    for (var i: number = 0; i < payloads.length; i++) {
                                        var loopUniverse: number = keys[i * 3];
                                        var loopTime: number = keys[i * 3 + 1];
                                        var loopUuid: number = keys[i * 3 + 2];
                                        results[i] = this._spaceManager.createAndMark(loopUniverse, loopTime, loopUuid, this.typeFromKey(loopUniverse, loopTime, loopUuid));
                                        var classIndex: number = -1;
                                        if (loopUniverse != org.kevoree.modeling.KConfig.NULL_LONG && loopTime != org.kevoree.modeling.KConfig.NULL_LONG && loopUuid != org.kevoree.modeling.KConfig.NULL_LONG) {
                                            var alreadyLoadedOrder: org.kevoree.modeling.memory.chunk.KLongLongMap = <org.kevoree.modeling.memory.chunk.KLongLongMap>this._spaceManager.getAndMark(org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, loopUuid);
                                            if (alreadyLoadedOrder != null) {
                                                classIndex = alreadyLoadedOrder.metaClassIndex();
                                                this._spaceManager.unmarkMemoryElement(alreadyLoadedOrder);
                                            }
                                        }
                                        results[i].init(payloads[i], this._manager.model().metaModel(), classIndex);
                                    }
                                    callback(results);
                                });
                            }

                            public getRelatedKeys(uuid: number, previousResolution: Float64Array): Float64Array {
                                return new Float64Array([previousResolution[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], previousResolution[org.kevoree.modeling.abs.AbstractKObject.TIME_PREVIOUS_INDEX], uuid, previousResolution[org.kevoree.modeling.abs.AbstractKObject.UNIVERSE_PREVIOUS_INDEX], org.kevoree.modeling.KConfig.NULL_LONG, uuid, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, uuid, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG, org.kevoree.modeling.KConfig.NULL_LONG]);
                            }

                        }

                    }
                }
                export module space {
                    export interface KChunkIterator {

                        hasNext(): boolean;

                        next(): Float64Array;

                        size(): number;

                    }

                    export interface KChunkSpace {

                        get(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk;

                        create(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk;

                        clone(previousElement: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;

                        clear(metaModel: org.kevoree.modeling.meta.KMetaModel): void;

                        delete(metaModel: org.kevoree.modeling.meta.KMetaModel): void;

                        remove(universe: number, time: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): void;

                        size(): number;

                        detachDirties(): org.kevoree.modeling.memory.space.KChunkIterator;

                        declareDirty(dirtyChunk: org.kevoree.modeling.memory.KChunk): void;

                        printDebug(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void;

                    }

                    export interface KChunkSpaceManager {

                        getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk;

                        unmark(universe: number, time: number, obj: number): void;

                        createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk;

                        unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void;

                        unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void;

                        cloneMarkAndUnmark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk;

                        clear(): void;

                        register(object: org.kevoree.modeling.KObject): void;

                        registerAll(objects: org.kevoree.modeling.KObject[]): void;

                        setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void;

                    }

                    export class KChunkTypes {

                        public static OBJECT_CHUNK: number = 0;
                        public static LONG_TREE: number = 1;
                        public static LONG_LONG_TREE: number = 2;
                        public static LONG_LONG_MAP: number = 3;
                    }

                    export module impl {
                        export class AbstractCountingChunkSpaceManager implements org.kevoree.modeling.memory.space.KChunkSpaceManager {

                            public _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            public _metaModel: org.kevoree.modeling.meta.KMetaModel;
                            constructor(p_storage: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._space = p_storage;
                            }

                            public getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                                var resolvedElement: org.kevoree.modeling.memory.KChunk = this._space.get(universe, time, obj);
                                if (resolvedElement != null && (resolvedElement.getFlags() & org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) != org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT) {
                                    resolvedElement.inc();
                                }
                                return resolvedElement;
                            }

                            public unmark(universe: number, time: number, obj: number): void {
                                var resolvedElement: org.kevoree.modeling.memory.KChunk = this._space.get(universe, time, obj);
                                if (resolvedElement != null) {
                                    var newCount: number = resolvedElement.dec();
                                    if (newCount == 0 && (resolvedElement.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                        resolvedElement.setFlags(org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT, 0);
                                        this._space.remove(resolvedElement.universe(), resolvedElement.time(), resolvedElement.obj(), this._metaModel);
                                    }
                                }
                            }

                            public createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                                var newCreatedElement: org.kevoree.modeling.memory.KChunk = this._space.create(universe, time, obj, type);
                                if (newCreatedElement != null) {
                                    newCreatedElement.inc();
                                }
                                return newCreatedElement;
                            }

                            public unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {
                                var newCount: number = element.dec();
                                if (newCount == 0 && (element.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                    element.setFlags(org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT, 0);
                                    this._space.remove(element.universe(), element.time(), element.obj(), this._metaModel);
                                }
                            }

                            public unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void {
                                for (var i: number = 0; i < elements.length; i++) {
                                    var loopChunk: org.kevoree.modeling.memory.KChunk = elements[i];
                                    var newCount: number = elements[i].dec();
                                    if (newCount == 0 && (loopChunk.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                        loopChunk.setFlags(org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT, 0);
                                        this._space.remove(loopChunk.universe(), loopChunk.time(), loopChunk.obj(), this._metaModel);
                                    }
                                }
                            }

                            public cloneMarkAndUnmark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                var newCreatedElement: org.kevoree.modeling.memory.chunk.KObjectChunk = this._space.clone(previous, newUniverse, newTime, obj, metaModel);
                                newCreatedElement.inc();
                                var newCount: number = previous.dec();
                                if (newCount == 0 && (previous.getFlags() & org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) != org.kevoree.modeling.memory.KChunkFlags.DIRTY_BIT) {
                                    previous.setFlags(org.kevoree.modeling.memory.KChunkFlags.REMOVED_BIT, 0);
                                    this._space.remove(previous.universe(), previous.time(), previous.obj(), this._metaModel);
                                }
                                return newCreatedElement;
                            }

                            public clear(): void {
                            }

                            public register(object: org.kevoree.modeling.KObject): void {
                                throw "Abstract method";
                            }

                            public registerAll(objects: org.kevoree.modeling.KObject[]): void {
                                throw "Abstract method";
                            }

                            public setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void {
                                throw "Abstract method";
                            }

                        }

                        export class ChunkIterator implements org.kevoree.modeling.memory.space.KChunkIterator {

                            private _dirties: Float64Array;
                            private _origin: org.kevoree.modeling.memory.space.KChunkSpace;
                            private currentIndex: number = 0;
                            private maxIndex: number = 0;
                            private tempKeys: Float64Array;
                            constructor(p_dirties: Float64Array, p_origin: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._dirties = p_dirties;
                                this._origin = p_origin;
                                this.maxIndex = p_dirties.length / 3;
                                this.tempKeys = new Float64Array(3);
                            }

                            public hasNext(): boolean {
                                return this.currentIndex < this.maxIndex;
                            }

                            public next(): Float64Array {
                                if (this.currentIndex < this.maxIndex) {
                                    this.tempKeys[0] = this._dirties[this.currentIndex * 3];
                                    this.tempKeys[1] = this._dirties[this.currentIndex * 3 + 1];
                                    this.tempKeys[2] = this._dirties[this.currentIndex * 3 + 2];
                                }
                                this.currentIndex++;
                                return this.tempKeys;
                            }

                            public size(): number {
                                return this.maxIndex;
                            }

                        }

                        export class HeapChunkSpace implements org.kevoree.modeling.memory.space.KChunkSpace {

                            private static LOAD_FACTOR: number = (<number>75 / <number>100);
                            private _state: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState>;
                            private _dirtyState: java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState>;
                            constructor() {
                                this._dirtyState = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState>();
                                this._state = new java.util.concurrent.atomic.AtomicReference<org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState>();
                                this._dirtyState.set(new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState());
                                var initialCapacity: number = org.kevoree.modeling.KConfig.CACHE_INIT_SIZE;
                                var newstate: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array());
                                for (var i: number = 0; i < initialCapacity; i++) {
                                    newstate.elementNext[i] = -1;
                                    newstate.elementHash.set(i, -1);
                                }
                                newstate._threshold = <number>(newstate.elementDataSize * HeapChunkSpace.LOAD_FACTOR);
                                this._state.set(newstate);
                            }

                            public get(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                                var internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                                if (internalState.elementDataSize == 0) {
                                    return null;
                                }
                                var index: number = ((<number>(universe ^ time ^ obj)) & 0x7FFFFFFF) % internalState.elementDataSize;
                                var m: number = internalState.elementHash.get(index);
                                while (m != -1){
                                    if (universe == internalState.elementK3[(m * 3)] && time == internalState.elementK3[((m * 3) + 1)] && obj == internalState.elementK3[((m * 3) + 2)]) {
                                        return internalState.values[m];
                                    } else {
                                        m = internalState.elementNext[m];
                                    }
                                }
                                return null;
                            }

                            public create(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                                var newElement: org.kevoree.modeling.memory.KChunk = this.internal_createElement(universe, time, obj, type);
                                return this.internal_put(universe, time, obj, newElement);
                            }

                            public clone(previousElement: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, newObj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                return <org.kevoree.modeling.memory.chunk.KObjectChunk>this.internal_put(newUniverse, newTime, newObj, previousElement.clone(newUniverse, newTime, newObj, metaModel));
                            }

                            private internal_createElement(p_universe: number, p_time: number, p_obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                                switch (type) {
                                    case org.kevoree.modeling.memory.space.KChunkTypes.OBJECT_CHUNK:
                                    return new org.kevoree.modeling.memory.chunk.impl.HeapObjectChunk(p_universe, p_time, p_obj, this);
                                    case org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_MAP:
                                    return new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(p_universe, p_time, p_obj, this);
                                    case org.kevoree.modeling.memory.space.KChunkTypes.LONG_TREE:
                                    return new org.kevoree.modeling.memory.chunk.impl.ArrayLongTree(p_universe, p_time, p_obj, this);
                                    case org.kevoree.modeling.memory.space.KChunkTypes.LONG_LONG_TREE:
                                    return new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongTree(p_universe, p_time, p_obj, this);
                                    default:
                                    return null;
                                }
                            }

                            private internal_put(universe: number, time: number, p_obj: number, payload: org.kevoree.modeling.memory.KChunk): org.kevoree.modeling.memory.KChunk {
                                var currentState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                                var nextState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                                var result: org.kevoree.modeling.memory.KChunk;
                                var nbTry: number = 0;
                                do {
                                    currentState = this._state.get();
                                    var entry: number = -1;
                                    var index: number = -1;
                                    var hash: number = <number>(universe ^ time ^ p_obj);
                                    if (currentState.elementDataSize != 0) {
                                        index = (hash & 0x7FFFFFFF) % currentState.elementDataSize;
                                        entry = this.findNonNullKeyEntry(universe, time, p_obj, index, currentState);
                                    }
                                    if (entry == -1) {
                                        var nextValueIndex: number = currentState._valuesIndex.getAndIncrement();
                                        if (nextValueIndex > currentState._threshold) {
                                            return this.complex_insert(universe, time, p_obj, payload, hash, nextValueIndex);
                                        } else {
                                            nextState = currentState;
                                        }
                                        nextState.elementK3[(nextValueIndex * 3)] = universe;
                                        nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                                        nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                                        nextState.values[nextValueIndex] = payload;
                                        nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                                        nextState._elementCount.incrementAndGet();
                                        result = payload;
                                    } else {
                                        nextState = currentState;
                                        result = nextState.values[entry];
                                    }
                                    nbTry++;
                                    if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                                        throw new Error("CompareAndSwap error, failed to converge");
                                    }
                                } while (!this._state.compareAndSet(currentState, nextState))
                                return result;
                            }

                            private complex_insert(universe: number, time: number, p_obj: number, payload: org.kevoree.modeling.memory.KChunk, prehash: number, nextValueIndex: number): org.kevoree.modeling.memory.KChunk {
                                var currentState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                                var nextState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                                do {
                                    currentState = this._state.get();
                                    if (nextValueIndex > currentState._threshold) {
                                        nextState = this.rehashCapacity(currentState);
                                    } else {
                                        nextState = currentState;
                                    }
                                    var index: number = (prehash & 0x7FFFFFFF) % nextState.elementDataSize;
                                    nextState.elementK3[(nextValueIndex * 3)] = universe;
                                    nextState.elementK3[((nextValueIndex * 3) + 1)] = time;
                                    nextState.elementK3[((nextValueIndex * 3) + 2)] = p_obj;
                                    nextState.values[nextValueIndex] = payload;
                                    nextState.elementNext[nextValueIndex] = nextState.elementHash.getAndSet(index, nextValueIndex);
                                    nextState._elementCount.incrementAndGet();
                                } while (!this._state.compareAndSet(currentState, nextState))
                                return payload;
                            }

                            private rehashCapacity(previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState): org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState {
                                var length: number = (previousState.elementDataSize == 0 ? 1 : previousState.elementDataSize << 1);
                                var newElementKV: Float64Array = new Float64Array(length * 3);
                                var newValues: org.kevoree.modeling.memory.KChunk[] = new Array();
                                var previousIsSparse: boolean = previousState.sparse;
                                if (!previousIsSparse) {
                                    java.lang.System.arraycopy(previousState.elementK3, 0, newElementKV, 0, previousState.elementDataSize * 3);
                                    java.lang.System.arraycopy(previousState.values, 0, newValues, 0, previousState.elementDataSize);
                                }
                                var newElementNext: Int32Array = new Int32Array(length);
                                var newElementHash: Int32Array = new Int32Array(length);
                                for (var i: number = 0; i < length; i++) {
                                    newElementNext[i] = -1;
                                    newElementHash[i] = -1;
                                }
                                var currentIndex: number = 0;
                                for (var i: number = 0; i < previousState.elementDataSize; i++) {
                                    if (previousState.values[i] != null) {
                                        var hash: number = <number>(previousState.elementK3[(i * 3)] ^ previousState.elementK3[(i * 3) + 1] ^ previousState.elementK3[(i * 3) + 2]);
                                        var index: number = (hash & 0x7FFFFFFF) % length;
                                        newElementNext[i] = newElementHash[index];
                                        newElementHash[index] = i;
                                        if (previousIsSparse) {
                                            newValues[currentIndex] = previousState.values[i];
                                            newElementKV[(currentIndex * 3)] = previousState.elementK3[(i * 3)];
                                            newElementKV[(currentIndex * 3) + 1] = previousState.elementK3[(i * 3) + 1];
                                            newElementKV[(currentIndex * 3) + 2] = previousState.elementK3[(i * 3) + 2];
                                            currentIndex++;
                                        }
                                    }
                                }
                                var newState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(length, newElementKV, newElementNext, newElementHash, newValues);
                                newState._threshold = <number>(length * HeapChunkSpace.LOAD_FACTOR);
                                newState._valuesIndex.set(previousState._valuesIndex.get());
                                if (previousIsSparse) {
                                    newState._elementCount.set(currentIndex);
                                    newState._valuesIndex.set(currentIndex);
                                } else {
                                    newState._elementCount.set(previousState._elementCount.get());
                                    newState._valuesIndex.set(previousState._valuesIndex.get());
                                }
                                return newState;
                            }

                            public findNonNullKeyEntry(universe: number, time: number, obj: number, index: number, internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState): number {
                                var m: number = internalState.elementHash.get(index);
                                while (m >= 0){
                                    if (universe == internalState.elementK3[m * 3] && time == internalState.elementK3[(m * 3) + 1] && obj == internalState.elementK3[(m * 3) + 2]) {
                                        return m;
                                    }
                                    m = internalState.elementNext[m];
                                }
                                return -1;
                            }

                            public size(): number {
                                return this._state.get()._elementCount.get();
                            }

                            public detachDirties(): org.kevoree.modeling.memory.space.KChunkIterator {
                                var detachedState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState = this._dirtyState.getAndSet(new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState());
                                var maxIndex: number = detachedState._dirtyIndex.get();
                                var shrinked: Float64Array = new Float64Array(maxIndex * 3);
                                java.lang.System.arraycopy(detachedState._dirtyList, 0, shrinked, 0, maxIndex * 3);
                                return new org.kevoree.modeling.memory.space.impl.ChunkIterator(shrinked, this);
                            }

                            public declareDirty(dirtyChunk: org.kevoree.modeling.memory.KChunk): void {
                                var nbTry: number = 0;
                                var current: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalDirtyState;
                                do {
                                    current = this._dirtyState.get();
                                    current.declareDirty(dirtyChunk.universe(), dirtyChunk.time(), dirtyChunk.obj());
                                    nbTry++;
                                    if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                                        throw new Error("CompareAndSwap error, failed to converge");
                                    }
                                } while (!this._dirtyState.compareAndSet(current, current))
                            }

                            public remove(universe: number, time: number, obj: number, p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                var previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState;
                                var nbTry: number = 0;
                                do {
                                    previousState = this._state.get();
                                    var hash: number = <number>(universe ^ time ^ obj);
                                    var index: number = (hash & 0x7FFFFFFF) % previousState.elementDataSize;
                                    if (previousState.elementDataSize == 0) {
                                        return;
                                    }
                                    var m: number = previousState.elementHash.get(index);
                                    var last: number = -1;
                                    while (m >= 0){
                                        if (universe == previousState.elementK3[m * 3] && time == previousState.elementK3[(m * 3) + 1] && obj == previousState.elementK3[(m * 3) + 2]) {
                                            break;
                                        }
                                        last = m;
                                        m = previousState.elementNext[m];
                                    }
                                    if (m == -1) {
                                        return;
                                    }
                                    if (last == -1) {
                                        var previousNext: number = previousState.elementNext[m];
                                        if (!previousState.elementHash.compareAndSet(index, m, previousNext)) {
                                        }
                                    } else {
                                        previousState.elementNext[last] = previousState.elementNext[m];
                                    }
                                    previousState.elementNext[m] = -1;
                                    var previousValue: org.kevoree.modeling.memory.KChunk = previousState.values[m];
                                    previousState.values[m] = null;
                                    previousValue.free(p_metaModel);
                                    previousState._elementCount.decrementAndGet();
                                    nbTry++;
                                    if (nbTry == org.kevoree.modeling.KConfig.CAS_MAX_TRY) {
                                        throw new Error("CompareAndSwap error, failed to converge");
                                    }
                                } while (!this._state.compareAndSet(previousState, previousState))
                            }

                            public clear(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                var previousState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                                if (previousState._elementCount.get() > 0) {
                                    for (var i: number = 0; i < previousState.elementDataSize; i++) {
                                        if (previousState.values[i] != null) {
                                            previousState.values[i].free(metaModel);
                                        }
                                    }
                                    var initialCapacity: number = org.kevoree.modeling.KConfig.CACHE_INIT_SIZE;
                                    var newstate: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = new org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState(initialCapacity, new Float64Array(initialCapacity * 3), new Int32Array(initialCapacity), new Int32Array(initialCapacity), new Array());
                                    for (var i: number = 0; i < initialCapacity; i++) {
                                        newstate.elementNext[i] = -1;
                                        newstate.elementHash.set(i, -1);
                                    }
                                    newstate._elementCount.set(0);
                                    newstate._valuesIndex.set(0);
                                    newstate._threshold = <number>(newstate.elementDataSize * HeapChunkSpace.LOAD_FACTOR);
                                    this._state.set(newstate);
                                }
                            }

                            public delete(metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                var internalState: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.getAndSet(null);
                                for (var i: number = 0; i < internalState.elementDataSize; i++) {
                                    if (internalState.values[i] != null) {
                                        internalState.values[i].free(metaModel);
                                    }
                                }
                                internalState._elementCount.set(0);
                                internalState._valuesIndex.set(0);
                                internalState._threshold = 0;
                            }

                            public printDebug(p_metaModel: org.kevoree.modeling.meta.KMetaModel): void {
                                try {
                                    var state: org.kevoree.modeling.memory.space.impl.HeapChunkSpace.InternalState = this._state.get();
                                    for (var i: number = 0; i < state.values.length; i++) {
                                        var loopChunk: org.kevoree.modeling.memory.KChunk = state.values[i];
                                        if (loopChunk != null) {
                                            var content: string = loopChunk.serialize(p_metaModel);
                                            console.error(state.elementK3[i * 3] + "," + state.elementK3[i * 3 + 1] + "," + state.elementK3[i * 3 + 2] + "=>" + loopChunk.type() + "(count:" + loopChunk.counter() + ",flag:" + loopChunk.getFlags() + ")" + "==>" + content);;
                                        }
                                    }
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                            }

                        }

                        export module HeapChunkSpace {
                            export class InternalState {

                                public sparse: boolean = false;
                                public elementDataSize: number;
                                public elementK3: Float64Array;
                                public elementNext: Int32Array;
                                public elementHash: java.util.concurrent.atomic.AtomicIntegerArray;
                                public values: org.kevoree.modeling.memory.KChunk[];
                                public _elementCount: java.util.concurrent.atomic.AtomicInteger;
                                public _valuesIndex: java.util.concurrent.atomic.AtomicInteger;
                                public _threshold: number;
                                constructor(p_elementDataSize: number, p_elementKE: Float64Array, p_elementNext: Int32Array, p_elementHash: Int32Array, p_values: org.kevoree.modeling.memory.KChunk[]) {
                                    this.elementDataSize = p_elementDataSize;
                                    this.elementK3 = p_elementKE;
                                    this.elementNext = p_elementNext;
                                    this.elementHash = new java.util.concurrent.atomic.AtomicIntegerArray(p_elementHash);
                                    this.values = p_values;
                                    this._elementCount = new java.util.concurrent.atomic.AtomicInteger(0);
                                    this._valuesIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                                }

                            }


                            export class InternalDirtyState {

                                public _dirtyList: Float64Array;
                                public _dirtyIndex: java.util.concurrent.atomic.AtomicInteger;
                                constructor() {
                                    this._dirtyList = new Float64Array(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE * 3);
                                    this._dirtyIndex = new java.util.concurrent.atomic.AtomicInteger(0);
                                }

                                public declareDirty(universe: number, time: number, obj: number): void {
                                    var nextIndex: number = this._dirtyIndex.getAndIncrement() * 3;
                                    if (nextIndex + 2 < this._dirtyList.length) {
                                        this._dirtyList[nextIndex] = universe;
                                        this._dirtyList[nextIndex + 1] = time;
                                        this._dirtyList[nextIndex + 2] = obj;
                                    } else {
                                        this.reallocate(nextIndex);
                                        this._dirtyList[nextIndex] = universe;
                                        this._dirtyList[nextIndex + 1] = time;
                                        this._dirtyList[nextIndex + 2] = obj;
                                    }
                                }

                                private reallocate(wantedIndex: number): void {
                                    if (wantedIndex + 2 >= this._dirtyList.length) {
                                        var newlength: number = wantedIndex << 1;
                                        var previousList: Float64Array = this._dirtyList;
                                        this._dirtyList = new Float64Array(newlength);
                                        java.lang.System.arraycopy(previousList, 0, this._dirtyList, 0, wantedIndex);
                                    }
                                }

                            }


                        }
                        export class NoopChunkSpaceManager implements org.kevoree.modeling.memory.space.KChunkSpaceManager {

                            private _space: org.kevoree.modeling.memory.space.KChunkSpace;
                            constructor(p_space: org.kevoree.modeling.memory.space.KChunkSpace) {
                                this._space = p_space;
                            }

                            public getAndMark(universe: number, time: number, obj: number): org.kevoree.modeling.memory.KChunk {
                                return this._space.get(universe, time, obj);
                            }

                            public unmark(universe: number, time: number, obj: number): void {
                            }

                            public createAndMark(universe: number, time: number, obj: number, type: number): org.kevoree.modeling.memory.KChunk {
                                return this._space.create(universe, time, obj, type);
                            }

                            public unmarkMemoryElement(element: org.kevoree.modeling.memory.KChunk): void {
                            }

                            public unmarkAllMemoryElements(elements: org.kevoree.modeling.memory.KChunk[]): void {
                            }

                            public cloneMarkAndUnmark(previous: org.kevoree.modeling.memory.chunk.KObjectChunk, newUniverse: number, newTime: number, obj: number, metaModel: org.kevoree.modeling.meta.KMetaModel): org.kevoree.modeling.memory.chunk.KObjectChunk {
                                return this._space.clone(previous, newUniverse, newTime, obj, metaModel);
                            }

                            public clear(): void {
                            }

                            public register(object: org.kevoree.modeling.KObject): void {
                            }

                            public registerAll(objects: org.kevoree.modeling.KObject[]): void {
                            }

                            public setResolver(resolver: org.kevoree.modeling.memory.resolver.KResolver): void {
                            }

                        }

                    }
                }
                export module strategy {
                    export interface KMemoryStrategy {

                        newSpace(): org.kevoree.modeling.memory.space.KChunkSpace;

                        newSpaceManager(space: org.kevoree.modeling.memory.space.KChunkSpace): org.kevoree.modeling.memory.space.KChunkSpaceManager;

                    }

                    export module impl {
                        export class HeapMemoryStrategy implements org.kevoree.modeling.memory.strategy.KMemoryStrategy {

                            public newSpace(): org.kevoree.modeling.memory.space.KChunkSpace {
                                return new org.kevoree.modeling.memory.space.impl.HeapChunkSpace();
                            }

                            public newSpaceManager(p_space: org.kevoree.modeling.memory.space.KChunkSpace): org.kevoree.modeling.memory.space.KChunkSpaceManager {
                                 return new org.kevoree.modeling.memory.space.impl.NoopChunkSpaceManager(p_space);
                            }

                        }

                    }
                }
            }
            export module message {
                export interface KMessage {

                    json(): string;

                    type(): number;

                }

                export class KMessageLoader {

                    public static TYPE_NAME: string = "type";
                    public static OPERATION_NAME: string = "op";
                    public static KEY_NAME: string = "key";
                    public static KEYS_NAME: string = "keys";
                    public static ID_NAME: string = "id";
                    public static VALUE_NAME: string = "value";
                    public static VALUES_NAME: string = "values";
                    public static CLASS_IDX_NAME: string = "class";
                    public static PARAMETERS_NAME: string = "params";
                    public static EVENTS_TYPE: number = 0;
                    public static GET_REQ_TYPE: number = 1;
                    public static GET_RES_TYPE: number = 2;
                    public static PUT_REQ_TYPE: number = 3;
                    public static PUT_RES_TYPE: number = 4;
                    public static OPERATION_CALL_TYPE: number = 5;
                    public static OPERATION_RESULT_TYPE: number = 6;
                    public static ATOMIC_GET_INC_REQUEST_TYPE: number = 7;
                    public static ATOMIC_GET_INC_RESULT_TYPE: number = 8;
                    public static load(payload: string): org.kevoree.modeling.message.KMessage {
                        if (payload == null) {
                            return null;
                        }
                        var objectReader: org.kevoree.modeling.format.json.JsonObjectReader = new org.kevoree.modeling.format.json.JsonObjectReader();
                        objectReader.parseObject(payload);
                        try {
                            var parsedType: number = org.kevoree.modeling.util.PrimitiveHelper.parseInt(objectReader.get(KMessageLoader.TYPE_NAME).toString());
                            if (parsedType == KMessageLoader.EVENTS_TYPE) {
                                var eventsMessage: org.kevoree.modeling.message.impl.Events = null;
                                if (objectReader.get(KMessageLoader.KEYS_NAME) != null) {
                                    var objIdsRaw: string[] = objectReader.getAsStringArray(KMessageLoader.KEYS_NAME);
                                    var keys: Float64Array = new Float64Array(objIdsRaw.length);
                                    for (var i: number = 0; i < objIdsRaw.length; i++) {
                                        try {
                                            keys[i] = org.kevoree.modeling.util.maths.Base64.decodeToLong(objIdsRaw[i]);
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    eventsMessage = new org.kevoree.modeling.message.impl.Events(keys);
                                }
                                return eventsMessage;
                            } else {
                                if (parsedType == KMessageLoader.GET_REQ_TYPE) {
                                    var getKeysRequest: org.kevoree.modeling.message.impl.GetRequest = new org.kevoree.modeling.message.impl.GetRequest();
                                    if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                        getKeysRequest.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                    }
                                    if (objectReader.get(KMessageLoader.KEYS_NAME) != null) {
                                        var metaInt: string[] = objectReader.getAsStringArray(KMessageLoader.KEYS_NAME);
                                        var keys: Float64Array = new Float64Array(metaInt.length);
                                        for (var i: number = 0; i < metaInt.length; i++) {
                                            keys[i] = org.kevoree.modeling.util.maths.Base64.decodeToLong(metaInt[i]);
                                        }
                                        getKeysRequest.keys = keys;
                                    }
                                    return getKeysRequest;
                                } else {
                                    if (parsedType == KMessageLoader.GET_RES_TYPE) {
                                        var getResult: org.kevoree.modeling.message.impl.GetResult = new org.kevoree.modeling.message.impl.GetResult();
                                        if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                            getResult.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                        }
                                        if (objectReader.get(KMessageLoader.VALUES_NAME) != null) {
                                            var metaInt: string[] = objectReader.getAsStringArray(KMessageLoader.VALUES_NAME);
                                            var values: string[] = new Array();
                                            for (var i: number = 0; i < metaInt.length; i++) {
                                                values[i] = org.kevoree.modeling.format.json.JsonString.unescape(metaInt[i]);
                                            }
                                            getResult.values = values;
                                        }
                                        return getResult;
                                    } else {
                                        if (parsedType == KMessageLoader.PUT_REQ_TYPE) {
                                            var putRequest: org.kevoree.modeling.message.impl.PutRequest = new org.kevoree.modeling.message.impl.PutRequest();
                                            if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                                putRequest.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                            }
                                            var toFlatKeys: string[] = null;
                                            var toFlatValues: string[] = null;
                                            if (objectReader.get(KMessageLoader.KEYS_NAME) != null) {
                                                toFlatKeys = objectReader.getAsStringArray(KMessageLoader.KEYS_NAME);
                                            }
                                            if (objectReader.get(KMessageLoader.VALUES_NAME) != null) {
                                                toFlatValues = objectReader.getAsStringArray(KMessageLoader.VALUES_NAME);
                                            }
                                            if (toFlatKeys != null && toFlatValues != null) {
                                                putRequest.keys = new Float64Array(toFlatKeys.length);
                                                putRequest.values = new Array();
                                                for (var i: number = 0; i < toFlatKeys.length; i++) {
                                                    putRequest.keys[i] = org.kevoree.modeling.util.maths.Base64.decodeToLong(toFlatKeys[i]);
                                                }
                                                for (var i: number = 0; i < toFlatValues.length; i++) {
                                                    putRequest.values[i] = org.kevoree.modeling.format.json.JsonString.unescape(toFlatValues[i]);
                                                }
                                            }
                                            return putRequest;
                                        } else {
                                            if (parsedType == KMessageLoader.PUT_RES_TYPE) {
                                                var putResult: org.kevoree.modeling.message.impl.PutResult = new org.kevoree.modeling.message.impl.PutResult();
                                                if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                                    putResult.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                                }
                                                return putResult;
                                            } else {
                                                if (parsedType == KMessageLoader.OPERATION_CALL_TYPE) {
                                                    return null;
                                                } else {
                                                    if (parsedType == KMessageLoader.OPERATION_RESULT_TYPE) {
                                                        var resultMessage: org.kevoree.modeling.message.impl.OperationResultMessage = new org.kevoree.modeling.message.impl.OperationResultMessage();
                                                        if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                                            resultMessage.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                                        }
                                                        if (objectReader.get(KMessageLoader.KEY_NAME) != null) {
                                                            resultMessage.key = org.kevoree.modeling.KContentKey.create(objectReader.get(KMessageLoader.KEY_NAME).toString());
                                                        }
                                                        if (objectReader.get(KMessageLoader.VALUE_NAME) != null) {
                                                            resultMessage.value = objectReader.get(KMessageLoader.VALUE_NAME).toString();
                                                        }
                                                        return resultMessage;
                                                    } else {
                                                        if (parsedType == KMessageLoader.ATOMIC_GET_INC_REQUEST_TYPE) {
                                                            var atomicGetMessage: org.kevoree.modeling.message.impl.AtomicGetIncrementRequest = new org.kevoree.modeling.message.impl.AtomicGetIncrementRequest();
                                                            if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                                                atomicGetMessage.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                                            }
                                                            if (objectReader.get(KMessageLoader.KEYS_NAME) != null) {
                                                                var metaInt: string[] = objectReader.getAsStringArray(KMessageLoader.KEYS_NAME);
                                                                var keys: Float64Array = new Float64Array(metaInt.length);
                                                                for (var i: number = 0; i < metaInt.length; i++) {
                                                                    keys[i] = org.kevoree.modeling.util.maths.Base64.decodeToLong(metaInt[i]);
                                                                }
                                                                atomicGetMessage.keys = keys;
                                                            }
                                                            return atomicGetMessage;
                                                        } else {
                                                            if (parsedType == KMessageLoader.ATOMIC_GET_INC_RESULT_TYPE) {
                                                                var atomicGetResultMessage: org.kevoree.modeling.message.impl.AtomicGetIncrementResult = new org.kevoree.modeling.message.impl.AtomicGetIncrementResult();
                                                                if (objectReader.get(KMessageLoader.ID_NAME) != null) {
                                                                    atomicGetResultMessage.id = org.kevoree.modeling.util.PrimitiveHelper.parseLong(objectReader.get(KMessageLoader.ID_NAME).toString());
                                                                }
                                                                if (objectReader.get(KMessageLoader.VALUE_NAME) != null) {
                                                                    try {
                                                                        atomicGetResultMessage.value = org.kevoree.modeling.util.PrimitiveHelper.parseShort(objectReader.get(KMessageLoader.VALUE_NAME).toString());
                                                                    } catch ($ex$) {
                                                                        if ($ex$ instanceof Error) {
                                                                            var e: Error = <Error>$ex$;
                                                                            console.error(e['stack']);;
                                                                        } else {
                                                                            throw $ex$;
                                                                        }
                                                                    }
                                                                }
                                                                return atomicGetResultMessage;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            return null;
                        } catch ($ex$) {
                            if ($ex$ instanceof Error) {
                                var e: Error = <Error>$ex$;
                                console.error(e['stack']);;
                                return null;
                            } else {
                                throw $ex$;
                            }
                        }
                    }

                }

                export module impl {
                    export class AtomicGetIncrementRequest implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public keys: Float64Array;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            if (this.keys != null) {
                                buffer.append(",");
                                buffer.append("\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.KEYS_NAME).append("\":[");
                                for (var i: number = 0; i < this.keys.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(this.keys[i], buffer);
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                            }
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.ATOMIC_GET_INC_REQUEST_TYPE;
                        }

                    }

                    export class AtomicGetIncrementResult implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public value: number;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.value, org.kevoree.modeling.message.KMessageLoader.VALUE_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.ATOMIC_GET_INC_RESULT_TYPE;
                        }

                    }

                    export class Events implements org.kevoree.modeling.message.KMessage {

                        public _keys: Float64Array;
                        public allKeys(): Float64Array {
                            return this._keys;
                        }

                        constructor(p_keys: Float64Array) {
                            this._keys = p_keys;
                        }

                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            buffer.append(",");
                            buffer.append("\"");
                            buffer.append(org.kevoree.modeling.message.KMessageLoader.KEYS_NAME).append("\":[");
                            for (var i: number = 0; i < this._keys.length; i++) {
                                if (i != 0) {
                                    buffer.append(",");
                                }
                                buffer.append("\"");
                                org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(this._keys[i], buffer);
                                buffer.append("\"");
                            }
                            buffer.append("]\n");
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.EVENTS_TYPE;
                        }

                    }

                    export class GetRequest implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public keys: Float64Array;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            if (this.keys != null) {
                                buffer.append(",");
                                buffer.append("\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.KEYS_NAME).append("\":[");
                                for (var i: number = 0; i < this.keys.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(this.keys[i], buffer);
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                            }
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.GET_REQ_TYPE;
                        }

                    }

                    export class GetResult implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public values: string[];
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            if (this.values != null) {
                                buffer.append(",");
                                buffer.append("\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.VALUES_NAME).append("\":[");
                                for (var i: number = 0; i < this.values.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    buffer.append(org.kevoree.modeling.format.json.JsonString.encode(this.values[i]));
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                            }
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.GET_RES_TYPE;
                        }

                    }

                    export class MessageHelper {

                        public static printJsonStart(builder: java.lang.StringBuilder): void {
                            builder.append("{\n");
                        }

                        public static printJsonEnd(builder: java.lang.StringBuilder): void {
                            builder.append("}\n");
                        }

                        public static printType(builder: java.lang.StringBuilder, type: number): void {
                            builder.append("\"");
                            builder.append(org.kevoree.modeling.message.KMessageLoader.TYPE_NAME);
                            builder.append("\":\"");
                            builder.append(type);
                            builder.append("\"\n");
                        }

                        public static printElem(elem: any, name: string, builder: java.lang.StringBuilder): void {
                            if (elem != null) {
                                builder.append(",");
                                builder.append("\"");
                                builder.append(name);
                                builder.append("\":\"");
                                builder.append(elem.toString());
                                builder.append("\"\n");
                            }
                        }

                    }

                    export class OperationCallMessage implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public classIndex: number;
                        public opIndex: number;
                        public params: string[];
                        public key: Float64Array;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.key, org.kevoree.modeling.message.KMessageLoader.KEY_NAME, buffer);
                            buffer.append(",\"").append(org.kevoree.modeling.message.KMessageLoader.CLASS_IDX_NAME).append("\":\"").append(this.classIndex).append("\"");
                            buffer.append(",\"").append(org.kevoree.modeling.message.KMessageLoader.OPERATION_NAME).append("\":\"").append(this.opIndex).append("\"");
                            if (this.params != null) {
                                buffer.append(",\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.PARAMETERS_NAME).append("\":[");
                                for (var i: number = 0; i < this.params.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    buffer.append(org.kevoree.modeling.format.json.JsonString.encode(this.params[i]));
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                            }
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.OPERATION_CALL_TYPE;
                        }

                    }

                    export class OperationResultMessage implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public value: string;
                        public key: org.kevoree.modeling.KContentKey;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.key, org.kevoree.modeling.message.KMessageLoader.KEY_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.value, org.kevoree.modeling.message.KMessageLoader.VALUE_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.OPERATION_RESULT_TYPE;
                        }

                    }

                    export class PutRequest implements org.kevoree.modeling.message.KMessage {

                        public keys: Float64Array;
                        public values: string[];
                        public id: number;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            if (this.keys != null && this.values != null) {
                                buffer.append(",\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.KEYS_NAME).append("\":[");
                                for (var i: number = 0; i < this.keys.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    org.kevoree.modeling.util.maths.Base64.encodeLongToBuffer(this.keys[i], buffer);
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                                buffer.append(",\"");
                                buffer.append(org.kevoree.modeling.message.KMessageLoader.VALUES_NAME).append("\":[");
                                for (var i: number = 0; i < this.values.length; i++) {
                                    if (i != 0) {
                                        buffer.append(",");
                                    }
                                    buffer.append("\"");
                                    buffer.append(org.kevoree.modeling.format.json.JsonString.encode(this.values[i]));
                                    buffer.append("\"");
                                }
                                buffer.append("]\n");
                            }
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.PUT_REQ_TYPE;
                        }

                    }

                    export class PutResult implements org.kevoree.modeling.message.KMessage {

                        public id: number;
                        public json(): string {
                            var buffer: java.lang.StringBuilder = new java.lang.StringBuilder();
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonStart(buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printType(buffer, this.type());
                            org.kevoree.modeling.message.impl.MessageHelper.printElem(this.id, org.kevoree.modeling.message.KMessageLoader.ID_NAME, buffer);
                            org.kevoree.modeling.message.impl.MessageHelper.printJsonEnd(buffer);
                            return buffer.toString();
                        }

                        public type(): number {
                            return org.kevoree.modeling.message.KMessageLoader.PUT_RES_TYPE;
                        }

                    }

                }
            }
            export module meta {
                export interface KLiteral extends org.kevoree.modeling.meta.KMeta {

                }

                export interface KMeta {

                    index(): number;

                    metaName(): string;

                    metaType(): org.kevoree.modeling.meta.MetaType;

                }

                export interface KMetaAttribute extends org.kevoree.modeling.meta.KMeta {

                    key(): boolean;

                    attributeTypeId(): number;

                    strategy(): org.kevoree.modeling.extrapolation.Extrapolation;

                    precision(): number;

                    setExtrapolation(extrapolation: org.kevoree.modeling.extrapolation.Extrapolation): void;

                    setPrecision(precision: number): void;

                }

                export interface KMetaClass extends org.kevoree.modeling.meta.KMeta {

                    metaElements(): org.kevoree.modeling.meta.KMeta[];

                    meta(index: number): org.kevoree.modeling.meta.KMeta;

                    metaByName(name: string): org.kevoree.modeling.meta.KMeta;

                    attribute(name: string): org.kevoree.modeling.meta.KMetaAttribute;

                    reference(name: string): org.kevoree.modeling.meta.KMetaReference;

                    operation(name: string): org.kevoree.modeling.meta.KMetaOperation;

                    addAttribute(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute;

                    addReference(referenceName: string, metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string, toMany: boolean): org.kevoree.modeling.meta.KMetaReference;

                    addDependency(dependencyName: string, referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency;

                    addInput(name: string, extractor: string): org.kevoree.modeling.meta.KMetaInferInput;

                    addOutput(name: string, metaClass: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaInferOutput;

                    addOperation(operationName: string): org.kevoree.modeling.meta.KMetaOperation;

                    inferAlg(): org.kevoree.modeling.infer.KInferAlg;

                    dependencies(): org.kevoree.modeling.meta.KMetaDependencies;

                    inputs(): org.kevoree.modeling.meta.KMetaInferInput[];

                    outputs(): org.kevoree.modeling.meta.KMetaInferOutput[];

                    temporalResolution(): number;

                    setTemporalResolution(tempo: number): void;

                }

                export interface KMetaDependencies extends org.kevoree.modeling.meta.KMeta {

                    origin(): org.kevoree.modeling.meta.KMetaClass;

                    allDependencies(): org.kevoree.modeling.meta.KMetaDependency[];

                    dependencyByName(dependencyName: string): org.kevoree.modeling.meta.KMetaDependency;

                    addDependency(dependencyName: string, p_referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency;

                }

                export interface KMetaDependency extends org.kevoree.modeling.meta.KMeta {

                    referredMetaClassIndex(): number;

                }

                export interface KMetaEnum extends org.kevoree.modeling.KType, org.kevoree.modeling.meta.KMeta {

                    literals(): org.kevoree.modeling.meta.KLiteral[];

                    literalByName(name: string): org.kevoree.modeling.meta.KLiteral;

                    literal(index: number): org.kevoree.modeling.meta.KLiteral;

                    addLiteral(name: string): org.kevoree.modeling.meta.KLiteral;

                }

                export interface KMetaInferInput extends org.kevoree.modeling.meta.KMeta {

                    extractorQuery(): string;

                    extractor(): org.kevoree.modeling.traversal.KTraversal;

                }

                export interface KMetaInferOutput extends org.kevoree.modeling.meta.KMeta {

                    attributeTypeId(): number;

                }

                export interface KMetaModel extends org.kevoree.modeling.meta.KMeta {

                    metaClasses(): org.kevoree.modeling.meta.KMetaClass[];

                    metaClassByName(name: string): org.kevoree.modeling.meta.KMetaClass;

                    metaClass(index: number): org.kevoree.modeling.meta.KMetaClass;

                    addMetaClass(metaClassName: string): org.kevoree.modeling.meta.KMetaClass;

                    addInferMetaClass(metaClassName: string, inferAlg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass;

                    metaTypes(): org.kevoree.modeling.meta.KMetaEnum[];

                    metaTypeByName(name: string): org.kevoree.modeling.meta.KMetaEnum;

                    addMetaEnum(enumName: string): org.kevoree.modeling.meta.KMetaEnum;

                    createModel(manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.KModel<any>;

                }

                export interface KMetaOperation extends org.kevoree.modeling.meta.KMeta {

                    originMetaClassIndex(): number;

                }

                export interface KMetaReference extends org.kevoree.modeling.meta.KMeta {

                    visible(): boolean;

                    single(): boolean;

                    referredMetaClassIndex(): number;

                    oppositeName(): string;

                    originMetaClassIndex(): number;

                }

                export class KPrimitiveTypes {

                    public static BOOL_ID: number = -1;
                    public static STRING_ID: number = -2;
                    public static LONG_ID: number = -3;
                    public static INT_ID: number = -4;
                    public static DOUBLE_ID: number = -5;
                    public static CONTINUOUS_ID: number = -6;
                    public static BOOL: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("BOOL", false, KPrimitiveTypes.BOOL_ID);
                    public static STRING: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("STRING", false, KPrimitiveTypes.STRING_ID);
                    public static LONG: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("LONG", false, KPrimitiveTypes.LONG_ID);
                    public static INT: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("INT", false, KPrimitiveTypes.INT_ID);
                    public static DOUBLE: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("DOUBLE", false, KPrimitiveTypes.DOUBLE_ID);
                    public static CONTINUOUS: org.kevoree.modeling.KType = new org.kevoree.modeling.abs.AbstractDataType("CONTINUOUS", false, KPrimitiveTypes.CONTINUOUS_ID);
                    public static isEnum(attributeTypeId: number): boolean {
                        return attributeTypeId >= 0;
                    }

                }

                export class MetaType {

                    public static ATTRIBUTE: MetaType = new MetaType();
                    public static REFERENCE: MetaType = new MetaType();
                    public static DEPENDENCY: MetaType = new MetaType();
                    public static DEPENDENCIES: MetaType = new MetaType();
                    public static INPUT: MetaType = new MetaType();
                    public static OUTPUT: MetaType = new MetaType();
                    public static OPERATION: MetaType = new MetaType();
                    public static CLASS: MetaType = new MetaType();
                    public static MODEL: MetaType = new MetaType();
                    public static ENUM: MetaType = new MetaType();
                    public static LITERAL: MetaType = new MetaType();
                    public equals(other: any): boolean {
                        return this == other;
                    }
                    public static _MetaTypeVALUES : MetaType[] = [
                        MetaType.ATTRIBUTE
                        ,MetaType.REFERENCE
                        ,MetaType.DEPENDENCY
                        ,MetaType.DEPENDENCIES
                        ,MetaType.INPUT
                        ,MetaType.OUTPUT
                        ,MetaType.OPERATION
                        ,MetaType.CLASS
                        ,MetaType.MODEL
                        ,MetaType.ENUM
                        ,MetaType.LITERAL
                    ];
                    public static values():MetaType[]{
                        return MetaType._MetaTypeVALUES;
                    }
                }

                export module impl {
                    export class GenericModel extends org.kevoree.modeling.abs.AbstractKModel<any> {

                        private _p_metaModel: org.kevoree.modeling.meta.KMetaModel;
                        constructor(mm: org.kevoree.modeling.meta.KMetaModel, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                            super(p_manager);
                            this._p_metaModel = mm;
                        }

                        public metaModel(): org.kevoree.modeling.meta.KMetaModel {
                            return this._p_metaModel;
                        }

                        public internalCreateUniverse(universe: number): org.kevoree.modeling.KUniverse<any, any> {
                            return new org.kevoree.modeling.meta.impl.GenericUniverse(universe, this._manager);
                        }

                        public internalCreateObject(universe: number, time: number, uuid: number, clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
                            if (clazz.inferAlg() != null) {
                                return new org.kevoree.modeling.meta.impl.GenericObjectInfer(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                            } else {
                                return new org.kevoree.modeling.meta.impl.GenericObject(universe, time, uuid, clazz, this._manager, previousUniverse, previousTime);
                            }
                        }

                    }

                    export class GenericObject extends org.kevoree.modeling.abs.AbstractKObject {

                        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                            super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
                        }

                    }

                    export class GenericObjectInfer extends org.kevoree.modeling.abs.AbstractKObjectInfer {

                        constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, currentUniverse: number, currentTime: number) {
                            super(p_universe, p_time, p_uuid, p_metaClass, p_manager, currentUniverse, currentTime);
                        }

                    }

                    export class GenericUniverse extends org.kevoree.modeling.abs.AbstractKUniverse<any, any> {

                        constructor(p_key: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                            super(p_key, p_manager);
                        }

                        public internal_create(timePoint: number): org.kevoree.modeling.KView {
                            return new org.kevoree.modeling.meta.impl.GenericView(this._universe, timePoint, this._manager);
                        }

                    }

                    export class GenericView extends org.kevoree.modeling.abs.AbstractKView {

                        constructor(p_universe: number, _time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                            super(p_universe, _time, p_manager);
                        }

                    }

                    export class MetaAttribute implements org.kevoree.modeling.meta.KMetaAttribute {

                        private _name: string;
                        private _index: number;
                        public _precision: number;
                        private _key: boolean;
                        private _attributeTypeId: number;
                        private _extrapolation: org.kevoree.modeling.extrapolation.Extrapolation;
                        public attributeTypeId(): number {
                            return this._attributeTypeId;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.ATTRIBUTE;
                        }

                        public precision(): number {
                            return this._precision;
                        }

                        public key(): boolean {
                            return this._key;
                        }

                        public strategy(): org.kevoree.modeling.extrapolation.Extrapolation {
                            return this._extrapolation;
                        }

                        public setExtrapolation(extrapolation: org.kevoree.modeling.extrapolation.Extrapolation): void {
                            this._extrapolation = extrapolation;
                        }

                        public setPrecision(p_precision: number): void {
                            this._precision = p_precision;
                        }

                        constructor(p_name: string, p_index: number, p_precision: number, p_key: boolean, p_attributeTypeId: number, p_extrapolation: org.kevoree.modeling.extrapolation.Extrapolation) {
                            this._name = p_name;
                            this._index = p_index;
                            this._precision = p_precision;
                            this._key = p_key;
                            this._attributeTypeId = p_attributeTypeId;
                            this._extrapolation = p_extrapolation;
                            if (this._extrapolation == null) {
                                this._extrapolation = org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance();
                            }
                        }

                    }

                    export class MetaClass implements org.kevoree.modeling.meta.KMetaClass {

                        private _name: string;
                        private _index: number;
                        private _meta: org.kevoree.modeling.meta.KMeta[];
                        private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<any> = null;
                        private _alg: org.kevoree.modeling.infer.KInferAlg;
                        private _cachedInputs: org.kevoree.modeling.meta.KMetaInferInput[] = null;
                        private _cachedOutputs: org.kevoree.modeling.meta.KMetaInferOutput[] = null;
                        private _temporalResolution: number = 1;
                        constructor(p_name: string, p_index: number, p_alg: org.kevoree.modeling.infer.KInferAlg) {
                            this._name = p_name;
                            this._index = p_index;
                            this._meta = new Array();
                            this._alg = p_alg;
                            this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            if (this._alg != null) {
                                this.internal_add_meta(new org.kevoree.modeling.meta.impl.MetaDependencies(this._meta.length, this));
                            }
                        }

                        public init(p_metaElements: org.kevoree.modeling.meta.KMeta[]): void {
                            this._indexes.clear();
                            this._meta = p_metaElements;
                            var tempDependencies: org.kevoree.modeling.meta.impl.MetaDependencies = null;
                            for (var i: number = 0; i < this._meta.length; i++) {
                                this._indexes.put(p_metaElements[i].metaName(), p_metaElements[i].index());
                            }
                            this.clearCached();
                        }

                        public metaByName(name: string): org.kevoree.modeling.meta.KMeta {
                            if (this._indexes != null) {
                                var resolvedIndex: number = this._indexes.get(name);
                                if (resolvedIndex != null) {
                                    return this._meta[resolvedIndex];
                                }
                            }
                            return null;
                        }

                        public attribute(name: string): org.kevoree.modeling.meta.KMetaAttribute {
                            var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
                            if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.ATTRIBUTE) {
                                return <org.kevoree.modeling.meta.KMetaAttribute>resolved;
                            }
                            return null;
                        }

                        public reference(name: string): org.kevoree.modeling.meta.KMetaReference {
                            var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
                            if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                return <org.kevoree.modeling.meta.KMetaReference>resolved;
                            }
                            return null;
                        }

                        public operation(name: string): org.kevoree.modeling.meta.KMetaOperation {
                            var resolved: org.kevoree.modeling.meta.KMeta = this.metaByName(name);
                            if (resolved != null && resolved.metaType() == org.kevoree.modeling.meta.MetaType.OUTPUT) {
                                return <org.kevoree.modeling.meta.KMetaOperation>resolved;
                            }
                            return null;
                        }

                        public metaElements(): org.kevoree.modeling.meta.KMeta[] {
                            return this._meta;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.CLASS;
                        }

                        public meta(index: number): org.kevoree.modeling.meta.KMeta {
                            if (index >= 0 && index < this._meta.length) {
                                return this._meta[index];
                            } else {
                                return null;
                            }
                        }

                        public addAttribute(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute {
                            return this.internal_addatt(attributeName, p_type);
                        }

                        private internal_addatt(attributeName: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaAttribute {
                            var precisionCleaned: number = -1;
                            var extrapolation: org.kevoree.modeling.extrapolation.Extrapolation;
                            if (p_type.id() == org.kevoree.modeling.meta.KPrimitiveTypes.CONTINUOUS_ID) {
                                extrapolation = org.kevoree.modeling.extrapolation.impl.PolynomialExtrapolation.instance();
                                precisionCleaned = 0.1;
                            } else {
                                extrapolation = org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance();
                            }
                            var tempAttribute: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute(attributeName, this._meta.length, precisionCleaned, false, p_type.id(), extrapolation);
                            this.internal_add_meta(tempAttribute);
                            return tempAttribute;
                        }

                        public addReference(referenceName: string, p_metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string, toMany: boolean): org.kevoree.modeling.meta.KMetaReference {
                            return this.internal_addref(referenceName, p_metaClass, oppositeName, toMany);
                        }

                        private internal_addref(referenceName: string, p_metaClass: org.kevoree.modeling.meta.KMetaClass, oppositeName: string, toMany: boolean): org.kevoree.modeling.meta.KMetaReference {
                            var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
                            var opName: string = oppositeName;
                            if (opName == null) {
                                opName = "op_" + referenceName;
                                (<org.kevoree.modeling.meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, false, false);
                            } else {
                                (<org.kevoree.modeling.meta.impl.MetaClass>p_metaClass).getOrCreate(opName, referenceName, this, true, false);
                            }
                            var tempReference: org.kevoree.modeling.meta.impl.MetaReference = new org.kevoree.modeling.meta.impl.MetaReference(referenceName, this._meta.length, false, !toMany, p_metaClass.index(), opName, tempOrigin.index());
                            this.internal_add_meta(tempReference);
                            return tempReference;
                        }

                        private getOrCreate(p_name: string, p_oppositeName: string, p_oppositeClass: org.kevoree.modeling.meta.KMetaClass, p_visible: boolean, p_single: boolean): org.kevoree.modeling.meta.KMetaReference {
                            var previous: org.kevoree.modeling.meta.KMetaReference = this.reference(p_name);
                            if (previous != null) {
                                return previous;
                            }
                            var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
                            var tempReference: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference(p_name, this._meta.length, p_visible, p_single, p_oppositeClass.index(), p_oppositeName, tempOrigin.index());
                            this.internal_add_meta(tempReference);
                            return tempReference;
                        }

                        public addOperation(operationName: string): org.kevoree.modeling.meta.KMetaOperation {
                            var tempOrigin: org.kevoree.modeling.meta.KMetaClass = this;
                            var tempOperation: org.kevoree.modeling.meta.impl.MetaOperation = new org.kevoree.modeling.meta.impl.MetaOperation(operationName, this._meta.length, tempOrigin.index());
                            this.internal_add_meta(tempOperation);
                            return tempOperation;
                        }

                        public inferAlg(): org.kevoree.modeling.infer.KInferAlg {
                            return this._alg;
                        }

                        public addDependency(dependencyName: string, referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency {
                            var currentDeps: org.kevoree.modeling.meta.KMetaDependencies = this.dependencies();
                            if (currentDeps != null) {
                                return currentDeps.addDependency(dependencyName, referredMetaClassIndex);
                            }
                            return null;
                        }

                        public addInput(p_name: string, p_extractor: string): org.kevoree.modeling.meta.KMetaInferInput {
                            var newInput: org.kevoree.modeling.meta.KMetaInferInput = new org.kevoree.modeling.meta.impl.MetaInferInput(p_name, this._meta.length, p_extractor);
                            this.internal_add_meta(newInput);
                            return newInput;
                        }

                        public addOutput(p_name: string, p_type: org.kevoree.modeling.KType): org.kevoree.modeling.meta.KMetaInferOutput {
                            var newOutput: org.kevoree.modeling.meta.KMetaInferOutput = new org.kevoree.modeling.meta.impl.MetaInferOutput(p_name, this._meta.length, p_type.id());
                            this.internal_add_meta(newOutput);
                            return newOutput;
                        }

                        public dependencies(): org.kevoree.modeling.meta.KMetaDependencies {
                            return <org.kevoree.modeling.meta.KMetaDependencies>this.metaByName(org.kevoree.modeling.meta.impl.MetaDependencies.DEPENDENCIES_NAME);
                        }

                        public inputs(): org.kevoree.modeling.meta.KMetaInferInput[] {
                            if (this._cachedInputs == null) {
                                this.cacheInputs();
                            }
                            return this._cachedInputs;
                        }

                        private cacheInputs(): void {
                            var nb: number = 0;
                            for (var i: number = 0; i < this._meta.length; i++) {
                                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.INPUT)) {
                                    nb++;
                                }
                            }
                            this._cachedInputs = new Array();
                            nb = 0;
                            for (var i: number = 0; i < this._meta.length; i++) {
                                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.INPUT)) {
                                    this._cachedInputs[nb] = <org.kevoree.modeling.meta.KMetaInferInput>this._meta[i];
                                    nb++;
                                }
                            }
                        }

                        public outputs(): org.kevoree.modeling.meta.KMetaInferOutput[] {
                            if (this._cachedOutputs == null) {
                                this.cacheOuputs();
                            }
                            return this._cachedOutputs;
                        }

                        public temporalResolution(): number {
                            return this._temporalResolution;
                        }

                        public setTemporalResolution(p_tempo: number): void {
                            this._temporalResolution = p_tempo;
                        }

                        private cacheOuputs(): void {
                            var nb: number = 0;
                            for (var i: number = 0; i < this._meta.length; i++) {
                                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.OUTPUT)) {
                                    nb++;
                                }
                            }
                            this._cachedOutputs = new Array();
                            nb = 0;
                            for (var i: number = 0; i < this._meta.length; i++) {
                                if (this._meta[i].metaType().equals(org.kevoree.modeling.meta.MetaType.OUTPUT)) {
                                    this._cachedOutputs[nb] = <org.kevoree.modeling.meta.KMetaInferOutput>this._meta[i];
                                    nb++;
                                }
                            }
                        }

                        private clearCached(): void {
                            this._cachedOutputs = null;
                            this._cachedInputs = null;
                        }

                        private internal_add_meta(p_new_meta: org.kevoree.modeling.meta.KMeta): void {
                             this.clearCached();
                             this._meta[p_new_meta.index()] = p_new_meta;
                             this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
                        }

                    }

                    export class MetaDependencies implements org.kevoree.modeling.meta.KMetaDependencies {

                        private _origin: org.kevoree.modeling.meta.KMetaClass;
                        private _dependencies: org.kevoree.modeling.meta.KMetaDependency[];
                        public static DEPENDENCIES_NAME: string = "allDependencies";
                        private _index: number;
                        private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<any> = null;
                        constructor(p_index: number, p_origin: org.kevoree.modeling.meta.KMetaClass) {
                            this._index = p_index;
                            this._origin = p_origin;
                            this._dependencies = new Array();
                            this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        }

                        public origin(): org.kevoree.modeling.meta.KMetaClass {
                            return this._origin;
                        }

                        public allDependencies(): org.kevoree.modeling.meta.KMetaDependency[] {
                            return this._dependencies;
                        }

                        public dependencyByName(dependencyName: string): org.kevoree.modeling.meta.KMetaDependency {
                            var foundedIndex: number = this._indexes.get(dependencyName);
                            if (foundedIndex != null) {
                                return this._dependencies[foundedIndex];
                            } else {
                                return null;
                            }
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return MetaDependencies.DEPENDENCIES_NAME;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.DEPENDENCIES;
                        }

                        public addDependency(p_dependencyName: string, p_referredMetaClassIndex: number): org.kevoree.modeling.meta.KMetaDependency {
                            var newDependency: org.kevoree.modeling.meta.KMetaDependency = new org.kevoree.modeling.meta.impl.MetaDependency(p_dependencyName, this._dependencies.length, this, p_referredMetaClassIndex);
                            this.internal_add_dep(newDependency);
                            return newDependency;
                        }

                        private internal_add_dep(p_new_meta: org.kevoree.modeling.meta.KMetaDependency): void {
                             this._dependencies[p_new_meta.index()] = p_new_meta;
                             this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
                        }

                    }

                    export class MetaDependency implements org.kevoree.modeling.meta.KMetaDependency {

                        private _name: string;
                        private _index: number;
                        private _referredMetaClassIndex: number;
                        public referredMetaClassIndex(): number {
                            return this._referredMetaClassIndex;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.DEPENDENCY;
                        }

                        constructor(p_name: string, p_index: number, p_origin: org.kevoree.modeling.meta.KMetaDependencies, p_referredMetaClassIndex: number) {
                            this._name = p_name;
                            this._index = p_index;
                            this._referredMetaClassIndex = p_referredMetaClassIndex;
                        }

                    }

                    export class MetaEnum implements org.kevoree.modeling.meta.KMetaEnum {

                        private _name: string;
                        private _index: number;
                        private _literals: org.kevoree.modeling.meta.KLiteral[];
                        private _indexes: org.kevoree.modeling.memory.chunk.KStringMap<any> = null;
                        constructor(p_name: string, p_index: number) {
                            this._name = p_name;
                            this._index = p_index;
                            this._literals = new Array();
                            this._indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        }

                        public init(lits: org.kevoree.modeling.meta.KLiteral[]): void {
                            this._literals = lits;
                            for (var i: number = 0; i < lits.length; i++) {
                                this._indexes.put(lits[i].metaName(), lits[i].index());
                            }
                        }

                        public literals(): org.kevoree.modeling.meta.KLiteral[] {
                            return this._literals;
                        }

                        public literalByName(p_name: string): org.kevoree.modeling.meta.KLiteral {
                            if (this._indexes != null) {
                                var resolvedIndex: number = this._indexes.get(p_name);
                                if (resolvedIndex != null) {
                                    return this._literals[resolvedIndex];
                                }
                            }
                            return null;
                        }

                        public literal(p_index: number): org.kevoree.modeling.meta.KLiteral {
                            return this._literals[p_index];
                        }

                        public addLiteral(p_name: string): org.kevoree.modeling.meta.KLiteral {
                            var newLiteral: org.kevoree.modeling.meta.impl.MetaLiteral = new org.kevoree.modeling.meta.impl.MetaLiteral(p_name, this._literals.length, this._name);
                            this.internal_add_meta(newLiteral);
                            return newLiteral;
                        }

                        public name(): string {
                            return this._name;
                        }

                        public isEnum(): boolean {
                            return true;
                        }

                        public id(): number {
                            return this._index;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.ENUM;
                        }

                        private internal_add_meta(p_new_meta: org.kevoree.modeling.meta.KLiteral): void {
                             this._literals[p_new_meta.index()] = p_new_meta;
                             this._indexes.put(p_new_meta.metaName(), p_new_meta.index());
                        }

                    }

                    export class MetaInferInput implements org.kevoree.modeling.meta.KMetaInferInput {

                        private _name: string;
                        private _index: number;
                        private _extractor: string;
                        private _cachedTraversal: org.kevoree.modeling.traversal.KTraversal;
                        constructor(p_name: string, p_index: number, p_extractor: string) {
                            this._name = p_name;
                            this._index = p_index;
                            this._extractor = p_extractor;
                        }

                        public extractorQuery(): string {
                            return this._extractor;
                        }

                        public extractor(): org.kevoree.modeling.traversal.KTraversal {
                            if (this._cachedTraversal != null) {
                                return this._cachedTraversal;
                            } else {
                                return this.cacheTraversal();
                            }
                        }

                        private cacheTraversal(): org.kevoree.modeling.traversal.KTraversal {
                            this._cachedTraversal = org.kevoree.modeling.traversal.query.impl.QueryEngine.getINSTANCE().buildTraversal(this._extractor);
                            return this._cachedTraversal;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.INPUT;
                        }

                    }

                    export class MetaInferOutput implements org.kevoree.modeling.meta.KMetaInferOutput {

                        private _name: string;
                        private _index: number;
                        private _type: number;
                        constructor(p_name: string, p_index: number, p_type: number) {
                            this._name = p_name;
                            this._index = p_index;
                            this._type = p_type;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.OUTPUT;
                        }

                        public attributeTypeId(): number {
                            return this._type;
                        }

                    }

                    export class MetaLiteral implements org.kevoree.modeling.meta.KLiteral {

                        private _name: string;
                        private _index: number;
                        private _className: string;
                        constructor(p_name: string, p_index: number, p_className: string) {
                            this._name = p_name;
                            this._index = p_index;
                            this._className = p_className;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.LITERAL;
                        }

                        public toString(): string {
                            return "KLiteral@" + this._className + "." + this._name;
                        }

                    }

                    export class MetaModel implements org.kevoree.modeling.meta.KMetaModel {

                        private _name: string;
                        private _index: number;
                        private _metaClasses: org.kevoree.modeling.meta.KMetaClass[];
                        private _metaClasses_indexes: org.kevoree.modeling.memory.chunk.KStringMap<any> = null;
                        private _metaTypes: org.kevoree.modeling.meta.KMetaEnum[];
                        private _metaTypes_indexes: org.kevoree.modeling.memory.chunk.KStringMap<any> = null;
                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.MODEL;
                        }

                        constructor(p_name: string) {
                            this._name = p_name;
                            this._index = 0;
                            this._metaClasses = new Array();
                            this._metaTypes = new Array();
                            this._metaClasses_indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            this._metaTypes_indexes = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        }

                        public init(p_metaClasses: org.kevoree.modeling.meta.KMetaClass[], p_metaEnums: org.kevoree.modeling.meta.KMetaEnum[]): void {
                            this._metaClasses_indexes.clear();
                            this._metaTypes_indexes.clear();
                            this._metaClasses = p_metaClasses;
                            this._metaTypes = p_metaEnums;
                            for (var i: number = 0; i < this._metaClasses.length; i++) {
                                this._metaClasses_indexes.put(p_metaClasses[i].metaName(), p_metaClasses[i].index());
                            }
                            for (var i: number = 0; i < this._metaTypes.length; i++) {
                                this._metaTypes_indexes.put(p_metaEnums[i].metaName(), p_metaEnums[i].index());
                            }
                        }

                        public metaClasses(): org.kevoree.modeling.meta.KMetaClass[] {
                            return this._metaClasses;
                        }

                        public metaClassByName(name: string): org.kevoree.modeling.meta.KMetaClass {
                            if (this._metaClasses_indexes == null) {
                                return null;
                            }
                            var resolved: number = this._metaClasses_indexes.get(name);
                            if (resolved == null) {
                                return null;
                            } else {
                                return this._metaClasses[resolved];
                            }
                        }

                        public metaClass(index: number): org.kevoree.modeling.meta.KMetaClass {
                            if (index >= 0 && index < this._metaClasses.length) {
                                return this._metaClasses[index];
                            }
                            return null;
                        }

                        public addMetaClass(metaClassName: string): org.kevoree.modeling.meta.KMetaClass {
                            return this.internal_addmetaclass(metaClassName, null);
                        }

                        public addInferMetaClass(metaClassName: string, inferAlg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass {
                            return this.internal_addmetaclass(metaClassName, inferAlg);
                        }

                        public metaTypes(): org.kevoree.modeling.meta.KMetaEnum[] {
                            return this._metaTypes;
                        }

                        public metaTypeByName(p_name: string): org.kevoree.modeling.meta.KMetaEnum {
                            if (this._metaTypes == null) {
                                return null;
                            }
                            var resolved: number = this._metaTypes_indexes.get(p_name);
                            if (resolved == null) {
                                return null;
                            } else {
                                return this._metaTypes[resolved];
                            }
                        }

                        public addMetaEnum(enumName: string): org.kevoree.modeling.meta.KMetaEnum {
                            var newEnumType: org.kevoree.modeling.meta.KMetaEnum = new org.kevoree.modeling.meta.impl.MetaEnum(enumName, this._metaTypes.length);
                            this.internal_add_type(newEnumType);
                            return newEnumType;
                        }

                        private internal_addmetaclass(metaClassName: string, alg: org.kevoree.modeling.infer.KInferAlg): org.kevoree.modeling.meta.KMetaClass {
                            if (this._metaClasses_indexes.contains(metaClassName)) {
                                return this.metaClassByName(metaClassName);
                            } else {
                                if (this._metaClasses == null) {
                                    this._metaClasses = new Array();
                                    this._metaClasses[0] = new org.kevoree.modeling.meta.impl.MetaClass(metaClassName, 0, alg);
                                    this._metaClasses_indexes.put(metaClassName, this._metaClasses[0].index());
                                    return this._metaClasses[0];
                                } else {
                                    var newMetaClass: org.kevoree.modeling.meta.KMetaClass = new org.kevoree.modeling.meta.impl.MetaClass(metaClassName, this._metaClasses.length, alg);
                                    this.internal_add_meta_class(newMetaClass);
                                    return newMetaClass;
                                }
                            }
                        }

                        private internal_add_meta_class(p_newMetaClass: org.kevoree.modeling.meta.KMetaClass): void {
                             this._metaClasses[p_newMetaClass.index()] = p_newMetaClass;
                             this._metaClasses_indexes.put(p_newMetaClass.metaName(), p_newMetaClass.index());
                        }

                        private internal_add_type(p_newType: org.kevoree.modeling.meta.KMetaEnum): void {
                             this._metaTypes[p_newType.index()] = p_newType;
                             this._metaTypes_indexes.put(p_newType.metaName(), p_newType.index());
                        }

                        public createModel(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager): org.kevoree.modeling.KModel<any> {
                            return new org.kevoree.modeling.meta.impl.GenericModel(this, p_manager);
                        }

                    }

                    export class MetaOperation implements org.kevoree.modeling.meta.KMetaOperation {

                        private _name: string;
                        private _index: number;
                        private _originMetaClassIndex: number;
                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.OPERATION;
                        }

                        public originMetaClassIndex(): number {
                            return this._originMetaClassIndex;
                        }

                        constructor(p_name: string, p_index: number, p_originMetaClassIndex: number) {
                            this._name = p_name;
                            this._index = p_index;
                            this._originMetaClassIndex = p_originMetaClassIndex;
                        }

                    }

                    export class MetaReference implements org.kevoree.modeling.meta.KMetaReference {

                        private _name: string;
                        private _index: number;
                        private _visible: boolean;
                        private _single: boolean;
                        private _referredMetaClassIndex: number;
                        private _op_name: string;
                        private _originMetaClassIndex: number;
                        public single(): boolean {
                            return this._single;
                        }

                        public referredMetaClassIndex(): number {
                            return this._referredMetaClassIndex;
                        }

                        public oppositeName(): string {
                            return this._op_name;
                        }

                        public originMetaClassIndex(): number {
                            return this._originMetaClassIndex;
                        }

                        public index(): number {
                            return this._index;
                        }

                        public metaName(): string {
                            return this._name;
                        }

                        public metaType(): org.kevoree.modeling.meta.MetaType {
                            return org.kevoree.modeling.meta.MetaType.REFERENCE;
                        }

                        public visible(): boolean {
                            return this._visible;
                        }

                        constructor(p_name: string, p_index: number, p_visible: boolean, p_single: boolean, p_referredMetaClassIndex: number, op_name: string, p_originMetaClassIndex: number) {
                            this._name = p_name;
                            this._index = p_index;
                            this._visible = p_visible;
                            this._single = p_single;
                            this._referredMetaClassIndex = p_referredMetaClassIndex;
                            this._op_name = op_name;
                            this._originMetaClassIndex = p_originMetaClassIndex;
                        }

                    }

                }
            }
            export module operation {
                export interface KOperationManager {

                    registerOperation(operation: org.kevoree.modeling.meta.KMetaOperation, callback: org.kevoree.modeling.KOperation<any, any>, target: org.kevoree.modeling.KObject): void;

                    call(source: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.meta.KMetaOperation, param: any[], callback: org.kevoree.modeling.KCallback<any>): void;

                    operationEventReceived(operationEvent: org.kevoree.modeling.message.KMessage): void;

                }

                export module impl {
                    export class HashOperationManager implements org.kevoree.modeling.operation.KOperationManager {

                        private staticOperations: org.kevoree.modeling.memory.chunk.KIntMap<any>;
                        private instanceOperations: org.kevoree.modeling.memory.chunk.KLongMap<any>;
                        private remoteCallCallbacks: org.kevoree.modeling.memory.chunk.KLongMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                        private _manager: org.kevoree.modeling.memory.manager.KDataManager;
                        private _callbackId: number = 0;
                        constructor(p_manager: org.kevoree.modeling.memory.manager.KDataManager) {
                            this.staticOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            this.instanceOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                            this._manager = p_manager;
                        }

                        public registerOperation(operation: org.kevoree.modeling.meta.KMetaOperation, callback: org.kevoree.modeling.KOperation<any, any>, target: org.kevoree.modeling.KObject): void {
                            if (target == null) {
                                var clazzOperations: org.kevoree.modeling.memory.chunk.KIntMap<any> = this.staticOperations.get(operation.originMetaClassIndex());
                                if (clazzOperations == null) {
                                    clazzOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    this.staticOperations.put(operation.originMetaClassIndex(), clazzOperations);
                                }
                                clazzOperations.put(operation.index(), callback);
                            } else {
                                var objectOperations: org.kevoree.modeling.memory.chunk.KIntMap<any> = this.instanceOperations.get(target.uuid());
                                if (objectOperations == null) {
                                    objectOperations = new org.kevoree.modeling.memory.chunk.impl.ArrayIntMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    this.instanceOperations.put(target.uuid(), objectOperations);
                                }
                                objectOperations.put(operation.index(), callback);
                            }
                        }

                        private searchOperation(source: number, clazz: number, operation: number): org.kevoree.modeling.KOperation<any, any> {
                            var objectOperations: org.kevoree.modeling.memory.chunk.KIntMap<any> = this.instanceOperations.get(source);
                            if (objectOperations != null) {
                                return objectOperations.get(operation);
                            }
                            var clazzOperations: org.kevoree.modeling.memory.chunk.KIntMap<any> = this.staticOperations.get(clazz);
                            if (clazzOperations != null) {
                                return clazzOperations.get(operation);
                            }
                            return null;
                        }

                        public call(source: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.meta.KMetaOperation, param: any[], callback: org.kevoree.modeling.KCallback<any>): void {
                            var operationCore: org.kevoree.modeling.KOperation<any, any> = this.searchOperation(source.uuid(), operation.originMetaClassIndex(), operation.index());
                            if (operationCore != null) {
                                operationCore(source, param, callback);
                            } else {
                                this.sendToRemote(source, operation, param, callback);
                            }
                        }

                        private sendToRemote(source: org.kevoree.modeling.KObject, operation: org.kevoree.modeling.meta.KMetaOperation, param: any[], callback: org.kevoree.modeling.KCallback<any>): void {
                            var stringParams: string[] = new Array();
                            for (var i: number = 0; i < param.length; i++) {
                                stringParams[i] = param[i].toString();
                            }
                            var operationCall: org.kevoree.modeling.message.impl.OperationCallMessage = new org.kevoree.modeling.message.impl.OperationCallMessage();
                            operationCall.id = this.nextKey();
                            operationCall.key = new Float64Array([source.universe(), source.now(), source.uuid()]);
                            operationCall.classIndex = source.metaClass().index();
                            operationCall.opIndex = operation.index();
                            operationCall.params = stringParams;
                            this.remoteCallCallbacks.put(operationCall.id, callback);
                        }

                        public nextKey(): number {
                            if (this._callbackId == org.kevoree.modeling.KConfig.CALLBACK_HISTORY) {
                                this._callbackId = 0;
                            } else {
                                this._callbackId++;
                            }
                            return this._callbackId;
                        }

                        public operationEventReceived(operationEvent: org.kevoree.modeling.message.KMessage): void {
                            if (operationEvent.type() == org.kevoree.modeling.message.KMessageLoader.OPERATION_RESULT_TYPE) {
                                var operationResult: org.kevoree.modeling.message.impl.OperationResultMessage = <org.kevoree.modeling.message.impl.OperationResultMessage>operationEvent;
                                var cb: org.kevoree.modeling.KCallback<any> = this.remoteCallCallbacks.get(operationResult.id);
                                if (cb != null) {
                                    cb(operationResult.value);
                                }
                            } else {
                                if (operationEvent.type() == org.kevoree.modeling.message.KMessageLoader.OPERATION_CALL_TYPE) {
                                    var operationCall: org.kevoree.modeling.message.impl.OperationCallMessage = <org.kevoree.modeling.message.impl.OperationCallMessage>operationEvent;
                                    var sourceKey: Float64Array = operationCall.key;
                                    var operationCore: org.kevoree.modeling.KOperation<any, any> = this.searchOperation(sourceKey[2], operationCall.classIndex, operationCall.opIndex);
                                    if (operationCore != null) {
                                        var view: org.kevoree.modeling.KView = this._manager.model().universe(sourceKey[0]).time(sourceKey[1]);
                                        view.lookup(sourceKey[2],  (kObject : org.kevoree.modeling.KObject) => {
                                            if (kObject != null) {
                                                operationCore(kObject, operationCall.params,  (o : any) => {
                                                });
                                            }
                                        });
                                    }
                                } else {
                                    console.error("BAD ROUTING !");;
                                }
                            }
                        }

                    }

                }
            }
            export module scheduler {
                export interface KScheduler {

                    dispatch(runnable: java.lang.Runnable): void;

                    stop(): void;

                }

                export module impl {
                    export class DirectScheduler implements org.kevoree.modeling.scheduler.KScheduler {

                        public dispatch(runnable: java.lang.Runnable): void {
                            runnable.run();
                        }

                        public stop(): void {
                        }

                    }

                    export class ExecutorServiceScheduler implements org.kevoree.modeling.scheduler.KScheduler {

                        public dispatch(p_runnable: java.lang.Runnable): void {
                             p_runnable.run();
                        }

                        public stop(): void {
                        }

                    }

                }
            }
            export module traversal {
                export interface KTraversal {

                    traverse(metaReference: org.kevoree.modeling.meta.KMetaReference): org.kevoree.modeling.traversal.KTraversal;

                    traverseQuery(metaReferenceQuery: string): org.kevoree.modeling.traversal.KTraversal;

                    attributeQuery(attributeQuery: string): org.kevoree.modeling.traversal.KTraversal;

                    withAttribute(attribute: org.kevoree.modeling.meta.KMetaAttribute, expectedValue: any): org.kevoree.modeling.traversal.KTraversal;

                    withoutAttribute(attribute: org.kevoree.modeling.meta.KMetaAttribute, expectedValue: any): org.kevoree.modeling.traversal.KTraversal;

                    filter(filter: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;

                    then(cb: org.kevoree.modeling.KCallback<any>): void;

                    eval(expression: string, callback: org.kevoree.modeling.KCallback<any>): void;

                    map(attribute: org.kevoree.modeling.meta.KMetaAttribute, cb: org.kevoree.modeling.KCallback<any>): void;

                    collect(metaReference: org.kevoree.modeling.meta.KMetaReference, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;

                    traverseTime(timeOffset: number, steps: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;

                    traverseUniverse(universeOffset: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal;

                    traverseIndex(indexName: string): org.kevoree.modeling.traversal.KTraversal;

                    exec(origins: org.kevoree.modeling.KObject[], resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver, callback: org.kevoree.modeling.KCallback<any>): void;

                }

                export interface KTraversalAction {

                    chain(next: org.kevoree.modeling.traversal.KTraversalAction): void;

                    execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void;

                }

                export interface KTraversalActionContext {

                    inputObjects(): org.kevoree.modeling.KObject[];

                    setInputObjects(newSet: org.kevoree.modeling.KObject[]): void;

                    indexResolver(): org.kevoree.modeling.traversal.KTraversalIndexResolver;

                    finalCallback(): org.kevoree.modeling.KCallback<any>;

                }

                export interface KTraversalFilter {

                    (obj: org.kevoree.modeling.KObject): boolean;

                }

                export interface KTraversalIndexResolver {

                    (indexName: string): org.kevoree.modeling.KObject[];

                }

                export module impl {
                    export class Traversal implements org.kevoree.modeling.traversal.KTraversal {

                        private static TERMINATED_MESSAGE: string = "Traversal is terminated by the call of done method, please create another promise";
                        private _initObjs: org.kevoree.modeling.KObject[];
                        private _initAction: org.kevoree.modeling.traversal.KTraversalAction;
                        private _lastAction: org.kevoree.modeling.traversal.KTraversalAction;
                        private _terminated: boolean = false;
                        constructor(p_roots: org.kevoree.modeling.KObject[]) {
                            this._initObjs = p_roots;
                        }

                        private internal_chain_action(p_action: org.kevoree.modeling.traversal.KTraversalAction): org.kevoree.modeling.traversal.KTraversal {
                            if (this._terminated) {
                                throw new Error(Traversal.TERMINATED_MESSAGE);
                            }
                            if (this._initAction == null) {
                                this._initAction = p_action;
                            }
                            if (this._lastAction != null) {
                                this._lastAction.chain(p_action);
                            }
                            this._lastAction = p_action;
                            return this;
                        }

                        public traverse(p_metaReference: org.kevoree.modeling.meta.KMetaReference): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseAction(p_metaReference));
                        }

                        public traverseQuery(p_metaReferenceQuery: string): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseQueryAction(p_metaReferenceQuery));
                        }

                        public withAttribute(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAttributeAction(p_attribute, p_expectedValue));
                        }

                        public withoutAttribute(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterNotAttributeAction(p_attribute, p_expectedValue));
                        }

                        public attributeQuery(p_attributeQuery: string): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction(p_attributeQuery));
                        }

                        public filter(p_filter: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.FilterAction(p_filter));
                        }

                        public collect(metaReference: org.kevoree.modeling.meta.KMetaReference, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.DeepCollectAction(metaReference, continueCondition));
                        }

                        public traverseIndex(p_indexName: string): org.kevoree.modeling.traversal.KTraversal {
                            return this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.TraverseIndexAction(p_indexName));
                        }

                        public traverseTime(timeOffset: number, steps: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
                            throw new Error("Not Implemented Yet!");
                        }

                        public traverseUniverse(universeOffset: number, continueCondition: org.kevoree.modeling.traversal.KTraversalFilter): org.kevoree.modeling.traversal.KTraversal {
                            throw new Error("Not Implemented Yet!");
                        }

                        public then(cb: org.kevoree.modeling.KCallback<any>): void {
                            if (this._initObjs != null) {
                                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null,  (objects : any[]) => {
                                    cb(<org.kevoree.modeling.KObject[]>objects);
                                }));
                            }
                        }

                        public eval(p_expression: string, callback: org.kevoree.modeling.KCallback<any>): void {
                            this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.MathExpressionAction(p_expression));
                            this._terminated = true;
                            if (this._initObjs != null) {
                                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null, callback));
                            }
                        }

                        public map(attribute: org.kevoree.modeling.meta.KMetaAttribute, cb: org.kevoree.modeling.KCallback<any>): void {
                            this.internal_chain_action(new org.kevoree.modeling.traversal.impl.actions.MapAction(attribute));
                            this._terminated = true;
                            if (this._initObjs != null) {
                                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(this._initObjs, null, cb));
                            }
                        }

                        public exec(origins: org.kevoree.modeling.KObject[], resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver, callback: org.kevoree.modeling.KCallback<any>): void {
                            if (this._initObjs == null) {
                                this._initAction.execute(new org.kevoree.modeling.traversal.impl.TraversalContext(origins, resolver, callback));
                            }
                        }

                    }

                    export class TraversalContext implements org.kevoree.modeling.traversal.KTraversalActionContext {

                        private _inputs: org.kevoree.modeling.KObject[];
                        private _resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver;
                        private _finalCallback: org.kevoree.modeling.KCallback<any>;
                        constructor(_inputs: org.kevoree.modeling.KObject[], _resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver, p_finalCallback: org.kevoree.modeling.KCallback<any>) {
                            this._inputs = _inputs;
                            this._resolver = _resolver;
                            this._finalCallback = p_finalCallback;
                        }

                        public inputObjects(): org.kevoree.modeling.KObject[] {
                            return this._inputs;
                        }

                        public setInputObjects(p_newSet: org.kevoree.modeling.KObject[]): void {
                            this._inputs = p_newSet;
                        }

                        public indexResolver(): org.kevoree.modeling.traversal.KTraversalIndexResolver {
                            return this._resolver;
                        }

                        public finalCallback(): org.kevoree.modeling.KCallback<any> {
                            return this._finalCallback;
                        }

                    }

                    export module actions {
                        export class DeepCollectAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _reference: org.kevoree.modeling.meta.KMetaReference;
                            private _continueCondition: org.kevoree.modeling.traversal.KTraversalFilter;
                            private _alreadyPassed: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any> = null;
                            private _finalElements: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any> = null;
                            constructor(p_reference: org.kevoree.modeling.meta.KMetaReference, p_continueCondition: org.kevoree.modeling.traversal.KTraversalFilter) {
                                this._reference = p_reference;
                                this._continueCondition = p_continueCondition;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    this._alreadyPassed = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    this._finalElements = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    var filtered_inputs: org.kevoree.modeling.KObject[] = new Array();
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        if (this._continueCondition == null || this._continueCondition(context.inputObjects()[i])) {
                                            filtered_inputs[i] = context.inputObjects()[i];
                                            this._alreadyPassed.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                                        }
                                    }
                                    var iterationCallbacks: org.kevoree.modeling.KCallback<any>[] = new Array();
                                    iterationCallbacks[0] =  (traversed : org.kevoree.modeling.KObject[]) => {
                                        var filtered_inputs2: org.kevoree.modeling.KObject[] = new Array();
                                        var nbSize: number = 0;
                                        for (var i: number = 0; i < traversed.length; i++) {
                                            if ((this._continueCondition == null || this._continueCondition(traversed[i])) && !this._alreadyPassed.contains(traversed[i].uuid())) {
                                                filtered_inputs2[i] = traversed[i];
                                                this._alreadyPassed.put(traversed[i].uuid(), traversed[i]);
                                                this._finalElements.put(traversed[i].uuid(), traversed[i]);
                                                nbSize++;
                                            }
                                        }
                                        if (nbSize > 0) {
                                            this.executeStep(filtered_inputs2, iterationCallbacks[0]);
                                        } else {
                                            var trimmed: org.kevoree.modeling.KObject[] = new Array();
                                            var nbInserted: Int32Array = new Int32Array([0]);
                                            this._finalElements.each( (key : number, value : org.kevoree.modeling.KObject) => {
                                                trimmed[nbInserted[0]] = value;
                                                nbInserted[0]++;
                                            });
                                            if (this._next == null) {
                                                context.finalCallback()(trimmed);
                                            } else {
                                                context.setInputObjects(trimmed);
                                                this._next.execute(context);
                                            }
                                        }
                                    };
                                    this.executeStep(filtered_inputs, iterationCallbacks[0]);
                                }
                            }

                            private executeStep(p_inputStep: org.kevoree.modeling.KObject[], private_callback: org.kevoree.modeling.KCallback<any>): void {
                                var currentObject: org.kevoree.modeling.abs.AbstractKObject = null;
                                var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                for (var i: number = 0; i < p_inputStep.length; i++) {
                                    if (p_inputStep[i] != null) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>p_inputStep[i];
                                            currentObject = loopObj;
                                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                            if (raw != null) {
                                                if (this._reference == null) {
                                                    var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                                    for (var j: number = 0; j < metaElements.length; j++) {
                                                        if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                            var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                                                            if (resolved != null) {
                                                                for (var k: number = 0; k < resolved.length; k++) {
                                                                    nextIds.put(resolved[k], resolved[k]);
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    var translatedRef: org.kevoree.modeling.meta.KMetaReference = loopObj.internal_transpose_ref(this._reference);
                                                    if (translatedRef != null) {
                                                        var resolved: Float64Array = raw.getLongArray(translatedRef.index(), loopObj.metaClass());
                                                        if (resolved != null) {
                                                            for (var j: number = 0; j < resolved.length; j++) {
                                                                nextIds.put(resolved[j], resolved[j]);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                }
                                var trimmed: Float64Array = new Float64Array(nextIds.size());
                                var inserted: Int32Array = new Int32Array([0]);
                                nextIds.each( (key : number, value : number) => {
                                    trimmed[inserted[0]] = key;
                                    inserted[0]++;
                                });
                                currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed,  (kObjects : org.kevoree.modeling.KObject[]) => {
                                    private_callback(kObjects);
                                });
                            }

                        }

                        export class FilterAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _filter: org.kevoree.modeling.traversal.KTraversalFilter;
                            constructor(p_filter: org.kevoree.modeling.traversal.KTraversalFilter) {
                                this._filter = p_filter;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                var selectedIndex: boolean[] = new Array();
                                var selected: number = 0;
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    try {
                                        if (this._filter(context.inputObjects()[i])) {
                                            selectedIndex[i] = true;
                                            selected++;
                                        }
                                    } catch ($ex$) {
                                        if ($ex$ instanceof Error) {
                                            var e: Error = <Error>$ex$;
                                            console.error(e['stack']);;
                                        } else {
                                            throw $ex$;
                                        }
                                    }
                                }
                                var nextStepElement: org.kevoree.modeling.KObject[] = new Array();
                                var inserted: number = 0;
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    if (selectedIndex[i]) {
                                        nextStepElement[inserted] = context.inputObjects()[i];
                                        inserted++;
                                    }
                                }
                                if (this._next == null) {
                                    context.finalCallback()(nextStepElement);
                                } else {
                                    context.setInputObjects(nextStepElement);
                                    this._next.execute(context);
                                }
                            }

                        }

                        export class FilterAttributeAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
                            private _expectedValue: any;
                            constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any) {
                                this._attribute = p_attribute;
                                this._expectedValue = p_expectedValue;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    var selectedIndexes: boolean[] = new Array();
                                    var nbSelected: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = (loopObj)._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                            if (raw != null) {
                                                if (this._attribute == null) {
                                                    if (this._expectedValue == null) {
                                                        selectedIndexes[i] = true;
                                                        nbSelected++;
                                                    } else {
                                                        var addToNext: boolean = false;
                                                        var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                                        for (var j: number = 0; j < metaElements.length; j++) {
                                                            if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                                                                var resolved: any = raw.getPrimitiveType(metaElements[j].index(), loopObj.metaClass());
                                                                if (resolved == null) {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                                        addToNext = true;
                                                                    }
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                                        addToNext = true;
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                            addToNext = true;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (addToNext) {
                                                            selectedIndexes[i] = true;
                                                            nbSelected++;
                                                        }
                                                    }
                                                } else {
                                                    var translatedAtt: org.kevoree.modeling.meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                                                    if (translatedAtt != null) {
                                                        var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                                                        if (this._expectedValue == null) {
                                                            if (resolved == null) {
                                                                selectedIndexes[i] = true;
                                                                nbSelected++;
                                                            }
                                                        } else {
                                                            if (resolved == null) {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                                    selectedIndexes[i] = true;
                                                                    nbSelected++;
                                                                }
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                                    selectedIndexes[i] = true;
                                                                    nbSelected++;
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                        selectedIndexes[i] = true;
                                                                        nbSelected++;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                console.error("WARN: Empty KObject " + loopObj.uuid());;
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    var nextStepElement: org.kevoree.modeling.KObject[] = new Array();
                                    var inserted: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        if (selectedIndexes[i]) {
                                            nextStepElement[inserted] = context.inputObjects()[i];
                                            inserted++;
                                        }
                                    }
                                    if (this._next == null) {
                                        context.finalCallback()(nextStepElement);
                                    } else {
                                        context.setInputObjects(nextStepElement);
                                        this._next.execute(context);
                                    }
                                }
                            }

                        }

                        export class FilterAttributeQueryAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _attributeQuery: string;
                            constructor(p_attributeQuery: string) {
                                this._attributeQuery = p_attributeQuery;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    var selectedIndexes: boolean[] = new Array();
                                    var nbSelected: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                                            if (this._attributeQuery == null) {
                                                selectedIndexes[i] = true;
                                                nbSelected++;
                                            } else {
                                                var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                                var params: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = this.buildParams(this._attributeQuery);
                                                var selectedForNext: boolean[] = [true];
                                                params.each( (key : string, param : org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam) => {
                                                    for (var j: number = 0; j < metaElements.length; j++) {
                                                        if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                                                            var metaAttribute: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[j];
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaAttribute.metaName(), "^" + param.name() + "$")) {
                                                                var o_raw: any = loopObj.get(metaAttribute);
                                                                if (o_raw != null) {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "null")) {
                                                                        if (!param.isNegative()) {
                                                                            selectedForNext[0] = false;
                                                                        }
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.matches(o_raw.toString(), "^" + param.value() + "$")) {
                                                                            if (param.isNegative()) {
                                                                                selectedForNext[0] = false;
                                                                            }
                                                                        } else {
                                                                            if (!param.isNegative()) {
                                                                                selectedForNext[0] = false;
                                                                            }
                                                                        }
                                                                    }
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "null") || org.kevoree.modeling.util.PrimitiveHelper.equals(param.value(), "*")) {
                                                                        if (param.isNegative()) {
                                                                            selectedForNext[0] = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                });
                                                if (selectedForNext[0]) {
                                                    selectedIndexes[i] = true;
                                                    nbSelected++;
                                                }
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    var nextStepElement: org.kevoree.modeling.KObject[] = new Array();
                                    var inserted: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        if (selectedIndexes[i]) {
                                            nextStepElement[inserted] = context.inputObjects()[i];
                                            inserted++;
                                        }
                                    }
                                    if (this._next == null) {
                                        context.finalCallback()(nextStepElement);
                                    } else {
                                        context.setInputObjects(nextStepElement);
                                        this._next.execute(context);
                                    }
                                }
                            }

                            private buildParams(p_paramString: string): org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> {
                                var params: org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                var iParam: number = 0;
                                var lastStart: number = iParam;
                                while (iParam < p_paramString.length){
                                    if (p_paramString.charAt(iParam) == ',') {
                                        var p: string = p_paramString.substring(lastStart, iParam).trim();
                                        if (!org.kevoree.modeling.util.PrimitiveHelper.equals(p, "") && !org.kevoree.modeling.util.PrimitiveHelper.equals(p, "*")) {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.endsWith(p, "=")) {
                                                p = p + "*";
                                            }
                                            var pArray: string[] = p.split("=");
                                            var pObject: org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                                            if (pArray.length > 1) {
                                                var paramKey: string = pArray[0].trim();
                                                var negative: boolean = org.kevoree.modeling.util.PrimitiveHelper.endsWith(paramKey, "!");
                                                pObject = new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                                                params.put(pObject.name(), pObject);
                                            }
                                        }
                                        lastStart = iParam + 1;
                                    }
                                    iParam = iParam + 1;
                                }
                                var lastParam: string = p_paramString.substring(lastStart, iParam).trim();
                                if (!org.kevoree.modeling.util.PrimitiveHelper.equals(lastParam, "") && !org.kevoree.modeling.util.PrimitiveHelper.equals(lastParam, "*")) {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.endsWith(lastParam, "=")) {
                                        lastParam = lastParam + "*";
                                    }
                                    var pArray: string[] = lastParam.split("=");
                                    var pObject: org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam;
                                    if (pArray.length > 1) {
                                        var paramKey: string = pArray[0].trim();
                                        var negative: boolean = org.kevoree.modeling.util.PrimitiveHelper.endsWith(paramKey, "!");
                                        pObject = new org.kevoree.modeling.traversal.impl.actions.FilterAttributeQueryAction.QueryParam(paramKey.replace("!", "").replace("*", ".*"), pArray[1].trim().replace("*", ".*"), negative);
                                        params.put(pObject.name(), pObject);
                                    }
                                }
                                return params;
                            }

                        }

                        export module FilterAttributeQueryAction {
                            export class QueryParam {

                                private _name: string;
                                private _value: string;
                                private _negative: boolean;
                                constructor(p_name: string, p_value: string, p_negative: boolean) {
                                    this._name = p_name;
                                    this._value = p_value;
                                    this._negative = p_negative;
                                }

                                public name(): string {
                                    return this._name;
                                }

                                public value(): string {
                                    return this._value;
                                }

                                public isNegative(): boolean {
                                    return this._negative;
                                }

                            }


                        }
                        export class FilterNotAttributeAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
                            private _expectedValue: any;
                            constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute, p_expectedValue: any) {
                                this._attribute = p_attribute;
                                this._expectedValue = p_expectedValue;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    var selectedIndexes: boolean[] = new Array();
                                    var nbSelected: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                            if (raw != null) {
                                                if (this._attribute == null) {
                                                    if (this._expectedValue == null) {
                                                        selectedIndexes[i] = true;
                                                        nbSelected++;
                                                    } else {
                                                        var addToNext: boolean = true;
                                                        var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                                        for (var j: number = 0; j < metaElements.length; j++) {
                                                            if (metaElements[j] instanceof org.kevoree.modeling.meta.impl.MetaAttribute) {
                                                                var ref: org.kevoree.modeling.meta.KMetaAttribute = <org.kevoree.modeling.meta.KMetaAttribute>metaElements[j];
                                                                var resolved: any = raw.getPrimitiveType(ref.index(), loopObj.metaClass());
                                                                if (resolved == null) {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                                        addToNext = false;
                                                                    }
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                                        addToNext = false;
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                            addToNext = false;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        if (addToNext) {
                                                            selectedIndexes[i] = true;
                                                            nbSelected++;
                                                        }
                                                    }
                                                } else {
                                                    var translatedAtt: org.kevoree.modeling.meta.KMetaAttribute = loopObj.internal_transpose_att(this._attribute);
                                                    if (translatedAtt != null) {
                                                        var resolved: any = raw.getPrimitiveType(translatedAtt.index(), loopObj.metaClass());
                                                        if (this._expectedValue == null) {
                                                            if (resolved != null) {
                                                                selectedIndexes[i] = true;
                                                                nbSelected++;
                                                            }
                                                        } else {
                                                            if (resolved == null) {
                                                                if (!org.kevoree.modeling.util.PrimitiveHelper.equals(this._expectedValue.toString(), "*")) {
                                                                    selectedIndexes[i] = true;
                                                                    nbSelected++;
                                                                }
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(resolved.toString(), this._expectedValue.toString())) {
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(resolved.toString(), this._expectedValue.toString().replace("*", ".*"))) {
                                                                    } else {
                                                                        selectedIndexes[i] = true;
                                                                        nbSelected++;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            } else {
                                                console.error("WARN: Empty KObject " + loopObj.uuid());;
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    var nextStepElement: org.kevoree.modeling.KObject[] = new Array();
                                    var inserted: number = 0;
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        if (selectedIndexes[i]) {
                                            nextStepElement[inserted] = context.inputObjects()[i];
                                            inserted++;
                                        }
                                    }
                                    if (this._next == null) {
                                        context.finalCallback()(nextStepElement);
                                    } else {
                                        context.setInputObjects(nextStepElement);
                                        this._next.execute(context);
                                    }
                                }
                            }

                        }

                        export class MapAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _attribute: org.kevoree.modeling.meta.KMetaAttribute;
                            constructor(p_attribute: org.kevoree.modeling.meta.KMetaAttribute) {
                                this._attribute = p_attribute;
                            }

                            public chain(next: org.kevoree.modeling.traversal.KTraversalAction): void {
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                var selected: any[] = new Array();
                                var nbElem: number = 0;
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    if (context.inputObjects()[i] != null) {
                                        var resolved: any = context.inputObjects()[i].get(this._attribute);
                                        if (resolved != null) {
                                            selected[i] = resolved;
                                            nbElem++;
                                        }
                                    }
                                }
                                var trimmed: any[] = new Array();
                                var nbInserted: number = 0;
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    if (selected[i] != null) {
                                        trimmed[nbInserted] = selected[i];
                                        nbInserted++;
                                    }
                                }
                                if (context.finalCallback() != null) {
                                    context.finalCallback()(trimmed);
                                }
                            }

                        }

                        export class MathExpressionAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _expression: string;
                            private _engine: org.kevoree.modeling.util.maths.expression.KMathExpressionEngine;
                            constructor(p_expression: string) {
                                this._expression = p_expression;
                                this._engine = new org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine();
                            }

                            public chain(next: org.kevoree.modeling.traversal.KTraversalAction): void {
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                var selected: any[] = new Array();
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    if (context.inputObjects()[i] != null) {
                                        var finalI: number = i;
                                        this._engine.setVarResolver( (potentialVarName : string) => {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "PI")) {
                                                return Math.PI;
                                            }
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "TRUE")) {
                                                return 1.0;
                                            }
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "FALSE")) {
                                                return 0.0;
                                            }
                                            var loopObj: org.kevoree.modeling.KObject = context.inputObjects()[finalI];
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "TIME_MS_NS")) {
                                                return <number>(loopObj.now() / 1000000);
                                            }
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "TIME_NS_MS")) {
                                                return <number>(loopObj.now() * 1000000);
                                            }
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "TIME")) {
                                                return <number>loopObj.now();
                                            }
                                            var resolved: any = loopObj.getByName(potentialVarName);
                                            if (resolved != null) {
                                                if (resolved instanceof org.kevoree.modeling.meta.impl.MetaLiteral) {
                                                    return <number>(<org.kevoree.modeling.meta.impl.MetaLiteral>resolved).index();
                                                } else {
                                                    var valueString: string = resolved.toString();
                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(valueString, "true")) {
                                                        return 1.0;
                                                    } else {
                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(valueString, "false")) {
                                                            return 0.0;
                                                        } else {
                                                            try {
                                                                return org.kevoree.modeling.util.PrimitiveHelper.parseDouble(resolved.toString());
                                                            } catch ($ex$) {
                                                                if ($ex$ instanceof Error) {
                                                                    var e: Error = <Error>$ex$;
                                                                } else {
                                                                    throw $ex$;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            return null;
                                        });
                                        selected[finalI] = this._engine.eval(this._expression);
                                    }
                                }
                                if (context.finalCallback() != null) {
                                    context.finalCallback()(selected);
                                }
                            }

                        }

                        export class RemoveDuplicateAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                var elems: org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any> = new org.kevoree.modeling.memory.chunk.impl.ArrayLongMap<any>(context.inputObjects().length, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                for (var i: number = 0; i < context.inputObjects().length; i++) {
                                    elems.put(context.inputObjects()[i].uuid(), context.inputObjects()[i]);
                                }
                                var trimmed: org.kevoree.modeling.KObject[] = new Array();
                                var nbInserted: Int32Array = new Int32Array([0]);
                                elems.each( (key : number, value : org.kevoree.modeling.KObject) => {
                                    trimmed[nbInserted[0]] = value;
                                    nbInserted[0]++;
                                });
                                if (this._next == null) {
                                    context.finalCallback()(trimmed);
                                } else {
                                    context.setInputObjects(trimmed);
                                    this._next.execute(context);
                                }
                            }

                        }

                        export class TraverseAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _reference: org.kevoree.modeling.meta.KMetaReference;
                            constructor(p_reference: org.kevoree.modeling.meta.KMetaReference) {
                                this._reference = p_reference;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    var currentObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[0];
                                    var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = currentObject._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                            if (raw != null) {
                                                if (this._reference == null) {
                                                    var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                                    for (var j: number = 0; j < metaElements.length; j++) {
                                                        if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                            var ref: org.kevoree.modeling.meta.KMetaReference = <org.kevoree.modeling.meta.KMetaReference>metaElements[j];
                                                            var resolved: Float64Array = raw.getLongArray(ref.index(), currentObject.metaClass());
                                                            if (resolved != null) {
                                                                for (var k: number = 0; k < resolved.length; k++) {
                                                                    nextIds.put(resolved[k], resolved[k]);
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    var translatedRef: org.kevoree.modeling.meta.KMetaReference = loopObj.internal_transpose_ref(this._reference);
                                                    if (translatedRef != null) {
                                                        var resolved: Float64Array = raw.getLongArray(translatedRef.index(), currentObject.metaClass());
                                                        if (resolved != null) {
                                                            for (var j: number = 0; j < resolved.length; j++) {
                                                                nextIds.put(resolved[j], resolved[j]);
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    var trimmed: Float64Array = new Float64Array(nextIds.size());
                                    var inserted: Int32Array = new Int32Array([0]);
                                    nextIds.each( (key : number, value : number) => {
                                        trimmed[inserted[0]] = key;
                                        inserted[0]++;
                                    });
                                    currentObject._manager.lookupAllObjects(currentObject.universe(), currentObject.now(), trimmed,  (kObjects : org.kevoree.modeling.KObject[]) => {
                                        if (this._next == null) {
                                            context.finalCallback()(kObjects);
                                        } else {
                                            context.setInputObjects(kObjects);
                                            this._next.execute(context);
                                        }
                                    });
                                }
                            }

                        }

                        export class TraverseIndexAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _indexName: string;
                            constructor(p_indexName: string) {
                                this._indexName = p_indexName;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this._indexName, "root")) {
                                    if (context.inputObjects().length > 0) {
                                        context.inputObjects()[0].manager().getRoot(context.inputObjects()[0].universe(), context.inputObjects()[0].now(),  (root : org.kevoree.modeling.KObject) => {
                                            var selectedElems: org.kevoree.modeling.KObject[] = new Array();
                                            selectedElems[0] = root;
                                            if (this._next == null) {
                                                context.finalCallback()(selectedElems);
                                            } else {
                                                context.setInputObjects(selectedElems);
                                                this._next.execute(context);
                                            }
                                        });
                                    }
                                } else {
                                    var resolver: org.kevoree.modeling.traversal.KTraversalIndexResolver = context.indexResolver();
                                    if (resolver != null) {
                                        var resolved: org.kevoree.modeling.KObject[] = resolver(this._indexName);
                                        if (resolved != null) {
                                            if (this._next == null) {
                                                context.finalCallback()(resolved);
                                            } else {
                                                context.setInputObjects(resolved);
                                                this._next.execute(context);
                                            }
                                        }
                                    } else {
                                        if (this._next == null) {
                                            context.finalCallback()(context.inputObjects());
                                        } else {
                                            this._next.execute(context);
                                        }
                                    }
                                }
                            }

                        }

                        export class TraverseQueryAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private SEP: string = ",";
                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _referenceQuery: string;
                            constructor(p_referenceQuery: string) {
                                this._referenceQuery = p_referenceQuery;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                if (context.inputObjects() == null || context.inputObjects().length == 0) {
                                    if (this._next != null) {
                                        this._next.execute(context);
                                    } else {
                                        context.finalCallback()(context.inputObjects());
                                    }
                                } else {
                                    var currentFirstObject: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[0];
                                    var nextIds: org.kevoree.modeling.memory.chunk.KLongLongMap = new org.kevoree.modeling.memory.chunk.impl.ArrayLongLongMap(-1, -1, -1, null);
                                    for (var i: number = 0; i < context.inputObjects().length; i++) {
                                        try {
                                            var loopObj: org.kevoree.modeling.abs.AbstractKObject = <org.kevoree.modeling.abs.AbstractKObject>context.inputObjects()[i];
                                            var raw: org.kevoree.modeling.memory.chunk.KObjectChunk = loopObj._manager.closestChunk(loopObj.universe(), loopObj.now(), loopObj.uuid(), loopObj.metaClass(), loopObj.previousResolved());
                                            var metaElements: org.kevoree.modeling.meta.KMeta[] = loopObj.metaClass().metaElements();
                                            if (raw != null) {
                                                if (this._referenceQuery == null) {
                                                    for (var j: number = 0; j < metaElements.length; j++) {
                                                        if (metaElements[j] != null && metaElements[j].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                            var resolved: Float64Array = raw.getLongArray(metaElements[j].index(), loopObj.metaClass());
                                                            if (resolved != null) {
                                                                for (var k: number = 0; k < resolved.length; k++) {
                                                                    var idResolved: number = resolved[k];
                                                                    nextIds.put(idResolved, idResolved);
                                                                }
                                                            }
                                                        }
                                                    }
                                                } else {
                                                    var queries: string[] = this._referenceQuery.split(this.SEP);
                                                    for (var k: number = 0; k < queries.length; k++) {
                                                        queries[k] = queries[k].replace("*", ".*");
                                                    }
                                                    for (var h: number = 0; h < metaElements.length; h++) {
                                                        if (metaElements[h] != null && metaElements[h].metaType() == org.kevoree.modeling.meta.MetaType.REFERENCE) {
                                                            var metaReference: org.kevoree.modeling.meta.KMetaReference = <org.kevoree.modeling.meta.KMetaReference>metaElements[h];
                                                            var selected: boolean = false;
                                                            for (var k: number = 0; k < queries.length; k++) {
                                                                if (queries[k] != null && org.kevoree.modeling.util.PrimitiveHelper.startsWith(queries[k].trim(), "<<")) {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaReference.oppositeName(), queries[k].trim().substring(2))) {
                                                                        selected = true;
                                                                        break;
                                                                    }
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.matches(metaReference.metaName(), "^" + queries[k] + "$")) {
                                                                        selected = true;
                                                                        break;
                                                                    }
                                                                }
                                                            }
                                                            if (selected) {
                                                                var resolved: Float64Array = raw.getLongArray(metaElements[h].index(), loopObj.metaClass());
                                                                if (resolved != null) {
                                                                    for (var j: number = 0; j < resolved.length; j++) {
                                                                        nextIds.put(resolved[j], resolved[j]);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        } catch ($ex$) {
                                            if ($ex$ instanceof Error) {
                                                var e: Error = <Error>$ex$;
                                                console.error(e['stack']);;
                                            } else {
                                                throw $ex$;
                                            }
                                        }
                                    }
                                    var trimmed: Float64Array = new Float64Array(nextIds.size());
                                    var inserted: Int32Array = new Int32Array([0]);
                                    nextIds.each( (key : number, value : number) => {
                                        trimmed[inserted[0]] = key;
                                        inserted[0]++;
                                    });
                                    currentFirstObject._manager.lookupAllObjects(currentFirstObject.universe(), currentFirstObject.now(), trimmed,  (nextStepElement : org.kevoree.modeling.KObject[]) => {
                                        if (this._next == null) {
                                            context.finalCallback()(nextStepElement);
                                        } else {
                                            context.setInputObjects(nextStepElement);
                                            this._next.execute(context);
                                        }
                                    });
                                }
                            }

                        }

                        export class TraverseTimeAction implements org.kevoree.modeling.traversal.KTraversalAction {

                            private _next: org.kevoree.modeling.traversal.KTraversalAction;
                            private _timeOffset: number;
                            private _steps: number;
                            private _continueContition: org.kevoree.modeling.traversal.KTraversalFilter;
                            constructor(p_timeOffset: number, p_steps: number, p_continueCondition: org.kevoree.modeling.traversal.KTraversalFilter) {
                                this._timeOffset = p_timeOffset;
                                this._steps = p_steps;
                                this._continueContition = p_continueCondition;
                            }

                            public chain(p_next: org.kevoree.modeling.traversal.KTraversalAction): void {
                                this._next = p_next;
                            }

                            public execute(context: org.kevoree.modeling.traversal.KTraversalActionContext): void {
                                throw new Error("Not implemented Yet!");
                            }

                        }

                    }
                }
                export module query {
                    export interface KQueryEngine {

                        eval(query: string, origins: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any>): void;

                        buildTraversal(query: string): org.kevoree.modeling.traversal.KTraversal;

                    }

                    export module impl {
                        export class QueryEngine implements org.kevoree.modeling.traversal.query.KQueryEngine {

                            private static INSTANCE: org.kevoree.modeling.traversal.query.KQueryEngine = null;
                            public static OPEN_BRACKET: string = '[';
                            public static CLOSE_BRACKET: string = ']';
                            public static PIPE_SEP: string = '|';
                            public static getINSTANCE(): org.kevoree.modeling.traversal.query.KQueryEngine {
                                if (QueryEngine.INSTANCE == null) {
                                    QueryEngine.INSTANCE = new org.kevoree.modeling.traversal.query.impl.QueryEngine();
                                }
                                return QueryEngine.INSTANCE;
                            }

                            public eval(query: string, origins: org.kevoree.modeling.KObject[], callback: org.kevoree.modeling.KCallback<any>): void {
                                if (callback != null) {
                                    this.buildTraversal(query).exec(origins, null, callback);
                                }
                            }

                            public buildTraversal(query: string): org.kevoree.modeling.traversal.KTraversal {
                                if (query == null || query.length == 0) {
                                    return null;
                                } else {
                                    var traversal: org.kevoree.modeling.traversal.KTraversal = new org.kevoree.modeling.traversal.impl.Traversal(null);
                                    var i: number = 0;
                                    var escaped: boolean = false;
                                    var previousKQueryStart: number = 0;
                                    var previousKQueryNameEnd: number = -1;
                                    var previousKQueryAttributesEnd: number = -1;
                                    var previousKQueryAttributesStart: number = 0;
                                    var endEval: boolean = false;
                                    while (i < query.length && !endEval){
                                        var notLastElem: boolean = (i + 1) != query.length;
                                        if (escaped && notLastElem) {
                                            escaped = false;
                                        } else {
                                            var currentChar: string = query.charAt(i);
                                            if (currentChar == QueryEngine.CLOSE_BRACKET && notLastElem) {
                                                previousKQueryAttributesEnd = i;
                                            } else {
                                                if (currentChar == '\\' && notLastElem) {
                                                    escaped = true;
                                                } else {
                                                    if (currentChar == QueryEngine.OPEN_BRACKET && notLastElem) {
                                                        previousKQueryNameEnd = i;
                                                        previousKQueryAttributesStart = i + 1;
                                                    } else {
                                                        if (currentChar == QueryEngine.PIPE_SEP || !notLastElem) {
                                                            var relationName: string;
                                                            var atts: string = null;
                                                            if (previousKQueryNameEnd == -1) {
                                                                if (notLastElem) {
                                                                    previousKQueryNameEnd = i;
                                                                } else {
                                                                    previousKQueryNameEnd = i + 1;
                                                                }
                                                            } else {
                                                                if (previousKQueryAttributesStart != -1) {
                                                                    if (previousKQueryAttributesEnd == -1) {
                                                                        if (notLastElem || currentChar == QueryEngine.PIPE_SEP || currentChar == QueryEngine.CLOSE_BRACKET) {
                                                                            previousKQueryAttributesEnd = i;
                                                                        } else {
                                                                            previousKQueryAttributesEnd = i + 1;
                                                                        }
                                                                    }
                                                                    atts = query.substring(previousKQueryAttributesStart, previousKQueryAttributesEnd);
                                                                    if (atts.length == 0) {
                                                                        atts = null;
                                                                    }
                                                                }
                                                            }
                                                            relationName = query.substring(previousKQueryStart, previousKQueryNameEnd).trim();
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "@")) {
                                                                traversal = traversal.traverseIndex(relationName.substring(1));
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "=")) {
                                                                    traversal.eval(relationName.substring(1), null);
                                                                    endEval = true;
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, ">>")) {
                                                                        traversal = traversal.traverseQuery(relationName.substring(2));
                                                                        if (atts != null) {
                                                                            traversal = traversal.attributeQuery(atts);
                                                                        }
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.startsWith(relationName, "<<")) {
                                                                            traversal = traversal.traverseQuery(relationName);
                                                                            if (atts != null) {
                                                                                traversal = traversal.attributeQuery(atts);
                                                                            }
                                                                        } else {
                                                                            traversal = traversal.traverseQuery(relationName);
                                                                            if (atts != null) {
                                                                                traversal = traversal.attributeQuery(atts);
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            previousKQueryStart = i + 1;
                                                            previousKQueryNameEnd = -1;
                                                            previousKQueryAttributesEnd = -1;
                                                            previousKQueryAttributesStart = -1;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        i = i + 1;
                                    }
                                    return traversal;
                                }
                            }

                        }

                    }
                }
                export module visitor {
                    export interface KModelAttributeVisitor {

                        (metaAttribute: org.kevoree.modeling.meta.KMetaAttribute, value: any): void;

                    }

                    export interface KModelVisitor {

                        (elem: org.kevoree.modeling.KObject): org.kevoree.modeling.traversal.visitor.KVisitResult;

                    }

                    export class KVisitResult {

                        public static CONTINUE: KVisitResult = new KVisitResult();
                        public static SKIP: KVisitResult = new KVisitResult();
                        public static STOP: KVisitResult = new KVisitResult();
                        public equals(other: any): boolean {
                            return this == other;
                        }
                        public static _KVisitResultVALUES : KVisitResult[] = [
                            KVisitResult.CONTINUE
                            ,KVisitResult.SKIP
                            ,KVisitResult.STOP
                        ];
                        public static values():KVisitResult[]{
                            return KVisitResult._KVisitResultVALUES;
                        }
                    }

                }
            }
            export module util {
                export class Checker {

                    public static isDefined(param: any): boolean {
                         return param != undefined && param != null;
                    }

                }

                export class PrimitiveHelper {

                    public static startsWith(src: string, prefix: string): boolean {
                         return src.slice(0, prefix.length) == prefix
                    }

                    public static endsWith(src: string, prefix: string): boolean {
                         return src.slice(-prefix.length) == prefix;
                    }

                    public static matches(src: string, regex: string): boolean {
                         if (regex == null) { return false; } else { var m = src.match(regex); return m != null && m.length > 0; }
                    }

                    public static equals(src: string, other: string): boolean {
                         return src === other
                    }

                    public static parseInt(val: string): number {
                         return parseInt(val);
                    }

                    public static parseLong(val: string): number {
                         return +val;
                    }

                    public static parseDouble(val: string): number {
                         return parseFloat(val);
                    }

                    public static parseShort(val: string): number {
                         return +val;
                    }

                    public static parseBoolean(val: string): boolean {
                         return val === "true";
                    }

                    public static SHORT_MIN_VALUE(): number {
                        return -0x8000;
                    }

                    public static SHORT_MAX_VALUE(): number {
                        return 0x7FFF;
                    }

                    public static isNaN(val: number): boolean {
                         return isNaN(val);
                    }

                    public static DOUBLE_MIN_VALUE(): number {
                         return Number.MIN_VALUE;
                    }

                    public static DOUBLE_MAX_VALUE(): number {
                         return Number.MAX_VALUE;
                    }

                }

                export module maths {
                    export class Base64 {

                         private static encodeArray = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'];
                         private static decodeArray = {"A":0, "B":1, "C":2, "D":3, "E":4, "F":5, "G":6, "H":7, "I":8, "J":9, "K":10, "L":11, "M":12, "N":13, "O":14, "P":15, "Q":16, "R":17, "S":18, "T":19, "U":20, "V":21, "W":22, "X":23, "Y":24, "Z":25, "a":26, "b":27, "c":28, "d":29, "e":30, "f":31, "g":32, "h":33, "i":34, "j":35, "k":36, "l":37, "m":38, "n":39, "o":40, "p":41, "q":42, "r":43, "s":44, "t":45, "u":46, "v":47, "w":48, "x":49, "y":50, "z":51, "0":52, "1":53, "2":54, "3":55, "4":56, "5":57, "6":58, "7":59, "8":60, "9":61, "+":62, "/":63};
                         public static encodeLong(l:number) {
                         var result = "";
                         var tmp = l;
                         if(l < 0) {
                         tmp = -tmp;
                         }
                         for (var i = 47; i >= 5; i -= 6) {
                         if (!(result === "" && ((tmp / Math.pow(2, i)) & 0x3F) == 0)) {
                         result += Base64.encodeArray[(tmp / Math.pow(2, i)) & 0x3F];
                         }
                         }
                         result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
                         return result;
                         }
                         public static encodeLongToBuffer(l:number, buffer:java.lang.StringBuilder) {
                         var empty=true;
                         var tmp = l;
                         if(l < 0) {
                         tmp = -tmp;
                         }
                         for (var i = 47; i >= 5; i -= 6) {
                         if (!(empty && ((tmp / Math.pow(2, i)) & 0x3F) == 0)) {
                         empty = false;
                         buffer.append(Base64.encodeArray[(tmp / Math.pow(2, i)) & 0x3F]);
                         }
                         }
                         buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
                         }
                         public static encodeInt(l:number) {
                         var result = "";
                         var tmp = l;
                         if(l < 0) {
                         tmp = -tmp;
                         }
                         for (var i = 29; i >= 5; i -= 6) {
                         if (!(result === "" && ((tmp / Math.pow(2, i)) & 0x3F) == 0)) {
                         result += Base64.encodeArray[(tmp / Math.pow(2, i)) & 0x3F];
                         }
                         }
                         result += Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)];
                         return result;
                         }
                         public static encodeIntToBuffer(l:number, buffer:java.lang.StringBuilder) {
                         var empty=true;
                         var tmp = l;
                         if(l < 0) {
                         tmp = -tmp;
                         }
                         for (var i = 29; i >= 5; i -= 6) {
                         if (!(empty && ((tmp / Math.pow(2, i)) & 0x3F) == 0)) {
                         empty = false;
                         buffer.append(Base64.encodeArray[(tmp / Math.pow(2, i)) & 0x3F]);
                         }
                         }
                         buffer.append(Base64.encodeArray[(tmp & 0x1F)*2 + (l<0?1:0)]);
                         }
                         public static decodeToLong(s) {
                         return Base64.decodeToLongWithBounds(s, 0, s.length);
                         }
                         public static decodeToLongWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
                         var result = 0;
                         result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
                         for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
                         result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Math.pow(2, (6 * i)-1);
                         }
                         if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
                         result = -result;
                         }
                         return result;
                         }
                         public static decodeToInt(s) {
                         return Base64.decodeToIntWithBounds(s, 0, s.length);
                         }
                         public static decodeToIntWithBounds(s:string, offsetBegin:number, offsetEnd:number) {
                         var result = 0;
                         result += (Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) / 2;
                         for (var i = 1; i < (offsetEnd - offsetBegin); i++) {
                         result += (Base64.decodeArray[s.charAt((offsetEnd - 1) - i)] & 0xFF) * Math.pow(2, (6 * i)-1);
                         }
                         if (((Base64.decodeArray[s.charAt((offsetEnd - 1))] & 0xFF) & 0x1) != 0) {
                         result = -result;
                         }
                         return result;
                         }
                         public static encodeDouble(d : number) {
                         var result = "";
                         var float = new Float64Array(1);
                         var bytes = new Uint8Array(float.buffer);
                         float[0] = d;
                         var exponent = ((bytes[7] & 0x7f) << 4 | bytes[6] >> 4) - 0x3ff;
                         var signAndExp = (((bytes[7] >> 7)&0x1) << 11) + (exponent + 1023);
                         //encode sign + exp
                         result += Base64.encodeArray[(signAndExp >> 6) & 0x3F];
                         result += Base64.encodeArray[signAndExp & 0x3F];
                         result += Base64.encodeArray[bytes[6] & 0x0F];
                         result += Base64.encodeArray[(bytes[5] >> 2) & 0x3F];
                         result += Base64.encodeArray[(bytes[5] & 0x3)<<4 | bytes[4] >> 4];
                         result += Base64.encodeArray[(bytes[4] & 0x0F)<<2 | bytes[3] >> 6];
                         result += Base64.encodeArray[(bytes[3] & 0x3F)];
                         result += Base64.encodeArray[(bytes[2] >> 2) & 0x3F];
                         result += Base64.encodeArray[(bytes[2] & 0x3)<<4 | bytes[1] >> 4];
                         result += Base64.encodeArray[(bytes[1] & 0x0F)<<2 | bytes[0] >> 6];
                         result += Base64.encodeArray[(bytes[0] & 0x3F)];
                         var i = result.length-1;
                         while(i >= 3 && result.charAt(i) == 'A') {
                         i--;
                         }
                         return result.substr(0,i+1);
                         }
                         public static encodeDoubleToBuffer(d : number, buffer : java.lang.StringBuilder) {
                         var result = "";
                         var float = new Float64Array(1);
                         var bytes = new Uint8Array(float.buffer);
                         float[0] = d;
                         var exponent = ((bytes[7] & 0x7f) << 4 | bytes[6] >> 4) - 0x3ff;
                         var signAndExp = (((bytes[7] >> 7)&0x1) << 11) + (exponent + 1023);
                         //encode sign + exp
                         result += Base64.encodeArray[(signAndExp >> 6) & 0x3F];
                         result += Base64.encodeArray[signAndExp & 0x3F];
                         result += Base64.encodeArray[bytes[6] & 0x0F];
                         result += Base64.encodeArray[(bytes[5] >> 2) & 0x3F];
                         result += Base64.encodeArray[(bytes[5] & 0x3)<<4 | bytes[4] >> 4];
                         result += Base64.encodeArray[(bytes[4] & 0x0F)<<2 | bytes[3] >> 6];
                         result += Base64.encodeArray[(bytes[3] & 0x3F)];
                         result += Base64.encodeArray[(bytes[2] >> 2) & 0x3F];
                         result += Base64.encodeArray[(bytes[2] & 0x3)<<4 | bytes[1] >> 4];
                         result += Base64.encodeArray[(bytes[1] & 0x0F)<<2 | bytes[0] >> 6];
                         result += Base64.encodeArray[(bytes[0] & 0x3F)];
                         var i = result.length-1;
                         while(i >= 3 && result.charAt(i) == 'A') {
                         i--;
                         }
                         buffer.append(result);
                         }
                         public static decodeToDouble(s:string) {
                         return Base64.decodeToDoubleWithBounds(s, 0, s.length);
                         }
                         public static decodeToDoubleWithBounds(s : string, offsetBegin : number, offsetEnd : number) {
                         var signAndExp = ((Base64.decodeArray[s.charAt(0)] & 0xFF) * Math.pow(2, 6)) + (Base64.decodeArray[s.charAt(1)] & 0xFF);
                         var sign = ((signAndExp & 0x800) != 0 ? -1 : 1);
                         var exp = signAndExp & 0x7FF;
                         //Mantisse
                         var mantissaBits = 0;
                         for (var i = 2; i < (offsetEnd - offsetBegin); i++) {
                         mantissaBits += (Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF) * Math.pow(2,(48 - (6 * (i-2))));
                         }
                         return (exp != 0) ? sign * Math.pow(2, exp - 1023) * (1 + (mantissaBits / Math.pow(2, 52))) : sign * Math.pow(2, -1022) * (0 + (mantissaBits / Math.pow(2, 52)));
                         }
                         public static encodeBoolArray(boolArr : Array<boolean>) {
                         var result = "";
                         var tmpVal = 0;
                         for (var i = 0; i < boolArr.length; i++) {
                         tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Math.pow(2, i % 6));
                         if (i % 6 == 5 || i == (boolArr.length - 1)) {
                         result += Base64.encodeArray[tmpVal];
                         tmpVal = 0;
                         }
                         }
                         return result;
                         }
                         public static encodeBoolArrayToBuffer(boolArr : Array<boolean>, buffer : java.lang.StringBuilder) {
                         var tmpVal = 0;
                         for (var i = 0; i < boolArr.length; i++) {
                         tmpVal = tmpVal | ((boolArr[i] ? 1 : 0) * Math.pow(2,i % 6));
                         if (i % 6 == 5 || i == boolArr.length - 1) {
                         buffer.append(Base64.encodeArray[tmpVal]);
                         tmpVal = 0;
                         }
                         }
                         }
                         public static decodeBoolArray(s : string, arraySize : number) {
                         return Base64.decodeToBoolArrayWithBounds(s, 0, s.length, arraySize);
                         }
                         public static decodeToBoolArrayWithBounds(s : string, offsetBegin : number, offsetEnd : number, arraySize : number) {
                         var resultTmp = [];
                         for (var i = 0; i < (offsetEnd - offsetBegin); i++) {
                         var bitarray = Base64.decodeArray[s.charAt(offsetBegin + i)] & 0xFF;
                         for (var bit_i = 0; bit_i < 6; bit_i++) {
                         if ((6 * i) + bit_i < arraySize) {
                         resultTmp[(6 * i) + bit_i] = (bitarray & (1 * Math.pow(2, bit_i))) != 0;
                         } else {
                         break;
                         }
                         }
                         }
                         return resultTmp;
                         }
                    }

                    export class Correlations {

                        public static pearson(x: Float64Array, y: Float64Array): number {
                            var meanX: number = 0.0;
                            var meanY: number = 0.0;
                            for (var i: number = 0; i < x.length; i++) {
                                meanX += x[i];
                                meanY += y[i];
                            }
                            meanX /= x.length;
                            meanY /= x.length;
                            var sumXY: number = 0.0;
                            var sumX2: number = 0.0;
                            var sumY2: number = 0.0;
                            for (var i: number = 0; i < x.length; i++) {
                                sumXY += ((x[i] - meanX) * (y[i] - meanY));
                                sumX2 += (x[i] - meanX) * (x[i] - meanX);
                                sumY2 += (y[i] - meanY) * (y[i] - meanY);
                            }
                            return (sumXY / (Math.sqrt(sumX2) * Math.sqrt(sumY2)));
                        }

                    }

                    export class Distribution {

                        public static inverseNormalCDF(q: number): number {
                            var b: Float64Array = new Float64Array([1.570796288, 0.03706987906, -0.8364353589e-3, -0.2250947176e-3, 0.6841218299e-5, 0.5824238515e-5, -0.104527497e-5, 0.8360937017e-7, -0.3231081277e-8, 0.3657763036e-10, 0.6936233982e-12]);
                            if (q < 0.0 || 1.0 < q || q == 0.5) {
                                return 0.0;
                            }
                            var w1: number = q;
                            if (q > 0.5) {
                                w1 = 1.0 - q;
                            }
                            var w3: number = -Math.log(4.0 * w1 * (1.0 - w1));
                            w1 = b[0];
                            for (var i: number = 1; i < 11; i++) {
                                w1 += b[i] * Math.pow(w3, i);
                            }
                            return q > 0.5 ? Math.sqrt(w1 * w3) : -Math.sqrt(w1 * w3);
                        }

                        public static gaussian(features: Float64Array, means: Float64Array, variances: Float64Array): number {
                            var dim: number = features.length;
                            var p: number = 1;
                            for (var i: number = 0; i < dim; i++) {
                                p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
                            }
                            return p;
                        }

                        public static gaussianArray(features: org.kevoree.modeling.util.maths.structure.KArray2D, row: number, means: Float64Array, variances: Float64Array): number {
                            var dim: number = features.nbColumns();
                            var p: number = 1;
                            for (var i: number = 0; i < dim; i++) {
                                p = p * (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features.get(row, i) - means[i]) * (features.get(row, i) - means[i])) / (2 * variances[i]));
                            }
                            return p;
                        }

                        public static parallelGaussian(features: Float64Array, means: Float64Array, variances: Float64Array): Float64Array {
                            var dim: number = features.length;
                            var p: Float64Array = new Float64Array(dim);
                            for (var i: number = 0; i < dim; i++) {
                                p[i] = (1 / Math.sqrt(2 * Math.PI * variances[i])) * Math.exp(-((features[i] - means[i]) * (features[i] - means[i])) / (2 * variances[i]));
                            }
                            return p;
                        }

                        public static gaussianOneFeature(feature: number, mean: number, variance: number): number {
                            return (1 / Math.sqrt(2 * Math.PI * variance)) * Math.exp(-((feature - mean) * (feature - mean)) / (2 * variance));
                        }

                    }

                    export class PolynomialFit {

                        public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                        public coef: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                        public y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                        public solver: org.kevoree.modeling.util.maths.matrix.solvers.AdjLinearSolverQr;
                        constructor(degree: number) {
                            this.coef = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(degree + 1, 1);
                            this.A = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, degree + 1);
                            this.y = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                            this.solver = new org.kevoree.modeling.util.maths.matrix.solvers.AdjLinearSolverQr();
                        }

                        public getCoef(): Float64Array {
                            return this.coef.data;
                        }

                        public fit(samplePoints: Float64Array, observations: Float64Array): void {
                            this.y.reshapeBoolean(observations.length, 1, false);
                            java.lang.System.arraycopy(observations, 0, this.y.data, 0, observations.length);
                            this.A.reshapeBoolean(this.y.numRows, this.coef.numRows, false);
                            for (var i: number = 0; i < observations.length; i++) {
                                var obs: number = 1;
                                for (var j: number = 0; j < this.coef.numRows; j++) {
                                    this.A.cset(i, j, obs);
                                    obs *= samplePoints[i];
                                }
                            }
                            this.solver.setA(this.A);
                            this.solver.solve(this.y, this.coef);
                        }

                        public static extrapolate(time: number, weights: Float64Array): number {
                            var result: number = 0;
                            var power: number = 1;
                            for (var j: number = 0; j < weights.length; j++) {
                                result += weights[j] * power;
                                power = power * time;
                            }
                            return result;
                        }

                    }

                    export class Ranking {

                        public static wilsonRank(positive: number, negative: number, confidence: number): number {
                            var n: number = positive + negative;
                            if (n == 0) {
                                return 0.0;
                            }
                            var z: number = org.kevoree.modeling.util.maths.Distribution.inverseNormalCDF(1.0 - confidence / 2.0);
                            var p_hat: number = (1.0 * positive) / n;
                            return (p_hat + z * z / (2.0 * n) - z * Math.sqrt((p_hat * (1.0 - p_hat) + z * z / (4.0 * n)) / n)) / (1.0 + z * z / n);
                        }

                    }

                    export class Statistic {

                        public static calcHistogram(data: Float64Array, dataratings: Float64Array, numBins: number): void {
                            var result: Int32Array = new Int32Array(numBins);
                            var max: number;
                            var min: number;
                            min = data[0];
                            max = data[0];
                            for (var i: number = 0; i < data.length; i++) {
                                if (data[i] < min) {
                                    min = data[i];
                                }
                                if (data[i] > max) {
                                    max = data[i];
                                }
                            }
                            var binSize: number = (max - min) / numBins;
                            for (var i: number = 0; i < data.length; i++) {
                                var bin: number = <number>((data[i] - min) / binSize);
                                result[bin]++;
                            }
                        }

                    }

                    export class StringDistance {

                        public static levenshtein(s0: string, s1: string): number {
                            var len0: number = s0.length + 1;
                            var len1: number = s1.length + 1;
                            var cost: Int32Array = new Int32Array(len0);
                            var newcost: Int32Array = new Int32Array(len0);
                            for (var i: number = 0; i < len0; i++) {
                                cost[i] = i;
                            }
                            for (var j: number = 1; j < len1; j++) {
                                newcost[0] = j;
                                for (var i: number = 1; i < len0; i++) {
                                    var match: number = (s0.charAt(i - 1) == s1.charAt(j - 1)) ? 0 : 1;
                                    var cost_replace: number = cost[i - 1] + match;
                                    var cost_insert: number = cost[i] + 1;
                                    var cost_delete: number = newcost[i - 1] + 1;
                                    newcost[i] = Math.min(Math.min(cost_insert, cost_delete), cost_replace);
                                }
                                var swap: Int32Array = cost;
                                cost = newcost;
                                newcost = swap;
                            }
                            return cost[len0 - 1];
                        }

                    }

                    export module expression {
                        export interface KMathExpressionEngine {

                            eval(p_expression: string): number;

                            setVarResolver(resolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver): void;

                        }

                        export interface KMathVariableResolver {

                            (potentialVarName: string): number;

                        }

                        export module impl {
                            export class MathEntities {

                                private static INSTANCE: org.kevoree.modeling.util.maths.expression.impl.MathEntities = null;
                                public operators: org.kevoree.modeling.memory.chunk.KStringMap<any>;
                                public functions: org.kevoree.modeling.memory.chunk.KStringMap<any>;
                                public static getINSTANCE(): org.kevoree.modeling.util.maths.expression.impl.MathEntities {
                                    if (MathEntities.INSTANCE == null) {
                                        MathEntities.INSTANCE = new org.kevoree.modeling.util.maths.expression.impl.MathEntities();
                                    }
                                    return MathEntities.INSTANCE;
                                }

                                constructor() {
                                    this.operators = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    this.operators.put("+", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("+", 20, true));
                                    this.operators.put("-", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("-", 20, true));
                                    this.operators.put("*", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("*", 30, true));
                                    this.operators.put("/", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("/", 30, true));
                                    this.operators.put("%", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("%", 30, true));
                                    this.operators.put("^", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("^", 40, false));
                                    this.operators.put("&&", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("&&", 4, false));
                                    this.operators.put("||", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("||", 2, false));
                                    this.operators.put(">", new org.kevoree.modeling.util.maths.expression.impl.MathOperation(">", 10, false));
                                    this.operators.put(">=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation(">=", 10, false));
                                    this.operators.put("<", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("<", 10, false));
                                    this.operators.put("<=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("<=", 10, false));
                                    this.operators.put("==", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("==", 7, false));
                                    this.operators.put("!=", new org.kevoree.modeling.util.maths.expression.impl.MathOperation("!=", 7, false));
                                    this.functions = new org.kevoree.modeling.memory.chunk.impl.ArrayStringMap<any>(org.kevoree.modeling.KConfig.CACHE_INIT_SIZE, org.kevoree.modeling.KConfig.CACHE_LOAD_FACTOR);
                                    this.functions.put("NOT", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("NOT", 1));
                                    this.functions.put("IF", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("IF", 3));
                                    this.functions.put("RAND", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("RAND", 0));
                                    this.functions.put("SIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SIN", 1));
                                    this.functions.put("COS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("COS", 1));
                                    this.functions.put("TAN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("TAN", 1));
                                    this.functions.put("ASIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ASIN", 1));
                                    this.functions.put("ACOS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ACOS", 1));
                                    this.functions.put("ATAN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ATAN", 1));
                                    this.functions.put("MAX", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MAX", 2));
                                    this.functions.put("MIN", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MIN", 2));
                                    this.functions.put("ABS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ABS", 1));
                                    this.functions.put("LOG", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("LOG", 1));
                                    this.functions.put("ROUND", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("ROUND", 2));
                                    this.functions.put("FLOOR", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("FLOOR", 1));
                                    this.functions.put("CEILING", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("CEILING", 1));
                                    this.functions.put("SQRT", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SQRT", 1));
                                    this.functions.put("SECONDS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("SECONDS", 1));
                                    this.functions.put("MINUTES", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MINUTES", 1));
                                    this.functions.put("HOURS", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("HOURS", 1));
                                    this.functions.put("DAY", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("DAY", 1));
                                    this.functions.put("MONTH", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("MONTH", 1));
                                    this.functions.put("YEAR", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("YEAR", 1));
                                    this.functions.put("DAYOFWEEK", new org.kevoree.modeling.util.maths.expression.impl.MathFunction("DAYOFWEEK", 1));
                                }

                            }

                            export class MathExpressionEngine implements org.kevoree.modeling.util.maths.expression.KMathExpressionEngine {

                                private varResolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver;
                                public static decimalSeparator: string = '.';
                                public static minusSign: string = '-';
                                constructor() {
                                    this.varResolver =  (potentialVarName : string) => {
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "PI")) {
                                            return Math.PI;
                                        }
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "TRUE")) {
                                            return 1.0;
                                        }
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(potentialVarName, "FALSE")) {
                                            return 0.0;
                                        }
                                        return null;
                                    };
                                }

                                public static isNumber(st: string): boolean {
                                     return !isNaN(+st);
                                }

                                public static isDigit(c: string): boolean {
                                     var cc = c.charCodeAt(0);
                                     if ( cc >= 0x30 && cc <= 0x39 ){
                                     return true ;
                                     }
                                     return false ;
                                }

                                public static isLetter(c: string): boolean {
                                     var cc = c.charCodeAt(0);
                                     if ( ( cc >= 0x41 && cc <= 0x5A ) || ( cc >= 0x61 && cc <= 0x7A ) ){
                                     return true ;
                                     }
                                     return false ;
                                }

                                public static isWhitespace(c: string): boolean {
                                     var cc = c.charCodeAt(0);
                                     if ( ( cc >= 0x0009 && cc <= 0x000D ) || ( cc == 0x0020 ) || ( cc == 0x0085 ) || ( cc == 0x00A0 ) ){
                                     return true ;
                                     }
                                     return false ;
                                }

                                private shuntingYard(expression: string): java.util.List<string> {
                                    var outputQueue: java.util.List<string> = new java.util.ArrayList<string>();
                                    var stack: java.util.Stack<string> = new java.util.Stack<string>();
                                    var tokenizer: org.kevoree.modeling.util.maths.expression.impl.MathExpressionTokenizer = new org.kevoree.modeling.util.maths.expression.impl.MathExpressionTokenizer(expression);
                                    var lastFunction: string = null;
                                    var previousToken: string = null;
                                    while (tokenizer.hasNext()){
                                        var token: string = tokenizer.next();
                                        if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isNumber(token)) {
                                            outputQueue.add(token);
                                        } else {
                                            if (this.varResolver(token) != null) {
                                                outputQueue.add(token);
                                            } else {
                                                if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                                                    stack.push(token);
                                                    lastFunction = token;
                                                } else {
                                                    if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(token.charAt(0))) {
                                                        stack.push(token);
                                                    } else {
                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(",", token)) {
                                                            while (!stack.isEmpty() && !org.kevoree.modeling.util.PrimitiveHelper.equals("(", stack.peek())){
                                                                outputQueue.add(stack.pop());
                                                            }
                                                            if (stack.isEmpty()) {
                                                                throw new Error("Parse error for function '" + lastFunction + "'");
                                                            }
                                                        } else {
                                                            if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                                                                var o1: org.kevoree.modeling.util.maths.expression.impl.MathOperation = org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token);
                                                                var token2: string = stack.isEmpty() ? null : stack.peek();
                                                                while (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token2) && ((o1.isLeftAssoc() && o1.getPrecedence() <= org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()) || (o1.getPrecedence() < org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token2).getPrecedence()))){
                                                                    outputQueue.add(stack.pop());
                                                                    token2 = stack.isEmpty() ? null : stack.peek();
                                                                }
                                                                stack.push(token);
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals("(", token)) {
                                                                    if (previousToken != null) {
                                                                        if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isNumber(previousToken)) {
                                                                            throw new Error("Missing operator at character position " + tokenizer.getPos());
                                                                        }
                                                                    }
                                                                    stack.push(token);
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(")", token)) {
                                                                        while (!stack.isEmpty() && !org.kevoree.modeling.util.PrimitiveHelper.equals("(", stack.peek())){
                                                                            outputQueue.add(stack.pop());
                                                                        }
                                                                        if (stack.isEmpty()) {
                                                                            throw new Error("Mismatched parentheses");
                                                                        }
                                                                        stack.pop();
                                                                        if (!stack.isEmpty() && org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(stack.peek().toUpperCase())) {
                                                                            outputQueue.add(stack.pop());
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        previousToken = token;
                                    }
                                    while (!stack.isEmpty()){
                                        var element: string = stack.pop();
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals("(", element) || org.kevoree.modeling.util.PrimitiveHelper.equals(")", element)) {
                                            throw new Error("Mismatched parentheses");
                                        }
                                        if (!org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(element)) {
                                            throw new Error("Unknown operator or function: " + element);
                                        }
                                        outputQueue.add(element);
                                    }
                                    return outputQueue;
                                }

                                public eval(p_expression: string): number {
                                    var rpn: java.util.List<string> = this.shuntingYard(p_expression);
                                    var stack: java.util.Stack<number> = new java.util.Stack<number>();
                                    for (var ii: number = 0; ii < rpn.size(); ii++) {
                                        var token: string = rpn.get(ii);
                                        if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token)) {
                                            var v1: number = stack.pop();
                                            var v2: number = stack.pop();
                                            stack.push(org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.get(token).eval(v2, v1));
                                        } else {
                                            if (this.varResolver(token) != null) {
                                                stack.push(this.varResolver(token));
                                            } else {
                                                if (org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.contains(token.toUpperCase())) {
                                                    var f: org.kevoree.modeling.util.maths.expression.impl.MathFunction = org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().functions.get(token.toUpperCase());
                                                    var p: Float64Array = new Float64Array(f.getNumParams());
                                                    for (var i: number = f.getNumParams() - 1; i >= 0; i--) {
                                                        p[i] = stack.pop();
                                                    }
                                                    var fResult: number = f.eval(p);
                                                    stack.push(fResult);
                                                } else {
                                                    stack.push(org.kevoree.modeling.util.PrimitiveHelper.parseDouble(token));
                                                }
                                            }
                                        }
                                    }
                                    return stack.pop();
                                }

                                public setVarResolver(p_resolver: org.kevoree.modeling.util.maths.expression.KMathVariableResolver): void {
                                    this.varResolver = p_resolver;
                                }

                            }

                            export class MathExpressionTokenizer {

                                private pos: number = 0;
                                private input: string;
                                private previousToken: string;
                                constructor(input: string) {
                                    this.input = input.trim();
                                }

                                public hasNext(): boolean {
                                    return (this.pos < this.input.length);
                                }

                                private peekNextChar(): string {
                                    if (this.pos < (this.input.length - 1)) {
                                        return this.input.charAt(this.pos + 1);
                                    } else {
                                        return '\0';
                                    }
                                }

                                public next(): string {
                                    var token: java.lang.StringBuilder = new java.lang.StringBuilder();
                                    if (this.pos >= this.input.length) {
                                        return this.previousToken = null;
                                    }
                                    var ch: string = this.input.charAt(this.pos);
                                    while (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && this.pos < this.input.length){
                                        ch = this.input.charAt(++this.pos);
                                    }
                                    if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch)) {
                                        while ((org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.decimalSeparator) && (this.pos < this.input.length)){
                                            token.append(this.input.charAt(this.pos++));
                                            ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                                        }
                                    } else {
                                        if (ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign && org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(this.peekNextChar()) && (org.kevoree.modeling.util.PrimitiveHelper.equals("(", this.previousToken) || org.kevoree.modeling.util.PrimitiveHelper.equals(",", this.previousToken) || this.previousToken == null || org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(this.previousToken))) {
                                            token.append(org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign);
                                            this.pos++;
                                            token.append(this.next());
                                        } else {
                                            if (org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || (ch == '_')) {
                                                while ((org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) || org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) || (ch == '_')) && (this.pos < this.input.length)){
                                                    token.append(this.input.charAt(this.pos++));
                                                    ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                                                }
                                            } else {
                                                if (ch == '(' || ch == ')' || ch == ',') {
                                                    token.append(ch);
                                                    this.pos++;
                                                } else {
                                                    while (!org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isLetter(ch) && !org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isDigit(ch) && ch != '_' && !org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.isWhitespace(ch) && ch != '(' && ch != ')' && ch != ',' && (this.pos < this.input.length)){
                                                        token.append(this.input.charAt(this.pos));
                                                        this.pos++;
                                                        ch = this.pos == this.input.length ? '\0' : this.input.charAt(this.pos);
                                                        if (ch == org.kevoree.modeling.util.maths.expression.impl.MathExpressionEngine.minusSign) {
                                                            break;
                                                        }
                                                    }
                                                    if (!org.kevoree.modeling.util.maths.expression.impl.MathEntities.getINSTANCE().operators.contains(token.toString())) {
                                                        throw new Error("Unknown operator '" + token + "' at position " + (this.pos - token.length + 1));
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return this.previousToken = token.toString();
                                }

                                public getPos(): number {
                                    return this.pos;
                                }

                            }

                            export class MathFunction {

                                private name: string;
                                private numParams: number;
                                constructor(name: string, numParams: number) {
                                    this.name = name.toUpperCase();
                                    this.numParams = numParams;
                                }

                                public getName(): string {
                                    return this.name;
                                }

                                public getNumParams(): number {
                                    return this.numParams;
                                }

                                public eval(p: Float64Array): number {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "NOT")) {
                                        return (p[0] == 0) ? 1 : 0;
                                    } else {
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "IF")) {
                                            return !(p[0] == 0) ? p[1] : p[2];
                                        } else {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "RAND")) {
                                                return Math.random();
                                            } else {
                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SIN")) {
                                                    return Math.sin(p[0]);
                                                } else {
                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "COS")) {
                                                        return Math.cos(p[0]);
                                                    } else {
                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "TAN")) {
                                                            return Math.tan(p[0]);
                                                        } else {
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ASIN")) {
                                                                return Math.asin(p[0]);
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ACOS")) {
                                                                    return Math.acos(p[0]);
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ATAN")) {
                                                                        return Math.atan(p[0]);
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MAX")) {
                                                                            return p[0] > p[1] ? p[0] : p[1];
                                                                        } else {
                                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MIN")) {
                                                                                return p[0] < p[1] ? p[0] : p[1];
                                                                            } else {
                                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ABS")) {
                                                                                    return Math.abs(p[0]);
                                                                                } else {
                                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "LOG")) {
                                                                                        return Math.log(p[0]);
                                                                                    } else {
                                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "ROUND")) {
                                                                                            var factor: number = <number>Math.pow(10, p[1]);
                                                                                            var value: number = p[0] * factor;
                                                                                            var tmp: number = Math.round(value);
                                                                                            return <number>tmp / factor;
                                                                                        } else {
                                                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "FLOOR")) {
                                                                                                return Math.floor(p[0]);
                                                                                            } else {
                                                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "CEILING")) {
                                                                                                    return Math.ceil(p[0]);
                                                                                                } else {
                                                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SQRT")) {
                                                                                                        return Math.sqrt(p[0]);
                                                                                                    } else {
                                                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "SECONDS")) {
                                                                                                            return this.date_to_seconds(p[0]);
                                                                                                        } else {
                                                                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MINUTES")) {
                                                                                                                return this.date_to_minutes(p[0]);
                                                                                                            } else {
                                                                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "HOURS")) {
                                                                                                                    return this.date_to_hours(p[0]);
                                                                                                                } else {
                                                                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "DAY")) {
                                                                                                                        return this.date_to_days(p[0]);
                                                                                                                    } else {
                                                                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "MONTH")) {
                                                                                                                            return this.date_to_months(p[0]);
                                                                                                                        } else {
                                                                                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "YEAR")) {
                                                                                                                                return this.date_to_year(p[0]);
                                                                                                                            } else {
                                                                                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.name, "DAYOFWEEK")) {
                                                                                                                                    return this.date_to_dayofweek(p[0]);
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return 0;
                                }

                                private date_to_seconds(value: number): number {
                                     var date = new Date(value);
                                     return date.getSeconds();
                                }

                                private date_to_minutes(value: number): number {
                                     var date = new Date(value);
                                     return date.getMinutes();
                                }

                                private date_to_hours(value: number): number {
                                     var date = new Date(value);
                                     return date.getHours();
                                }

                                private date_to_days(value: number): number {
                                     var date = new Date(value);
                                     return date.getDate();
                                }

                                private date_to_months(value: number): number {
                                     var date = new Date(value);
                                     return date.getMonth();
                                }

                                private date_to_year(value: number): number {
                                     var date = new Date(value);
                                     return date.getFullYear();
                                }

                                private date_to_dayofweek(value: number): number {
                                     var date = new Date(value);
                                     return date.getDay();
                                }

                            }

                            export class MathOperation {

                                private oper: string;
                                private precedence: number;
                                private leftAssoc: boolean;
                                constructor(oper: string, precedence: number, leftAssoc: boolean) {
                                    this.oper = oper;
                                    this.precedence = precedence;
                                    this.leftAssoc = leftAssoc;
                                }

                                public getOper(): string {
                                    return this.oper;
                                }

                                public getPrecedence(): number {
                                    return this.precedence;
                                }

                                public isLeftAssoc(): boolean {
                                    return this.leftAssoc;
                                }

                                public eval(v1: number, v2: number): number {
                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "+")) {
                                        return v1 + v2;
                                    } else {
                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "-")) {
                                            return v1 - v2;
                                        } else {
                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "*")) {
                                                return v1 * v2;
                                            } else {
                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "/")) {
                                                    return v1 / v2;
                                                } else {
                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "%")) {
                                                        return v1 % v2;
                                                    } else {
                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "^")) {
                                                            return Math.pow(v1, v2);
                                                        } else {
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "&&")) {
                                                                var b1: boolean = !(v1 == 0);
                                                                var b2: boolean = !(v2 == 0);
                                                                return b1 && b2 ? 1 : 0;
                                                            } else {
                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "||")) {
                                                                    var b1: boolean = !(v1 == 0);
                                                                    var b2: boolean = !(v2 == 0);
                                                                    return b1 || b2 ? 1 : 0;
                                                                } else {
                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, ">")) {
                                                                        return v1 > v2 ? 1 : 0;
                                                                    } else {
                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, ">=")) {
                                                                            return v1 >= v2 ? 1 : 0;
                                                                        } else {
                                                                            if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "<")) {
                                                                                return v1 < v2 ? 1 : 0;
                                                                            } else {
                                                                                if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "<=")) {
                                                                                    return v1 <= v2 ? 1 : 0;
                                                                                } else {
                                                                                    if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "==")) {
                                                                                        return v1 == v2 ? 1 : 0;
                                                                                    } else {
                                                                                        if (org.kevoree.modeling.util.PrimitiveHelper.equals(this.oper, "!=")) {
                                                                                            return v1 != v2 ? 1 : 0;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return 0;
                                }

                            }

                        }
                    }
                    export module gmm {
                        export class BaseSampleDistribution {

                            public mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mGlobalWeight: number;
                            public mGlobalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mGlobalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mSubspaceGlobalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mSubspaceInverseCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mForgettingFactor: number;
                            public getForgettingFactor(): number {
                                return this.mForgettingFactor;
                            }

                            public setForgettingFactor(forgettingFactor: number): void {
                                this.mForgettingFactor = forgettingFactor;
                            }

                            public getGlobalWeight(): number {
                                return this.mGlobalWeight;
                            }

                            public getBandwidthMatrix(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mBandwidthMatrix;
                            }

                            public setBandwidthMatrix(mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                throw "Abstract method";
                            }

                            public getGlobalCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mGlobalCovariance;
                            }

                            public setGlobalCovariance(globalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalCovariance = globalCovariance;
                            }

                            public getSubspaceGlobalCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mSubspaceGlobalCovariance;
                            }

                            public setGlobalWeight(weight: number): void {
                                this.mGlobalWeight = weight;
                            }

                            public scaleGlobalWeight(scaleFactor: number): void {
                                this.mGlobalWeight = this.mGlobalWeight * scaleFactor;
                            }

                            public setSubspaceGlobalCovariance(subspaceCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mSubspaceGlobalCovariance = subspaceCovariance;
                            }

                            public getSubspaceInverseCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mSubspaceInverseCovariance;
                            }

                            public setSubspaceInverseCovariance(subspaceInverseCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mSubspaceInverseCovariance = subspaceInverseCovariance;
                            }

                            public evaluateMatrix(pointVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                throw "Abstract method";
                            }

                            public evaluate(points: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): Float64Array {
                                var resultPoints: Float64Array = new Float64Array(points.length);
                                for (var i: number = 0; i < points.length; i++) {
                                    resultPoints[i] = this.evaluateMatrix(points[i]);
                                }
                                return resultPoints;
                            }

                            public getGlobalMean(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mGlobalMean;
                            }

                            public setGlobalMean(globalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalMean = globalMean;
                            }

                            public getmGlobalCovarianceSmoothed(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                if (this.mBandwidthMatrix == null) {
                                    this.mBandwidthMatrix = this.mGlobalCovariance.scale(0);
                                }
                                return (this.mGlobalCovariance.plus(this.mBandwidthMatrix));
                            }

                        }

                        export class Compressor {

                            private static CONST_SMALL_TOLERANCE: number = 1E-10;
                            private static MAX: number = 1.7976931348623157E308;
                            private static MIN_EM_DISTANCE: number = 2.34;
                            private static INC_TH_SCALE: number = 1.5;
                            private static DEC_TH_SCALE: number = 0.6;
                            private static CHECK_IF_DEC_SCALE: number = 0.5;
                            private static setNoOfComponentsThreshold(dist: org.kevoree.modeling.util.maths.gmm.SampleModel, noOfCompsBeforeCompression: number, noOfCompsAfterCompression: number): void {
                                var threshold: number = dist.getNoOfCompsThreshold();
                                if (noOfCompsAfterCompression > threshold) {
                                    threshold = threshold * Compressor.INC_TH_SCALE;
                                } else {
                                    if (noOfCompsAfterCompression <= threshold * Compressor.CHECK_IF_DEC_SCALE) {
                                        threshold = threshold * Compressor.DEC_TH_SCALE;
                                    }
                                }
                                dist.setNoOfCompsThreshold(threshold);
                            }

                            public static emUpdate(dist: org.kevoree.modeling.util.maths.gmm.SampleModel, updatePoints: Int32Array): boolean {
                                var subDistributions: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = dist.getSubDistributions();
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = dist.getSubMeans();
                                var smoothedCovariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = dist.getSubSmoothedCovariances();
                                var covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = dist.getSubCovariances();
                                var weights: Float64Array = dist.getSubWeights();
                                var pointMerged: boolean = false;
                                var count: number = 0;
                                for (var k: number = 0; k < updatePoints.length; k++) {
                                    var point: number = updatePoints[k];
                                    for (var i: number = 0; i < means.length && i != point && !pointMerged; i++) {
                                        if (subDistributions[i] instanceof org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution) {
                                            var subComponent: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = <org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i];
                                            var md: number = means[point].minus(means[i]).transpose().mult(smoothedCovariances[i].invert()).mult(means[point].minus(means[i])).trace();
                                            if (md < Compressor.MIN_EM_DISTANCE) {
                                                var subSubComponents: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[] = subComponent.getSubComponents();
                                                var distance1: number = org.kevoree.modeling.util.maths.gmm.Compressor.euclidianDistance(subSubComponents[0].getGlobalMean(), means[point]);
                                                var distance2: number = org.kevoree.modeling.util.maths.gmm.Compressor.euclidianDistance(subSubComponents[1].getGlobalMean(), means[point]);
                                                var mergeId: number = 0;
                                                if (distance1 < distance2) {
                                                    mergeId = 0;
                                                } else {
                                                    mergeId = 1;
                                                }
                                                var componentToMerge: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = subSubComponents[mergeId];
                                                var meansArray: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [componentToMerge.getGlobalMean(), means[point]];
                                                var covarianceArray: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [componentToMerge.getGlobalCovariance(), covariances[point]];
                                                var subSubweight1: number = componentToMerge.getGlobalWeight() * subComponent.getGlobalWeight();
                                                var subSubweight2: number = weights[point];
                                                var globalWeight: number = subComponent.getGlobalWeight() + subSubweight2;
                                                var subSubWeightSum: number = subSubweight1 + subSubweight2;
                                                subSubweight1 /= subSubWeightSum;
                                                subSubweight2 /= subSubWeightSum;
                                                var weightsArray: Float64Array = new Float64Array([subSubweight1, subSubweight2]);
                                                var oneCompDist: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = null;
                                                try {
                                                    var twoCompDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = new org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution(weightsArray, meansArray, covarianceArray, dist.getBandwidthMatrix());
                                                    var subWeight1: number = subSubComponents[0].getGlobalWeight() * subComponent.getGlobalWeight();
                                                    var subWeight2: number = subSubComponents[1].getGlobalWeight() * subComponent.getGlobalWeight();
                                                    if (mergeId == 0) {
                                                        subWeight1 += weights[point];
                                                    } else {
                                                        subWeight2 += weights[point];
                                                    }
                                                    var subWeightSum: number = subWeight1 + subWeight2;
                                                    subWeight1 /= subWeightSum;
                                                    subWeight2 /= subWeightSum;
                                                    org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments2Comp(twoCompDist);
                                                    oneCompDist = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                                    oneCompDist.setComponent(twoCompDist);
                                                    subSubComponents[mergeId] = oneCompDist;
                                                    subSubComponents[0].setGlobalWeight(subWeight1);
                                                    subSubComponents[1].setGlobalWeight(subWeight2);
                                                    org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments2Comp(subComponent);
                                                    subComponent.setGlobalWeight(globalWeight);
                                                    dist.mEMCount++;
                                                } catch ($ex$) {
                                                    if ($ex$ instanceof Error) {
                                                        var e: Error = <Error>$ex$;
                                                        console.error(e['stack']);;
                                                    } else {
                                                        throw $ex$;
                                                    }
                                                }
                                                dist.removeSubDistributions(point);
                                                count++;
                                                pointMerged = true;
                                            }
                                        }
                                    }
                                }
                                return (count == updatePoints.length);
                            }

                            public static compress(dist: org.kevoree.modeling.util.maths.gmm.SampleModel, newComponents: Int32Array): void {
                                if (dist.getSubMeans().length <= dist.getNoOfCompsThreshold()) {
                                    return;
                                }
                                var successfulEMUpdate: boolean = org.kevoree.modeling.util.maths.gmm.Compressor.emUpdate(dist, newComponents);
                                if (successfulEMUpdate) {
                                    return;
                                }
                                var projectionData: org.kevoree.modeling.util.maths.gmm.projection.ProjectionData = null;
                                try {
                                    projectionData = org.kevoree.modeling.util.maths.gmm.projection.Projector.projectSampleDistToSubspace(dist);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.log("projection failed. Aborted Compression");;
                                        return;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                                org.kevoree.modeling.util.maths.gmm.Compressor.revitalizeComponents(dist);
                                var noOfCompsBeforeCompression: number = dist.getSubMeans().length;
                                var inputModelCopy: org.kevoree.modeling.util.maths.gmm.SampleModel = new org.kevoree.modeling.util.maths.gmm.SampleModel();
                                inputModelCopy.setSampleModel(dist);
                                var compressionError: number = Compressor.MAX;
                                if (inputModelCopy.getSubDistributions().length > 1) {
                                    compressionError = org.kevoree.modeling.util.maths.gmm.Compressor.mergeTwoClosestComps(inputModelCopy);
                                }
                                while (compressionError < dist.mCompressionThreshold){
                                    dist.overWirite(inputModelCopy);
                                    if (inputModelCopy.getSubDistributions().length > 1) {
                                        compressionError = org.kevoree.modeling.util.maths.gmm.Compressor.mergeTwoClosestComps(inputModelCopy);
                                    } else {
                                        compressionError = Compressor.MAX;
                                    }
                                }
                                org.kevoree.modeling.util.maths.gmm.projection.Projector.projectSampleDistToOriginalSpace(dist, projectionData);
                                var noOfCompsAfterCompression: number = dist.getSubMeans().length;
                                org.kevoree.modeling.util.maths.gmm.Compressor.setNoOfComponentsThreshold(dist, noOfCompsBeforeCompression, noOfCompsAfterCompression);
                            }

                            private static revitalizeComponents(dist: org.kevoree.modeling.util.maths.gmm.SampleModel): void {
                                for (var i: number = 0; i < dist.getSubDistributions().length; i++) {
                                    if (dist.getSubDistributions()[i] instanceof org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution) {
                                        var subDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = <org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>dist.getSubDistributions()[i];
                                        var tmpWeight: number = subDist.getGlobalWeight();
                                        org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments2Comp(subDist);
                                        var oneCompDist: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                        oneCompDist.setComponent(subDist);
                                        var compressionError: number = org.kevoree.modeling.util.maths.gmm.Hellinger.calculateUnscentedHellingerDistance(oneCompDist, subDist);
                                        subDist.setGlobalWeight(tmpWeight);
                                        if (compressionError >= dist.mCompressionThreshold) {
                                            var subComp1: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = subDist.getSubComponents()[0];
                                            var subComp2: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = subDist.getSubComponents()[1];
                                            var splitDist1: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = null;
                                            var splitDist2: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = null;
                                            if (subComp1.getGlobalCovariance().elementSum() > Compressor.CONST_SMALL_TOLERANCE) {
                                                splitDist1 = subComp1.split(tmpWeight);
                                            } else {
                                                subComp1.scaleGlobalWeight(tmpWeight);
                                                splitDist1 = subComp1;
                                            }
                                            if (subComp2.getGlobalCovariance().elementSum() > Compressor.CONST_SMALL_TOLERANCE) {
                                                splitDist2 = subComp2.split(tmpWeight);
                                            } else {
                                                subComp2.scaleGlobalWeight(tmpWeight);
                                                splitDist2 = subComp2;
                                            }
                                            dist.getSubDistributions()[i] = splitDist1;
                                            dist.addToSubDistribution(splitDist2);
                                        }
                                    }
                                }
                            }

                            private static mergeTwoClosestComps(dist: org.kevoree.modeling.util.maths.gmm.SampleModel): number {
                                var compressionError: number = 0;
                                var twoCompDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = null;
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = dist.getSubMeans();
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = dist.getSubCovariances();
                                var weights: Float64Array = dist.getSubWeights();
                                var distance: number = -1;
                                var indexComp1: number = 0;
                                var indexComp2: number = 0;
                                for (var i: number = 0; i < means.length; i++) {
                                    var mean1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                    for (var j: number = (i + 1); j < means.length; j++) {
                                        var mean2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[j];
                                        var tmpDistance: number = org.kevoree.modeling.util.maths.gmm.Compressor.euclidianDistance(mean1, mean2);
                                        if ((distance == -1) || (tmpDistance < distance)) {
                                            distance = tmpDistance;
                                            indexComp1 = i;
                                            indexComp2 = j;
                                        }
                                        if (distance == 0) {
                                            break;
                                        }
                                    }
                                    if (distance == 0) {
                                        break;
                                    }
                                }
                                var meansArray: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [means[indexComp1], means[indexComp2]];
                                var covarianceArray: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [covs[indexComp1], covs[indexComp2]];
                                var weightsArray: Float64Array = new Float64Array([weights[indexComp1], weights[indexComp2]]);
                                try {
                                    twoCompDist = new org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution(weightsArray, meansArray, covarianceArray, dist.getBandwidthMatrix());
                                    org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments2Comp(twoCompDist);
                                    var oneCompDist: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                    oneCompDist.setComponent(twoCompDist);
                                    compressionError = org.kevoree.modeling.util.maths.gmm.Hellinger.calculateUnscentedHellingerDistance(oneCompDist, twoCompDist);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                                var subWeights: number[] = twoCompDist.getSubWeights();
                                var newWeight1: number = subWeights[0] / (subWeights[0] + subWeights[1]);
                                var newWeight2: number = subWeights[1] / (subWeights[0] + subWeights[1]);
                                twoCompDist.getSubComponents()[0].setGlobalWeight(newWeight1);
                                twoCompDist.getSubComponents()[1].setGlobalWeight(newWeight2);
                                dist.getSubDistributions()[indexComp2] = twoCompDist;
                                dist.removeSubDistributions(indexComp1);
                                return compressionError;
                            }

                            public static euclidianDistance(columnVector1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, columnVector2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var distance: number = 0;
                                var distVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = columnVector2.minus(columnVector1);
                                distance = Math.sqrt(org.kevoree.modeling.util.maths.matrix.CommonOps.elemPow(distVector, 2).elementSum());
                                return distance;
                            }

                        }

                        export class ConditionalDistribution {

                            public conditionalMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[];
                            public conditionalCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[];
                            public conditionalWeights: Float64Array;
                            constructor(conditionalMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], conditionalCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], conditionalWeights: Float64Array) {
                                this.conditionalMeans = conditionalMeans;
                                this.conditionalCovs = conditionalCovs;
                                this.conditionalWeights = conditionalWeights;
                            }

                        }

                        export class Hellinger {

                            private static MIN_TOL: number = 1e-5;
                            private static HALF: number = 0.5;
                            public static calculateUnscentedHellingerDistance(dist1: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution, dist2: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution): number {
                                var dist0: org.kevoree.modeling.util.maths.gmm.ThreeComponentDistribution = org.kevoree.modeling.util.maths.gmm.Hellinger.mergeSampleDists(dist1, dist2, Hellinger.HALF, Hellinger.HALF);
                                var sigmaPoints: java.util.List<org.kevoree.modeling.util.maths.gmm.SigmaPoint> = org.kevoree.modeling.util.maths.gmm.Hellinger.getAllSigmaPoints(dist0, 3);
                                var points: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                var weights: Float64Array = new Float64Array(sigmaPoints.size());
                                for (var i: number = 0; i < sigmaPoints.size(); i++) {
                                    points[i] = sigmaPoints.get(i).getmPointVecor();
                                    weights[i] = sigmaPoints.get(i).getmWeight();
                                }
                                var dist1Ev: Float64Array = dist1.evaluate(points);
                                var dist2Ev: Float64Array = dist2.evaluate(points);
                                dist1Ev = org.kevoree.modeling.util.maths.matrix.CommonOps.setNegativeValuesToZero(dist1Ev);
                                dist2Ev = org.kevoree.modeling.util.maths.matrix.CommonOps.setNegativeValuesToZero(dist2Ev);
                                var dist0Ev: Float64Array = dist0.evaluate(points);
                                dist0Ev = org.kevoree.modeling.util.maths.matrix.CommonOps.setNegativeValuesToZero(dist0Ev);
                                var mat0: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.doubleListToMatrix(dist0Ev);
                                var mat1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.doubleListToMatrix(dist1Ev);
                                var mat2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.doubleListToMatrix(dist2Ev);
                                var weightsMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.doubleListToMatrix(weights);
                                var g: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.elemPow((org.kevoree.modeling.util.maths.matrix.CommonOps.elemSqrt(mat1).minus(org.kevoree.modeling.util.maths.matrix.CommonOps.elemSqrt(mat2))), 2);
                                var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = weightsMatrix.elementMult(g);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementDiv(tmp.getMatrix(), mat0.getMatrix(), tmp.getMatrix());
                                var val: number = tmp.elementSum();
                                var H: number = Math.sqrt(Math.abs(val / 2));
                                return H;
                            }

                            private static mergeSampleDists(dist1: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution, dist2: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution, w1: number, w2: number): org.kevoree.modeling.util.maths.gmm.ThreeComponentDistribution {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                means[0] = dist1.getGlobalMean();
                                for (var i: number = 1; i < dist2.getSubMeans().length + 1; i++) {
                                    means[i] = dist2.getSubMeans()[i - 1];
                                }
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                covs[0] = dist1.getGlobalCovariance();
                                for (var i: number = 1; i < dist2.getSubCovariances().length + 1; i++) {
                                    covs[i] = dist2.getSubCovariances()[i - 1];
                                }
                                var weights: Float64Array = new Float64Array(3);
                                weights[0] = w1;
                                for (var i: number = 1; i < dist2.getSubWeights().length + 1; i++) {
                                    weights[i] = dist2.getSubWeights()[i - 1] * w2;
                                }
                                var dist: org.kevoree.modeling.util.maths.gmm.ThreeComponentDistribution = null;
                                dist = new org.kevoree.modeling.util.maths.gmm.ThreeComponentDistribution(weights, means, covs, dist1.getBandwidthMatrix());
                                return dist;
                            }

                            public static getAllSigmaPoints(distribution: org.kevoree.modeling.util.maths.gmm.ThreeComponentDistribution, max: number): java.util.List<org.kevoree.modeling.util.maths.gmm.SigmaPoint> {
                                var sigmaPoints: java.util.ArrayList<org.kevoree.modeling.util.maths.gmm.SigmaPoint> = new java.util.ArrayList<org.kevoree.modeling.util.maths.gmm.SigmaPoint>();
                                var noOfComponents: number = distribution.getSubMeans().length;
                                var dim: number = distribution.getSubMeans()[0].numRows();
                                var k: number = max - dim;
                                var noOfSigmaPoints: number;
                                if (k != 0) {
                                    noOfSigmaPoints = 2 * dim + 1;
                                } else {
                                    noOfSigmaPoints = 2 * dim;
                                }
                                var weights: java.util.ArrayList<number> = new java.util.ArrayList<number>();
                                for (var i: number = 0; i < (2 * dim); i++) {
                                    weights.add(1 / (2 * (<number>dim + k)));
                                }
                                if (k != 0) {
                                    weights.add(<number>k / <number>(dim + k));
                                }
                                var sum: number = 0;
                                for (var j: number = 0; j < weights.size(); j++) {
                                    sum += weights.get(j);
                                }
                                if ((sum - 1) > Hellinger.MIN_TOL) {
                                    throw new Error("Weights in the unscented transform should sum to one!");
                                }
                                for (var i: number = 0; i < noOfComponents; i++) {
                                    var x: java.util.List<org.kevoree.modeling.util.maths.matrix.SimpleMatrix> = org.kevoree.modeling.util.maths.gmm.Hellinger.getSigmaPoints(distribution.getSubMeans()[i], distribution.getSubCovariances()[i], noOfSigmaPoints, k);
                                    var count: number = 0;
                                    var componentWeight: number = distribution.getSubWeights()[i];
                                    for (var d: number = 0; d < x.size(); d++) {
                                        var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = x.get(d);
                                        sigmaPoints.add(new org.kevoree.modeling.util.maths.gmm.SigmaPoint(m, weights.get(count) * componentWeight, weights.get(count)));
                                        count++;
                                    }
                                }
                                return sigmaPoints;
                            }

                            private static getSigmaPoints(mean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, cov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, no: number, k: number): java.util.List<org.kevoree.modeling.util.maths.matrix.SimpleMatrix> {
                                var resultVectors: java.util.List<org.kevoree.modeling.util.maths.matrix.SimpleMatrix> = new java.util.ArrayList<org.kevoree.modeling.util.maths.matrix.SimpleMatrix>();
                                var n: number = cov.numRows();
                                var svd: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> = cov.svd(true);
                                var U: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getU();
                                var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getW();
                                S = U.mult(org.kevoree.modeling.util.maths.matrix.CommonOps.elemSqrt(S)).scale(Math.sqrt(n + k));
                                for (var i: number = 0; i < S.numCols(); i++) {
                                    var columnVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = S.extractVector(false, i);
                                    var negColumnVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = S.extractVector(false, i).scale(-1);
                                    resultVectors.add(columnVector.plus(mean));
                                    resultVectors.add(negColumnVector.plus(mean));
                                }
                                if (k != 0) {
                                    resultVectors.add(mean);
                                }
                                return resultVectors;
                            }

                        }

                        export class MomentMatcher {

                            public static matchMoments(distribution: org.kevoree.modeling.util.maths.gmm.SampleModel): void {
                                var smCovariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubCovariances();
                                var smMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubMeans();
                                var smWeights: Float64Array = distribution.getSubWeights();
                                if (smWeights.length == 0) {
                                    return;
                                }
                                if (smWeights.length == 1) {
                                    var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smMeans[0];
                                    var newCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = null;
                                    if (smCovariances.length > 0) {
                                        newCovariance = smCovariances[0];
                                    }
                                    distribution.setGlobalCovariance(newCovariance);
                                    distribution.setGlobalMean(newMean);
                                    distribution.setGlobalWeight(smWeights[0]);
                                    return;
                                }
                                var newWeight: number = 0;
                                for (var i: number = 0; i < smWeights.length; i++) {
                                    newWeight += smWeights[i];
                                }
                                var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(smMeans[0].numRows(), smMeans[0].numCols());
                                for (var i: number = 0; i < smMeans.length; i++) {
                                    newMean = newMean.plus((smMeans[i].scale(smWeights[i])));
                                }
                                newMean = newMean.scale(1 / newWeight);
                                var newCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(smCovariances[0].numRows(), smCovariances[0].numCols());
                                for (var i: number = 0; i < smCovariances.length; i++) {
                                    var dyadSmMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smMeans[i].mult(smMeans[i].transpose());
                                    var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smCovariances[i].plus(dyadSmMean);
                                    newCovariance = newCovariance.plus(S.scale(smWeights[i]));
                                }
                                newCovariance = newCovariance.scale(1 / newWeight);
                                var dyadNewMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = newMean.mult(newMean.transpose());
                                newCovariance = newCovariance.minus(dyadNewMean);
                                distribution.setGlobalCovariance(newCovariance);
                                distribution.setGlobalMean(newMean);
                                distribution.setGlobalWeight(newWeight);
                            }

                            public static matchMoments2Comp(distribution: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution): void {
                                var smCovariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubCovariances();
                                var smMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubMeans();
                                var smWeights: number[] = distribution.getSubWeights();
                                if (smWeights.length == 0) {
                                    return;
                                }
                                if (smWeights.length == 1) {
                                    var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smMeans[0];
                                    var newCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = null;
                                    if (smCovariances.length > 0) {
                                        newCovariance = smCovariances[0];
                                    }
                                    distribution.setGlobalCovariance(newCovariance);
                                    distribution.setGlobalMean(newMean);
                                    distribution.setGlobalWeight(smWeights[0]);
                                    return;
                                }
                                var newWeight: number = 0;
                                for (var i: number = 0; i < smWeights.length; i++) {
                                    newWeight += smWeights[i];
                                }
                                var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(smMeans[0].numRows(), smMeans[0].numCols());
                                for (var i: number = 0; i < smMeans.length; i++) {
                                    newMean = newMean.plus((smMeans[i].scale(smWeights[i])));
                                }
                                newMean = newMean.scale(1 / newWeight);
                                var newCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(smCovariances[0].numRows(), smCovariances[0].numCols());
                                for (var i: number = 0; i < smCovariances.length; i++) {
                                    var dyadSmMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smMeans[i].mult(smMeans[i].transpose());
                                    var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = smCovariances[i].plus(dyadSmMean);
                                    newCovariance = newCovariance.plus(S.scale(smWeights[i]));
                                }
                                newCovariance = newCovariance.scale(1 / newWeight);
                                var dyadNewMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = newMean.mult(newMean.transpose());
                                newCovariance = newCovariance.minus(dyadNewMean);
                                distribution.setGlobalCovariance(newCovariance);
                                distribution.setGlobalMean(newMean);
                                distribution.setGlobalWeight(newWeight);
                            }

                        }

                        export class MultipleComponentDistribution extends org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution {

                            private mSubDistributions: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[];
                            constructor() {
                                super();
                            }

                            public setValues(weights: Float64Array, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalWeight = 0;
                                this.mForgettingFactor = 0;
                                if (bandwidth == null) {
                                    bandwidth = covariances[0].scale(0);
                                }
                                this.mBandwidthMatrix = bandwidth;
                                this.mSubDistributions = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var res: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                    res.setValues(weights[i], means[i], covariances[i], bandwidth);
                                    this.mSubDistributions[i] = res;
                                }
                                this.mGlobalWeight = 0;
                                for (var j: number = 0; j < weights.length; j++) {
                                    this.mGlobalWeight += weights[j];
                                }
                                this.mForgettingFactor = 1;
                            }

                            public setComponent(dist: org.kevoree.modeling.util.maths.gmm.MultipleComponentDistribution): void {
                                var subDists: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[] = dist.getSubComponents();
                                var copy: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[] = new Array();
                                for (var i: number = 0; i < subDists.length; i++) {
                                    copy[i] = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                    copy[i].setComponent(subDists[i]);
                                }
                                this.mSubDistributions = copy;
                                this.mBandwidthMatrix = dist.getBandwidthMatrix();
                                this.mGlobalCovariance = dist.getGlobalCovariance();
                                this.mGlobalMean = dist.getGlobalMean();
                                this.mSubspaceGlobalCovariance = dist.getSubspaceGlobalCovariance();
                                this.mSubspaceInverseCovariance = dist.getSubspaceInverseCovariance();
                                this.mGlobalWeight = dist.getGlobalWeight();
                            }

                            public evaluateMatrix(pointVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubMeans();
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubCovariances();
                                var weights: number[] = this.getSubWeights();
                                var d: number = 0;
                                var n: number = means[0].numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                for (var i: number = 0; i < means.length; i++) {
                                    var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                    var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i].plus(this.mBandwidthMatrix);
                                    var w: number = weights[i];
                                    var tmp: number = (-0.5) * pointVector.minus(m).transpose().mult(c.invert()).mult(pointVector.minus(m)).trace();
                                    d += ((1 / (a * Math.sqrt(c.determinant()))) * Math.exp(tmp)) * w;
                                }
                                return d;
                            }

                            public setSubComponents(subComponents: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[]): void {
                                this.mSubDistributions = subComponents;
                            }

                            public getSubComponents(): org.kevoree.modeling.util.maths.gmm.OneComponentDistribution[] {
                                return this.mSubDistributions;
                            }

                            public getSubMeans(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    means[i] = this.mSubDistributions[i].getGlobalMean();
                                }
                                return means;
                            }

                            public getSubCovariances(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] {
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    covs[i] = this.mSubDistributions[i].getGlobalCovariance();
                                }
                                return covs;
                            }

                            public getSubWeights(): number[] {
                                var weights: number[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    weights[i] = this.mSubDistributions[i].getGlobalWeight();
                                }
                                return weights;
                            }

                            public setSubMeans(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): void {
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    this.mSubDistributions[i].setGlobalMean(means[i]);
                                }
                            }

                            public setSubCovariances(covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): void {
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    this.mSubDistributions[i].setGlobalCovariance(covariances[i]);
                                }
                            }

                            public setBandwidthMatrix(mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mBandwidthMatrix = mBandwidthMatrix;
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    d.setBandwidthMatrix(mBandwidthMatrix);
                                }
                            }

                        }

                        export class OneComponentDistribution extends org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution {

                            constructor() {
                                super();
                            }

                            public setValues(w: number, mean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, covariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalWeight = 0;
                                this.mForgettingFactor = 0;
                                this.mGlobalWeight = w;
                                this.mGlobalMean = mean;
                                this.mGlobalCovariance = covariance;
                                this.mBandwidthMatrix = bandwidth;
                                this.mForgettingFactor = 1;
                            }

                            public setComponent(oneComponentDistribution: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution): void {
                                this.mBandwidthMatrix = oneComponentDistribution.getBandwidthMatrix();
                                this.mGlobalCovariance = oneComponentDistribution.getGlobalCovariance();
                                this.mGlobalMean = oneComponentDistribution.getGlobalMean();
                                this.mSubspaceGlobalCovariance = oneComponentDistribution.getSubspaceGlobalCovariance();
                                this.mSubspaceInverseCovariance = oneComponentDistribution.getSubspaceInverseCovariance();
                                this.mGlobalWeight = oneComponentDistribution.getGlobalWeight();
                            }

                            public split(parentWeight: number): org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution {
                                var svd: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> = this.mGlobalCovariance.svd(true);
                                var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getW();
                                var V: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getV();
                                var d: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = S.extractDiag();
                                var max: number = org.kevoree.modeling.util.maths.matrix.CommonOps.maxVectorElement(d);
                                var maxIndex: number = org.kevoree.modeling.util.maths.matrix.CommonOps.maxVectorElementIndex(d);
                                var len: number = this.mGlobalCovariance.numRows();
                                var M: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(len, 1);
                                M.setValue2D(maxIndex, 0, 1.0);
                                var dMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = V.mult(M).scale(0.5 * Math.sqrt(max));
                                var meanSplit1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.mGlobalMean.plus(dMean);
                                var meanSplit2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.mGlobalMean.minus(dMean);
                                var dyadMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.mGlobalMean.mult(this.mGlobalMean.transpose());
                                var dyadMeanSplit1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = meanSplit1.mult(meanSplit1.transpose());
                                var dyadMeanSplit2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = meanSplit2.mult(meanSplit2.transpose());
                                var covSplit: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.mGlobalCovariance.plus(dyadMean).minus(dyadMeanSplit1.plus(dyadMeanSplit2).scale(0.5));
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [meanSplit1, meanSplit2];
                                var covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = [covSplit, covSplit];
                                var weights: Float64Array = new Float64Array([0.5, 0.5]);
                                var splitDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = null;
                                try {
                                    splitDist = new org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution(weights, means, covariances, this.mBandwidthMatrix);
                                    splitDist.setGlobalWeight(parentWeight * this.mGlobalWeight);
                                    splitDist.setGlobalCovariance(this.mGlobalCovariance);
                                    splitDist.setGlobalMean(this.mGlobalMean);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                                return splitDist;
                            }

                            public evaluateMatrix(pointVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var smoothedCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.mGlobalCovariance.plus(this.mBandwidthMatrix);
                                var d: number = 0;
                                var n: number = this.mGlobalMean.numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                var tmp: number = (-0.5) * pointVector.minus(this.mGlobalMean).transpose().mult(smoothedCov.invert()).mult(pointVector.minus(this.mGlobalMean)).trace();
                                d += ((1 / (a * Math.sqrt(smoothedCov.determinant()))) * Math.exp(tmp)) * this.mGlobalWeight;
                                return d;
                            }

                            public setBandwidthMatrix(mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mBandwidthMatrix = mBandwidthMatrix;
                            }

                        }

                        export class SampleModel {

                            private static DEFAULT_NO_OF_COMPS_THRES: number = 6;
                            private mProbabilityCache: java.util.HashMap<org.kevoree.modeling.util.maths.matrix.SimpleMatrixHashable, number> = new java.util.HashMap<org.kevoree.modeling.util.maths.matrix.SimpleMatrixHashable, number>();
                            private static MAX_MAHALANOBIS_DIST: number = 40;
                            public mCompressionThreshold: number;
                            public mEffectiveNoOfSamples: number;
                            public mSubDistributions: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[];
                            public mNoOfCompsThreshold: number;
                            public mEMError: number = 0;
                            public mEMCount: number = 0;
                            public mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mGlobalWeight: number;
                            public mGlobalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mGlobalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mSubspaceGlobalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mSubspaceInverseCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public mForgettingFactor: number;
                            private mSubspace: Int32Array;
                            public getForgettingFactor(): number {
                                return this.mForgettingFactor;
                            }

                            public setForgettingFactor(forgettingFactor: number): void {
                                this.mForgettingFactor = forgettingFactor;
                            }

                            public getGlobalWeight(): number {
                                return this.mGlobalWeight;
                            }

                            public getBandwidthMatrix(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mBandwidthMatrix;
                            }

                            public getGlobalCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mGlobalCovariance;
                            }

                            public setGlobalCovariance(globalCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalCovariance = globalCovariance;
                            }

                            public getSubspaceGlobalCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mSubspaceGlobalCovariance;
                            }

                            public setGlobalWeight(weight: number): void {
                                this.mGlobalWeight = weight;
                            }

                            public scaleGlobalWeight(scaleFactor: number): void {
                                this.mGlobalWeight = this.mGlobalWeight * scaleFactor;
                            }

                            public setSubspaceGlobalCovariance(subspaceCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mSubspaceGlobalCovariance = subspaceCovariance;
                            }

                            public getSubspaceInverseCovariance(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mSubspaceInverseCovariance;
                            }

                            public setSubspaceInverseCovariance(subspaceInverseCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mSubspaceInverseCovariance = subspaceInverseCovariance;
                            }

                            public evaluateArray(points: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): Float64Array {
                                var resultPoints: Float64Array = new Float64Array(points.length);
                                for (var i: number = 0; i < points.length; i++) {
                                    resultPoints[i] = this.evaluateMatrix(points[i]);
                                }
                                return resultPoints;
                            }

                            public getGlobalMean(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mGlobalMean;
                            }

                            public setGlobalMean(globalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mGlobalMean = globalMean;
                            }

                            public getmGlobalCovarianceSmoothed(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                if (this.mBandwidthMatrix == null) {
                                    this.mBandwidthMatrix = this.mGlobalCovariance.scale(0);
                                }
                                return (this.mGlobalCovariance.plus(this.mBandwidthMatrix));
                            }

                            public setSampleModelForget(forgettingFactor: number, compressionThreshold: number): void {
                                this.mGlobalWeight = 0;
                                this.mForgettingFactor = 0;
                                this.mSubDistributions = new Array();
                                this.mBandwidthMatrix = null;
                                this.mGlobalCovariance = null;
                                this.mGlobalMean = null;
                                this.mSubspace = null;
                                this.mSubspaceGlobalCovariance = null;
                                this.mSubspaceInverseCovariance = null;
                                this.mGlobalWeight = 0;
                                this.mEffectiveNoOfSamples = 0;
                                this.mForgettingFactor = forgettingFactor;
                                this.mCompressionThreshold = compressionThreshold;
                                this.mNoOfCompsThreshold = SampleModel.DEFAULT_NO_OF_COMPS_THRES;
                            }

                            constructor() {
                            }

                            public setSampleModel(dist: org.kevoree.modeling.util.maths.gmm.SampleModel): void {
                                var subDists: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = dist.getSubDistributions();
                                var copy: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                for (var i: number = 0; i < subDists.length; i++) {
                                    copy[i] = subDists[i];
                                }
                                this.mSubDistributions = copy;
                                this.mBandwidthMatrix = dist.getBandwidthMatrix();
                                this.mGlobalCovariance = dist.getGlobalCovariance();
                                this.mGlobalMean = dist.getGlobalMean();
                                this.mSubspace = dist.getmSubspace();
                                this.mSubspaceGlobalCovariance = dist.getSubspaceGlobalCovariance();
                                this.mSubspaceInverseCovariance = dist.getSubspaceInverseCovariance();
                                this.mGlobalWeight = dist.getGlobalWeight();
                                this.mEffectiveNoOfSamples = dist.mEffectiveNoOfSamples;
                            }

                            public overWirite(dist: org.kevoree.modeling.util.maths.gmm.SampleModel): void {
                                var subDists: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = dist.getSubDistributions();
                                var copy: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                this.mSubDistributions = copy;
                                this.mBandwidthMatrix = dist.getBandwidthMatrix();
                                this.mGlobalCovariance = dist.getGlobalCovariance();
                                this.mGlobalMean = dist.getGlobalMean();
                                this.mSubspace = dist.getmSubspace();
                                this.mSubspaceGlobalCovariance = dist.getSubspaceGlobalCovariance();
                                this.mSubspaceInverseCovariance = dist.getSubspaceInverseCovariance();
                                this.mGlobalWeight = dist.getGlobalWeight();
                                this.mEffectiveNoOfSamples = dist.mEffectiveNoOfSamples;
                            }

                            public getmSubspace(): Int32Array {
                                return this.mSubspace;
                            }

                            public setmSubspace(mSubspace: Int32Array): void {
                                this.mSubspace = mSubspace;
                            }

                            public updateDistributionArrayMatrix(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], weights: Float64Array): void {
                                this.checkInputParams(means, covariances, weights);
                                this.addDistributions(weights, means, covariances);
                                var newPoints: Int32Array = new Int32Array(this.mSubDistributions.length - (this.mSubDistributions.length - means.length));
                                var j: number = 0;
                                for (var i: number = (this.mSubDistributions.length - means.length); i < this.mSubDistributions.length; i++) {
                                    newPoints[j] = i;
                                }
                                this.updateDistributionArray(newPoints);
                            }

                            public updateDistributionValues(mean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, covariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, weight: number): void {
                                this.addDistribution(weight, mean, covariance);
                                var newPoints: Int32Array = new Int32Array(1);
                                newPoints[0] = (this.mSubDistributions.length - 1);
                                this.updateDistributionArray(newPoints);
                            }

                            private updateDistributionArray(newPoints: Int32Array): void {
                                var subDists: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = this.getSubDistributions();
                                var weights: Float64Array = new Float64Array(subDists.length);
                                for (var i: number = 0; i < subDists.length; i++) {
                                    weights[i] = subDists[i].getGlobalWeight();
                                }
                                var subSpaceDist: org.kevoree.modeling.util.maths.gmm.SampleModel = null;
                                try {
                                    subSpaceDist = org.kevoree.modeling.util.maths.gmm.SampleModel.projectToSubspace(this);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var ex: Error = <Error>$ex$;
                                        console.error(ex['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                                var bandwidthFactor: number = this.reestimateBandwidth(subSpaceDist.getSubMeans(), subSpaceDist.getSubCovariances(), weights, subSpaceDist.getSubspaceGlobalCovariance(), this.mEffectiveNoOfSamples);
                                var bandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.gmm.SampleModel.projectBandwidthToOriginalSpace(subSpaceDist, bandwidthFactor);
                                this.mBandwidthMatrix = bandwidthMatrix;
                                for (var i: number = 0; i < this.getSubDistributions().length; i++) {
                                    this.getSubDistributions()[i].setBandwidthMatrix(bandwidthMatrix);
                                }
                                if (this.mGlobalCovariance == null) {
                                    this.mGlobalCovariance = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(2, 2);
                                }
                                try {
                                    org.kevoree.modeling.util.maths.gmm.Compressor.compress(this, newPoints);
                                } catch ($ex$) {
                                    if ($ex$ instanceof Error) {
                                        var e: Error = <Error>$ex$;
                                        console.error(e['stack']);;
                                    } else {
                                        throw $ex$;
                                    }
                                }
                            }

                            private checkInputParams(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], weights: Float64Array): boolean {
                                if (weights == null || weights.length == 0 || means == null || means.length == 0 || covariances == null || covariances.length == 0) {
                                    return false;
                                } else {
                                    return true;
                                }
                            }

                            private addDistributions(weights: Float64Array, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): void {
                                var sumOfNewWeights: number = 0;
                                var len: number = this.mSubDistributions.length;
                                var array2: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                java.lang.System.arraycopy(this.mSubDistributions, 0, array2, 0, this.mSubDistributions.length);
                                this.mSubDistributions = array2;
                                for (var i: number = 0; i < weights.length; i++) {
                                    sumOfNewWeights += weights[i];
                                    var res: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                    res.setValues(weights[i], means[i], covariances[i], this.mBandwidthMatrix);
                                    this.mSubDistributions[i + len] = (res);
                                }
                                var mixWeightOld: number = (this.mEffectiveNoOfSamples * this.mForgettingFactor) / (this.mEffectiveNoOfSamples * this.mForgettingFactor + sumOfNewWeights);
                                var mixWeightNew: number = sumOfNewWeights / (this.mEffectiveNoOfSamples * this.mForgettingFactor + sumOfNewWeights);
                                this.mEffectiveNoOfSamples = this.mEffectiveNoOfSamples * this.mForgettingFactor + weights.length;
                                this.mGlobalWeight = mixWeightOld + mixWeightNew;
                                for (var i: number = 0; i < this.mSubDistributions.length - weights.length; i++) {
                                    var tmpWeight: number = this.mSubDistributions[i].getGlobalWeight();
                                    this.mSubDistributions[i].setGlobalWeight(tmpWeight * mixWeightOld);
                                }
                                for (var i: number = this.mSubDistributions.length - weights.length; i < this.mSubDistributions.length; i++) {
                                    var tmpWeight: number = this.mSubDistributions[i].getGlobalWeight();
                                    this.mSubDistributions[i].setGlobalWeight(tmpWeight * mixWeightNew * (1 / weights.length));
                                }
                            }

                            private addDistribution(weight: number, mean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, covariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                var sumOfNewWeights: number = 0;
                                sumOfNewWeights += weight;
                                var res: org.kevoree.modeling.util.maths.gmm.OneComponentDistribution = new org.kevoree.modeling.util.maths.gmm.OneComponentDistribution();
                                res.setValues(weight, mean, covariance, this.mBandwidthMatrix);
                                var array2: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                java.lang.System.arraycopy(this.mSubDistributions, 0, array2, 0, this.mSubDistributions.length);
                                array2[this.mSubDistributions.length] = res;
                                this.mSubDistributions = array2;
                                var mixWeightOld: number = (this.mEffectiveNoOfSamples * this.mForgettingFactor) / (this.mEffectiveNoOfSamples * this.mForgettingFactor + sumOfNewWeights);
                                var mixWeightNew: number = sumOfNewWeights / (this.mEffectiveNoOfSamples * this.mForgettingFactor + sumOfNewWeights);
                                this.mEffectiveNoOfSamples = this.mEffectiveNoOfSamples * this.mForgettingFactor + 1;
                                this.mGlobalWeight = mixWeightOld + mixWeightNew;
                                for (var i: number = 0; i < this.mSubDistributions.length - 1; i++) {
                                    var tmpWeight: number = this.mSubDistributions[i].getGlobalWeight();
                                    this.mSubDistributions[i].setGlobalWeight(tmpWeight * mixWeightOld);
                                }
                                for (var i: number = this.mSubDistributions.length - 1; i < this.mSubDistributions.length; i++) {
                                    var tmpWeight: number = this.mSubDistributions[i].getGlobalWeight();
                                    this.mSubDistributions[i].setGlobalWeight(tmpWeight * mixWeightNew * (1 / 1));
                                }
                            }

                            private static projectToSubspace(dist: org.kevoree.modeling.util.maths.gmm.SampleModel): org.kevoree.modeling.util.maths.gmm.SampleModel {
                                var minBW: number = 1e-7;
                                var distribution: org.kevoree.modeling.util.maths.gmm.SampleModel = new org.kevoree.modeling.util.maths.gmm.SampleModel();
                                distribution.setSampleModel(dist);
                                var subSpace: Int32Array = new Int32Array(1);
                                org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments(distribution);
                                var overallCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getGlobalCovariance();
                                var svd: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> = overallCovariance.svd(true);
                                var U: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getU();
                                var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getW();
                                S = S.extractDiag();
                                var F: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(0, 0);
                                var count: number = 0;
                                var mean: number = 0;
                                for (var i: number = 0; i < U.numRows(); i++) {
                                    if (S.getValue2D(i, 0) > minBW) {
                                        var array2: Int32Array = new Int32Array(subSpace.length + 1);
                                        java.lang.System.arraycopy(subSpace, 0, array2, 0, subSpace.length);
                                        array2[subSpace.length] = i;
                                        subSpace = array2;
                                        var colU: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = U.extractVector(false, i);
                                        var rowW: number = Math.pow(S.getValue2D(i, 0), -0.5);
                                        colU = colU.scale(rowW);
                                        F = F.combine(0, F.numCols(), colU);
                                        mean += S.getValue2D(i, 0);
                                        count++;
                                    }
                                }
                                mean = (mean / count) * 1e-2;
                                for (var i: number = 0; i < S.numRows(); i++) {
                                    if (S.getValue2D(i, 0) < minBW) {
                                        S.setValue2D(i, 0, mean);
                                    }
                                }
                                var iF: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(0, 0);
                                for (var i: number = 0; i < U.numCols(); i++) {
                                    var coliF: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = U.extractVector(false, i);
                                    var rowW: number = Math.pow(S.getValue2D(i, 0), 0.5);
                                    coliF = coliF.scale(rowW).transpose();
                                    iF = iF.combine(iF.numRows(), 0, coliF);
                                }
                                var subspaceCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = F.transpose().mult(overallCovariance).mult(F);
                                distribution.setSubspaceGlobalCovariance(subspaceCov);
                                var originalMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubMeans();
                                var subspaceMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getGlobalMean();
                                for (var i: number = 0; i < originalMeans.length; i++) {
                                    originalMeans[i] = originalMeans[i].minus(subspaceMean);
                                }
                                var covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = distribution.getSubCovariances();
                                for (var i: number = 0; i < originalMeans.length; i++) {
                                    originalMeans[i] = F.transpose().mult(originalMeans[i]);
                                    covariances[i] = F.transpose().mult(covariances[i]).mult(F);
                                }
                                distribution.setSubCovariances(covariances);
                                distribution.setSubMeans(originalMeans);
                                distribution.setSubspaceInverseCovariance(iF);
                                distribution.setmSubspace(subSpace);
                                return distribution;
                            }

                            public static containsVal(i: number, j: number, subspace: Int32Array): boolean {
                                var conti: boolean = false;
                                var contj: boolean = false;
                                for (var k: number = 0; k < subspace.length; k++) {
                                    conti = conti || (subspace[k] == i);
                                    contj = contj || (subspace[k] == j);
                                }
                                return conti && contj;
                            }

                            private static projectBandwidthToOriginalSpace(distribution: org.kevoree.modeling.util.maths.gmm.SampleModel, bandwidthFactor: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(distribution.getGlobalCovariance().numCols());
                                var subSpaceBandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getSubspaceGlobalCovariance().scale(Math.pow(bandwidthFactor, 2));
                                var subspace: Int32Array = distribution.getmSubspace();
                                for (var i: number = 0; i < subSpaceBandwidth.numRows(); i++) {
                                    for (var j: number = 0; j < subSpaceBandwidth.numCols(); j++) {
                                        if (org.kevoree.modeling.util.maths.gmm.SampleModel.containsVal(i, j, subspace)) {
                                            bandwidth.setValue2D(i, j, subSpaceBandwidth.getValue2D(i, j));
                                        }
                                    }
                                }
                                var invSubspaceCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getSubspaceInverseCovariance();
                                bandwidth = invSubspaceCov.transpose().mult(bandwidth).mult(invSubspaceCov);
                                return bandwidth;
                            }

                            private reestimateBandwidth(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], weights: Float64Array, Cov_smp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, N_eff: number): number {
                                var d: number = means[0].numRows();
                                var G: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = Cov_smp.scale(Math.pow((2 / (d + 2)), (2 / (d + 4))) * 4 * Math.pow(N_eff, -2 / (4 + d)));
                                var alphaScale: number = 1;
                                var F: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = Cov_smp.scale(alphaScale);
                                var Rf2: number = this.getIntSquaredHessian(means, weights, covariance, F, G);
                                var hAmise: number = Math.pow((Math.pow(N_eff, (-1)) * Math.pow(F.determinant(), (-1 / 2)) / (Math.pow(Math.sqrt(4 * Math.PI), d) * Rf2 * d)), (1 / (d + 4)));
                                return hAmise;
                            }

                            private getIntSquaredHessian(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], weights: Float64Array, covariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], F: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, g: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var d: number = means[0].numRows();
                                var N: number = means.length;
                                var constNorm: number = Math.pow((1 / (2 * Math.PI)), (d / 2));
                                var Id: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(F.numCols());
                                var deltaF: number = F.minus(Id).elementSum();
                                var w1: number;
                                var w2: number;
                                var m: number;
                                var I: number = 0;
                                var eta: number;
                                var f_t: number;
                                var c: number;
                                var s1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var s2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var mu1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var mu2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var dm: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var ds: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var B: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                var C: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                for (var i1: number = 0; i1 < N; i1++) {
                                    s1 = covariance[i1].plus(g);
                                    mu1 = means[i1];
                                    w1 = weights[i1];
                                    for (var i2: number = i1; i2 < N; i2++) {
                                        s2 = covariance[i2];
                                        mu2 = means[i2];
                                        w2 = weights[i2];
                                        var A: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = s1.plus(s2).invert();
                                        dm = mu1.minus(mu2);
                                        if (deltaF > 1e-3) {
                                            ds = dm.transpose().mult(A);
                                            b = ds.transpose().mult(ds);
                                            B = A.minus(b.scale(2));
                                            C = A.minus(b);
                                            f_t = constNorm * Math.sqrt(A.determinant()) * Math.exp(-0.5 * ds.mult(dm).trace());
                                            c = 2 * F.mult(A).mult(F).mult(B).trace() + Math.pow(F.mult(C).trace(), 2);
                                        } else {
                                            m = dm.transpose().mult(A).mult(dm).getValue1D(0);
                                            f_t = constNorm * Math.sqrt(A.determinant()) * Math.exp(-0.5 * m);
                                            var A_sqr: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows(), A.numCols());
                                            org.kevoree.modeling.util.maths.matrix.CommonOps.elementMult(A.getMatrix(), A.transpose().getMatrix(), A_sqr);
                                            var sum: number = org.kevoree.modeling.util.maths.matrix.CommonOps.elementSum(A_sqr);
                                            c = 2 * sum * (1 - 2 * m) + Math.pow((1 - m), 2) * Math.pow(A.trace(), 2);
                                        }
                                        if (i1 == i2) {
                                            eta = 1;
                                        } else {
                                            eta = 2;
                                        }
                                        I = I + f_t * c * w2 * w1 * eta;
                                    }
                                }
                                return I;
                            }

                            public setSubDistributions(subDistributions: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[]): void {
                                this.mSubDistributions = subDistributions;
                            }

                            public getSubDistributions(): org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] {
                                return this.mSubDistributions;
                            }

                            public addToSubDistribution(dist: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution): void {
                                var array2: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                java.lang.System.arraycopy(this.mSubDistributions, 0, array2, 0, this.mSubDistributions.length);
                                array2[array2.length - 1] = dist;
                                this.mSubDistributions = array2;
                            }

                            public setSubMeans(means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): void {
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    this.mSubDistributions[i].setGlobalMean(means[i]);
                                }
                            }

                            public setSubCovariances(covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): void {
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    this.mSubDistributions[i].setGlobalCovariance(covariances[i]);
                                }
                            }

                            public getSubSmoothedCovariances(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] {
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    covs[i] = (d.getmGlobalCovarianceSmoothed());
                                }
                                return covs;
                            }

                            public getSubMeans(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    try {
                                        means[i] = (d.getGlobalMean());
                                    } catch ($ex$) {
                                        if ($ex$ instanceof Error) {
                                            var ex: Error = <Error>$ex$;
                                            var x: number = 9;
                                        } else {
                                            throw $ex$;
                                        }
                                    }
                                }
                                return means;
                            }

                            public getSubCovariances(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] {
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    covs[i] = (d.getGlobalCovariance());
                                }
                                return covs;
                            }

                            public getSubWeights(): Float64Array {
                                var weights: Float64Array = new Float64Array(this.mSubDistributions.length);
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    weights[i] = (d.getGlobalWeight());
                                }
                                return weights;
                            }

                            public setSubWeights(weights: Float64Array): void {
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    this.mSubDistributions[i].setGlobalWeight(weights[i]);
                                }
                            }

                            public getMarginalDistribution(n: number): org.kevoree.modeling.util.maths.gmm.ConditionalDistribution {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubMeans();
                                var marginalMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubSmoothedCovariances();
                                var marginalCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                var weights: Float64Array = this.getSubWeights();
                                var result: org.kevoree.modeling.util.maths.gmm.ConditionalDistribution = null;
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                for (var i: number = 0; i < means.length; i++) {
                                    var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                    var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                    var m1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(n, 1);
                                    var newC1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(n, n);
                                    for (var j: number = 0; j < n; j++) {
                                        for (var k: number = 0; k < n; k++) {
                                            newC1.setValue2D(j, k, c.getValue2D(j, k));
                                        }
                                    }
                                    for (var j: number = 0; j < n; j++) {
                                        m1.setValue2D(j, 0, m.getValue2D(j, 0));
                                    }
                                    marginalMeans[i] = (m1);
                                    marginalCovs[i] = (newC1);
                                }
                                result = new org.kevoree.modeling.util.maths.gmm.ConditionalDistribution(marginalMeans, marginalCovs, weights);
                                return result;
                            }

                            public getConditionalDistribution(condition: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.gmm.ConditionalDistribution {
                                var lenCond: number = condition.numRows();
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubMeans();
                                var conditionalMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubSmoothedCovariances();
                                var conditionalCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                var weights: Float64Array = this.getSubWeights();
                                var conditionalWeights: Float64Array = new Float64Array(means.length);
                                var result: org.kevoree.modeling.util.maths.gmm.ConditionalDistribution = null;
                                var n: number = condition.numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                for (var i: number = 0; i < means.length; i++) {
                                    var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                    var invC: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = c.invert();
                                    var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                    var lenM1: number = m.numRows() - lenCond;
                                    var m1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(lenM1, 1);
                                    var m2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(lenCond, 1);
                                    var newC1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(lenM1, lenM1);
                                    for (var j: number = 0; j < lenM1; j++) {
                                        for (var k: number = 0; k < lenM1; k++) {
                                            newC1.setValue2D(j, k, invC.getValue2D(j + lenCond, k + lenCond));
                                        }
                                    }
                                    var newC2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(lenM1, lenCond);
                                    for (var j: number = 0; j < lenM1; j++) {
                                        for (var k: number = 0; k < lenCond; k++) {
                                            newC2.setValue2D(j, k, invC.getValue2D(j + lenCond, k));
                                        }
                                    }
                                    for (var j: number = 0; j < lenCond; j++) {
                                        m2.setValue2D(j, 0, m.getValue2D(j, 0));
                                    }
                                    for (var j: number = 0; j < lenM1; j++) {
                                        m1.setValue2D(j, 0, m.getValue2D(j + lenCond, 0));
                                    }
                                    var invNewC1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = newC1.invert();
                                    var condMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = m1.minus(invNewC1.mult(newC2).mult(condition.minus(m2)));
                                    var condCovariance: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = invNewC1;
                                    conditionalMeans[i] = (condMean);
                                    conditionalCovs[i] = (condCovariance);
                                    var newC22: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(lenCond, lenCond);
                                    for (var j: number = 0; j < lenCond; j++) {
                                        for (var k: number = 0; k < lenCond; k++) {
                                            newC22.setValue2D(j, k, c.getValue2D(j, k));
                                        }
                                    }
                                    var mahalanobisDistance: number = condition.minus(m2).transpose().mult(newC22.invert()).mult(condition.minus(m2)).trace();
                                    var newWeight: number = ((1 / (a * Math.sqrt(newC22.determinant()))) * Math.exp((-0.5) * mahalanobisDistance)) * weights[i];
                                    conditionalWeights[i] = (newWeight);
                                }
                                var weightSum: number = 0;
                                for (var i: number = 0; i < conditionalWeights.length; i++) {
                                    weightSum += conditionalWeights[i];
                                }
                                for (var i: number = 0; i < conditionalWeights.length; i++) {
                                    var weight: number = conditionalWeights[i];
                                    weight = weight / weightSum;
                                    conditionalWeights[i] = weight;
                                }
                                result = new org.kevoree.modeling.util.maths.gmm.ConditionalDistribution(conditionalMeans, conditionalCovs, conditionalWeights);
                                return result;
                            }

                            public gradQuadrSearch(start: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.gmm.SearchResult {
                                var condVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(4, 1);
                                for (var i: number = 0; i < condVector.numRows(); i++) {
                                    condVector.setValue2D(i, 0, start.getValue2D(i, 0));
                                }
                                var conditionalDist: org.kevoree.modeling.util.maths.gmm.ConditionalDistribution = this.getConditionalDistribution(condVector);
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = conditionalDist.conditionalMeans;
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = conditionalDist.conditionalCovs;
                                var weights: Float64Array = conditionalDist.conditionalWeights;
                                var gradient: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(2, 1);
                                var hessian: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(2, 2);
                                var n: number = means[0].numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                var x: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(2, 1);
                                x.setValue2D(0, 0, start.getValue2D(start.numRows() - 2, 0));
                                x.setValue2D(1, 0, start.getValue2D(start.numRows() - 1, 0));
                                var mahalanobisDistances: Float64Array;
                                var step: number = 1;
                                var probability: number = 0;
                                var gradStep: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = null;
                                do {
                                    mahalanobisDistances = this.mahalanobis(x, means, covs);
                                    var prob: number = 0;
                                    for (var i: number = 0; i < means.length; i++) {
                                        if (mahalanobisDistances[i] < SampleModel.MAX_MAHALANOBIS_DIST) {
                                            var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                            var dm: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = m.minus(x);
                                            var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                            var invC: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = c.invert();
                                            var w: number = weights[i];
                                            var p: number = ((1 / (a * Math.sqrt(c.determinant()))) * Math.exp((-0.5) * mahalanobisDistances[i])) * w;
                                            prob += p;
                                            gradient = gradient.plus(invC.mult(dm).scale(p));
                                            hessian = hessian.plus(invC.mult(dm.mult(dm.transpose()).minus(c)).mult(invC).scale(p));
                                        }
                                    }
                                    var xOld: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = x.copy();
                                    var hessianEVD: org.kevoree.modeling.util.maths.matrix.solvers.SimpleEVD<any> = hessian.eig();
                                    var maxEVIndex: number = hessianEVD.getIndexMax();
                                    if (hessianEVD.getEigenvalue(maxEVIndex).getReal() < 0) {
                                        gradStep = hessian.invert().mult(gradient);
                                        x = xOld.minus(gradStep);
                                    }
                                    var prob1: number = this.evaluate(x, means, covs, weights);
                                    if (prob1 <= prob || hessianEVD.getEigenvalue(maxEVIndex).getReal() >= 0) {
                                        gradStep = gradient.scale(step);
                                        x = xOld.plus(gradStep);
                                        while (this.evaluate(x, means, covs, weights) < prob){
                                            step = step / 2;
                                            gradStep = gradient.scale(step);
                                            x = xOld.plus(gradStep);
                                        }
                                    }
                                    probability = this.evaluate(x, means, covs, weights);
                                } while (gradStep.elementMaxAbs() > 1E-10)
                                return new org.kevoree.modeling.util.maths.gmm.SearchResult(x, probability);
                            }

                            public evaluateMatrix(pointVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubMeans();
                                var covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = this.getSubSmoothedCovariances();
                                var weights: Float64Array = this.getSubWeights();
                                var d: number = 0;
                                var n: number = means[0].numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                var mahalanobisDistances: Float64Array = this.mahalanobis(pointVector, means, covs);
                                for (var i: number = 0; i < means.length; i++) {
                                    if (mahalanobisDistances[i] < SampleModel.MAX_MAHALANOBIS_DIST) {
                                        var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                        var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                        var w: number = weights[i];
                                        d += ((1 / (a * Math.sqrt(c.determinant()))) * Math.exp((-0.5) * mahalanobisDistances[i])) * w;
                                    }
                                }
                                return d;
                            }

                            public evaluate(pointVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], weights: Float64Array): number {
                                var d: number = 0;
                                var n: number = means[0].numRows();
                                var a: number = Math.pow(Math.sqrt(2 * Math.PI), n);
                                var mahalanobisDistances: Float64Array = this.mahalanobis(pointVector, means, covs);
                                for (var i: number = 0; i < means.length; i++) {
                                    if (mahalanobisDistances[i] < SampleModel.MAX_MAHALANOBIS_DIST) {
                                        var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                        var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                        var w: number = weights[i];
                                        d += ((1 / (a * Math.sqrt(c.determinant()))) * Math.exp((-0.5) * mahalanobisDistances[i])) * w;
                                    }
                                }
                                return d;
                            }

                            public mahalanobis(x: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[]): Float64Array {
                                var mahalanobisDistances: Float64Array = new Float64Array(means.length);
                                for (var i: number = 0; i < means.length; i++) {
                                    var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = means[i];
                                    var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = covs[i];
                                    var distance: number = x.minus(m).transpose().mult(c.invert()).mult(x.minus(m)).trace();
                                    mahalanobisDistances[i] = (distance);
                                }
                                return mahalanobisDistances;
                            }

                            public resetProbabilityCache(): void {
                                this.mProbabilityCache.clear();
                            }

                            public setBandwidthMatrix(mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mBandwidthMatrix = mBandwidthMatrix;
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    var d: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution = this.mSubDistributions[i];
                                    d.setBandwidthMatrix(mBandwidthMatrix);
                                }
                            }

                            public setNoOfCompsThreshold(threshold: number): void {
                                this.mNoOfCompsThreshold = threshold;
                            }

                            public getNoOfCompsThreshold(): number {
                                return this.mNoOfCompsThreshold;
                            }

                            public removeSubDistributions(index: number): void {
                                var array2: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = new Array();
                                for (var i: number = 0; i < this.mSubDistributions.length; i++) {
                                    if (i < index) {
                                        array2[i] = this.mSubDistributions[i];
                                    } else {
                                        if (i > index) {
                                            array2[i] = this.mSubDistributions[i - 1];
                                        }
                                    }
                                }
                                this.mSubDistributions = array2;
                            }

                        }

                        export class SearchResult {

                            public point: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            public probability: number;
                            constructor(point: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, probability: number) {
                                this.point = point;
                                this.probability = probability;
                            }

                        }

                        export class SigmaPoint {

                            private mPointVecor: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            private mWeightInComponent: number;
                            private mWeight: number;
                            public getmWeightInComponent(): number {
                                return this.mWeightInComponent;
                            }

                            public setmWeightInComponent(mWeightInComponent: number): void {
                                this.mWeightInComponent = mWeightInComponent;
                            }

                            constructor(mPointVecor: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, weight: number, weightInComponent: number) {
                                this.mPointVecor = mPointVecor;
                                this.mWeight = weight;
                                this.mWeightInComponent = weightInComponent;
                            }

                            public getmPointVecor(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                return this.mPointVecor;
                            }

                            public setmPointVecor(mPointVecor: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                this.mPointVecor = mPointVecor;
                            }

                            public getmWeight(): number {
                                return this.mWeight;
                            }

                            public setmWeight(mWeight: number): void {
                                this.mWeight = mWeight;
                            }

                        }

                        export class ThreeComponentDistribution extends org.kevoree.modeling.util.maths.gmm.MultipleComponentDistribution {

                            private static NO_OF_COMPONENTS: number = 3;
                            constructor(weights: Float64Array, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix) {
                                super();
                                super.setValues(weights, means, covariances, bandwidth);
                            }

                        }

                        export class TwoComponentDistribution extends org.kevoree.modeling.util.maths.gmm.MultipleComponentDistribution {

                            private static NO_OF_COMPONENTS: number = 2;
                            constructor(weights: Float64Array, means: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], covariances: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[], bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix) {
                                super();
                                super.setValues(weights, means, covariances, bandwidth);
                            }

                        }

                        export module projection {
                            export class ProjectionData {

                                public mSVD: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any>;
                                public mValidElements: Float64Array;
                                public mCountValidElements: number;
                                public mBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                public mGlobalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                            }

                            export class Projector {

                                private static MIN_VALUE: number = 1E-7;
                                private static CONST_SMALL_FACTOR: number = 1E-10;
                                public static projectSampleDistToSubspace(distribution: org.kevoree.modeling.util.maths.gmm.SampleModel): org.kevoree.modeling.util.maths.gmm.projection.ProjectionData {
                                    var projectionData: org.kevoree.modeling.util.maths.gmm.projection.ProjectionData = new org.kevoree.modeling.util.maths.gmm.projection.ProjectionData();
                                    org.kevoree.modeling.util.maths.gmm.MomentMatcher.matchMoments(distribution);
                                    var globalSmoothedCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getmGlobalCovarianceSmoothed();
                                    var globalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getGlobalMean();
                                    var globalCovSize: number = globalSmoothedCov.numRows();
                                    var identity: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(globalCovSize);
                                    globalSmoothedCov = globalSmoothedCov.plus(identity.scale(Projector.CONST_SMALL_FACTOR));
                                    var d: number = globalSmoothedCov.numCols();
                                    projectionData.mSVD = globalSmoothedCov.svd(true);
                                    var svd: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> = globalSmoothedCov.svd(true);
                                    var U: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getU();
                                    var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getW();
                                    var V: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getV();
                                    V = U;
                                    var s: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = S.extractDiag();
                                    s = s.scale(1 / S.elementMaxAbs());
                                    var validElements: Float64Array = new Float64Array(d);
                                    var countValidElements: number = 0;
                                    var invS: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = null;
                                    if (s.elementMaxAbs() < Projector.MIN_VALUE || org.kevoree.modeling.util.PrimitiveHelper.isNaN(s.elementSum())) {
                                        S = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(S.numCols()).transpose();
                                        invS = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(d).scale(2 / Projector.MIN_VALUE);
                                        for (var i: number = 0; i < validElements.length; i++) {
                                            validElements[i] = 1;
                                        }
                                        countValidElements = validElements.length;
                                    } else {
                                        for (var i: number = 0; i < validElements.length; i++) {
                                            if (s.getValue2D(i, 0) > Projector.MIN_VALUE) {
                                                validElements[i] = 1;
                                                countValidElements++;
                                            } else {
                                                validElements[i] = s.getValue2D(i, 0);
                                            }
                                        }
                                        S = org.kevoree.modeling.util.maths.matrix.CommonOps.elemPow(S, -1);
                                        invS = org.kevoree.modeling.util.maths.matrix.SimpleMatrix.identity(d).scale(0);
                                        for (var i: number = 0; i < validElements.length; i++) {
                                            if (validElements[i] == 1) {
                                                invS.setValue2D(i, i, S.getValue2D(i, i));
                                            } else {
                                                invS.setValue2D(i, i, 1 / validElements[i]);
                                            }
                                        }
                                    }
                                    var trnsF: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.matrix.CommonOps.elemSqrt(org.kevoree.modeling.util.maths.matrix.CommonOps.abs(invS)).mult(V.invert());
                                    var trnsBandwidthMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = org.kevoree.modeling.util.maths.gmm.projection.Projector.transformMatrix(trnsF, distribution.getBandwidthMatrix(), validElements, countValidElements);
                                    var subDistributions: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = distribution.getSubDistributions();
                                    for (var i: number = 0; i < subDistributions.length; i++) {
                                        var subSubMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                        var subSubCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                        if (subDistributions[i] instanceof org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution) {
                                            var subDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = <org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i];
                                            subSubMeans = subDist.getSubMeans();
                                            subSubCovs = subDist.getSubCovariances();
                                        }
                                        if (subSubMeans.length > 1) {
                                            for (var j: number = 0; j < subSubMeans.length; j++) {
                                                subSubCovs[j] = org.kevoree.modeling.util.maths.gmm.projection.Projector.transformMatrix(trnsF, subSubCovs[j], validElements, countValidElements);
                                                var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = trnsF.mult(subSubMeans[j].minus(globalMean));
                                                tmp = org.kevoree.modeling.util.maths.matrix.CommonOps.deleteElementsFromVector(tmp, validElements, countValidElements);
                                                subSubMeans[j] = tmp;
                                            }
                                            try {
                                                (<org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i]).setSubMeans(subSubMeans);
                                                (<org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i]).setSubCovariances(subSubCovs);
                                            } catch ($ex$) {
                                                if ($ex$ instanceof Error) {
                                                    var e: Error = <Error>$ex$;
                                                    console.error(e['stack']);;
                                                } else {
                                                    throw $ex$;
                                                }
                                            }
                                        }
                                        var subMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = subDistributions[i].getGlobalMean();
                                        var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = trnsF.mult(subMean.minus(globalMean));
                                        tmp = org.kevoree.modeling.util.maths.matrix.CommonOps.deleteElementsFromVector(tmp, validElements, countValidElements);
                                        subDistributions[i].setGlobalMean(tmp);
                                        var subCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = subDistributions[i].getGlobalCovariance();
                                        subCov = org.kevoree.modeling.util.maths.gmm.projection.Projector.transformMatrix(trnsF, subCov, validElements, countValidElements);
                                        subDistributions[i].setGlobalCovariance(subCov);
                                        subDistributions[i].setBandwidthMatrix(trnsBandwidthMatrix);
                                    }
                                    globalSmoothedCov = org.kevoree.modeling.util.maths.gmm.projection.Projector.transformMatrix(trnsF, globalSmoothedCov, validElements, countValidElements);
                                    distribution.setBandwidthMatrix(trnsBandwidthMatrix);
                                    projectionData.mCountValidElements = countValidElements;
                                    projectionData.mValidElements = validElements;
                                    projectionData.mGlobalMean = globalMean;
                                    return projectionData;
                                }

                                private static transformMatrix(trnsF: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, validElements: Float64Array, countValidElements: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                    var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = trnsF.mult(matrix).mult(trnsF.transpose());
                                    var trnsMatrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(countValidElements, countValidElements);
                                    var row: number = 0;
                                    var column: number = 0;
                                    for (var i: number = 0; i < validElements.length; i++) {
                                        for (var j: number = 0; j < validElements.length; j++) {
                                            if (validElements[i] == 1 && validElements[j] == 1) {
                                                trnsMatrix.setValue2D(row, column++, tmp.getValue2D(i, j));
                                            }
                                        }
                                        column = 0;
                                        row++;
                                    }
                                    return trnsMatrix;
                                }

                                private static backTransformMatrix(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, matrixToTransform: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, validElements: Float64Array): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                    var row: number = 0;
                                    var column: number = 0;
                                    for (var i: number = 0; i < validElements.length; i++) {
                                        for (var j: number = 0; j < validElements.length; j++) {
                                            if (validElements[i] == 1 && validElements[j] == 1) {
                                                matrix.setValue2D(i, j, matrixToTransform.getValue2D(row, column++));
                                            }
                                        }
                                        column = 0;
                                        row++;
                                    }
                                    return matrix;
                                }

                                public static projectSampleDistToOriginalSpace(distribution: org.kevoree.modeling.util.maths.gmm.SampleModel, projectionData: org.kevoree.modeling.util.maths.gmm.projection.ProjectionData): void {
                                    var bandwidth: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = distribution.getBandwidthMatrix();
                                    var svd: org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> = projectionData.mSVD;
                                    var U: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getU();
                                    var S: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getW();
                                    var V: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = svd.getV();
                                    var globalMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = projectionData.mGlobalMean;
                                    var validElements: Float64Array = projectionData.mValidElements;
                                    var countValidElements: number = projectionData.mCountValidElements;
                                    var noOfNullDirs: number = S.numCols() - countValidElements;
                                    var trnsF: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = V.mult(org.kevoree.modeling.util.maths.matrix.CommonOps.elemSqrt(S));
                                    var protC: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = S.scale(0);
                                    protC = org.kevoree.modeling.util.maths.gmm.projection.Projector.backTransformMatrix(protC, bandwidth, validElements);
                                    bandwidth = trnsF.mult(protC).mult(trnsF.transpose());
                                    distribution.setBandwidthMatrix(bandwidth);
                                    var subDistributions: org.kevoree.modeling.util.maths.gmm.BaseSampleDistribution[] = distribution.getSubDistributions();
                                    for (var i: number = 0; i < subDistributions.length; i++) {
                                        var subSubMeans: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                        var subSubCovs: org.kevoree.modeling.util.maths.matrix.SimpleMatrix[] = new Array();
                                        if (subDistributions[i] instanceof org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution) {
                                            var subDist: org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution = <org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i];
                                            subSubMeans = subDist.getSubMeans();
                                            subSubCovs = subDist.getSubCovariances();
                                        }
                                        if (subSubMeans.length > 1) {
                                            for (var j: number = 0; j < subSubMeans.length; j++) {
                                                var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(subSubMeans[j].numRows() + noOfNullDirs, 1);
                                                newMean = org.kevoree.modeling.util.maths.gmm.projection.Projector.setVectorElements(newMean, subSubMeans[j], validElements);
                                                var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = trnsF.mult(newMean).plus(globalMean);
                                                subSubMeans[j] = tmp;
                                                protC = protC.scale(0);
                                                subSubCovs[j] = org.kevoree.modeling.util.maths.gmm.projection.Projector.backTransformMatrix(protC, subSubCovs[j], validElements);
                                                subSubCovs[j] = trnsF.mult(subSubCovs[j]).mult(trnsF.transpose());
                                            }
                                            try {
                                                (<org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i]).setSubMeans(subSubMeans);
                                                (<org.kevoree.modeling.util.maths.gmm.TwoComponentDistribution>subDistributions[i]).setSubCovariances(subSubCovs);
                                            } catch ($ex$) {
                                                if ($ex$ instanceof Error) {
                                                    var e: Error = <Error>$ex$;
                                                    console.error(e['stack']);;
                                                } else {
                                                    throw $ex$;
                                                }
                                            }
                                        }
                                        var subMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = subDistributions[i].getGlobalMean();
                                        var newMean: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(subMean.numRows() + noOfNullDirs, 1);
                                        newMean = org.kevoree.modeling.util.maths.gmm.projection.Projector.setVectorElements(newMean, subMean, validElements);
                                        var tmp: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = trnsF.mult(newMean).plus(globalMean);
                                        subDistributions[i].setGlobalMean(tmp);
                                        var subCov: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = subDistributions[i].getGlobalCovariance();
                                        protC = protC.scale(0);
                                        subCov = org.kevoree.modeling.util.maths.gmm.projection.Projector.backTransformMatrix(protC, subCov, validElements);
                                        subCov = trnsF.mult(subCov).mult(trnsF.transpose());
                                        subDistributions[i].setGlobalCovariance(subCov);
                                        subDistributions[i].setBandwidthMatrix(bandwidth);
                                    }
                                }

                                private static setVectorElements(v1: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, v2: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, elementsInV1: Float64Array): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                    var j: number = 0;
                                    for (var i: number = 0; i < v1.numRows(); i++) {
                                        if (elementsInV1[i] == 1) {
                                            v1.setValue2D(i, 0, v2.getValue1D(j++));
                                        }
                                    }
                                    return v1;
                                }

                            }

                        }
                    }
                    export module matrix {
                        export class CommonOps {

                            public static BLOCK_WIDTH: number = 60;
                            public static TRANSPOSE_SWITCH: number = 375;
                            public static MULT_COLUMN_SWITCH: number = 15;
                            public static MULT_TRANAB_COLUMN_SWITCH: number = 40;
                            public static MULT_INNER_SWITCH: number = 100;
                            public static EPS: number = Math.pow(2, -52);
                            public static TOL32: number = 1e-4;
                            public static TOL64: number = 1e-8;
                            public static CMULT_COLUMN_SWITCH: number = 7;
                            public static SWITCH_BLOCK64_CHOLESKY: number = 1000;
                            public static SWITCH_BLOCK64_QR: number = 1500;
                            public static BLOCK_WIDTH_CHOL: number = 20;
                            public static BLOCK_SIZE: number = CommonOps.BLOCK_WIDTH * CommonOps.BLOCK_WIDTH;
                            public static mult(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols == 1) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                                } else {
                                    if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_small(a, b, c);
                                    }
                                }
                            }

                            public static memset(data: Float64Array, val: number): void {
                                for (var i: number = 0; i < data.length; i++) {
                                    data[i] = val;
                                }
                            }

                            public static multalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_reorderalpha(alpha, a, b, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.mult_smallalpha(alpha, a, b, c);
                                }
                            }

                            public static multTransA(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols == 1) {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_small(a, b, c);
                                    }
                                } else {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_small(a, b, c);
                                    }
                                }
                            }

                            public static multTransalphaA(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorderalpha(alpha, a, b, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_smallalpha(alpha, a, b, c);
                                }
                            }

                            public static multTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numRows == 1) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.mult(a, b, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransB(a, b, c);
                                }
                            }

                            public static multTransalphaB(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransBalpha(alpha, a, b, c);
                            }

                            public static multTransAB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numRows == 1) {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multTransA_small(a, b, c);
                                    }
                                } else {
                                    if (a.numCols >= CommonOps.MULT_TRANAB_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransAB_aux(a, b, c, null);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransAB(a, b, c);
                                    }
                                }
                            }

                            public static multTransalphaAB(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols >= CommonOps.MULT_TRANAB_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransAB_auxalpha(alpha, a, b, c, null);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransABalpha(alpha, a, b, c);
                                }
                            }

                            public static dot(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                return org.kevoree.modeling.util.maths.matrix.VectorVectorMult.innerProd(a, b);
                            }

                            public static multInner(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols >= CommonOps.MULT_INNER_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMultProduct.inner_small(a, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMultProduct.inner_reorder(a, c);
                                }
                            }

                            public static multOuter(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                org.kevoree.modeling.util.maths.matrix.MatrixMultProduct.outer(a, c);
                            }

                            public static multAdd(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols == 1) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multAdd(a, b, c);
                                } else {
                                    if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_small(a, b, c);
                                    }
                                }
                            }

                            public static multAddalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_reorderalpha(alpha, a, b, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAdd_smallalpha(alpha, a, b, c);
                                }
                            }

                            public static multAddTransA(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols == 1) {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multAddTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multAddTransA_small(a, b, c);
                                    }
                                } else {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransA_small(a, b, c);
                                    }
                                }
                            }

                            public static multAddTransAalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH || b.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransA_reorderalpha(alpha, a, b, c);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransA_smallalpha(alpha, a, b, c);
                                }
                            }

                            public static multAddTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransB(a, b, c);
                            }

                            public static multAddTransBalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransBalpha(alpha, a, b, c);
                            }

                            public static multAddTransAB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numRows == 1) {
                                    if (a.numCols >= CommonOps.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multAddTransA_reorder(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixVectorMult.multAddTransA_small(a, b, c);
                                    }
                                } else {
                                    if (a.numCols >= CommonOps.MULT_TRANAB_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransAB_aux(a, b, c, null);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransAB(a, b, c);
                                    }
                                }
                            }

                            public static subvector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, rowA: number, colA: number, length: number, row: boolean, offsetV: number, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (row) {
                                    for (var i: number = 0; i < length; i++) {
                                        v.setValueAtIndex(offsetV + i, A.get(rowA, colA + i));
                                    }
                                } else {
                                    for (var i: number = 0; i < length; i++) {
                                        v.setValueAtIndex(offsetV + i, A.get(rowA + i, colA));
                                    }
                                }
                            }

                            public static abs(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                for (var i: number = 0; i < matrix.numRows(); i++) {
                                    for (var j: number = 0; j < matrix.numCols(); j++) {
                                        matrix.setValue2D(i, j, Math.abs(matrix.getValue2D(i, j)));
                                    }
                                }
                                return matrix;
                            }

                            public static elemSqrt(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                for (var i: number = 0; i < matrix.numRows(); i++) {
                                    for (var j: number = 0; j < matrix.numCols(); j++) {
                                        matrix.setValue2D(i, j, Math.sqrt(matrix.getValue2D(i, j)));
                                    }
                                }
                                return matrix;
                            }

                            public static elemPow(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, p: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                for (var i: number = 0; i < matrix.numRows(); i++) {
                                    for (var j: number = 0; j < matrix.numCols(); j++) {
                                        matrix.setValue2D(i, j, Math.pow(matrix.getValue2D(i, j), p));
                                    }
                                }
                                return matrix;
                            }

                            public static deleteElementsFromVector(vector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, elements: Float64Array, vectorSize: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var newVector: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(vectorSize, 1);
                                var j: number = 0;
                                for (var i: number = 0; i < vector.numRows(); i++) {
                                    if (elements[i] == 1) {
                                        newVector.setValue2D(j++, 0, vector.getValue1D(i));
                                    }
                                }
                                return newVector;
                            }

                            public static ones(rows: number, cols: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(rows, cols);
                                for (var i: number = 0; i < rows; i++) {
                                    for (var j: number = 0; j < rows; j++) {
                                        matrix.setValue2D(i, j, 1);
                                    }
                                }
                                return matrix;
                            }

                            public static doubleListToMatrix(valueList: Float64Array): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(1, valueList.length);
                                for (var i: number = 0; i < valueList.length; i++) {
                                    m.setValue2D(0, i, valueList[i]);
                                }
                                return m;
                            }

                            public static setNegativeValuesToZero(valueList: Float64Array): Float64Array {
                                for (var i: number = 0; i < valueList.length; i++) {
                                    if (valueList[i] < 0) {
                                        valueList[i] = 0;
                                    }
                                }
                                return valueList;
                            }

                            public static maxVectorElement(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var d: number = org.kevoree.modeling.util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                                for (var i: number = 0; i < matrix.numRows(); i++) {
                                    if (matrix.getValue2D(i, 0) > d) {
                                        d = matrix.getValue2D(i, 0);
                                    }
                                }
                                return d;
                            }

                            public static maxVectorElementIndex(matrix: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): number {
                                var d: number = org.kevoree.modeling.util.PrimitiveHelper.DOUBLE_MIN_VALUE();
                                var row: number = 0;
                                for (var i: number = 0; i < matrix.numRows(); i++) {
                                    if (matrix.getValue2D(i, 0) > d) {
                                        d = matrix.getValue2D(i, 0);
                                        row = i;
                                    }
                                }
                                return row;
                            }

                            public static multAddTransABalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols >= CommonOps.MULT_TRANAB_COLUMN_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransAB_auxalpha(alpha, a, b, c, null);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multAddTransABalpha(alpha, a, b, c);
                                }
                            }

                            public static trace(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var N: number = Math.min(a.numRows, a.numCols);
                                var sum: number = 0;
                                var index: number = 0;
                                for (var i: number = 0; i < N; i++) {
                                    sum += a.getValueAtIndex(index);
                                    index += 1 + a.numCols;
                                }
                                return sum;
                            }

                            public static transposeMatrix(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (A_tran == null) {
                                    A_tran = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numCols, A.numRows);
                                } else {
                                    if (A.numRows != A_tran.numCols || A.numCols != A_tran.numRows) {
                                        throw new Error("Incompatible matrix dimensions");
                                    }
                                }
                                if (A.numRows > CommonOps.TRANSPOSE_SWITCH && A.numCols > CommonOps.TRANSPOSE_SWITCH) {
                                    org.kevoree.modeling.util.maths.matrix.TransposeAlgs.block(A, A_tran, CommonOps.BLOCK_WIDTH);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.TransposeAlgs.standard(A, A_tran);
                                }
                                return A_tran;
                            }

                            public static transpose(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (mat.numCols == mat.numRows) {
                                    org.kevoree.modeling.util.maths.matrix.TransposeAlgs.square(mat);
                                } else {
                                    var b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(mat.numCols, mat.numRows);
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(mat, b);
                                    mat.setMatrix(b);
                                }
                            }

                            public static det(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var numCol: number = mat.getNumCols();
                                var numRow: number = mat.getNumRows();
                                if (numCol != numRow) {
                                    throw new Error("Must be a square matrix.");
                                } else {
                                    if (numCol <= 1) {
                                        return mat.getValueAtIndex(0);
                                    } else {
                                        var alg: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64();
                                        if (!alg.decompose(mat)) {
                                            return 0.0;
                                        }
                                        return alg.computeDeterminant();
                                    }
                                }
                            }

                            public static invert(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                var alg: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64();
                                var solver: org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64(alg);
                                if (solver.modifiesA()) {
                                    mat = mat.copy();
                                }
                                if (!solver.setA(mat)) {
                                    return false;
                                }
                                solver.invert(result);
                                return true;
                            }

                            public static extractImpl(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcX0: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number, numRows: number, numCols: number): void {
                                for (var y: number = 0; y < numRows; y++) {
                                    var indexSrc: number = src.getIndex(y + srcY0, srcX0);
                                    var indexDst: number = dst.getIndex(y + dstY0, dstX0);
                                    java.lang.System.arraycopy(src.data, indexSrc, dst.data, indexDst, numCols);
                                }
                            }

                            public static extractInsert(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                                var w: number = srcX1 - srcX0;
                                var h: number = srcY1 - srcY0;
                                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
                            }

                            public static insert(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dest: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, destY0: number, destX0: number): void {
                                org.kevoree.modeling.util.maths.matrix.CommonOps.extractInsert(src, 0, src.getNumRows(), 0, src.getNumCols(), dest, destY0, destX0);
                            }

                            public static extract4Int(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.numRows) {
                                    throw new Error("srcY1 <= srcY0 || srcY0 < 0 || srcY1 > src.getNumRows");
                                }
                                if (srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.numCols) {
                                    throw new Error("srcX1 <= srcX0 || srcX0 < 0 || srcX1 > src.getNumCols");
                                }
                                var w: number = srcX1 - srcX0;
                                var h: number = srcY1 - srcY0;
                                var dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(h, w);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, 0, 0, h, w);
                                return dst;
                            }

                            public static columnsToVector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[]): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                                if (v == null || v.length < A.numCols) {
                                    ret = new Array();
                                } else {
                                    ret = v;
                                }
                                for (var i: number = 0; i < ret.length; i++) {
                                    if (ret[i] == null) {
                                        ret[i] = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                                    } else {
                                        ret[i].reshapeBoolean(A.numRows, 1, false);
                                    }
                                    var u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = ret[i];
                                    for (var j: number = 0; j < A.numRows; j++) {
                                        u.set(j, 0, A.get(j, i));
                                    }
                                }
                                return ret;
                            }

                            public static rowsToVector(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[]): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                                if (v == null || v.length < A.numRows) {
                                    ret = new Array();
                                } else {
                                    ret = v;
                                }
                                for (var i: number = 0; i < ret.length; i++) {
                                    if (ret[i] == null) {
                                        ret[i] = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numCols, 1);
                                    } else {
                                        ret[i].reshapeBoolean(A.numCols, 1, false);
                                    }
                                    var u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = ret[i];
                                    for (var j: number = 0; j < A.numCols; j++) {
                                        u.set(j, 0, A.get(i, j));
                                    }
                                }
                                return ret;
                            }

                            public static setIdentity(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                                java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                                var index: number = 0;
                                for (var i: number = 0; i < width; ) {
                                    mat.data[index] = 1;
                                }
                            }

                            public static identity1D(width: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                                for (var i: number = 0; i < width; i++) {
                                    ret.set(i, i, 1.0);
                                }
                                return ret;
                            }

                            public static identity(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                                var small: number = numRows < numCols ? numRows : numCols;
                                for (var i: number = 0; i < small; i++) {
                                    ret.set(i, i, 1.0);
                                }
                                return ret;
                            }

                            public static diag(diagEl: Float64Array): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                return org.kevoree.modeling.util.maths.matrix.CommonOps.diagMatrix(null, diagEl.length, diagEl);
                            }

                            public static diagMatrix(ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, width: number, diagEl: Float64Array): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (ret == null) {
                                    ret = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(ret, 0);
                                }
                                for (var i: number = 0; i < width; i++) {
                                    ret.set(i, i, diagEl[i]);
                                }
                                return ret;
                            }

                            public static kron(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var numColsC: number = A.numCols * B.numCols;
                                var numRowsC: number = A.numRows * B.numRows;
                                for (var i: number = 0; i < A.numRows; i++) {
                                    for (var j: number = 0; j < A.numCols; j++) {
                                        var a: number = A.get(i, j);
                                        for (var rowB: number = 0; rowB < B.numRows; rowB++) {
                                            for (var colB: number = 0; colB < B.numCols; colB++) {
                                                var val: number = a * B.get(rowB, colB);
                                                C.set(i * B.numRows + rowB, j * B.numCols + colB, val);
                                            }
                                        }
                                    }
                                }
                            }

                            public static extractDiag(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var N: number = Math.min(src.numRows, src.numCols);
                                if (!org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isVector(dst)) {
                                    throw new Error("Expected a vector for dst.");
                                }
                                for (var i: number = 0; i < N; i++) {
                                    dst.setValueAtIndex(i, src.get(i, i));
                                }
                            }

                            public static extractRow(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, row: number, out: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (out == null) {
                                    out = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, a.numCols);
                                }
                                java.lang.System.arraycopy(a.data, a.getIndex(row, 0), out.data, 0, a.numCols);
                                return out;
                            }

                            public static extractColumn(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, column: number, out: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (out == null) {
                                    out = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(a.numRows, 1);
                                }
                                var index: number = column;
                                for (var i: number = 0; i < a.numRows; ) {
                                    out.data[i] = a.data[index];
                                }
                                return out;
                            }

                            public static elementMax(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var size: number = a.getNumElements();
                                var max: number = a.getValueAtIndex(0);
                                for (var i: number = 1; i < size; i++) {
                                    var val: number = a.getValueAtIndex(i);
                                    if (val >= max) {
                                        max = val;
                                    }
                                }
                                return max;
                            }

                            public static elementMaxAbs(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var size: number = a.getNumElements();
                                var max: number = 0;
                                for (var i: number = 0; i < size; i++) {
                                    var val: number = Math.abs(a.getValueAtIndex(i));
                                    if (val > max) {
                                        max = val;
                                    }
                                }
                                return max;
                            }

                            public static elementMin(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var size: number = a.getNumElements();
                                var min: number = a.getValueAtIndex(0);
                                for (var i: number = 1; i < size; i++) {
                                    var val: number = a.getValueAtIndex(i);
                                    if (val < min) {
                                        min = val;
                                    }
                                }
                                return min;
                            }

                            public static elementMinAbs(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var size: number = a.getNumElements();
                                var min: number = Math.abs(a.getValueAtIndex(0));
                                for (var i: number = 0; i < size; i++) {
                                    var val: number = Math.abs(a.getValueAtIndex(i));
                                    if (val < min) {
                                        min = val;
                                    }
                                }
                                return min;
                            }

                            public static elementMult2mat(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.times(i, b.getValueAtIndex(i));
                                }
                            }

                            public static elementMult(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, a.getValueAtIndex(i) * b.getValueAtIndex(i));
                                }
                            }

                            public static elementDiv2mat(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.div(i, b.getValueAtIndex(i));
                                }
                            }

                            public static elementDiv(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, a.getValueAtIndex(i) / b.getValueAtIndex(i));
                                }
                            }

                            public static elementSum(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var total: number = 0;
                                var size: number = mat.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    total += mat.getValueAtIndex(i);
                                }
                                return total;
                            }

                            public static elementSumAbs(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var total: number = 0;
                                var size: number = mat.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    total += Math.abs(mat.getValueAtIndex(i));
                                }
                                return total;
                            }

                            public static elementPower(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = A.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    C.data[i] = Math.pow(A.data[i], B.data[i]);
                                }
                            }

                            public static elementPoweralpha(a: number, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = B.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    C.data[i] = Math.pow(a, B.data[i]);
                                }
                            }

                            public static elementPowerMat(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: number, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = A.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    C.data[i] = Math.pow(A.data[i], b);
                                }
                            }

                            public static elementLog(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = A.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    C.data[i] = Math.log(A.data[i]);
                                }
                            }

                            public static elementExp(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = A.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    C.data[i] = Math.exp(A.data[i]);
                                }
                            }

                            public static sumRows(input: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, output: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (output == null) {
                                    output = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(input.numRows, 1);
                                }
                                for (var row: number = 0; row < input.numRows; row++) {
                                    var total: number = 0;
                                    var end: number = (row + 1) * input.numCols;
                                    for (var index: number = row * input.numCols; index < end; index++) {
                                        total += input.data[index];
                                    }
                                    output.setValueAtIndex(row, total);
                                }
                                return output;
                            }

                            public static sumCols(input: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, output: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                if (output == null) {
                                    output = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, input.numCols);
                                }
                                for (var cols: number = 0; cols < input.numCols; cols++) {
                                    var total: number = 0;
                                    var index: number = cols;
                                    var end: number = index + input.numCols * input.numRows;
                                    for (; index < end; index += input.numCols) {
                                        total += input.data[index];
                                    }
                                    output.setValueAtIndex(cols, total);
                                }
                                return output;
                            }

                            public static addEquals(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.plus(i, b.getValueAtIndex(i));
                                }
                            }

                            public static addEqualsbeta(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.plus(i, beta * b.getValueAtIndex(i));
                                }
                            }

                            public static add(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, a.getValueAtIndex(i) + b.getValueAtIndex(i));
                                }
                            }

                            public static addbeta(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, a.getValueAtIndex(i) + beta * b.getValueAtIndex(i));
                                }
                            }

                            public static addalphabeta(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, beta: number, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, alpha * a.getValueAtIndex(i) + beta * b.getValueAtIndex(i));
                                }
                            }

                            public static add3Mat(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.setValueAtIndex(i, alpha * a.getValueAtIndex(i) + b.getValueAtIndex(i));
                                }
                            }

                            public static addval(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, val: number): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.plus(i, val);
                                }
                            }

                            public static addval2mat(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, val: number, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.data[i] = a.data[i] + val;
                                }
                            }

                            public static subtract(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, val: number, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.data[i] = a.data[i] - val;
                                }
                            }

                            public static subtract1(val: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.data[i] = val - a.data[i];
                                }
                            }

                            public static subtractEquals(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    a.data[i] -= b.data[i];
                                }
                            }

                            public static subtract3mat(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    c.data[i] = a.data[i] - b.data[i];
                                }
                            }

                            public static scale(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    a.data[i] *= alpha;
                                }
                            }

                            public static scalemat(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    throw new Error("Matrices must have the same shape");
                                }
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    b.data[i] = a.data[i] * alpha;
                                }
                            }

                            public static divide0(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    a.data[i] = alpha / a.data[i];
                                }
                            }

                            public static divide(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, alpha: number): void {
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    a.data[i] /= alpha;
                                }
                            }

                            public static divide2(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    throw new Error("Matrices must have the same shape");
                                }
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    b.data[i] = alpha / a.data[i];
                                }
                            }

                            public static divide3(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, alpha: number, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    throw new Error("Matrices must have the same shape");
                                }
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    b.data[i] = a.data[i] / alpha;
                                }
                            }

                            public static changeSign(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    a.data[i] = -a.data[i];
                                }
                            }

                            public static changeSign2mat(input: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, output: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (input.numRows != output.numRows || input.numCols != output.numCols) {
                                    throw new Error("Matrices must have the same shape");
                                }
                                var size: number = input.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    output.data[i] = -input.data[i];
                                }
                            }

                            public static fill(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, value: number): void {
                                java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
                            }

                            public static normalizeF(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var val: number = org.kevoree.modeling.util.maths.matrix.CommonOps.normF(A);
                                if (val == 0) {
                                    return;
                                }
                                var size: number = A.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    A.div(i, val);
                                }
                            }

                            public static normF(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var total: number = 0;
                                var scale: number = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(a);
                                if (scale == 0.0) {
                                    return 0.0;
                                }
                                var size: number = a.getNumElements();
                                for (var i: number = 0; i < size; i++) {
                                    var val: number = a.getValueAtIndex(i) / scale;
                                    total += val * val;
                                }
                                return scale * Math.sqrt(total);
                            }

                            public static extract6M(src: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, srcY0: number, srcY1: number, srcX0: number, srcX1: number, dst: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, dstY0: number, dstX0: number): void {
                                var w: number = srcX1 - srcX0;
                                var h: number = srcY1 - srcY0;
                                org.kevoree.modeling.util.maths.matrix.CommonOps.extractImpl(src, srcY0, srcX0, dst, dstY0, dstX0, h, w);
                            }

                        }

                        export class Complex64F {

                            public real: number;
                            public imaginary: number;
                            constructor() {
                            }

                            public getReal(): number {
                                return this.real;
                            }

                            public getMagnitude(): number {
                                return Math.sqrt(this.real * this.real + this.imaginary * this.imaginary);
                            }

                            public getMagnitude2(): number {
                                return this.real * this.real + this.imaginary * this.imaginary;
                            }

                            public setReal(real: number): void {
                                this.real = real;
                            }

                            public getImaginary(): number {
                                return this.imaginary;
                            }

                            public setImaginary(imaginary: number): void {
                                this.imaginary = imaginary;
                            }

                            public setValues(real: number, imaginary: number): void {
                                this.real = real;
                                this.imaginary = imaginary;
                            }

                            public setComplex(a: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                this.real = a.real;
                                this.imaginary = a.imaginary;
                            }

                            public isReal(): boolean {
                                return this.imaginary == 0.0;
                            }

                            public toString(): string {
                                if (this.imaginary == 0) {
                                    return "" + this.real;
                                } else {
                                    return this.real + " " + this.imaginary + "i";
                                }
                            }

                            public plus(a: org.kevoree.modeling.util.maths.matrix.Complex64F): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                org.kevoree.modeling.util.maths.matrix.ComplexMath64F.plus(this, a, ret);
                                return ret;
                            }

                            public minus(a: org.kevoree.modeling.util.maths.matrix.Complex64F): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                org.kevoree.modeling.util.maths.matrix.ComplexMath64F.minus(this, a, ret);
                                return ret;
                            }

                            public times(a: org.kevoree.modeling.util.maths.matrix.Complex64F): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                org.kevoree.modeling.util.maths.matrix.ComplexMath64F.multiply(this, a, ret);
                                return ret;
                            }

                            public divide(a: org.kevoree.modeling.util.maths.matrix.Complex64F): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                org.kevoree.modeling.util.maths.matrix.ComplexMath64F.divide(this, a, ret);
                                return ret;
                            }

                        }

                        export class ComplexMath64F {

                            public static conj(input: org.kevoree.modeling.util.maths.matrix.Complex64F, conj: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                conj.real = input.real;
                                conj.imaginary = -input.imaginary;
                            }

                            public static plus(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                result.real = a.real + b.real;
                                result.imaginary = a.imaginary + b.imaginary;
                            }

                            public static minus(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                result.real = a.real - b.real;
                                result.imaginary = a.imaginary - b.imaginary;
                            }

                            public static multiply(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                result.real = a.real * b.real - a.imaginary * b.imaginary;
                                result.imaginary = a.real * b.imaginary + a.imaginary * b.real;
                            }

                            public static divide(a: org.kevoree.modeling.util.maths.matrix.Complex64F, b: org.kevoree.modeling.util.maths.matrix.Complex64F, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                var norm: number = b.getMagnitude2();
                                result.real = (a.real * b.real + a.imaginary * b.imaginary) / norm;
                                result.imaginary = (a.imaginary * b.real - a.real * b.imaginary) / norm;
                            }

                            public static root(a: org.kevoree.modeling.util.maths.matrix.Complex64F, N: number, k: number, result: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                var r: number = a.getMagnitude();
                                var theta: number = Math.atan2(a.imaginary, a.real);
                                r = Math.pow(r, 1.0 / N);
                                theta = (theta + 2.0 * k * Math.PI) / N;
                                result.real = r * Math.cos(theta);
                                result.imaginary = r * Math.sin(theta);
                            }

                            public static sqrt(input: org.kevoree.modeling.util.maths.matrix.Complex64F, root: org.kevoree.modeling.util.maths.matrix.Complex64F): void {
                                var r: number = input.getMagnitude();
                                var a: number = input.real;
                                root.real = Math.sqrt((r + a) / 2.0);
                                root.imaginary = Math.sqrt((r - a) / 2.0);
                                if (input.imaginary < 0) {
                                    root.imaginary = -root.imaginary;
                                }
                            }

                        }

                        export class DenseMatrix64F {

                            public numRows: number;
                            public numCols: number;
                            public data: Float64Array;
                            public static MULT_COLUMN_SWITCH: number = 15;
                            constructor(numRows: number, numCols: number) {
                                this.data = new Float64Array(numRows * numCols);
                                this.numRows = numRows;
                                this.numCols = numCols;
                            }

                            public constructorDenseMatrix(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                var result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(orig.numRows, orig.numCols);
                                java.lang.System.arraycopy(orig.data, 0, result.data, 0, orig.getNumElements());
                                return result;
                            }

                            public static setIdentity(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var width: number = mat.numRows < mat.numCols ? mat.numRows : mat.numCols;
                                java.util.Arrays.fill(mat.data, 0, mat.getNumElements(), 0);
                                var index: number = 0;
                                for (var i: number = 0; i < width; i++) {
                                    mat.data[index] = 1;
                                    index += mat.numCols + 1;
                                }
                            }

                            public static widentity(width: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(width, width);
                                for (var i: number = 0; i < width; i++) {
                                    ret.cset(i, i, 1.0);
                                }
                                return ret;
                            }

                            public static identity(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                var ret: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                                var small: number = numRows < numCols ? numRows : numCols;
                                for (var i: number = 0; i < small; i++) {
                                    ret.cset(i, i, 1.0);
                                }
                                return ret;
                            }

                            public constructor1dArray(length: number): void {
                                this.data = new Float64Array(length);
                            }

                            public isInBounds(row: number, col: number): boolean {
                                return (col >= 0 && col < this.numCols && row >= 0 && row < this.numRows);
                            }

                            public zero(): void {
                                java.util.Arrays.fill(this.data, 0, this.getNumElements(), 0.0);
                            }

                            public copy(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                return this.constructorDenseMatrix(this);
                            }

                            public static fill(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, value: number): void {
                                java.util.Arrays.fill(a.data, 0, a.getNumElements(), value);
                            }

                            public reshapeBoolean(numRows: number, numCols: number, saveValues: boolean): void {
                                if (this.data.length < numRows * numCols) {
                                    var d: Float64Array = new Float64Array(numRows * numCols);
                                    if (saveValues) {
                                        java.lang.System.arraycopy(this.data, 0, d, 0, this.getNumElements());
                                    }
                                    this.data = d;
                                }
                                this.numRows = numRows;
                                this.numCols = numCols;
                            }

                            public cset(row: number, col: number, value: number): void {
                                this.data[row * this.numCols + col] = value;
                            }

                            public add(row: number, col: number, value: number): void {
                                this.data[row * this.numCols + col] += value;
                            }

                            public plus(index: number, val: number): number {
                                return this.data[index] += val;
                            }

                            public plusMatrix(matrix2: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                for (var i: number = 0; i < this.data.length; i++) {
                                    this.data[i] += matrix2.data[i];
                                }
                                return this;
                            }

                            public scale(value: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                for (var i: number = 0; i < this.data.length; i++) {
                                    this.data[i] *= value;
                                }
                                return this;
                            }

                            public minus(index: number, val: number): number {
                                return this.data[index] -= val;
                            }

                            public times(index: number, val: number): number {
                                return this.data[index] *= val;
                            }

                            public div(index: number, val: number): number {
                                return this.data[index] /= val;
                            }

                            public reshape(numRows: number, numCols: number): void {
                                this.reshapeBoolean(numRows, numCols, false);
                            }

                            public getNumRows(): number {
                                return this.numRows;
                            }

                            public getNumCols(): number {
                                return this.numCols;
                            }

                            public getData(): Float64Array {
                                return this.data;
                            }

                            public get(row: number, col: number): number {
                                return this.data[row * this.numCols + col];
                            }

                            public getNumElements(): number {
                                return this.numRows * this.numCols;
                            }

                            public getIndex(row: number, col: number): number {
                                return row * this.numCols + col;
                            }

                            public getValueAtIndex(index: number): number {
                                return this.data[index];
                            }

                            public setValueAtIndex(index: number, val: number): number {
                                return this.data[index] = val;
                            }

                            public setNumRows(numRows: number): void {
                                this.numRows = numRows;
                            }

                            public setNumCols(numCols: number): void {
                                this.numCols = numCols;
                            }

                            public setData(data: Float64Array): void {
                                this.data = data;
                            }

                            public setMatrix(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                this.reshape(b.numRows, b.numCols);
                                var dataLength: number = b.getNumElements();
                                java.lang.System.arraycopy(b.data, 0, this.data, 0, dataLength);
                            }

                            public set(row: number, col: number, value: number): void {
                                this.data[row * this.numCols + col] = value;
                            }

                            public setArray(numRows: number, numCols: number, rowMajor: boolean, data: Float64Array): void {
                                this.reshapeBoolean(numRows, numCols, false);
                                var length: number = numRows * numCols;
                                if (rowMajor) {
                                    java.lang.System.arraycopy(data, 0, this.data, 0, length);
                                } else {
                                    var index: number = 0;
                                    for (var i: number = 0; i < numRows; i++) {
                                        for (var j: number = 0; j < numCols; j++) {
                                            this.data[index++] = data[j * numRows + i];
                                        }
                                    }
                                }
                            }

                        }

                        export class MatrixFeatures {

                            public static isZeros(m: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                var length: number = m.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    if (Math.abs(m.getValueAtIndex(i)) > tol) {
                                        return false;
                                    }
                                }
                                return true;
                            }

                            public static isVector(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                return (mat.getNumCols() == 1 || mat.getNumRows() == 1);
                            }

                            public static isSquare(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                return mat.numCols == mat.numRows;
                            }

                            public static isSymmetricDouble(m: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (m.numCols != m.numRows) {
                                    return false;
                                }
                                var max: number = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(m);
                                for (var i: number = 0; i < m.numRows; i++) {
                                    for (var j: number = 0; j < i; j++) {
                                        var a: number = m.get(i, j) / max;
                                        var b: number = m.get(j, i) / max;
                                        var diff: number = Math.abs(a - b);
                                        if (!(diff <= tol)) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            }

                            public static isSymmetric(m: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                return org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isSymmetricDouble(m, 0.0);
                            }

                            public static isSkewSymmetric(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (A.numCols != A.numRows) {
                                    return false;
                                }
                                for (var i: number = 0; i < A.numRows; i++) {
                                    for (var j: number = 0; j < i; j++) {
                                        var a: number = A.get(i, j);
                                        var b: number = A.get(j, i);
                                        var diff: number = Math.abs(a + b);
                                        if (!(diff <= tol)) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            }

                            public static isInverse(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    return false;
                                }
                                var numRows: number = a.numRows;
                                var numCols: number = a.numCols;
                                for (var i: number = 0; i < numRows; i++) {
                                    for (var j: number = 0; j < numCols; j++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < numCols; k++) {
                                            total += a.get(i, k) * b.get(k, j);
                                        }
                                        if (i == j) {
                                            if (!(Math.abs(total - 1) <= tol)) {
                                                return false;
                                            }
                                        } else {
                                            if (!(Math.abs(total) <= tol)) {
                                                return false;
                                            }
                                        }
                                    }
                                }
                                return true;
                            }

                            public static isEqualsDouble(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    return false;
                                }
                                if (tol == 0.0) {
                                    return org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isEquals(a, b);
                                }
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    if (!(tol >= Math.abs(a.getValueAtIndex(i) - b.getValueAtIndex(i)))) {
                                        return false;
                                    }
                                }
                                return true;
                            }

                            public static isEquals(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    return false;
                                }
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    if (!(a.getValueAtIndex(i) == b.getValueAtIndex(i))) {
                                        return false;
                                    }
                                }
                                return true;
                            }

                            public static isIdentical(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    return false;
                                }
                                if (tol < 0) {
                                    throw new Error("Tolerance must be greater than or equal to zero.");
                                }
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    var valA: number = a.getValueAtIndex(i);
                                    var valB: number = b.getValueAtIndex(i);
                                    var diff: number = Math.abs(valA - valB);
                                    if (tol >= diff) {
                                        continue;
                                    }
                                    return false;
                                }
                                return true;
                            }

                            public static isIdentity(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                var index: number = 0;
                                for (var i: number = 0; i < mat.numRows; i++) {
                                    for (var j: number = 0; j < mat.numCols; j++) {
                                        if (i == j) {
                                            if (!(Math.abs(mat.getValueAtIndex(index++) - 1) <= tol)) {
                                                return false;
                                            }
                                        } else {
                                            if (!(Math.abs(mat.getValueAtIndex(index++)) <= tol)) {
                                                return false;
                                            }
                                        }
                                    }
                                }
                                return true;
                            }

                            public static isConstantVal(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, val: number, tol: number): boolean {
                                var index: number = 0;
                                for (var i: number = 0; i < mat.numRows; i++) {
                                    for (var j: number = 0; j < mat.numCols; j++) {
                                        if (!(Math.abs(mat.getValueAtIndex(index++) - val) <= tol)) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            }

                            public static isDiagonalPositive(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                for (var i: number = 0; i < a.numRows; i++) {
                                    if (!(a.get(i, i) >= 0)) {
                                        return false;
                                    }
                                }
                                return true;
                            }

                            public static isFullRank(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                throw new Error("Implement");
                            }

                            public static isNegative(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tol: number): boolean {
                                if (a.numRows != b.numRows || a.numCols != b.numCols) {
                                    throw new Error("matrix dimensions must match");
                                }
                                var length: number = a.getNumElements();
                                for (var i: number = 0; i < length; i++) {
                                    if (!(Math.abs(a.getValueAtIndex(i) + b.getValueAtIndex(i)) <= tol)) {
                                        return false;
                                    }
                                }
                                return true;
                            }

                            public static isUpperTriangle(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, hessenberg: number, tol: number): boolean {
                                if (A.numRows != A.numCols) {
                                    return false;
                                }
                                for (var i: number = hessenberg + 1; i < A.numRows; i++) {
                                    for (var j: number = 0; j < i - hessenberg; j++) {
                                        if (!(Math.abs(A.get(i, j)) <= tol)) {
                                            return false;
                                        }
                                    }
                                }
                                return true;
                            }

                        }

                        export class MatrixMatrixMult {

                            public static MULT_COLUMN_SWITCH: number = 15;
                            public static multTransA_smallMV(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < A.numCols; i++) {
                                    var total: number = 0.0;
                                    var indexA: number = i;
                                    for (var j: number = 0; j < A.numRows; j++) {
                                        total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                                        indexA += A.numCols;
                                    }
                                    C.setValueAtIndex(cIndex++, total);
                                }
                            }

                            public static multTransA_reorderMV(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (A.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.fill(C, 0);
                                    return;
                                }
                                var B_val: number = B.getValueAtIndex(0);
                                for (var i: number = 0; i < A.numCols; i++) {
                                    C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                                }
                                var indexA: number = A.numCols;
                                for (var i: number = 1; i < A.numRows; i++) {
                                    B_val = B.getValueAtIndex(i);
                                    for (var j: number = 0; j < A.numCols; j++) {
                                        C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                                    }
                                }
                            }

                            public static multTransA_reorderMM(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.fill(c, 0);
                                    return;
                                }
                                var valA: number;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC_start: number = i * c.numCols;
                                    valA = a.getValueAtIndex(i);
                                    var indexB: number = 0;
                                    var end: number = indexB + b.numCols;
                                    var indexC: number = indexC_start;
                                    while (indexB < end){
                                        c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        valA = a.get(k, i);
                                        end = indexB + b.numCols;
                                        indexC = indexC_start;
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                }
                            }

                            public static multTransA_smallMM(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var end: number = indexB + b.numRows * b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; indexB += b.numCols) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                            indexA += a.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, total);
                                    }
                                }
                            }

                            public static multTransA(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (b.numCols == 1) {
                                    if (a.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorderMV(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_smallMV(a, b, c);
                                    }
                                } else {
                                    if (a.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH || b.numCols >= org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.MULT_COLUMN_SWITCH) {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_reorderMM(a, b, c);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA_smallMM(a, b, c);
                                    }
                                }
                            }

                            public static mult_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var valA: number;
                                var indexCbase: number = 0;
                                var endOfKLoop: number = b.numRows * b.numCols;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    var indexA: number = i * a.numCols;
                                    var indexB: number = 0;
                                    var indexC: number = indexCbase;
                                    var end: number = indexB + b.numCols;
                                    valA = a.getValueAtIndex(indexA++);
                                    while (indexB < end){
                                        c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    while (indexB != endOfKLoop){
                                        indexC = indexCbase;
                                        end = indexB + b.numCols;
                                        valA = a.getValueAtIndex(indexA++);
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                    indexCbase += c.numCols;
                                }
                            }

                            public static mult_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var aIndexStart: number = 0;
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var total: number = 0;
                                        var indexA: number = aIndexStart;
                                        var indexB: number = j;
                                        var end: number = indexA + b.numRows;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                            indexB += b.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static mult_aux(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(b.numRows);
                                }
                                for (var j: number = 0; j < b.numCols; j++) {
                                    for (var k: number = 0; k < b.numRows; k++) {
                                        aux[k] = b.get(k, j);
                                    }
                                    var indexA: number = 0;
                                    for (var i: number = 0; i < a.numRows; i++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numRows; ) {
                                            total += a.getValueAtIndex(indexA++) * aux[k++];
                                        }
                                        c.setValueAtIndex(i * c.numCols + j, total);
                                    }
                                }
                            }

                            public static multTransA_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var valA: number;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC_start: number = i * c.numCols;
                                    valA = a.getValueAtIndex(i);
                                    var indexB: number = 0;
                                    var end: number = indexB + b.numCols;
                                    var indexC: number = indexC_start;
                                    while (indexB < end){
                                        c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        valA = a.get(k, i);
                                        end = indexB + b.numCols;
                                        indexC = indexC_start;
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                }
                            }

                            public static multTransA_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var end: number = indexB + b.numRows * b.numCols;
                                        var total: number = 0.0;
                                        for (; indexB < end; indexB += b.numCols) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                            indexA += a.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, total);
                                    }
                                }
                            }

                            public static multTransAB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexB: number = 0;
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var indexA: number = i;
                                        var end: number = indexB + b.numCols;
                                        var total: number = 0.0;
                                        for (; indexB < end; ) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB++);
                                            indexA += a.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, total);
                                    }
                                }
                            }

                            public static multTransAB_aux(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(a.numRows);
                                }
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var indexC: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var k: number = 0; k < b.numCols; k++) {
                                        aux[k] = a.get(k, i);
                                    }
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numCols; k++) {
                                            total += aux[k] * b.get(j, k);
                                        }
                                        c.setValueAtIndex(indexC++, total);
                                    }
                                }
                            }

                            public static multTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                var aIndexStart: number = 0;
                                for (var xA: number = 0; xA < a.numRows; xA++) {
                                    var end: number = aIndexStart + b.numCols;
                                    var indexB: number = 0;
                                    for (var xB: number = 0; xB < b.numRows; xB++) {
                                        var indexA: number = aIndexStart;
                                        var total: number = 0;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                                        }
                                        c.setValueAtIndex(cIndex++, total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static multAdd_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var valA: number;
                                var indexCbase: number = 0;
                                var endOfKLoop: number = b.numRows * b.numCols;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    var indexA: number = i * a.numCols;
                                    var indexB: number = 0;
                                    var indexC: number = indexCbase;
                                    var end: number = indexB + b.numCols;
                                    valA = a.getValueAtIndex(indexA++);
                                    while (indexB < end){
                                        c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    while (indexB != endOfKLoop){
                                        indexC = indexCbase;
                                        end = indexB + b.numCols;
                                        valA = a.getValueAtIndex(indexA++);
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                    indexCbase += c.numCols;
                                }
                            }

                            public static multAdd_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var aIndexStart: number = 0;
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var total: number = 0;
                                        var indexA: number = aIndexStart;
                                        var indexB: number = j;
                                        var end: number = indexA + b.numRows;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                            indexB += b.numCols;
                                        }
                                        c.plus(cIndex++, total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static multAdd_aux(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(b.numRows);
                                }
                                for (var j: number = 0; j < b.numCols; j++) {
                                    for (var k: number = 0; k < b.numRows; k++) {
                                        aux[k] = b.get(k, j);
                                    }
                                    var indexA: number = 0;
                                    for (var i: number = 0; i < a.numRows; i++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numRows; ) {
                                            total += a.getValueAtIndex(indexA++) * aux[k++];
                                        }
                                        c.plus(i * c.numCols + j, total);
                                    }
                                }
                            }

                            public static multAddTransA_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var valA: number;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC_start: number = i * c.numCols;
                                    valA = a.getValueAtIndex(i);
                                    var indexB: number = 0;
                                    var end: number = indexB + b.numCols;
                                    var indexC: number = indexC_start;
                                    while (indexB < end){
                                        c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        valA = a.get(k, i);
                                        end = indexB + b.numCols;
                                        indexC = indexC_start;
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                }
                            }

                            public static multAddTransA_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var end: number = indexB + b.numRows * b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; indexB += b.numCols) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                            indexA += a.numCols;
                                        }
                                        c.plus(cIndex++, total);
                                    }
                                }
                            }

                            public static multAddTransAB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexB: number = 0;
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var indexA: number = i;
                                        var end: number = indexB + b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; ) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB++);
                                            indexA += a.numCols;
                                        }
                                        c.plus(cIndex++, total);
                                    }
                                }
                            }

                            public static multAddTransAB_aux(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(a.numRows);
                                }
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var indexC: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var k: number = 0; k < b.numCols; k++) {
                                        aux[k] = a.get(k, i);
                                    }
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numCols; k++) {
                                            total += aux[k] * b.get(j, k);
                                        }
                                        c.plus(indexC++, total);
                                    }
                                }
                            }

                            public static multAddTransB(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                var aIndexStart: number = 0;
                                for (var xA: number = 0; xA < a.numRows; xA++) {
                                    var end: number = aIndexStart + b.numCols;
                                    var indexB: number = 0;
                                    for (var xB: number = 0; xB < b.numRows; xB++) {
                                        var indexA: number = aIndexStart;
                                        var total: number = 0;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                                        }
                                        c.plus(cIndex++, total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static mult_reorderalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var valA: number;
                                var indexCbase: number = 0;
                                var endOfKLoop: number = b.numRows * b.numCols;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    var indexA: number = i * a.numCols;
                                    var indexB: number = 0;
                                    var indexC: number = indexCbase;
                                    var end: number = indexB + b.numCols;
                                    valA = alpha * a.getValueAtIndex(indexA++);
                                    while (indexB < end){
                                        c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    while (indexB != endOfKLoop){
                                        indexC = indexCbase;
                                        end = indexB + b.numCols;
                                        valA = alpha * a.getValueAtIndex(indexA++);
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                    indexCbase += c.numCols;
                                }
                            }

                            public static mult_smallalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var aIndexStart: number = 0;
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var total: number = 0;
                                        var indexA: number = aIndexStart;
                                        var indexB: number = j;
                                        var end: number = indexA + b.numRows;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                            indexB += b.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, alpha * total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static mult_auxalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(b.numRows);
                                }
                                for (var j: number = 0; j < b.numCols; j++) {
                                    for (var k: number = 0; k < b.numRows; k++) {
                                        aux[k] = b.get(k, j);
                                    }
                                    var indexA: number = 0;
                                    for (var i: number = 0; i < a.numRows; i++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numRows; ) {
                                            total += a.getValueAtIndex(indexA++) * aux[k++];
                                        }
                                        c.setValueAtIndex(i * c.numCols + j, alpha * total);
                                    }
                                }
                            }

                            public static multTransA_reorderalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var valA: number;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC_start: number = i * c.numCols;
                                    valA = alpha * a.getValueAtIndex(i);
                                    var indexB: number = 0;
                                    var end: number = indexB + b.numCols;
                                    var indexC: number = indexC_start;
                                    while (indexB < end){
                                        c.setValueAtIndex(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        valA = alpha * a.get(k, i);
                                        end = indexB + b.numCols;
                                        indexC = indexC_start;
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                }
                            }

                            public static multTransA_smallalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var end: number = indexB + b.numRows * b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; indexB += b.numCols) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                            indexA += a.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, alpha * total);
                                    }
                                }
                            }

                            public static multTransABalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexB: number = 0;
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var indexA: number = i;
                                        var end: number = indexB + b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; ) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB++);
                                            indexA += a.numCols;
                                        }
                                        c.setValueAtIndex(cIndex++, alpha * total);
                                    }
                                }
                            }

                            public static multTransAB_auxalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(a.numRows);
                                }
                                if (a.numCols == 0 || a.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(c, 0);
                                    return;
                                }
                                var indexC: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var k: number = 0; k < b.numCols; k++) {
                                        aux[k] = a.get(k, i);
                                    }
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numCols; k++) {
                                            total += aux[k] * b.get(j, k);
                                        }
                                        c.setValueAtIndex(indexC++, alpha * total);
                                    }
                                }
                            }

                            public static multTransBalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                var aIndexStart: number = 0;
                                for (var xA: number = 0; xA < a.numRows; xA++) {
                                    var end: number = aIndexStart + b.numCols;
                                    var indexB: number = 0;
                                    for (var xB: number = 0; xB < b.numRows; xB++) {
                                        var indexA: number = aIndexStart;
                                        var total: number = 0;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                                        }
                                        c.setValueAtIndex(cIndex++, alpha * total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static multAdd_reorderalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var valA: number;
                                var indexCbase: number = 0;
                                var endOfKLoop: number = b.numRows * b.numCols;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    var indexA: number = i * a.numCols;
                                    var indexB: number = 0;
                                    var indexC: number = indexCbase;
                                    var end: number = indexB + b.numCols;
                                    valA = alpha * a.getValueAtIndex(indexA++);
                                    while (indexB < end){
                                        c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    while (indexB != endOfKLoop){
                                        indexC = indexCbase;
                                        end = indexB + b.numCols;
                                        valA = alpha * a.getValueAtIndex(indexA++);
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                    indexCbase += c.numCols;
                                }
                            }

                            public static multAdd_smallalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var aIndexStart: number = 0;
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numRows; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var total: number = 0;
                                        var indexA: number = aIndexStart;
                                        var indexB: number = j;
                                        var end: number = indexA + b.numRows;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB);
                                            indexB += b.numCols;
                                        }
                                        c.plus(cIndex++, alpha * total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                            public static multAdd_auxalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(b.numRows);
                                }
                                for (var j: number = 0; j < b.numCols; j++) {
                                    for (var k: number = 0; k < b.numRows; k++) {
                                        aux[k] = b.get(k, j);
                                    }
                                    var indexA: number = 0;
                                    for (var i: number = 0; i < a.numRows; i++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numRows; ) {
                                            total += a.getValueAtIndex(indexA++) * aux[k++];
                                        }
                                        c.plus(i * c.numCols + j, alpha * total);
                                    }
                                }
                            }

                            public static multAddTransA_reorderalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var valA: number;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC_start: number = i * c.numCols;
                                    valA = alpha * a.getValueAtIndex(i);
                                    var indexB: number = 0;
                                    var end: number = indexB + b.numCols;
                                    var indexC: number = indexC_start;
                                    while (indexB < end){
                                        c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        valA = alpha * a.get(k, i);
                                        end = indexB + b.numCols;
                                        indexC = indexC_start;
                                        while (indexB < end){
                                            c.plus(indexC++, valA * b.getValueAtIndex(indexB++));
                                        }
                                    }
                                }
                            }

                            public static multAddTransA_smallalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = 0; j < b.numCols; j++) {
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var end: number = indexB + b.numRows * b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; indexB += b.numCols) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB);
                                            indexA += a.numCols;
                                        }
                                        c.plus(cIndex++, alpha * total);
                                    }
                                }
                            }

                            public static multAddTransABalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexB: number = 0;
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var indexA: number = i;
                                        var end: number = indexB + b.numCols;
                                        var total: number = 0;
                                        for (; indexB < end; ) {
                                            total += a.getValueAtIndex(indexA) * b.getValueAtIndex(indexB++);
                                            indexA += a.numCols;
                                        }
                                        c.plus(cIndex++, alpha * total);
                                    }
                                }
                            }

                            public static multAddTransAB_auxalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, aux: Float64Array): void {
                                if (aux == null) {
                                    aux = new Float64Array(a.numRows);
                                }
                                if (a.numCols == 0 || a.numRows == 0) {
                                    return;
                                }
                                var indexC: number = 0;
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var k: number = 0; k < b.numCols; k++) {
                                        aux[k] = a.get(k, i);
                                    }
                                    for (var j: number = 0; j < b.numRows; j++) {
                                        var total: number = 0;
                                        for (var k: number = 0; k < b.numCols; k++) {
                                            total += aux[k] * b.get(j, k);
                                        }
                                        c.plus(indexC++, alpha * total);
                                    }
                                }
                            }

                            public static multAddTransBalpha(alpha: number, a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                var aIndexStart: number = 0;
                                for (var xA: number = 0; xA < a.numRows; xA++) {
                                    var end: number = aIndexStart + b.numCols;
                                    var indexB: number = 0;
                                    for (var xB: number = 0; xB < b.numRows; xB++) {
                                        var indexA: number = aIndexStart;
                                        var total: number = 0;
                                        while (indexA < end){
                                            total += a.getValueAtIndex(indexA++) * b.getValueAtIndex(indexB++);
                                        }
                                        c.plus(cIndex++, alpha * total);
                                    }
                                    aIndexStart += a.numCols;
                                }
                            }

                        }

                        export class MatrixMultProduct {

                            public static outer(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                for (var i: number = 0; i < a.numRows; i++) {
                                    var indexC1: number = i * c.numCols + i;
                                    var indexC2: number = indexC1;
                                    for (var j: number = i; j < a.numRows; ) {
                                        var indexA: number = i * a.numCols;
                                        var indexB: number = j * a.numCols;
                                        var sum: number = 0;
                                        var end: number = indexA + a.numCols;
                                        for (; indexA < end; ) {
                                            sum += a.data[indexA] * a.data[indexB];
                                        }
                                        c.data[indexC2] = c.data[indexC1++] = sum;
                                    }
                                }
                            }

                            public static inner_small(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                for (var i: number = 0; i < a.numCols; i++) {
                                    for (var j: number = i; j < a.numCols; j++) {
                                        var indexC1: number = i * c.numCols + j;
                                        var indexC2: number = j * c.numCols + i;
                                        var indexA: number = i;
                                        var indexB: number = j;
                                        var sum: number = 0;
                                        var end: number = indexA + a.numRows * a.numCols;
                                        for (; indexA < end; ) {
                                            sum += a.data[indexA] * a.data[indexB];
                                        }
                                        c.data[indexC1] = c.data[indexC2] = sum;
                                    }
                                }
                            }

                            public static inner_reorder(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC: number = i * c.numCols + i;
                                    var valAi: number = a.data[i];
                                    for (var j: number = i; j < a.numCols; j++) {
                                        c.data[indexC++] = valAi * a.data[j];
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        indexC = i * c.numCols + i;
                                        var indexB: number = k * a.numCols + i;
                                        valAi = a.data[indexB];
                                        for (var j: number = i; j < a.numCols; j++) {
                                            c.data[indexC++] += valAi * a.data[indexB++];
                                        }
                                    }
                                    indexC = i * c.numCols + i;
                                    var indexC2: number = indexC;
                                    for (var j: number = i; j < a.numCols; ) {
                                        c.data[indexC2] = c.data[indexC++];
                                    }
                                }
                            }

                            public static inner_reorder_upper(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, c: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                for (var i: number = 0; i < a.numCols; i++) {
                                    var indexC: number = i * c.numCols + i;
                                    var valAi: number = a.data[i];
                                    for (var j: number = i; j < a.numCols; j++) {
                                        c.data[indexC++] = valAi * a.data[j];
                                    }
                                    for (var k: number = 1; k < a.numRows; k++) {
                                        indexC = i * c.numCols + i;
                                        var indexB: number = k * a.numCols + i;
                                        valAi = a.data[indexB];
                                        for (var j: number = i; j < a.numCols; j++) {
                                            c.data[indexC++] += valAi * a.data[indexB++];
                                        }
                                    }
                                }
                            }

                        }

                        export class MatrixVectorMult {

                            public static mult(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (A.numCols == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(C, 0);
                                    return;
                                }
                                var indexA: number = 0;
                                var cIndex: number = 0;
                                var b0: number = B.getValueAtIndex(0);
                                for (var i: number = 0; i < A.numRows; i++) {
                                    var total: number = A.getValueAtIndex(indexA++) * b0;
                                    for (var j: number = 1; j < A.numCols; j++) {
                                        total += A.getValueAtIndex(indexA++) * B.getValueAtIndex(j);
                                    }
                                    C.setValueAtIndex(cIndex++, total);
                                }
                            }

                            public static multAdd(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (A.numCols == 0) {
                                    return;
                                }
                                var indexA: number = 0;
                                var cIndex: number = 0;
                                for (var i: number = 0; i < A.numRows; i++) {
                                    var total: number = A.getValueAtIndex(indexA++) * B.getValueAtIndex(0);
                                    for (var j: number = 1; j < A.numCols; j++) {
                                        total += A.getValueAtIndex(indexA++) * B.getValueAtIndex(j);
                                    }
                                    C.plus(cIndex++, total);
                                }
                            }

                            public static multTransA_small(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < A.numCols; i++) {
                                    var total: number = 0;
                                    var indexA: number = i;
                                    for (var j: number = 0; j < A.numRows; j++) {
                                        total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                                        indexA += A.numCols;
                                    }
                                    C.setValueAtIndex(cIndex++, total);
                                }
                            }

                            public static multTransA_reorder(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (A.numRows == 0) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.fill(C, 0);
                                    return;
                                }
                                var B_val: number = B.getValueAtIndex(0);
                                for (var i: number = 0; i < A.numCols; i++) {
                                    C.setValueAtIndex(i, A.getValueAtIndex(i) * B_val);
                                }
                                var indexA: number = A.numCols;
                                for (var i: number = 1; i < A.numRows; i++) {
                                    B_val = B.getValueAtIndex(i);
                                    for (var j: number = 0; j < A.numCols; j++) {
                                        C.plus(j, A.getValueAtIndex(indexA++) * B_val);
                                    }
                                }
                            }

                            public static multAddTransA_small(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var cIndex: number = 0;
                                for (var i: number = 0; i < A.numCols; i++) {
                                    var total: number = 0;
                                    var indexA: number = i;
                                    for (var j: number = 0; j < A.numRows; j++) {
                                        total += A.getValueAtIndex(indexA) * B.getValueAtIndex(j);
                                        indexA += A.numCols;
                                    }
                                    C.plus(cIndex++, total);
                                }
                            }

                            public static multAddTransA_reorder(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, C: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                if (A.numRows == 0) {
                                    return;
                                }
                                var indexA: number = 0;
                                for (var j: number = 0; j < A.numRows; j++) {
                                    var B_val: number = B.getValueAtIndex(j);
                                    for (var i: number = 0; i < A.numCols; i++) {
                                        C.plus(i, A.getValueAtIndex(indexA++) * B_val);
                                    }
                                }
                            }

                        }

                        export class SimpleMatrix {

                            public mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                            public getMatrix(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                return this.mat;
                            }

                            public setValue2D(row: number, col: number, value: number): void {
                                this.mat.set(row, col, value);
                            }

                            public setValue1D(index: number, value: number): void {
                                this.mat.setValueAtIndex(index, value);
                            }

                            public getValue2D(row: number, col: number): number {
                                return this.mat.get(row, col);
                            }

                            public getValue1D(index: number): number {
                                return this.mat.data[index];
                            }

                            public getIndex(row: number, col: number): number {
                                return row * this.mat.numCols + col;
                            }

                            public mult(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, b.getMatrix().numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.mult(this.mat, b.getMatrix(), ret.getMatrix());
                                return ret;
                            }

                            public scale(val: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                                org.kevoree.modeling.util.maths.matrix.CommonOps.scale(val, ret.getMatrix());
                                return ret;
                            }

                            public plus(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                                org.kevoree.modeling.util.maths.matrix.CommonOps.addEquals(ret.getMatrix(), b.getMatrix());
                                return ret;
                            }

                            public copy(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                ret.getMatrix().setMatrix(this.getMatrix());
                                return ret;
                            }

                            public numRows(): number {
                                return this.mat.numRows;
                            }

                            public numCols(): number {
                                return this.mat.numCols;
                            }

                            public getNumElements(): number {
                                return this.mat.getNumElements();
                            }

                            public extractDiag(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var N: number = Math.min(this.mat.numCols, this.mat.numRows);
                                var diag: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(N, 1);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.extractDiag(this.mat, diag.getMatrix());
                                return diag;
                            }

                            public isIdentical(a: org.kevoree.modeling.util.maths.matrix.SimpleMatrix, tol: number): boolean {
                                return org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isIdentical(this.mat, a.getMatrix(), tol);
                            }

                            public trace(): number {
                                return org.kevoree.modeling.util.maths.matrix.CommonOps.trace(this.mat);
                            }

                            public elementMaxAbs(): number {
                                return org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(this.mat);
                            }

                            public elementSum(): number {
                                return org.kevoree.modeling.util.maths.matrix.CommonOps.elementSum(this.mat);
                            }

                            public elementMult(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementMult(this.mat, b.getMatrix(), c.getMatrix());
                                return c;
                            }

                            public elementDiv(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementDiv(this.mat, b.getMatrix(), c.getMatrix());
                                return c;
                            }

                            public elementPowerMatrix(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementPower(this.mat, b.getMatrix(), c.getMatrix());
                                return c;
                            }

                            public elementPower(b: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementPowerMat(this.mat, b, c.getMatrix());
                                return c;
                            }

                            public elementExp(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementExp(this.mat, c.getMatrix());
                                return c;
                            }

                            public elementLog(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var c: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.elementLog(this.mat, c.getMatrix());
                                return c;
                            }

                            public negative(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var A: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                                org.kevoree.modeling.util.maths.matrix.CommonOps.changeSign(A.getMatrix());
                                return A;
                            }

                            public isInBounds(row: number, col: number): boolean {
                                return row >= 0 && col >= 0 && row < this.mat.numRows && col < this.mat.numCols;
                            }

                            public printDimensions(): void {
                                console.log("[rows = " + this.numRows() + " , cols = " + this.numCols() + " ]");;
                            }

                            public transpose(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numCols, this.mat.numRows);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.mat, ret.getMatrix());
                                return ret;
                            }

                            constructor(numRows: number, numCols: number) {
                                this.mat = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                            }

                            public static wrap(internalMat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(internalMat.numRows, internalMat.numCols);
                                ret.mat = internalMat;
                                return ret;
                            }

                            public static identity(width: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(width, width);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(ret.mat);
                                return ret;
                            }

                            public minus(b: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.copy();
                                org.kevoree.modeling.util.maths.matrix.CommonOps.subtract3mat(this.getMatrix(), b.getMatrix(), ret.getMatrix());
                                return ret;
                            }

                            public invert(): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = this.createMatrix(this.mat.numRows, this.mat.numCols);
                                org.kevoree.modeling.util.maths.matrix.CommonOps.invert(this.mat, ret.getMatrix());
                                return ret;
                            }

                            public determinant(): number {
                                var ret: number = org.kevoree.modeling.util.maths.matrix.CommonOps.det(this.mat);
                                return ret;
                            }

                            public createMatrix(numRows: number, numCols: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var sm: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = new org.kevoree.modeling.util.maths.matrix.SimpleMatrix(numRows, numCols);
                                return sm;
                            }

                            public extractVector(extractRow: boolean, element: number): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var length: number = extractRow ? this.mat.numCols : this.mat.numRows;
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = extractRow ? this.createMatrix(1, length) : this.createMatrix(length, 1);
                                if (extractRow) {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.mat, element, 0, length, true, 0, ret.getMatrix());
                                } else {
                                    org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.mat, 0, element, length, false, 0, ret.getMatrix());
                                }
                                return ret;
                            }

                            public eig(): org.kevoree.modeling.util.maths.matrix.solvers.SimpleEVD<any> {
                                return new org.kevoree.modeling.util.maths.matrix.solvers.SimpleEVD<any>(this.mat);
                            }

                            public svd(compact: boolean): org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any> {
                                return new org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD<any>(this.mat, compact);
                            }

                            public combine(insertRow: number, insertCol: number, B: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): org.kevoree.modeling.util.maths.matrix.SimpleMatrix {
                                var maxRow: number = insertRow + B.numRows();
                                var maxCol: number = insertCol + B.numCols();
                                var ret: org.kevoree.modeling.util.maths.matrix.SimpleMatrix;
                                if (maxRow > this.mat.numRows || maxCol > this.mat.numCols) {
                                    var M: number = Math.max(maxRow, this.mat.numRows);
                                    var N: number = Math.max(maxCol, this.mat.numCols);
                                    ret = this.createMatrix(M, N);
                                    ret.insertIntoThis(0, 0, this);
                                } else {
                                    ret = this.copy();
                                }
                                ret.insertIntoThis(insertRow, insertCol, B);
                                return ret;
                            }

                            public insertIntoThis(insertRow: number, insertCol: number, B: org.kevoree.modeling.util.maths.matrix.SimpleMatrix): void {
                                org.kevoree.modeling.util.maths.matrix.CommonOps.insert(B.getMatrix(), this.mat, insertRow, insertCol);
                            }

                        }

                        export class SimpleMatrixHashable extends org.kevoree.modeling.util.maths.matrix.SimpleMatrix {

                            constructor(m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix) {
                                super(m.numRows(), m.numCols());
                                this.mat = m.getMatrix();
                            }

                            public equals(obj: any): boolean {
                                var m: org.kevoree.modeling.util.maths.matrix.SimpleMatrix = <org.kevoree.modeling.util.maths.matrix.SimpleMatrix>obj;
                                if (m.isIdentical(this, 1E-30)) {
                                    return true;
                                } else {
                                    return false;
                                }
                            }

                            public hashCode(): number {
                                return <number>this.getValue2D(this.numRows() - 1, 0);
                            }

                        }

                        export class TransposeAlgs {

                            public static square(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var index: number = 1;
                                var indexEnd: number = mat.numCols;
                                for (var i: number = 0; i < mat.numRows; ) {
                                    var indexOther: number = (i + 1) * mat.numCols + i;
                                    for (; index < indexEnd; ) {
                                        var val: number = mat.data[index];
                                        mat.data[index] = mat.data[indexOther];
                                        mat.data[indexOther] = val;
                                    }
                                }
                            }

                            public static block(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, blockLength: number): void {
                                for (var i: number = 0; i < A.numRows; i += blockLength) {
                                    var blockHeight: number = Math.min(blockLength, A.numRows - i);
                                    var indexSrc: number = i * A.numCols;
                                    var indexDst: number = i;
                                    for (var j: number = 0; j < A.numCols; j += blockLength) {
                                        var blockWidth: number = Math.min(blockLength, A.numCols - j);
                                        var indexSrcEnd: number = indexSrc + blockWidth;
                                        for (; indexSrc < indexSrcEnd; indexSrc++) {
                                            var rowSrc: number = indexSrc;
                                            var rowDst: number = indexDst;
                                            var end: number = rowDst + blockHeight;
                                            for (; rowDst < end; rowSrc += A.numCols) {
                                                A_tran.data[rowDst++] = A.data[rowSrc];
                                            }
                                            indexDst += A_tran.numCols;
                                        }
                                    }
                                }
                            }

                            public static standard(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A_tran: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var index: number = 0;
                                for (var i: number = 0; i < A_tran.numRows; i++) {
                                    var index2: number = i;
                                    var end: number = index + A_tran.numCols;
                                    while (index < end){
                                        A_tran.data[index++] = A.data[index2];
                                        index2 += A.numCols;
                                    }
                                }
                            }

                        }

                        export class VectorVectorMult {

                            public static innerProd(x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var m: number = x.getNumElements();
                                var total: number = 0;
                                for (var i: number = 0; i < m; i++) {
                                    total += x.getValueAtIndex(i) * y.getValueAtIndex(i);
                                }
                                return total;
                            }

                            public static innerProdA(x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var n: number = A.numRows;
                                var m: number = A.numCols;
                                var result: number = 0;
                                for (var i: number = 0; i < m; i++) {
                                    var total: number = 0;
                                    for (var j: number = 0; j < n; j++) {
                                        total += x.getValueAtIndex(j) * A.get(j, i);
                                    }
                                    result += total * y.getValueAtIndex(i);
                                }
                                return result;
                            }

                            public static innerProdTranA(x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): number {
                                var n: number = A.numRows;
                                var result: number = 0;
                                for (var i: number = 0; i < n; i++) {
                                    var total: number = 0;
                                    for (var j: number = 0; j < n; j++) {
                                        total += x.getValueAtIndex(j) * A.get(i, j);
                                    }
                                    result += total * y.getValueAtIndex(i);
                                }
                                return result;
                            }

                            public static outerProd(x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var m: number = A.numRows;
                                var n: number = A.numCols;
                                var index: number = 0;
                                for (var i: number = 0; i < m; i++) {
                                    var xdat: number = x.getValueAtIndex(i);
                                    for (var j: number = 0; j < n; j++) {
                                        A.setValueAtIndex(index++, xdat * y.getValueAtIndex(j));
                                    }
                                }
                            }

                            public static addOuterProd(gamma: number, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var m: number = A.numRows;
                                var n: number = A.numCols;
                                var index: number = 0;
                                if (gamma == 1.0) {
                                    for (var i: number = 0; i < m; i++) {
                                        var xdat: number = x.getValueAtIndex(i);
                                        for (var j: number = 0; j < n; j++) {
                                            A.plus(index++, xdat * y.getValueAtIndex(j));
                                        }
                                    }
                                } else {
                                    for (var i: number = 0; i < m; i++) {
                                        var xdat: number = x.getValueAtIndex(i);
                                        for (var j: number = 0; j < n; j++) {
                                            A.plus(index++, gamma * xdat * y.getValueAtIndex(j));
                                        }
                                    }
                                }
                            }

                            public static householder(gamma: number, u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var n: number = u.getNumElements();
                                var sum: number = 0;
                                for (var i: number = 0; i < n; i++) {
                                    sum += u.getValueAtIndex(i) * x.getValueAtIndex(i);
                                }
                                for (var i: number = 0; i < n; i++) {
                                    y.setValueAtIndex(i, x.getValueAtIndex(i) + gamma * u.getValueAtIndex(i) * sum);
                                }
                            }

                            public static rank1Update4Mat(gamma: number, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, w: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var n: number = u.getNumElements();
                                var matrixIndex: number = 0;
                                for (var i: number = 0; i < n; i++) {
                                    var elementU: number = u.data[i];
                                    for (var j: number = 0; j < n; ) {
                                        B.data[matrixIndex] = A.data[matrixIndex] + gamma * elementU * w.data[j];
                                    }
                                }
                            }

                            public static rank1Update(gamma: number, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, w: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                var n: number = u.getNumElements();
                                var matrixIndex: number = 0;
                                for (var i: number = 0; i < n; i++) {
                                    var elementU: number = u.data[i];
                                    for (var j: number = 0; j < n; j++) {
                                        A.data[matrixIndex++] += gamma * elementU * w.data[j];
                                    }
                                }
                            }

                        }

                        export module solvers {
                            export class AdjLinearSolverQr {

                                public numRows: number;
                                public numCols: number;
                                private decomposer: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64;
                                public maxRows: number = -1;
                                public maxCols: number = -1;
                                public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public R: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                private Y: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                private Z: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    if (A.numRows > this.maxRows || A.numCols > this.maxCols) {
                                        this.setMaxSize(A.numRows, A.numCols);
                                    }
                                    this.numRows = A.numRows;
                                    this.numCols = A.numCols;
                                    if (!this.decomposer.decompose(A)) {
                                        return false;
                                    }
                                    this.Q.reshapeBoolean(this.numRows, this.numRows, false);
                                    this.R.reshapeBoolean(this.numRows, this.numCols, false);
                                    this.decomposer.getQ(this.Q, false);
                                    this.decomposer.getR(this.R, false);
                                    return true;
                                }

                                private solveU(U: Float64Array, b: Float64Array, n: number): void {
                                    for (var i: number = n - 1; i >= 0; i--) {
                                        var sum: number = b[i];
                                        var indexU: number = i * n + i + 1;
                                        for (var j: number = i + 1; j < n; j++) {
                                            sum -= U[indexU++] * b[j];
                                        }
                                        b[i] = sum / U[i * n + i];
                                    }
                                }

                                public solve(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, X: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    var BnumCols: number = B.numCols;
                                    this.Y.reshapeBoolean(this.numRows, 1, false);
                                    this.Z.reshapeBoolean(this.numRows, 1, false);
                                    for (var colB: number = 0; colB < BnumCols; colB++) {
                                        for (var i: number = 0; i < this.numRows; i++) {
                                            this.Y.data[i] = B.get(i, colB);
                                        }
                                        org.kevoree.modeling.util.maths.matrix.MatrixMatrixMult.multTransA(this.Q, this.Y, this.Z);
                                        this.solveU(this.R.data, this.Z.data, this.numCols);
                                        for (var i: number = 0; i < this.numCols; i++) {
                                            X.cset(i, colB, this.Z.data[i]);
                                        }
                                    }
                                }

                                constructor() {
                                    this.decomposer = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64();
                                }

                                public setMaxSize(maxRows: number, maxCols: number): void {
                                    maxRows += 5;
                                    this.maxRows = maxRows;
                                    this.maxCols = maxCols;
                                    this.Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, maxRows);
                                    this.R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, maxCols);
                                    this.Y = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, 1);
                                    this.Z = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(maxRows, 1);
                                }

                            }

                            export class LUDecompositionAlt_D64 {

                                public LU: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public maxWidth: number = -1;
                                public m: number;
                                public n: number;
                                public dataLU: Float64Array;
                                public vv: Float64Array;
                                public indx: Int32Array;
                                public pivot: Int32Array;
                                public pivsign: number;
                                public setExpectedMaxSize(numRows: number, numCols: number): void {
                                    this.LU = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                                    this.dataLU = this.LU.data;
                                    this.maxWidth = Math.max(numRows, numCols);
                                    this.vv = new Float64Array(this.maxWidth);
                                    this.indx = new Int32Array(this.maxWidth);
                                    this.pivot = new Int32Array(this.maxWidth);
                                }

                                public getLU(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    return this.LU;
                                }

                                public getIndx(): Int32Array {
                                    return this.indx;
                                }

                                public getPivot(): Int32Array {
                                    return this.pivot;
                                }

                                public getLower(lower: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    var numRows: number = this.LU.numRows;
                                    var numCols: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                                    if (lower == null) {
                                        lower = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.fill(lower, 0);
                                    }
                                    for (var i: number = 0; i < numCols; i++) {
                                        lower.set(i, i, 1.0);
                                        for (var j: number = 0; j < i; j++) {
                                            lower.set(i, j, this.LU.get(i, j));
                                        }
                                    }
                                    if (numRows > numCols) {
                                        for (var i: number = numCols; i < numRows; i++) {
                                            for (var j: number = 0; j < numCols; j++) {
                                                lower.set(i, j, this.LU.get(i, j));
                                            }
                                        }
                                    }
                                    return lower;
                                }

                                public getUpper(upper: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    var numRows: number = this.LU.numRows < this.LU.numCols ? this.LU.numRows : this.LU.numCols;
                                    var numCols: number = this.LU.numCols;
                                    if (upper == null) {
                                        upper = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numRows, numCols);
                                    } else {
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.fill(upper, 0);
                                    }
                                    for (var i: number = 0; i < numRows; i++) {
                                        for (var j: number = i; j < numCols; j++) {
                                            upper.set(i, j, this.LU.get(i, j));
                                        }
                                    }
                                    return upper;
                                }

                                public decomposeCommonInit(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    if (a.numRows > this.maxWidth || a.numCols > this.maxWidth) {
                                        this.setExpectedMaxSize(a.numRows, a.numCols);
                                    }
                                    this.m = a.numRows;
                                    this.n = a.numCols;
                                    this.LU.setMatrix(a);
                                    for (var i: number = 0; i < this.m; i++) {
                                        this.pivot[i] = i;
                                    }
                                    this.pivsign = 1;
                                }

                                public _solveVectorInternal(vv: Float64Array): void {
                                    var ii: number = 0;
                                    for (var i: number = 0; i < this.n; i++) {
                                        var ip: number = this.indx[i];
                                        var sum: number = vv[ip];
                                        vv[ip] = vv[i];
                                        if (ii != 0) {
                                            var index: number = i * this.n + ii - 1;
                                            for (var j: number = ii - 1; j < i; j++) {
                                                sum -= this.dataLU[index++] * vv[j];
                                            }
                                        } else {
                                            if (sum != 0.0) {
                                                ii = i + 1;
                                            }
                                        }
                                        vv[i] = sum;
                                    }
                                    org.kevoree.modeling.util.maths.matrix.solvers.TriangularSolver.solveU2arr(this.dataLU, vv, this.n);
                                }

                                public _getVV(): Float64Array {
                                    return this.vv;
                                }

                                public computeDeterminant(): number {
                                    var ret: number = this.pivsign;
                                    var total: number = this.m * this.n;
                                    for (var i: number = 0; i < total; i += this.n + 1) {
                                        ret *= this.dataLU[i];
                                    }
                                    return ret;
                                }

                                public decompose(a: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    this.decomposeCommonInit(a);
                                    var LUcolj: Float64Array = this.vv;
                                    for (var j: number = 0; j < this.n; j++) {
                                        for (var i: number = 0; i < this.m; i++) {
                                            LUcolj[i] = this.dataLU[i * this.n + j];
                                        }
                                        for (var i: number = 0; i < this.m; i++) {
                                            var rowIndex: number = i * this.n;
                                            var kmax: number = i < j ? i : j;
                                            var s: number = 0.0;
                                            for (var k: number = 0; k < kmax; k++) {
                                                s += this.dataLU[rowIndex + k] * LUcolj[k];
                                            }
                                            this.dataLU[rowIndex + j] = LUcolj[i] -= s;
                                        }
                                        var p: number = j;
                                        var max: number = Math.abs(LUcolj[p]);
                                        for (var i: number = j + 1; i < this.m; i++) {
                                            var v: number = Math.abs(LUcolj[i]);
                                            if (v > max) {
                                                p = i;
                                                max = v;
                                            }
                                        }
                                        if (p != j) {
                                            var rowP: number = p * this.n;
                                            var rowJ: number = j * this.n;
                                            var endP: number = rowP + this.n;
                                            for (; rowP < endP; ) {
                                                var t: number = this.dataLU[rowP];
                                                this.dataLU[rowP] = this.dataLU[rowJ];
                                                this.dataLU[rowJ] = t;
                                            }
                                            var k: number = this.pivot[p];
                                            this.pivot[p] = this.pivot[j];
                                            this.pivot[j] = k;
                                            this.pivsign = -this.pivsign;
                                        }
                                        this.indx[j] = p;
                                        if (j < this.m) {
                                            var lujj: number = this.dataLU[j * this.n + j];
                                            if (lujj != 0) {
                                                for (var i: number = j + 1; i < this.m; i++) {
                                                    this.dataLU[i * this.n + j] /= lujj;
                                                }
                                            }
                                        }
                                    }
                                    return true;
                                }

                            }

                            export class LinearSolverLu_D64 {

                                public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public numRows: number;
                                public numCols: number;
                                public decomp: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64;
                                public doImprove: boolean = false;
                                public getA(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    return this.A;
                                }

                                public _setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    this.A = A;
                                    this.numRows = A.numRows;
                                    this.numCols = A.numCols;
                                }

                                constructor(decomp: org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64) {
                                    this.decomp = decomp;
                                }

                                public setA(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    this._setA(A);
                                    return this.decomp.decompose(A);
                                }

                                public invert(A_inv: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    var vv: Float64Array = this.decomp._getVV();
                                    var LU: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decomp.getLU();
                                    var n: number = this.A.numCols;
                                    var dataInv: Float64Array = A_inv.data;
                                    for (var j: number = 0; j < n; j++) {
                                        for (var i: number = 0; i < n; i++) {
                                            vv[i] = i == j ? 1 : 0;
                                        }
                                        this.decomp._solveVectorInternal(vv);
                                        var index: number = j;
                                        for (var i: number = 0; i < n; ) {
                                            dataInv[index] = vv[i];
                                        }
                                    }
                                }

                                public improveSol(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    var dataA: Float64Array = this.A.data;
                                    var dataB: Float64Array = b.data;
                                    var dataX: Float64Array = x.data;
                                    var nc: number = b.numCols;
                                    var n: number = b.numCols;
                                    var vv: Float64Array = this.decomp._getVV();
                                    for (var k: number = 0; k < nc; k++) {
                                        for (var i: number = 0; i < n; i++) {
                                            var sdp: number = -dataB[i * nc + k];
                                            for (var j: number = 0; j < n; j++) {
                                                sdp += dataA[i * n + j] * dataX[j * nc + k];
                                            }
                                            vv[i] = sdp;
                                        }
                                        this.decomp._solveVectorInternal(vv);
                                        for (var i: number = 0; i < n; i++) {
                                            dataX[i * nc + k] -= vv[i];
                                        }
                                    }
                                }

                                public modifiesA(): boolean {
                                    return false;
                                }

                                public modifiesB(): boolean {
                                    return false;
                                }

                                public solve(b: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, x: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    var numCols: number = b.numCols;
                                    var dataB: Float64Array = b.data;
                                    var dataX: Float64Array = x.data;
                                    var vv: Float64Array = this.decomp._getVV();
                                    for (var j: number = 0; j < numCols; j++) {
                                        var index: number = j;
                                        for (var i: number = 0; i < this.numCols; ) {
                                            vv[i] = dataB[index];
                                        }
                                        this.decomp._solveVectorInternal(vv);
                                        index = j;
                                        for (var i: number = 0; i < this.numCols; ) {
                                            dataX[index] = vv[i];
                                        }
                                    }
                                    if (this.doImprove) {
                                        this.improveSol(b, x);
                                    }
                                }

                            }

                            export class SimpleEVD<T extends org.kevoree.modeling.util.maths.matrix.SimpleMatrix> {

                                private eig: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition;
                                public mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                constructor(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F) {
                                    this.mat = mat;
                                    this.eig = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition(mat.numCols, true, 1e-8);
                                    if (!this.eig.decompose(mat)) {
                                        throw new Error("Eigenvalue Decomposition failed");
                                    }
                                }

                                public getNumberOfEigenvalues(): number {
                                    return this.eig.getNumberOfEigenvalues();
                                }

                                public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                    return this.eig.getEigenvalue(index);
                                }

                                public getEigenVector(index: number): T {
                                    return <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.eig.getEigenVector(index));
                                }

                                public getEVD(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SwitchingEigenDecomposition {
                                    return this.eig;
                                }

                                public getIndexMax(): number {
                                    var indexMax: number = 0;
                                    var max: number = this.getEigenvalue(0).getMagnitude2();
                                    var N: number = this.getNumberOfEigenvalues();
                                    for (var i: number = 1; i < N; i++) {
                                        var m: number = this.getEigenvalue(i).getMagnitude2();
                                        if (m > max) {
                                            max = m;
                                            indexMax = i;
                                        }
                                    }
                                    return indexMax;
                                }

                                public getIndexMin(): number {
                                    var indexMin: number = 0;
                                    var min: number = this.getEigenvalue(0).getMagnitude2();
                                    var N: number = this.getNumberOfEigenvalues();
                                    for (var i: number = 1; i < N; i++) {
                                        var m: number = this.getEigenvalue(i).getMagnitude2();
                                        if (m < min) {
                                            min = m;
                                            indexMin = i;
                                        }
                                    }
                                    return indexMin;
                                }

                            }

                            export class SimpleSVD<T extends org.kevoree.modeling.util.maths.matrix.SimpleMatrix> {

                                private svd: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64;
                                private U: T;
                                private W: T;
                                private V: T;
                                private mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public tol: number;
                                private static swapRowOrCol(M: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tran: boolean, i: number, bigIndex: number): void {
                                    var tmp: number;
                                    if (tran) {
                                        for (var col: number = 0; col < M.numCols; col++) {
                                            tmp = M.get(i, col);
                                            M.set(i, col, M.get(bigIndex, col));
                                            M.set(bigIndex, col, tmp);
                                        }
                                    } else {
                                        for (var row: number = 0; row < M.numRows; row++) {
                                            tmp = M.get(row, i);
                                            M.set(row, i, M.get(row, bigIndex));
                                            M.set(row, bigIndex, tmp);
                                        }
                                    }
                                }

                                public static singularThreshold(svd: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64): number {
                                    var largest: number = 0;
                                    var w: Float64Array = svd.getSingularValues();
                                    var N: number = svd.numberOfSingularValues();
                                    for (var j: number = 0; j < N; j++) {
                                        if (w[j] > largest) {
                                            largest = w[j];
                                        }
                                    }
                                    var M: number = Math.max(svd.getNumCols(), svd.getNumRows());
                                    return M * largest * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                }

                                public static descendingOrder(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tranU: boolean, W: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, tranV: boolean): void {
                                    var numSingular: number = Math.min(W.numRows, W.numCols);
                                    for (var i: number = 0; i < numSingular; i++) {
                                        var bigValue: number = -1;
                                        var bigIndex: number = -1;
                                        for (var j: number = i; j < numSingular; j++) {
                                            var v: number = W.get(j, j);
                                            if (v > bigValue) {
                                                bigValue = v;
                                                bigIndex = j;
                                            }
                                        }
                                        if (bigIndex == i) {
                                            continue;
                                        }
                                        if (bigIndex == -1) {
                                            break;
                                        }
                                        var tmp: number = W.get(i, i);
                                        W.set(i, i, bigValue);
                                        W.set(bigIndex, bigIndex, tmp);
                                        if (V != null) {
                                            org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(V, tranV, i, bigIndex);
                                        }
                                        if (U != null) {
                                            org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.swapRowOrCol(U, tranU, i, bigIndex);
                                        }
                                    }
                                }

                                constructor(mat: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean) {
                                    this.mat = mat;
                                    this.svd = new org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrDecompose_D64(compact, true, true, false);
                                    if (!this.svd.decompose(mat)) {
                                        throw new Error("Decomposition failed");
                                    }
                                    this.U = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getU(null, false));
                                    this.W = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getW(null));
                                    this.V = <T>org.kevoree.modeling.util.maths.matrix.SimpleMatrix.wrap(this.svd.getV(null, false));
                                    org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.descendingOrder(this.U.getMatrix(), false, this.W.getMatrix(), this.V.getMatrix(), false);
                                    this.tol = org.kevoree.modeling.util.maths.matrix.solvers.SimpleSVD.singularThreshold(this.svd);
                                }

                                public getU(): T {
                                    return this.U;
                                }

                                public getW(): T {
                                    return this.W;
                                }

                                public getV(): T {
                                    return this.V;
                                }

                            }

                            export class SvdImplicitQrAlgorithm {

                                public rand: java.util.Random = new java.util.Random();
                                public Ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public Vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                public totalSteps: number;
                                public maxValue: number;
                                public N: number;
                                public eigenSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                                public numExceptional: number;
                                public nextExceptional: number;
                                public diag: Float64Array;
                                public off: Float64Array;
                                public bulge: number;
                                public x1: number;
                                public x2: number;
                                public steps: number;
                                public splits: Int32Array;
                                public numSplits: number;
                                private exceptionalThresh: number = 15;
                                private maxIterations: number = this.exceptionalThresh * 100;
                                public followScript: boolean;
                                private static giveUpOnKnown: number = 10;
                                private values: Float64Array;
                                private fastValues: boolean = false;
                                private findingZeros: boolean;
                                public c: number;
                                public s: number;
                                constructor() {
                                }

                                public getUt(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    return this.Ut;
                                }

                                public setUt(ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    this.Ut = ut;
                                }

                                public getVt(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    return this.Vt;
                                }

                                public setVt(vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                    this.Vt = vt;
                                }

                                public setMatrix(numRows: number, numCols: number, diag: Float64Array, off: Float64Array): void {
                                    this.initParam(numRows, numCols);
                                    this.diag = diag;
                                    this.off = off;
                                    this.maxValue = Math.abs(diag[0]);
                                    for (var i: number = 1; i < this.N; i++) {
                                        var a: number = Math.abs(diag[i]);
                                        var b: number = Math.abs(off[i - 1]);
                                        if (a > this.maxValue) {
                                            this.maxValue = Math.abs(a);
                                        }
                                        if (b > this.maxValue) {
                                            this.maxValue = Math.abs(b);
                                        }
                                    }
                                }

                                public swapDiag(diag: Float64Array): Float64Array {
                                    var ret: Float64Array = this.diag;
                                    this.diag = diag;
                                    return ret;
                                }

                                public swapOff(off: Float64Array): Float64Array {
                                    var ret: Float64Array = this.off;
                                    this.off = off;
                                    return ret;
                                }

                                public setMaxValue(maxValue: number): void {
                                    this.maxValue = maxValue;
                                }

                                public initParam(M: number, N: number): void {
                                    if (N > M) {
                                        throw new Error("Must be a square or tall matrix");
                                    }
                                    this.N = N;
                                    if (this.splits == null || this.splits.length < N) {
                                        this.splits = new Int32Array(N);
                                    }
                                    this.x1 = 0;
                                    this.x2 = this.N - 1;
                                    this.steps = 0;
                                    this.totalSteps = 0;
                                    this.numSplits = 0;
                                    this.numExceptional = 0;
                                    this.nextExceptional = this.exceptionalThresh;
                                }

                                public process(): boolean {
                                    this.followScript = false;
                                    this.findingZeros = true;
                                    return this._process();
                                }

                                public processValues(values: Float64Array): boolean {
                                    this.followScript = true;
                                    this.values = values;
                                    this.findingZeros = false;
                                    return this._process();
                                }

                                public _process(): boolean {
                                    if (this.maxValue == 0) {
                                        return true;
                                    }
                                    while (this.x2 >= 0){
                                        if (this.steps > this.maxIterations) {
                                            return false;
                                        }
                                        if (this.x1 == this.x2) {
                                            this.resetSteps();
                                            if (!this.nextSplit()) {
                                                break;
                                            }
                                        } else {
                                            if (this.fastValues && this.x2 - this.x1 == 1) {
                                                this.resetSteps();
                                                this.eigenBB_2x2(this.x1);
                                                this.setSubmatrix(this.x2, this.x2);
                                            } else {
                                                if (this.steps >= this.nextExceptional) {
                                                    this.exceptionShift();
                                                } else {
                                                    if (!this.checkForAndHandleZeros()) {
                                                        if (this.followScript) {
                                                            this.performScriptedStep();
                                                        } else {
                                                            this.performDynamicStep();
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    return true;
                                }

                                private performDynamicStep(): void {
                                    if (this.findingZeros) {
                                        if (this.steps > 6) {
                                            this.findingZeros = false;
                                        } else {
                                            var scale: number = this.computeBulgeScale();
                                            this.performImplicitSingleStep(scale, 0, false);
                                        }
                                    } else {
                                        var scale: number = this.computeBulgeScale();
                                        var lambda: number = this.selectWilkinsonShift(scale);
                                        this.performImplicitSingleStep(scale, lambda, false);
                                    }
                                }

                                private performScriptedStep(): void {
                                    var scale: number = this.computeBulgeScale();
                                    if (this.steps > SvdImplicitQrAlgorithm.giveUpOnKnown) {
                                        this.followScript = false;
                                    } else {
                                        var s: number = this.values[this.x2] / scale;
                                        this.performImplicitSingleStep(scale, s * s, false);
                                    }
                                }

                                public incrementSteps(): void {
                                    this.steps++;
                                    this.totalSteps++;
                                }

                                public isOffZero(i: number): boolean {
                                    var bottom: number = Math.abs(this.diag[i]) + Math.abs(this.diag[i + 1]);
                                    return Math.abs(this.off[i]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                }

                                public isDiagonalZero(i: number): boolean {
                                    var bottom: number = Math.abs(this.diag[i + 1]) + Math.abs(this.off[i]);
                                    return Math.abs(this.diag[i]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                }

                                public resetSteps(): void {
                                    this.steps = 0;
                                    this.nextExceptional = this.exceptionalThresh;
                                    this.numExceptional = 0;
                                }

                                public nextSplit(): boolean {
                                    if (this.numSplits == 0) {
                                        return false;
                                    }
                                    this.x2 = this.splits[--this.numSplits];
                                    if (this.numSplits > 0) {
                                        this.x1 = this.splits[this.numSplits - 1] + 1;
                                    } else {
                                        this.x1 = 0;
                                    }
                                    return true;
                                }

                                public performImplicitSingleStep(scale: number, lambda: number, byAngle: boolean): void {
                                    this.createBulge(this.x1, lambda, scale, byAngle);
                                    for (var i: number = this.x1; i < this.x2 - 1 && this.bulge != 0.0; i++) {
                                        this.removeBulgeLeft(i, true);
                                        if (this.bulge == 0) {
                                            break;
                                        }
                                        this.removeBulgeRight(i);
                                    }
                                    if (this.bulge != 0) {
                                        this.removeBulgeLeft(this.x2 - 1, false);
                                    }
                                    this.incrementSteps();
                                }

                                public updateRotator(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, m: number, n: number, c: number, s: number): void {
                                    var rowA: number = m * Q.numCols;
                                    var rowB: number = n * Q.numCols;
                                    var endA: number = rowA + Q.numCols;
                                    for (; rowA != endA; ) {
                                        var a: number = Q.getValueAtIndex(rowA);
                                        var b: number = Q.getValueAtIndex(rowB);
                                        Q.setValueAtIndex(rowA, c * a + s * b);
                                        Q.setValueAtIndex(rowB, -s * a + c * b);
                                    }
                                }

                                private computeBulgeScale(): number {
                                    var b11: number = this.diag[this.x1];
                                    var b12: number = this.off[this.x1];
                                    return Math.max(Math.abs(b11), Math.abs(b12));
                                }

                                public createBulge(x1: number, p: number, scale: number, byAngle: boolean): void {
                                    var b11: number = this.diag[x1];
                                    var b12: number = this.off[x1];
                                    var b22: number = this.diag[x1 + 1];
                                    if (byAngle) {
                                        this.c = Math.cos(p);
                                        this.s = Math.sin(p);
                                    } else {
                                        var u1: number = (b11 / scale) * (b11 / scale) - p;
                                        var u2: number = (b12 / scale) * (b11 / scale);
                                        var gamma: number = Math.sqrt(u1 * u1 + u2 * u2);
                                        this.c = u1 / gamma;
                                        this.s = u2 / gamma;
                                    }
                                    this.diag[x1] = b11 * this.c + b12 * this.s;
                                    this.off[x1] = b12 * this.c - b11 * this.s;
                                    this.diag[x1 + 1] = b22 * this.c;
                                    this.bulge = b22 * this.s;
                                    if (this.Vt != null) {
                                        this.updateRotator(this.Vt, x1, x1 + 1, this.c, this.s);
                                    }
                                }

                                public computeRotator(rise: number, run: number): void {
                                    if (Math.abs(rise) < Math.abs(run)) {
                                        var k: number = rise / run;
                                        var bottom: number = Math.sqrt(1.0 + k * k);
                                        this.s = 1.0 / bottom;
                                        this.c = k / bottom;
                                    } else {
                                        var t: number = run / rise;
                                        var bottom: number = Math.sqrt(1.0 + t * t);
                                        this.c = 1.0 / bottom;
                                        this.s = t / bottom;
                                    }
                                }

                                public removeBulgeLeft(x1: number, notLast: boolean): void {
                                    var b11: number = this.diag[x1];
                                    var b12: number = this.off[x1];
                                    var b22: number = this.diag[x1 + 1];
                                    this.computeRotator(b11, this.bulge);
                                    this.diag[x1] = this.c * b11 + this.s * this.bulge;
                                    this.off[x1] = this.c * b12 + this.s * b22;
                                    this.diag[x1 + 1] = this.c * b22 - this.s * b12;
                                    if (notLast) {
                                        var b23: number = this.off[x1 + 1];
                                        this.bulge = this.s * b23;
                                        this.off[x1 + 1] = this.c * b23;
                                    }
                                    if (this.Ut != null) {
                                        this.updateRotator(this.Ut, x1, x1 + 1, this.c, this.s);
                                    }
                                }

                                public removeBulgeRight(x1: number): void {
                                    var b12: number = this.off[x1];
                                    var b22: number = this.diag[x1 + 1];
                                    var b23: number = this.off[x1 + 1];
                                    this.computeRotator(b12, this.bulge);
                                    this.off[x1] = b12 * this.c + this.bulge * this.s;
                                    this.diag[x1 + 1] = b22 * this.c + b23 * this.s;
                                    this.off[x1 + 1] = -b22 * this.s + b23 * this.c;
                                    var b33: number = this.diag[x1 + 2];
                                    this.diag[x1 + 2] = b33 * this.c;
                                    this.bulge = b33 * this.s;
                                    if (this.Vt != null) {
                                        this.updateRotator(this.Vt, x1 + 1, x1 + 2, this.c, this.s);
                                    }
                                }

                                public setSubmatrix(x1: number, x2: number): void {
                                    this.x1 = x1;
                                    this.x2 = x2;
                                }

                                public selectWilkinsonShift(scale: number): number {
                                    var a11: number;
                                    var a22: number;
                                    if (this.x2 - this.x1 > 1) {
                                        var d1: number = this.diag[this.x2 - 1] / scale;
                                        var o1: number = this.off[this.x2 - 2] / scale;
                                        var d2: number = this.diag[this.x2] / scale;
                                        var o2: number = this.off[this.x2 - 1] / scale;
                                        a11 = o1 * o1 + d1 * d1;
                                        a22 = o2 * o2 + d2 * d2;
                                        this.eigenSmall.symm2x2_fast(a11, o2 * d1, a22);
                                    } else {
                                        var a: number = this.diag[this.x2 - 1] / scale;
                                        var b: number = this.off[this.x2 - 1] / scale;
                                        var c: number = this.diag[this.x2] / scale;
                                        a11 = a * a;
                                        a22 = b * b + c * c;
                                        this.eigenSmall.symm2x2_fast(a11, a * b, a22);
                                    }
                                    var diff0: number = Math.abs(this.eigenSmall.value0.real - a22);
                                    var diff1: number = Math.abs(this.eigenSmall.value1.real - a22);
                                    return diff0 < diff1 ? this.eigenSmall.value0.real : this.eigenSmall.value1.real;
                                }

                                public static signum(d: number): number {
                                    if (d < 0) {
                                        return -1.0;
                                    }
                                    if (d > 0) {
                                        return 1.0;
                                    }
                                    return 0.0;
                                }

                                public eigenBB_2x2(x1: number): void {
                                    var b11: number = this.diag[x1];
                                    var b12: number = this.off[x1];
                                    var b22: number = this.diag[x1 + 1];
                                    var absA: number = Math.abs(b11);
                                    var absB: number = Math.abs(b12);
                                    var absC: number = Math.abs(b22);
                                    var scale: number = absA > absB ? absA : absB;
                                    if (absC > scale) {
                                        scale = absC;
                                    }
                                    if (scale == 0) {
                                        return;
                                    }
                                    b11 /= scale;
                                    b12 /= scale;
                                    b22 /= scale;
                                    this.eigenSmall.symm2x2_fast(b11 * b11, b11 * b12, b12 * b12 + b22 * b22);
                                    this.off[x1] = 0;
                                    this.diag[x1] = scale * Math.sqrt(this.eigenSmall.value0.real);
                                    var sgn: number = org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm.signum(this.eigenSmall.value1.real);
                                    this.diag[x1 + 1] = sgn * scale * Math.sqrt(Math.abs(this.eigenSmall.value1.real));
                                }

                                public checkForAndHandleZeros(): boolean {
                                    for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                                        if (this.isOffZero(i)) {
                                            this.resetSteps();
                                            this.splits[this.numSplits++] = i;
                                            this.x1 = i + 1;
                                            return true;
                                        }
                                    }
                                    for (var i: number = this.x2 - 1; i >= this.x1; i--) {
                                        if (this.isDiagonalZero(i)) {
                                            this.pushRight(i);
                                            this.resetSteps();
                                            this.splits[this.numSplits++] = i;
                                            this.x1 = i + 1;
                                            return true;
                                        }
                                    }
                                    return false;
                                }

                                private pushRight(row: number): void {
                                    if (this.isOffZero(row)) {
                                        return;
                                    }
                                    this.rotatorPushRight(row);
                                    var end: number = this.N - 2 - row;
                                    for (var i: number = 0; i < end && this.bulge != 0; i++) {
                                        this.rotatorPushRight2(row, i + 2);
                                    }
                                }

                                private rotatorPushRight(m: number): void {
                                    var b11: number = this.off[m];
                                    var b21: number = this.diag[m + 1];
                                    this.computeRotator(b21, -b11);
                                    this.off[m] = 0;
                                    this.diag[m + 1] = b21 * this.c - b11 * this.s;
                                    if (m + 2 < this.N) {
                                        var b22: number = this.off[m + 1];
                                        this.off[m + 1] = b22 * this.c;
                                        this.bulge = b22 * this.s;
                                    } else {
                                        this.bulge = 0;
                                    }
                                    if (this.Ut != null) {
                                        this.updateRotator(this.Ut, m, m + 1, this.c, this.s);
                                    }
                                }

                                private rotatorPushRight2(m: number, offset: number): void {
                                    var b11: number = this.bulge;
                                    var b12: number = this.diag[m + offset];
                                    this.computeRotator(b12, -b11);
                                    this.diag[m + offset] = b12 * this.c - b11 * this.s;
                                    if (m + offset < this.N - 1) {
                                        var b22: number = this.off[m + offset];
                                        this.off[m + offset] = b22 * this.c;
                                        this.bulge = b22 * this.s;
                                    }
                                    if (this.Ut != null) {
                                        this.updateRotator(this.Ut, m, m + offset, this.c, this.s);
                                    }
                                }

                                public exceptionShift(): void {
                                    this.numExceptional++;
                                    var mag: number = 0.05 * this.numExceptional;
                                    if (mag > 1.0) {
                                        mag = 1.0;
                                    }
                                    var angle: number = 2.0 * Math.PI * (this.rand.nextDouble() - 0.5) * mag;
                                    this.performImplicitSingleStep(0, angle, true);
                                    this.nextExceptional = this.steps + this.exceptionalThresh;
                                }

                                public getNumberOfSingularValues(): number {
                                    return this.N;
                                }

                                public getSingularValue(index: number): number {
                                    return this.diag[index];
                                }

                                public setFastValues(b: boolean): void {
                                    this.fastValues = b;
                                }

                                public getSingularValues(): Float64Array {
                                    return this.diag;
                                }

                                public getDiag(): Float64Array {
                                    return this.diag;
                                }

                                public getOff(): Float64Array {
                                    return this.off;
                                }

                                public getMaxValue(): number {
                                    return this.maxValue;
                                }

                            }

                            export class SvdImplicitQrDecompose_D64 {

                                private numRows: number;
                                private numCols: number;
                                private numRowsT: number;
                                private numColsT: number;
                                private canUseTallBidiagonal: boolean;
                                private bidiag: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<any>;
                                private qralg: org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm = new org.kevoree.modeling.util.maths.matrix.solvers.SvdImplicitQrAlgorithm();
                                public diag: Float64Array;
                                public off: Float64Array;
                                private Ut: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                private Vt: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                private singularValues: Float64Array;
                                private numSingular: number;
                                private compact: boolean;
                                private computeU: boolean;
                                private computeV: boolean;
                                private prefComputeU: boolean;
                                private prefComputeV: boolean;
                                private transposed: boolean;
                                private A_mod: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                                constructor(compact: boolean, computeU: boolean, computeV: boolean, canUseTallBidiagonal: boolean) {
                                    this.compact = compact;
                                    this.prefComputeU = computeU;
                                    this.prefComputeV = computeV;
                                    this.canUseTallBidiagonal = canUseTallBidiagonal;
                                }

                                public getSingularValues(): Float64Array {
                                    return this.singularValues;
                                }

                                public numberOfSingularValues(): number {
                                    return this.numSingular;
                                }

                                public isCompact(): boolean {
                                    return this.compact;
                                }

                                public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    if (!this.prefComputeU) {
                                        throw new Error("As requested U was not computed.");
                                    }
                                    if (transpose) {
                                        if (U == null) {
                                            return this.Ut;
                                        } else {
                                            if (U.numRows != this.Ut.numRows || U.numCols != this.Ut.numCols) {
                                                throw new Error("Unexpected shape of U");
                                            }
                                        }
                                        U.setMatrix(this.Ut);
                                    } else {
                                        if (U == null) {
                                            U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.Ut.numCols, this.Ut.numRows);
                                        } else {
                                            if (U.numRows != this.Ut.numCols || U.numCols != this.Ut.numRows) {
                                                throw new Error("Unexpected shape of U");
                                            }
                                        }
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.Ut, U);
                                    }
                                    return U;
                                }

                                public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    if (!this.prefComputeV) {
                                        throw new Error("As requested V was not computed.");
                                    }
                                    if (transpose) {
                                        if (V == null) {
                                            return this.Vt;
                                        } else {
                                            if (V.numRows != this.Vt.numRows || V.numCols != this.Vt.numCols) {
                                                throw new Error("Unexpected shape of V");
                                            }
                                        }
                                        V.setMatrix(this.Vt);
                                    } else {
                                        if (V == null) {
                                            V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.Vt.numCols, this.Vt.numRows);
                                        } else {
                                            if (V.numRows != this.Vt.numCols || V.numCols != this.Vt.numRows) {
                                                throw new Error("Unexpected shape of V");
                                            }
                                        }
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(this.Vt, V);
                                    }
                                    return V;
                                }

                                public getW(W: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                    var m: number = this.compact ? this.numSingular : this.numRows;
                                    var n: number = this.compact ? this.numSingular : this.numCols;
                                    if (W == null) {
                                        W = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, n);
                                    } else {
                                        W.reshapeBoolean(m, n, false);
                                        W.zero();
                                    }
                                    for (var i: number = 0; i < this.numSingular; i++) {
                                        W.set(i, i, this.singularValues[i]);
                                    }
                                    return W;
                                }

                                public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    if (!this.setup(orig)) {
                                        return false;
                                    }
                                    if (this.bidiagonalization(orig)) {
                                        return false;
                                    }
                                    if (this.computeUWV()) {
                                        return false;
                                    }
                                    this.makeSingularPositive();
                                    this.undoTranspose();
                                    return true;
                                }

                                public inputModified(): boolean {
                                    return false;
                                }

                                private bidiagonalization(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    if (this.transposed) {
                                        this.A_mod.reshapeBoolean(orig.numCols, orig.numRows, false);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.transposeMatrix(orig, this.A_mod);
                                    } else {
                                        this.A_mod.reshapeBoolean(orig.numRows, orig.numCols, false);
                                        this.A_mod.setMatrix(orig);
                                    }
                                    return !this.bidiag.decompose(this.A_mod);
                                }

                                private undoTranspose(): void {
                                    if (this.transposed) {
                                        var temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.Vt;
                                        this.Vt = this.Ut;
                                        this.Ut = temp;
                                    }
                                }

                                private computeUWV(): boolean {
                                    this.bidiag.getDiagonal(this.diag, this.off);
                                    this.qralg.setMatrix(this.numRowsT, this.numColsT, this.diag, this.off);
                                    if (this.computeU) {
                                        this.Ut = this.bidiag.getU(this.Ut, true, this.compact);
                                    }
                                    if (this.computeV) {
                                        this.Vt = this.bidiag.getV(this.Vt, true, this.compact);
                                    }
                                    this.qralg.setFastValues(false);
                                    if (this.computeU) {
                                        this.qralg.setUt(this.Ut);
                                    } else {
                                        this.qralg.setUt(null);
                                    }
                                    if (this.computeV) {
                                        this.qralg.setVt(this.Vt);
                                    } else {
                                        this.qralg.setVt(null);
                                    }
                                    var ret: boolean = !this.qralg.process();
                                    return ret;
                                }

                                private setup(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                    this.transposed = orig.numCols > orig.numRows;
                                    if (this.transposed) {
                                        this.computeU = this.prefComputeV;
                                        this.computeV = this.prefComputeU;
                                        this.numRowsT = orig.numCols;
                                        this.numColsT = orig.numRows;
                                    } else {
                                        this.computeU = this.prefComputeU;
                                        this.computeV = this.prefComputeV;
                                        this.numRowsT = orig.numRows;
                                        this.numColsT = orig.numCols;
                                    }
                                    this.numRows = orig.numRows;
                                    this.numCols = orig.numCols;
                                    if (this.numRows == 0 || this.numCols == 0) {
                                        return false;
                                    }
                                    if (this.diag == null || this.diag.length < this.numColsT) {
                                        this.diag = new Float64Array(this.numColsT);
                                        this.off = new Float64Array(this.numColsT - 1);
                                    }
                                    if (this.canUseTallBidiagonal && this.numRows > this.numCols * 2 && !this.computeU) {
                                        if (this.bidiag == null || !(this.bidiag instanceof org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64)) {
                                            this.bidiag = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionTall_D64();
                                        }
                                    } else {
                                        if (this.bidiag == null || !(this.bidiag instanceof org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64)) {
                                            this.bidiag = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                                        }
                                    }
                                    return true;
                                }

                                private makeSingularPositive(): void {
                                    this.numSingular = this.qralg.getNumberOfSingularValues();
                                    this.singularValues = this.qralg.getSingularValues();
                                    for (var i: number = 0; i < this.numSingular; i++) {
                                        var val: number = this.qralg.getSingularValue(i);
                                        if (val < 0) {
                                            this.singularValues[i] = 0.0 - val;
                                            if (this.computeU) {
                                                var start: number = i * this.Ut.numCols;
                                                var stop: number = start + this.Ut.numCols;
                                                for (var j: number = start; j < stop; j++) {
                                                    this.Ut.setValueAtIndex(j, 0.0 - this.Ut.getValueAtIndex(j));
                                                }
                                            }
                                        } else {
                                            this.singularValues[i] = val;
                                        }
                                    }
                                }

                                public getNumRows(): number {
                                    return this.numRows;
                                }

                                public getNumCols(): number {
                                    return this.numCols;
                                }

                            }

                            export class TriangularSolver {

                                public static invertLower(L: Float64Array, m: number): void {
                                    for (var i: number = 0; i < m; i++) {
                                        var L_ii: number = L[i * m + i];
                                        for (var j: number = 0; j < i; j++) {
                                            var val: number = 0;
                                            for (var k: number = j; k < i; k++) {
                                                val += L[i * m + k] * L[k * m + j];
                                            }
                                            L[i * m + j] = -val / L_ii;
                                        }
                                        L[i * m + i] = 1.0 / L_ii;
                                    }
                                }

                                public static invertLower2arr(L: Float64Array, L_inv: Float64Array, m: number): void {
                                    for (var i: number = 0; i < m; i++) {
                                        var L_ii: number = L[i * m + i];
                                        for (var j: number = 0; j < i; j++) {
                                            var val: number = 0;
                                            for (var k: number = j; k < i; k++) {
                                                val -= L[i * m + k] * L_inv[k * m + j];
                                            }
                                            L_inv[i * m + j] = val / L_ii;
                                        }
                                        L_inv[i * m + i] = 1.0 / L_ii;
                                    }
                                }

                                public static solveL2arr(L: Float64Array, b: Float64Array, n: number): void {
                                    for (var i: number = 0; i < n; i++) {
                                        var sum: number = b[i];
                                        var indexL: number = i * n;
                                        for (var k: number = 0; k < i; k++) {
                                            sum -= L[indexL++] * b[k];
                                        }
                                        b[i] = sum / L[indexL];
                                    }
                                }

                                public static solveL(L: Float64Array, b: Float64Array, m: number, n: number): void {
                                    for (var j: number = 0; j < n; j++) {
                                        for (var i: number = 0; i < m; i++) {
                                            var sum: number = b[i * n + j];
                                            for (var k: number = 0; k < i; k++) {
                                                sum -= L[i * m + k] * b[k * n + j];
                                            }
                                            b[i * n + j] = sum / L[i * m + i];
                                        }
                                    }
                                }

                                public static solveTranL(L: Float64Array, b: Float64Array, n: number): void {
                                    for (var i: number = n - 1; i >= 0; i--) {
                                        var sum: number = b[i];
                                        for (var k: number = i + 1; k < n; k++) {
                                            sum -= L[k * n + i] * b[k];
                                        }
                                        b[i] = sum / L[i * n + i];
                                    }
                                }

                                public static solveU2arr(U: Float64Array, b: Float64Array, n: number): void {
                                    for (var i: number = n - 1; i >= 0; i--) {
                                        var sum: number = b[i];
                                        var indexU: number = i * n + i + 1;
                                        for (var j: number = i + 1; j < n; j++) {
                                            sum -= U[indexU++] * b[j];
                                        }
                                        b[i] = sum / U[i * n + i];
                                    }
                                }

                                public static solveU(U: Float64Array, b: Float64Array, sideLength: number, minRow: number, maxRow: number): void {
                                    for (var i: number = maxRow - 1; i >= minRow; i--) {
                                        var sum: number = b[i];
                                        var indexU: number = i * sideLength + i + 1;
                                        for (var j: number = i + 1; j < maxRow; j++) {
                                            sum -= U[indexU++] * b[j];
                                        }
                                        b[i] = sum / U[i * sideLength + i];
                                    }
                                }

                                public static solveUArray(U: Float64Array, startU: number, strideU: number, widthU: number, b: Float64Array, startB: number, strideB: number, widthB: number): void {
                                    for (var colB: number = 0; colB < widthB; colB++) {
                                        for (var i: number = widthU - 1; i >= 0; i--) {
                                            var sum: number = b[startB + i * strideB + colB];
                                            for (var j: number = i + 1; j < widthU; j++) {
                                                sum -= U[startU + i * strideU + j] * b[startB + j * strideB + colB];
                                            }
                                            b[startB + i * strideB + colB] = sum / U[startU + i * strideU + i];
                                        }
                                    }
                                }

                            }

                            export module decomposition {
                                export interface BidiagonalDecomposition<T extends org.kevoree.modeling.util.maths.matrix.DenseMatrix64F> {

                                    getB(B: T, compact: boolean): T;

                                    getU(U: T, transpose: boolean, compact: boolean): T;

                                    getV(V: T, transpose: boolean, compact: boolean): T;

                                    getDiagonal(diag: Float64Array, off: Float64Array): void;

                                    decompose(orig: T): boolean;

                                    inputModified(): boolean;

                                }

                                export class BidiagonalDecompositionRow_D64 implements org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<any> {

                                    private UBV: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private m: number;
                                    private n: number;
                                    private min: number;
                                    private gammasU: Float64Array;
                                    private gammasV: Float64Array;
                                    private b: Float64Array;
                                    private u: Float64Array;
                                    constructor(numElements: number) {
                                        this.UBV = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(numElements, 1);
                                        this.gammasU = new Float64Array(numElements);
                                        this.gammasV = new Float64Array(numElements);
                                        this.b = new Float64Array(numElements);
                                        this.u = new Float64Array(numElements);
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.init(A);
                                        return this._decompose();
                                    }

                                    public init(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        this.UBV = A;
                                        this.m = this.UBV.numRows;
                                        this.n = this.UBV.numCols;
                                        this.min = Math.min(this.m, this.n);
                                        var max: number = Math.max(this.m, this.n);
                                        if (this.b.length < max + 1) {
                                            this.b = new Float64Array(max + 1);
                                            this.u = new Float64Array(max + 1);
                                        }
                                        if (this.gammasU.length < this.m) {
                                            this.gammasU = new Float64Array(this.m);
                                        }
                                        if (this.gammasV.length < this.n) {
                                            this.gammasV = new Float64Array(this.n);
                                        }
                                    }

                                    public getUBV(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.UBV;
                                    }

                                    public getDiagonal(diag: Float64Array, off: Float64Array): void {
                                        diag[0] = this.UBV.getValueAtIndex(0);
                                        for (var i: number = 1; i < this.n; i++) {
                                            diag[i] = this.UBV.get(i, i);
                                            off[i - 1] = this.UBV.get(i - 1, i);
                                        }
                                    }

                                    public getB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        B = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                                        B.set(0, 0, this.UBV.get(0, 0));
                                        for (var i: number = 1; i < this.min; i++) {
                                            B.set(i, i, this.UBV.get(i, i));
                                            B.set(i - 1, i, this.UBV.get(i - 1, i));
                                        }
                                        if (this.n > this.m) {
                                            B.set(this.min - 1, this.min, this.UBV.get(this.min - 1, this.min));
                                        }
                                        return B;
                                    }

                                    public static handleB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        var w: number = n > m ? min + 1 : min;
                                        if (compact) {
                                            if (B == null) {
                                                B = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(min, w);
                                            } else {
                                                B.reshapeBoolean(min, w, false);
                                                B.zero();
                                            }
                                        } else {
                                            if (B == null) {
                                                B = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, n);
                                            } else {
                                                B.reshapeBoolean(m, n, false);
                                                B.zero();
                                            }
                                        }
                                        return B;
                                    }

                                    public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        U = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, transpose, compact, this.m, this.n, this.min);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(U);
                                        for (var i: number = 0; i < this.m; i++) {
                                            this.u[i] = 0;
                                        }
                                        for (var j: number = this.min - 1; j >= 0; j--) {
                                            this.u[j] = 1;
                                            for (var i: number = j + 1; i < this.m; i++) {
                                                this.u[i] = this.UBV.get(i, j);
                                            }
                                            if (transpose) {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(U, this.u, this.gammasU[j], j, j, this.m);
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(U, this.u, this.gammasU[j], j, j, this.m, this.b);
                                            }
                                        }
                                        return U;
                                    }

                                    public static handleU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (compact) {
                                            if (transpose) {
                                                if (U == null) {
                                                    U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(min, m);
                                                } else {
                                                    U.reshapeBoolean(min, m, false);
                                                }
                                            } else {
                                                if (U == null) {
                                                    U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, min);
                                                } else {
                                                    U.reshapeBoolean(m, min, false);
                                                }
                                            }
                                        } else {
                                            if (U == null) {
                                                U = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(m, m);
                                            } else {
                                                U.reshapeBoolean(m, m, false);
                                            }
                                        }
                                        return U;
                                    }

                                    public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        V = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleV(V, transpose, compact, this.m, this.n, this.min);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(V);
                                        for (var j: number = this.min - 1; j >= 0; j--) {
                                            this.u[j + 1] = 1;
                                            for (var i: number = j + 2; i < this.n; i++) {
                                                this.u[i] = this.UBV.get(j, i);
                                            }
                                            if (transpose) {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(V, this.u, this.gammasV[j], j + 1, j + 1, this.n);
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(V, this.u, this.gammasV[j], j + 1, j + 1, this.n, this.b);
                                            }
                                        }
                                        return V;
                                    }

                                    public static handleV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean, m: number, n: number, min: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        var w: number = n > m ? min + 1 : min;
                                        if (compact) {
                                            if (transpose) {
                                                if (V == null) {
                                                    V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(w, n);
                                                } else {
                                                    V.reshapeBoolean(w, n, false);
                                                }
                                            } else {
                                                if (V == null) {
                                                    V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(n, w);
                                                } else {
                                                    V.reshapeBoolean(n, w, false);
                                                }
                                            }
                                        } else {
                                            if (V == null) {
                                                V = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(n, n);
                                            } else {
                                                V.reshapeBoolean(n, n, false);
                                            }
                                        }
                                        return V;
                                    }

                                    private _decompose(): boolean {
                                        for (var k: number = 0; k < this.min; k++) {
                                            this.computeU(k);
                                            this.computeV(k);
                                        }
                                        return true;
                                    }

                                    public computeU(k: number): void {
                                        var b: Float64Array = this.UBV.data;
                                        var max: number = 0;
                                        for (var i: number = k; i < this.m; i++) {
                                            var val: number = this.u[i] = b[i * this.n + k];
                                            val = Math.abs(val);
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                        if (max > 0) {
                                            var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4arg(k, this.m, this.u, max);
                                            var nu: number = this.u[k] + tau;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Bcol(k + 1, this.m, this.n, this.u, b, k, nu);
                                            this.u[k] = 1.0;
                                            var gamma: number = nu / tau;
                                            this.gammasU[k] = gamma;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.UBV, this.u, gamma, k + 1, k, this.m, this.b);
                                            b[k * this.n + k] = -tau * max;
                                        } else {
                                            this.gammasU[k] = 0;
                                        }
                                    }

                                    public computeV(k: number): void {
                                        var b: Float64Array = this.UBV.data;
                                        var row: number = k * this.n;
                                        var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMax(b, row + k + 1, this.n - k - 1);
                                        if (max > 0) {
                                            var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k + 1, this.n, b, row, max);
                                            var nu: number = b[row + k + 1] + tau;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements_Brow(k + 2, this.n, this.u, b, row, nu);
                                            this.u[k + 1] = 1.0;
                                            var gamma: number = nu / tau;
                                            this.gammasV[k] = gamma;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.UBV, this.u, gamma, k + 1, k + 1, this.n);
                                            b[row + k + 1] = -tau * max;
                                        } else {
                                            this.gammasV[k] = 0;
                                        }
                                    }

                                    public getGammasU(): Float64Array {
                                        return this.gammasU;
                                    }

                                    public getGammasV(): Float64Array {
                                        return this.gammasV;
                                    }

                                    public inputModified(): boolean {
                                        return true;
                                    }

                                }

                                export class BidiagonalDecompositionTall_D64 implements org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<any> {

                                    public decompQRP: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRxColPivDecompositionHouseholderColumn_D64();
                                    public decompBi: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecomposition<any> = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64(1);
                                    public B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                                    public m: number;
                                    public n: number;
                                    public min: number;
                                    public getDiagonal(diag: Float64Array, off: Float64Array): void {
                                        diag[0] = this.B.getValueAtIndex(0);
                                        for (var i: number = 1; i < this.n; i++) {
                                            diag[i] = this.B.get(i, i);
                                            off[i - 1] = this.B.get(i - 1, i);
                                        }
                                    }

                                    public getB(B: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        B = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleB(B, compact, this.m, this.n, this.min);
                                        B.set(0, 0, this.B.get(0, 0));
                                        for (var i: number = 1; i < this.min; i++) {
                                            B.set(i, i, this.B.get(i, i));
                                            B.set(i - 1, i, this.B.get(i - 1, i));
                                        }
                                        if (this.n > this.m) {
                                            B.set(this.min - 1, this.min, this.B.get(this.min - 1, this.min));
                                        }
                                        return B;
                                    }

                                    public getU(U: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        U = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.BidiagonalDecompositionRow_D64.handleU(U, false, compact, this.m, this.n, this.min);
                                        if (compact) {
                                            var Q1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(null, true);
                                            var U1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                                            org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q1, U1, U);
                                        } else {
                                            var Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getQ(U, false);
                                            var U1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompBi.getU(null, false, true);
                                            var Q1: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = org.kevoree.modeling.util.maths.matrix.CommonOps.extract4Int(Q, 0, Q.numRows, 0, this.min);
                                            var tmp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(Q1.numRows, U1.numCols);
                                            org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q1, U1, tmp);
                                            org.kevoree.modeling.util.maths.matrix.CommonOps.insert(tmp, Q, 0, 0);
                                        }
                                        if (transpose) {
                                            org.kevoree.modeling.util.maths.matrix.CommonOps.transpose(U);
                                        }
                                        return U;
                                    }

                                    public getV(V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transpose: boolean, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.decompBi.getV(V, transpose, compact);
                                    }

                                    public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        if (!this.decompQRP.decompose(orig)) {
                                            return false;
                                        }
                                        this.m = orig.numRows;
                                        this.n = orig.numCols;
                                        this.min = Math.min(this.m, this.n);
                                        this.B.reshapeBoolean(this.min, this.n, false);
                                        this.decompQRP.getR(this.B, true);
                                        var result: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.min, this.n);
                                        var P: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.decompQRP.getPivotMatrix(null);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.multTransB(this.B, P, result);
                                        this.B.setMatrix(result);
                                        return this.decompBi.decompose(this.B);
                                    }

                                    public inputModified(): boolean {
                                        return this.decompQRP.inputModified();
                                    }

                                }

                                export class EigenvalueSmall {

                                    public value0: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                    public value1: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                    public value2x2(a11: number, a12: number, a21: number, a22: number): void {
                                        var c: number;
                                        var s: number;
                                        if (a12 + a21 == 0) {
                                            c = s = 1.0 / Math.sqrt(2);
                                        } else {
                                            var aa: number = (a11 - a22);
                                            var bb: number = (a12 + a21);
                                            var t_hat: number = aa / bb;
                                            var t: number = t_hat / (1.0 + Math.sqrt(1.0 + t_hat * t_hat));
                                            c = 1.0 / Math.sqrt(1.0 + t * t);
                                            s = c * t;
                                        }
                                        var c2: number = c * c;
                                        var s2: number = s * s;
                                        var cs: number = c * s;
                                        var b11: number = c2 * a11 + s2 * a22 - cs * (a12 + a21);
                                        var b12: number = c2 * a12 - s2 * a21 + cs * (a11 - a22);
                                        var b21: number = c2 * a21 - s2 * a12 + cs * (a11 - a22);
                                        if (b21 * b12 >= 0) {
                                            if (b12 == 0) {
                                                c = 0;
                                                s = 1;
                                            } else {
                                                s = Math.sqrt(b21 / (b12 + b21));
                                                c = Math.sqrt(b12 / (b12 + b21));
                                            }
                                            cs = c * s;
                                            a11 = b11 - cs * (b12 + b21);
                                            a22 = b11 + cs * (b12 + b21);
                                            this.value0.real = a11;
                                            this.value1.real = a22;
                                            this.value0.imaginary = this.value1.imaginary = 0;
                                        } else {
                                            this.value0.real = this.value1.real = b11;
                                            this.value0.imaginary = Math.sqrt(-b21 * b12);
                                            this.value1.imaginary = -this.value0.imaginary;
                                        }
                                    }

                                    public value2x2_fast(a11: number, a12: number, a21: number, a22: number): void {
                                        var left: number = (a11 + a22) / 2.0;
                                        var inside: number = 4.0 * a12 * a21 + (a11 - a22) * (a11 - a22);
                                        if (inside < 0) {
                                            this.value0.real = this.value1.real = left;
                                            this.value0.imaginary = Math.sqrt(-inside) / 2.0;
                                            this.value1.imaginary = -this.value0.imaginary;
                                        } else {
                                            var right: number = Math.sqrt(inside) / 2.0;
                                            this.value0.real = (left + right);
                                            this.value1.real = (left - right);
                                            this.value0.imaginary = this.value1.imaginary = 0.0;
                                        }
                                    }

                                    public symm2x2_fast(a11: number, a12: number, a22: number): void {
                                        var left: number = (a11 + a22) * 0.5;
                                        var b: number = (a11 - a22) * 0.5;
                                        var right: number = Math.sqrt(b * b + a12 * a12);
                                        this.value0.real = left + right;
                                        this.value1.real = left - right;
                                    }

                                }

                                export class HessenbergSimilarDecomposition_D64 {

                                    private QH: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private N: number;
                                    private gammas: Float64Array;
                                    private b: Float64Array;
                                    private u: Float64Array;
                                    constructor(initialSize: number) {
                                        this.gammas = new Float64Array(initialSize);
                                        this.b = new Float64Array(initialSize);
                                        this.u = new Float64Array(initialSize);
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        if (A.numRows != A.numCols) {
                                            throw new Error("A must be square.");
                                        }
                                        if (A.numRows <= 0) {
                                            return false;
                                        }
                                        this.QH = A;
                                        this.N = A.numCols;
                                        if (this.b.length < this.N) {
                                            this.b = new Float64Array(this.N);
                                            this.gammas = new Float64Array(this.N);
                                            this.u = new Float64Array(this.N);
                                        }
                                        return this._decompose();
                                    }

                                    public inputModified(): boolean {
                                        return true;
                                    }

                                    public getQH(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.QH;
                                    }

                                    public getH(H: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (H == null) {
                                            H = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                        } else {
                                            H.zero();
                                        }
                                        java.lang.System.arraycopy(this.QH.data, 0, H.data, 0, this.N);
                                        for (var i: number = 1; i < this.N; i++) {
                                            for (var j: number = i - 1; j < this.N; j++) {
                                                H.set(i, j, this.QH.get(i, j));
                                            }
                                        }
                                        return H;
                                    }

                                    public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (Q == null) {
                                            Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                            for (var i: number = 0; i < this.N; i++) {
                                                Q.data[i * this.N + i] = 1;
                                            }
                                        } else {
                                            if (this.N != Q.numRows || this.N != Q.numCols) {
                                                throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                                            }
                                        }
                                        for (var j: number = this.N - 2; j >= 0; j--) {
                                            this.u[j + 1] = 1;
                                            for (var i: number = j + 2; i < this.N; i++) {
                                                this.u[i] = this.QH.get(i, j);
                                            }
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.u, this.gammas[j], j + 1, j + 1, this.N, this.b);
                                        }
                                        return Q;
                                    }

                                    private _decompose(): boolean {
                                        var h: Float64Array = this.QH.data;
                                        for (var k: number = 0; k < this.N - 2; k++) {
                                            var max: number = 0;
                                            for (var i: number = k + 1; i < this.N; i++) {
                                                var val: number = this.u[i] = h[i * this.N + k];
                                                val = Math.abs(val);
                                                if (val > max) {
                                                    max = val;
                                                }
                                            }
                                            if (max > 0) {
                                                var tau: number = 0;
                                                for (var i: number = k + 1; i < this.N; i++) {
                                                    var val: number = this.u[i] /= max;
                                                    tau += val * val;
                                                }
                                                tau = Math.sqrt(tau);
                                                if (this.u[k + 1] < 0) {
                                                    tau = -tau;
                                                }
                                                var nu: number = this.u[k + 1] + tau;
                                                this.u[k + 1] = 1.0;
                                                for (var i: number = k + 2; i < this.N; i++) {
                                                    h[i * this.N + k] = this.u[i] /= nu;
                                                }
                                                var gamma: number = nu / tau;
                                                this.gammas[k] = gamma;
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.QH, this.u, gamma, k + 1, k + 1, this.N, this.b);
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.QH, this.u, gamma, 0, k + 1, this.N);
                                                h[(k + 1) * this.N + k] = -tau * max;
                                            } else {
                                                this.gammas[k] = 0;
                                            }
                                        }
                                        return true;
                                    }

                                    public getGammas(): Float64Array {
                                        return this.gammas;
                                    }

                                }

                                export class QRDecompositionHouseholderColumn_D64 {

                                    public dataQR: org.kevoree.modeling.util.maths.structure.KArray2D;
                                    public v: Float64Array;
                                    public numCols: number;
                                    public numRows: number;
                                    public minLength: number;
                                    public gammas: Float64Array;
                                    public gamma: number;
                                    public tau: number;
                                    public error: boolean;
                                    public setExpectedMaxSize(numRows: number, numCols: number): void {
                                        this.numCols = numCols;
                                        this.numRows = numRows;
                                        this.minLength = Math.min(numCols, numRows);
                                        var maxLength: number = Math.max(numCols, numRows);
                                        if (this.dataQR == null || this.dataQR.nbRows() < numRows || this.dataQR.nbColumns() < numCols) {
                                            this.dataQR = new org.kevoree.modeling.util.maths.structure.impl.NativeArray2D(numRows, numCols);
                                            this.v = new Float64Array(maxLength);
                                            this.gammas = new Float64Array(this.minLength);
                                        }
                                        if (this.v.length < maxLength) {
                                            this.v = new Float64Array(maxLength);
                                        }
                                        if (this.gammas.length < this.minLength) {
                                            this.gammas = new Float64Array(this.minLength);
                                        }
                                    }

                                    public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (compact) {
                                            if (Q == null) {
                                                Q = org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.identity(this.numRows, this.minLength);
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                                            }
                                        } else {
                                            if (Q == null) {
                                                Q = org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.widentity(this.numRows);
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.DenseMatrix64F.setIdentity(Q);
                                            }
                                        }
                                        for (var j: number = this.minLength - 1; j >= 0; j--) {
                                            var vv: number = this.dataQR.get(j, j);
                                            this.dataQR.set(j, j, 1);
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.rank1UpdateMultR(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                                            this.dataQR.set(j, j, vv);
                                        }
                                        return Q;
                                    }

                                    public getR(R: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (R == null) {
                                            if (compact) {
                                                R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.minLength, this.numCols);
                                            } else {
                                                R = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.numRows, this.numCols);
                                            }
                                        } else {
                                            for (var i: number = 0; i < R.numRows; i++) {
                                                var min: number = Math.min(i, R.numCols);
                                                for (var j: number = 0; j < min; j++) {
                                                    R.cset(i, j, 0);
                                                }
                                            }
                                        }
                                        for (var j: number = 0; j < this.numCols; j++) {
                                            var l: number = Math.min(j, this.numRows - 1);
                                            for (var i: number = 0; i <= l; i++) {
                                                var val: number = this.dataQR.get(i, j);
                                                R.cset(i, j, val);
                                            }
                                        }
                                        return R;
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.setExpectedMaxSize(A.numRows, A.numCols);
                                        this.convertToColumnMajor(A);
                                        this.error = false;
                                        for (var j: number = 0; j < this.minLength; j++) {
                                            this.householder(j);
                                            this.updateA(j);
                                        }
                                        return !this.error;
                                    }

                                    public convertToColumnMajor(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        for (var x: number = 0; x < this.numCols; x++) {
                                            for (var y: number = 0; y < this.numRows; y++) {
                                                this.dataQR.set(y, x, A.data[y * this.numCols + x]);
                                            }
                                        }
                                    }

                                    public householder(j: number): void {
                                        var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.findMax(this.dataQR, j, j, this.numRows - j);
                                        if (max == 0.0) {
                                            this.gamma = 0;
                                            this.error = true;
                                        } else {
                                            this.tau = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.computeTauAndDivide(j, this.numRows, this.dataQR, j, max);
                                            var u_0: number = this.dataQR.get(j, j) + this.tau;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64.divideElements(j + 1, this.numRows, this.dataQR, j, u_0);
                                            this.gamma = u_0 / this.tau;
                                            this.tau *= max;
                                            this.dataQR.set(j, j, -this.tau);
                                        }
                                        this.gammas[j] = this.gamma;
                                    }

                                    public updateA(w: number): void {
                                        for (var j: number = w + 1; j < this.numCols; j++) {
                                            var val: number = this.dataQR.get(w, j);
                                            for (var k: number = w + 1; k < this.numRows; k++) {
                                                val += this.dataQR.get(k, w) * this.dataQR.get(k, j);
                                            }
                                            val *= this.gamma;
                                            this.dataQR.add(w, j, -val);
                                            for (var i: number = w + 1; i < this.numRows; i++) {
                                                this.dataQR.add(i, j, -this.dataQR.get(i, w) * val);
                                            }
                                        }
                                    }

                                    public static findMax(u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                                        var max: number = -1;
                                        var index: number = startU;
                                        var stopIndex: number = startU + length;
                                        for (; index < stopIndex; index++) {
                                            var val: number = u.get(index, col);
                                            val = (val < 0.0) ? -val : val;
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                        return max;
                                    }

                                    public static divideElements(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, u_0: number): void {
                                        for (var i: number = j; i < numRows; i++) {
                                            u.set(i, col, u.get(i, col) / u_0);
                                        }
                                    }

                                    public static computeTauAndDivide(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, max: number): number {
                                        var tau: number = 0;
                                        for (var i: number = j; i < numRows; i++) {
                                            u.set(i, col, u.get(i, col) / max);
                                            var d: number = u.get(i, col);
                                            tau += d * d;
                                        }
                                        tau = Math.sqrt(tau);
                                        if (u.get(j, col) < 0) {
                                            tau = -tau;
                                        }
                                        return tau;
                                    }

                                    public inputModified(): boolean {
                                        return false;
                                    }

                                    public static rank1UpdateMultR(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                                        }
                                        for (var k: number = w0 + 1; k < w1; k++) {
                                            var indexA: number = k * A.numCols + colA0;
                                            var valU: number = u.get(k, col);
                                            for (var i: number = colA0; i < A.numCols; i++) {
                                                _temp[i] += valU * A.data[indexA++];
                                            }
                                        }
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] *= gamma;
                                        }
                                        for (var i: number = w0; i < w1; i++) {
                                            var valU: number = u.get(i, col);
                                            var indexA: number = i * A.numCols + colA0;
                                            for (var j: number = colA0; j < A.numCols; j++) {
                                                A.data[indexA++] -= valU * _temp[j];
                                            }
                                        }
                                    }

                                }

                                export class QRxColPivDecompositionHouseholderColumn_D64 extends org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QRDecompositionHouseholderColumn_D64 {

                                    public pivots: Int32Array;
                                    public normsCol: Float64Array;
                                    public maxAbs: number;
                                    public singularThreshold: number = org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                    public rank: number;
                                    constructor() {
                                        super();
                                    }

                                    public setSingularThreshold(threshold: number): void {
                                        this.singularThreshold = threshold;
                                    }

                                    public setExpectedMaxSize(numRows: number, numCols: number): void {
                                        super.setExpectedMaxSize(numRows, numCols);
                                        if (this.pivots == null || this.pivots.length < numCols) {
                                            this.pivots = new Int32Array(numCols);
                                            this.normsCol = new Float64Array(numCols);
                                        }
                                    }

                                    public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, compact: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (compact) {
                                            if (Q == null) {
                                                Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity(this.numRows, this.minLength);
                                            } else {
                                                if (Q.numRows != this.numRows || Q.numCols != this.minLength) {
                                                    throw new Error("Unexpected matrix dimension.");
                                                } else {
                                                    org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                                                }
                                            }
                                        } else {
                                            if (Q == null) {
                                                Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.numRows);
                                            } else {
                                                if (Q.numRows != this.numRows || Q.numCols != this.numRows) {
                                                    throw new Error("Unexpected matrix dimension.");
                                                } else {
                                                    org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                                                }
                                            }
                                        }
                                        for (var j: number = this.rank - 1; j >= 0; j--) {
                                            var vv: number = this.dataQR.get(j, j);
                                            this.dataQR.set(j, j, 1);
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultRArray(Q, this.dataQR, j, this.gammas[j], j, j, this.numRows, this.v);
                                            this.dataQR.set(j, j, vv);
                                        }
                                        return Q;
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.setExpectedMaxSize(A.numRows, A.numCols);
                                        this.convertToColumnMajor(A);
                                        this.maxAbs = org.kevoree.modeling.util.maths.matrix.CommonOps.elementMaxAbs(A);
                                        this.setupPivotInfo();
                                        for (var j: number = 0; j < this.minLength; j++) {
                                            if (j > 0) {
                                                this.updateNorms(j);
                                            }
                                            this.swapColumns(j);
                                            if (!this.householderPivot(j)) {
                                                break;
                                            }
                                            this.updateA(j);
                                            this.rank = j + 1;
                                        }
                                        return true;
                                    }

                                    private setupPivotInfo(): void {
                                        for (var col: number = 0; col < this.numCols; col++) {
                                            this.pivots[col] = col;
                                            var norm: number = 0;
                                            for (var row: number = 0; row < this.numRows; row++) {
                                                var element: number = this.dataQR.get(row, col);
                                                norm += element * element;
                                            }
                                            this.normsCol[col] = norm;
                                        }
                                    }

                                    private updateNorms(j: number): void {
                                        var foundNegative: boolean = false;
                                        for (var col: number = j; col < this.numCols; col++) {
                                            var e: number = this.dataQR.get(j - 1, col);
                                            this.normsCol[col] -= e * e;
                                            if (this.normsCol[col] < 0) {
                                                foundNegative = true;
                                                break;
                                            }
                                        }
                                        if (foundNegative) {
                                            for (var col: number = j; col < this.numCols; col++) {
                                                var actual: number = 0;
                                                for (var i: number = j; i < this.numRows; i++) {
                                                    var v: number = this.dataQR.get(i, col);
                                                    actual += v * v;
                                                }
                                                this.normsCol[col] = actual;
                                            }
                                        }
                                    }

                                    private swapColumns(j: number): void {
                                        var largestIndex: number = j;
                                        var largestNorm: number = this.normsCol[j];
                                        for (var col: number = j + 1; col < this.numCols; col++) {
                                            var n: number = this.normsCol[col];
                                            if (n > largestNorm) {
                                                largestNorm = n;
                                                largestIndex = col;
                                            }
                                        }
                                        var val: number = 0;
                                        for (var k: number = 0; k < this.dataQR.nbRows(); k++) {
                                            val = this.dataQR.get(k, j);
                                            this.dataQR.set(k, j, this.dataQR.get(k, largestIndex));
                                            this.dataQR.set(k, largestIndex, val);
                                        }
                                        var tempN: number = this.normsCol[j];
                                        this.normsCol[j] = this.normsCol[largestIndex];
                                        this.normsCol[largestIndex] = tempN;
                                        var tempP: number = this.pivots[j];
                                        this.pivots[j] = this.pivots[largestIndex];
                                        this.pivots[largestIndex] = tempP;
                                    }

                                    public householderPivot(j: number): boolean {
                                        var max: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.findMaxArray(this.dataQR, j, j, this.numRows - j);
                                        if (max <= 0) {
                                            return false;
                                        } else {
                                            this.tau = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide4argArray(j, this.numRows, this.dataQR, j, max);
                                            var u_0: number = this.dataQR.get(j, j) + this.tau;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements4argArray(j + 1, this.numRows, this.dataQR, j, u_0);
                                            this.gamma = u_0 / this.tau;
                                            this.tau *= max;
                                            this.dataQR.set(j, j, -this.tau);
                                            if (Math.abs(this.tau) <= this.singularThreshold) {
                                                return false;
                                            }
                                        }
                                        this.gammas[j] = this.gamma;
                                        return true;
                                    }

                                    public getRank(): number {
                                        return this.rank;
                                    }

                                    public getPivots(): Int32Array {
                                        return this.pivots;
                                    }

                                    public getPivotMatrix(P: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (P == null) {
                                            P = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.numCols, this.numCols);
                                        } else {
                                            if (P.numRows != this.numCols) {
                                                throw new Error("Number of rows must be " + this.numCols);
                                            } else {
                                                if (P.numCols != this.numCols) {
                                                    throw new Error("Number of columns must be " + this.numCols);
                                                } else {
                                                    P.zero();
                                                }
                                            }
                                        }
                                        for (var i: number = 0; i < this.numCols; i++) {
                                            P.set(this.pivots[i], i, 1);
                                        }
                                        return P;
                                    }

                                }

                                export class QrHelperFunctions_D64 {

                                    public static findMax(u: Float64Array, startU: number, length: number): number {
                                        var max: number = -1;
                                        var index: number = startU;
                                        var stopIndex: number = startU + length;
                                        for (; index < stopIndex; index++) {
                                            var val: number = u[index];
                                            val = (val < 0.0) ? -val : val;
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                        return max;
                                    }

                                    public static findMaxArray(u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, startU: number, length: number): number {
                                        var max: number = -1;
                                        var index: number = startU;
                                        var stopIndex: number = startU + length;
                                        for (; index < stopIndex; index++) {
                                            var val: number = u.get(index, col);
                                            val = (val < 0.0) ? -val : val;
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                        return max;
                                    }

                                    public static divideElements4arg(j: number, numRows: number, u: Float64Array, u_0: number): void {
                                        for (var i: number = j; i < numRows; i++) {
                                            u[i] /= u_0;
                                        }
                                    }

                                    public static divideElements4argArray(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, u_0: number): void {
                                        for (var i: number = j; i < numRows; i++) {
                                            u.set(i, col, u.get(i, col) / u_0);
                                        }
                                    }

                                    public static divideElements(j: number, numRows: number, u: Float64Array, startU: number, u_0: number): void {
                                        for (var i: number = j; i < numRows; i++) {
                                            u[i + startU] /= u_0;
                                        }
                                    }

                                    public static divideElements_Brow(j: number, numRows: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                                        for (var i: number = j; i < numRows; i++) {
                                            u[i] = b[i + startB] /= u_0;
                                        }
                                    }

                                    public static divideElements_Bcol(j: number, numRows: number, numCols: number, u: Float64Array, b: Float64Array, startB: number, u_0: number): void {
                                        var indexB: number = j * numCols + startB;
                                        for (var i: number = j; i < numRows; ) {
                                            b[indexB] = u[i] /= u_0;
                                        }
                                    }

                                    public static computeTauAndDivide(j: number, numRows: number, u: Float64Array, startU: number, max: number): number {
                                        var tau: number = 0;
                                        for (var i: number = j; i < numRows; i++) {
                                            var d: number = u[startU + i] /= max;
                                            tau += d * d;
                                        }
                                        tau = Math.sqrt(tau);
                                        if (u[startU + j] < 0) {
                                            tau = -tau;
                                        }
                                        return tau;
                                    }

                                    public static computeTauAndDivide4arg(j: number, numRows: number, u: Float64Array, max: number): number {
                                        var tau: number = 0;
                                        for (var i: number = j; i < numRows; i++) {
                                            var d: number = u[i] /= max;
                                            tau += d * d;
                                        }
                                        tau = Math.sqrt(tau);
                                        if (u[j] < 0) {
                                            tau = -tau;
                                        }
                                        return tau;
                                    }

                                    public static computeTauAndDivide4argArray(j: number, numRows: number, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, max: number): number {
                                        var tau: number = 0;
                                        for (var i: number = j; i < numRows; i++) {
                                            u.set(i, col, u.get(i, col) / max);
                                            var d: number = u.get(i, col);
                                            tau += d * d;
                                        }
                                        tau = Math.sqrt(tau);
                                        if (u.get(j, col) < 0) {
                                            tau = -tau;
                                        }
                                        return tau;
                                    }

                                    public static rank1UpdateMultR(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] = u[w0] * A.data[w0 * A.numCols + i];
                                        }
                                        for (var k: number = w0 + 1; k < w1; k++) {
                                            var indexA: number = k * A.numCols + colA0;
                                            var valU: number = u[k];
                                            for (var i: number = colA0; i < A.numCols; i++) {
                                                _temp[i] += valU * A.data[indexA++];
                                            }
                                        }
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] *= gamma;
                                        }
                                        for (var i: number = w0; i < w1; i++) {
                                            var valU: number = u[i];
                                            var indexA: number = i * A.numCols + colA0;
                                            for (var j: number = colA0; j < A.numCols; j++) {
                                                A.data[indexA++] -= valU * _temp[j];
                                            }
                                        }
                                    }

                                    public static rank1UpdateMultRArray(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: org.kevoree.modeling.util.maths.structure.KArray2D, col: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] = u.get(w0, col) * A.data[w0 * A.numCols + i];
                                        }
                                        for (var k: number = w0 + 1; k < w1; k++) {
                                            var indexA: number = k * A.numCols + colA0;
                                            var valU: number = u.get(k, col);
                                            for (var i: number = colA0; i < A.numCols; i++) {
                                                _temp[i] += valU * A.data[indexA++];
                                            }
                                        }
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] *= gamma;
                                        }
                                        for (var i: number = w0; i < w1; i++) {
                                            var valU: number = u.get(i, col);
                                            var indexA: number = i * A.numCols + colA0;
                                            for (var j: number = colA0; j < A.numCols; j++) {
                                                A.data[indexA++] -= valU * _temp[j];
                                            }
                                        }
                                    }

                                    public static rank1UpdateMultR8param(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, offsetU: number, gamma: number, colA0: number, w0: number, w1: number, _temp: Float64Array): void {
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] = u[w0 + offsetU] * A.data[w0 * A.numCols + i];
                                        }
                                        for (var k: number = w0 + 1; k < w1; k++) {
                                            var indexA: number = k * A.numCols + colA0;
                                            var valU: number = u[k + offsetU];
                                            for (var i: number = colA0; i < A.numCols; i++) {
                                                _temp[i] += valU * A.data[indexA++];
                                            }
                                        }
                                        for (var i: number = colA0; i < A.numCols; i++) {
                                            _temp[i] *= gamma;
                                        }
                                        for (var i: number = w0; i < w1; i++) {
                                            var valU: number = u[i + offsetU];
                                            var indexA: number = i * A.numCols + colA0;
                                            for (var j: number = colA0; j < A.numCols; j++) {
                                                A.data[indexA++] -= valU * _temp[j];
                                            }
                                        }
                                    }

                                    public static rank1UpdateMultL(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, u: Float64Array, gamma: number, colA0: number, w0: number, w1: number): void {
                                        for (var i: number = colA0; i < A.numRows; i++) {
                                            var startIndex: number = i * A.numCols + w0;
                                            var sum: number = 0;
                                            var rowIndex: number = startIndex;
                                            for (var j: number = w0; j < w1; j++) {
                                                sum += A.data[rowIndex++] * u[j];
                                            }
                                            sum = -gamma * sum;
                                            rowIndex = startIndex;
                                            for (var j: number = w0; j < w1; j++) {
                                                A.data[rowIndex++] += sum * u[j];
                                            }
                                        }
                                    }

                                }

                                export class SwitchingEigenDecomposition {

                                    private tol: number;
                                    public symmetricAlg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64;
                                    public generalAlg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64;
                                    public symmetric: boolean;
                                    public computeVectors: boolean;
                                    public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(1, 1);
                                    constructor(matrixSize: number, computeVectors: boolean, tol: number) {
                                        var decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64 = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64();
                                        this.symmetricAlg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQRAlgorithmDecomposition_D64(decomp, computeVectors);
                                        this.generalAlg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQRDecomposition_D64(computeVectors);
                                        this.computeVectors = computeVectors;
                                        this.tol = tol;
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.symmetric ? this.symmetricAlg.getNumberOfEigenvalues() : this.generalAlg.getNumberOfEigenvalues();
                                    }

                                    public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                        return this.symmetric ? this.symmetricAlg.getEigenvalue(index) : this.generalAlg.getEigenvalue(index);
                                    }

                                    public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (!this.computeVectors) {
                                            throw new Error("Configured to not compute eignevectors");
                                        }
                                        return this.symmetric ? this.symmetricAlg.getEigenVector(index) : this.generalAlg.getEigenVector(index);
                                    }

                                    public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.A.setMatrix(orig);
                                        this.symmetric = org.kevoree.modeling.util.maths.matrix.MatrixFeatures.isSymmetricDouble(this.A, this.tol);
                                        return this.symmetric ? this.symmetricAlg.decompose(this.A) : this.generalAlg.decompose(this.A);
                                    }

                                    public inputModified(): boolean {
                                        return false;
                                    }

                                }

                                export class SymmetricQRAlgorithmDecomposition_D64 {

                                    private decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64;
                                    private helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                                    private vector: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm;
                                    private computeVectorsWithValues: boolean = false;
                                    private values: Float64Array;
                                    private diag: Float64Array;
                                    private off: Float64Array;
                                    private diagSaved: Float64Array;
                                    private offSaved: Float64Array;
                                    private V: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private eigenvectors: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                                    public computeVectors: boolean;
                                    constructor(decomp: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.TridiagonalDecompositionHouseholder_D64, computeVectors: boolean) {
                                        this.decomp = decomp;
                                        this.computeVectors = computeVectors;
                                        this.helper = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper();
                                        this.vector = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQrAlgorithm(this.helper);
                                    }

                                    public setComputeVectorsWithValues(computeVectorsWithValues: boolean): void {
                                        if (!this.computeVectors) {
                                            throw new Error("Compute eigenvalues has been set to false");
                                        }
                                        this.computeVectorsWithValues = computeVectorsWithValues;
                                    }

                                    public setMaxIterations(max: number): void {
                                        this.vector.setMaxIterations(max);
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.helper.getMatrixSize();
                                    }

                                    public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                        var c: org.kevoree.modeling.util.maths.matrix.Complex64F = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                        c.setValues(this.values[index], 0);
                                        return c;
                                    }

                                    public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.eigenvectors[index];
                                    }

                                    public decompose(orig: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        if (orig.numCols != orig.numRows) {
                                            throw new Error("Matrix must be square.");
                                        }
                                        if (orig.numCols <= 0) {
                                            return false;
                                        }
                                        var N: number = orig.numRows;
                                        if (!this.decomp.decompose(orig)) {
                                            return false;
                                        }
                                        if (this.diag == null || this.diag.length < N) {
                                            this.diag = new Float64Array(N);
                                            this.off = new Float64Array(N - 1);
                                        }
                                        this.decomp.getDiagonal(this.diag, this.off);
                                        this.helper.init(this.diag, this.off, N);
                                        if (this.computeVectors) {
                                            if (this.computeVectorsWithValues) {
                                                return this.extractTogether();
                                            } else {
                                                return this.extractSeparate(N);
                                            }
                                        } else {
                                            return this.computeEigenValues();
                                        }
                                    }

                                    public inputModified(): boolean {
                                        return this.decomp.inputModified();
                                    }

                                    private extractTogether(): boolean {
                                        this.V = this.decomp.getQ(this.V, true);
                                        this.helper.setQ(this.V);
                                        this.vector.setFastEigenvalues(false);
                                        if (!this.vector.process3arg(-1, null, null)) {
                                            return false;
                                        }
                                        this.eigenvectors = org.kevoree.modeling.util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                                        this.values = this.helper.copyEigenvalues(this.values);
                                        return true;
                                    }

                                    private extractSeparate(numCols: number): boolean {
                                        if (!this.computeEigenValues()) {
                                            return false;
                                        }
                                        this.helper.reset(numCols);
                                        this.diagSaved = this.helper.swapDiag(this.diagSaved);
                                        this.offSaved = this.helper.swapOff(this.offSaved);
                                        this.V = this.decomp.getQ(this.V, true);
                                        this.vector.setQ(this.V);
                                        if (!this.vector.process(-1, null, null, this.values)) {
                                            return false;
                                        }
                                        this.values = this.helper.copyEigenvalues(this.values);
                                        this.eigenvectors = org.kevoree.modeling.util.maths.matrix.CommonOps.rowsToVector(this.V, this.eigenvectors);
                                        return true;
                                    }

                                    private computeEigenValues(): boolean {
                                        this.diagSaved = this.helper.copyDiag(this.diagSaved);
                                        this.offSaved = this.helper.copyOff(this.offSaved);
                                        this.vector.setQ(null);
                                        this.vector.setFastEigenvalues(true);
                                        if (!this.vector.process3arg(-1, null, null)) {
                                            return false;
                                        }
                                        this.values = this.helper.copyEigenvalues(this.values);
                                        return true;
                                    }

                                }

                                export class SymmetricQREigenHelper {

                                    public rand: java.util.Random = new java.util.Random();
                                    public steps: number;
                                    public numExceptional: number;
                                    public lastExceptional: number;
                                    public eigenSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                                    public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public N: number;
                                    public diag: Float64Array;
                                    public off: Float64Array;
                                    public x1: number;
                                    public x2: number;
                                    public splits: Int32Array;
                                    public numSplits: number;
                                    private bulge: number;
                                    private c: number;
                                    private s: number;
                                    private c2: number;
                                    private s2: number;
                                    private cs: number;
                                    constructor() {
                                        this.splits = new Int32Array(1);
                                    }

                                    public setQ(q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        this.Q = q;
                                    }

                                    public incrementSteps(): void {
                                        this.steps++;
                                    }

                                    public init(diag: Float64Array, off: Float64Array, numCols: number): void {
                                        this.reset(numCols);
                                        this.diag = diag;
                                        this.off = off;
                                    }

                                    public swapDiag(diag: Float64Array): Float64Array {
                                        var ret: Float64Array = this.diag;
                                        this.diag = diag;
                                        return ret;
                                    }

                                    public swapOff(off: Float64Array): Float64Array {
                                        var ret: Float64Array = this.off;
                                        this.off = off;
                                        return ret;
                                    }

                                    public reset(N: number): void {
                                        this.N = N;
                                        this.diag = null;
                                        this.off = null;
                                        if (this.splits.length < N) {
                                            this.splits = new Int32Array(N);
                                        }
                                        this.numSplits = 0;
                                        this.x1 = 0;
                                        this.x2 = N - 1;
                                        this.steps = this.numExceptional = this.lastExceptional = 0;
                                        this.Q = null;
                                    }

                                    public copyDiag(ret: Float64Array): Float64Array {
                                        if (ret == null || ret.length < this.N) {
                                            ret = new Float64Array(this.N);
                                        }
                                        java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                                        return ret;
                                    }

                                    public copyOff(ret: Float64Array): Float64Array {
                                        if (ret == null || ret.length < this.N - 1) {
                                            ret = new Float64Array(this.N - 1);
                                        }
                                        java.lang.System.arraycopy(this.off, 0, ret, 0, this.N - 1);
                                        return ret;
                                    }

                                    public copyEigenvalues(ret: Float64Array): Float64Array {
                                        if (ret == null || ret.length < this.N) {
                                            ret = new Float64Array(this.N);
                                        }
                                        java.lang.System.arraycopy(this.diag, 0, ret, 0, this.N);
                                        return ret;
                                    }

                                    public setSubmatrix(x1: number, x2: number): void {
                                        this.x1 = x1;
                                        this.x2 = x2;
                                    }

                                    public isZero(index: number): boolean {
                                        var bottom: number = Math.abs(this.diag[index]) + Math.abs(this.diag[index + 1]);
                                        return (Math.abs(this.off[index]) <= bottom * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS);
                                    }

                                    public performImplicitSingleStep(lambda: number, byAngle: boolean): void {
                                        if (this.x2 - this.x1 == 1) {
                                            this.createBulge2by2(this.x1, lambda, byAngle);
                                        } else {
                                            this.createBulge(this.x1, lambda, byAngle);
                                            for (var i: number = this.x1; i < this.x2 - 2 && this.bulge != 0.0; i++) {
                                                this.removeBulge(i);
                                            }
                                            if (this.bulge != 0.0) {
                                                this.removeBulgeEnd(this.x2 - 2);
                                            }
                                        }
                                    }

                                    public updateQ(m: number, n: number, c: number, s: number): void {
                                        var rowA: number = m * this.N;
                                        var rowB: number = n * this.N;
                                        var endA: number = rowA + this.N;
                                        while (rowA < endA){
                                            var a: number = this.Q.data[rowA];
                                            var b: number = this.Q.data[rowB];
                                            this.Q.data[rowA++] = c * a + s * b;
                                            this.Q.data[rowB++] = -s * a + c * b;
                                        }
                                    }

                                    public createBulge(x1: number, p: number, byAngle: boolean): void {
                                        var a11: number = this.diag[x1];
                                        var a22: number = this.diag[x1 + 1];
                                        var a12: number = this.off[x1];
                                        var a23: number = this.off[x1 + 1];
                                        if (byAngle) {
                                            this.c = Math.cos(p);
                                            this.s = Math.sin(p);
                                            this.c2 = this.c * this.c;
                                            this.s2 = this.s * this.s;
                                            this.cs = this.c * this.s;
                                        } else {
                                            this.computeRotation(a11 - p, a12);
                                        }
                                        this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                                        this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                                        this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                                        this.off[x1 + 1] = this.c * a23;
                                        this.bulge = this.s * a23;
                                        if (this.Q != null) {
                                            this.updateQ(x1, x1 + 1, this.c, this.s);
                                        }
                                    }

                                    public createBulge2by2(x1: number, p: number, byAngle: boolean): void {
                                        var a11: number = this.diag[x1];
                                        var a22: number = this.diag[x1 + 1];
                                        var a12: number = this.off[x1];
                                        if (byAngle) {
                                            this.c = Math.cos(p);
                                            this.s = Math.sin(p);
                                            this.c2 = this.c * this.c;
                                            this.s2 = this.s * this.s;
                                            this.cs = this.c * this.s;
                                        } else {
                                            this.computeRotation(a11 - p, a12);
                                        }
                                        this.diag[x1] = this.c2 * a11 + 2.0 * this.cs * a12 + this.s2 * a22;
                                        this.diag[x1 + 1] = this.c2 * a22 - 2.0 * this.cs * a12 + this.s2 * a11;
                                        this.off[x1] = a12 * (this.c2 - this.s2) + this.cs * (a22 - a11);
                                        if (this.Q != null) {
                                            this.updateQ(x1, x1 + 1, this.c, this.s);
                                        }
                                    }

                                    private computeRotation(run: number, rise: number): void {
                                        if (Math.abs(rise) > Math.abs(run)) {
                                            var k: number = run / rise;
                                            var bottom: number = 1.0 + k * k;
                                            var bottom_sq: number = Math.sqrt(bottom);
                                            this.s2 = 1.0 / bottom;
                                            this.c2 = k * k / bottom;
                                            this.cs = k / bottom;
                                            this.s = 1.0 / bottom_sq;
                                            this.c = k / bottom_sq;
                                        } else {
                                            var t: number = rise / run;
                                            var bottom: number = 1.0 + t * t;
                                            var bottom_sq: number = Math.sqrt(bottom);
                                            this.c2 = 1.0 / bottom;
                                            this.s2 = t * t / bottom;
                                            this.cs = t / bottom;
                                            this.c = 1.0 / bottom_sq;
                                            this.s = t / bottom_sq;
                                        }
                                    }

                                    public removeBulge(x1: number): void {
                                        var a22: number = this.diag[x1 + 1];
                                        var a33: number = this.diag[x1 + 2];
                                        var a12: number = this.off[x1];
                                        var a23: number = this.off[x1 + 1];
                                        var a34: number = this.off[x1 + 2];
                                        this.computeRotation(a12, this.bulge);
                                        this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                                        this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                                        this.off[x1] = this.c * a12 + this.s * this.bulge;
                                        this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                                        this.off[x1 + 2] = this.c * a34;
                                        this.bulge = this.s * a34;
                                        if (this.Q != null) {
                                            this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                                        }
                                    }

                                    public removeBulgeEnd(x1: number): void {
                                        var a22: number = this.diag[x1 + 1];
                                        var a12: number = this.off[x1];
                                        var a23: number = this.off[x1 + 1];
                                        var a33: number = this.diag[x1 + 2];
                                        this.computeRotation(a12, this.bulge);
                                        this.diag[x1 + 1] = this.c2 * a22 + 2.0 * this.cs * a23 + this.s2 * a33;
                                        this.diag[x1 + 2] = this.c2 * a33 - 2.0 * this.cs * a23 + this.s2 * a22;
                                        this.off[x1] = this.c * a12 + this.s * this.bulge;
                                        this.off[x1 + 1] = a23 * (this.c2 - this.s2) + this.cs * (a33 - a22);
                                        if (this.Q != null) {
                                            this.updateQ(x1 + 1, x1 + 2, this.c, this.s);
                                        }
                                    }

                                    public eigenvalue2by2(x1: number): void {
                                        var a: number = this.diag[x1];
                                        var b: number = this.off[x1];
                                        var c: number = this.diag[x1 + 1];
                                        var absA: number = Math.abs(a);
                                        var absB: number = Math.abs(b);
                                        var absC: number = Math.abs(c);
                                        var scale: number = absA > absB ? absA : absB;
                                        if (absC > scale) {
                                            scale = absC;
                                        }
                                        if (scale == 0) {
                                            this.off[x1] = 0;
                                            this.diag[x1] = 0;
                                            this.diag[x1 + 1] = 0;
                                            return;
                                        }
                                        a /= scale;
                                        b /= scale;
                                        c /= scale;
                                        this.eigenSmall.symm2x2_fast(a, b, c);
                                        this.off[x1] = 0;
                                        this.diag[x1] = scale * this.eigenSmall.value0.real;
                                        this.diag[x1 + 1] = scale * this.eigenSmall.value1.real;
                                    }

                                    public exceptionalShift(): void {
                                        this.numExceptional++;
                                        var mag: number = 0.05 * this.numExceptional;
                                        if (mag > 1.0) {
                                            mag = 1.0;
                                        }
                                        var theta: number = 2.0 * (this.rand.nextDouble() - 0.5) * mag;
                                        this.performImplicitSingleStep(theta, true);
                                        this.lastExceptional = this.steps;
                                    }

                                    public nextSplit(): boolean {
                                        if (this.numSplits == 0) {
                                            return false;
                                        }
                                        this.x2 = this.splits[--this.numSplits];
                                        if (this.numSplits > 0) {
                                            this.x1 = this.splits[this.numSplits - 1] + 1;
                                        } else {
                                            this.x1 = 0;
                                        }
                                        return true;
                                    }

                                    public computeShift(): number {
                                        if (this.x2 - this.x1 >= 1) {
                                            return this.computeWilkinsonShift();
                                        } else {
                                            return this.diag[this.x2];
                                        }
                                    }

                                    public computeWilkinsonShift(): number {
                                        var a: number = this.diag[this.x2 - 1];
                                        var b: number = this.off[this.x2 - 1];
                                        var c: number = this.diag[this.x2];
                                        var absA: number = Math.abs(a);
                                        var absB: number = Math.abs(b);
                                        var absC: number = Math.abs(c);
                                        var scale: number = absA > absB ? absA : absB;
                                        if (absC > scale) {
                                            scale = absC;
                                        }
                                        if (scale == 0) {
                                            throw new Error("this should never happen");
                                        }
                                        a /= scale;
                                        b /= scale;
                                        c /= scale;
                                        this.eigenSmall.symm2x2_fast(a, b, c);
                                        var diff0: number = Math.abs(this.eigenSmall.value0.real - c);
                                        var diff1: number = Math.abs(this.eigenSmall.value1.real - c);
                                        if (diff0 < diff1) {
                                            return scale * this.eigenSmall.value0.real;
                                        } else {
                                            return scale * this.eigenSmall.value1.real;
                                        }
                                    }

                                    public getMatrixSize(): number {
                                        return this.N;
                                    }

                                    public resetSteps(): void {
                                        this.steps = 0;
                                        this.lastExceptional = 0;
                                    }

                                }

                                export class SymmetricQrAlgorithm {

                                    private helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper;
                                    private Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private eigenvalues: Float64Array;
                                    private exceptionalThresh: number = 15;
                                    private maxIterations: number = this.exceptionalThresh * 15;
                                    private fastEigenvalues: boolean;
                                    private followingScript: boolean;
                                    constructor(helper: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.SymmetricQREigenHelper) {
                                        this.helper = helper;
                                    }

                                    public setMaxIterations(maxIterations: number): void {
                                        this.maxIterations = maxIterations;
                                    }

                                    public getQ(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.Q;
                                    }

                                    public setQ(q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        this.Q = q;
                                    }

                                    public setFastEigenvalues(fastEigenvalues: boolean): void {
                                        this.fastEigenvalues = fastEigenvalues;
                                    }

                                    public getEigenvalue(index: number): number {
                                        return this.helper.diag[index];
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.helper.N;
                                    }

                                    public process(sideLength: number, diag: Float64Array, off: Float64Array, eigenvalues: Float64Array): boolean {
                                        if (diag != null) {
                                            this.helper.init(diag, off, sideLength);
                                        }
                                        if (this.Q == null) {
                                            this.Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.helper.N);
                                        }
                                        this.helper.setQ(this.Q);
                                        this.followingScript = true;
                                        this.eigenvalues = eigenvalues;
                                        this.fastEigenvalues = false;
                                        return this._process();
                                    }

                                    public process3arg(sideLength: number, diag: Float64Array, off: Float64Array): boolean {
                                        if (diag != null) {
                                            this.helper.init(diag, off, sideLength);
                                        }
                                        this.followingScript = false;
                                        this.eigenvalues = null;
                                        return this._process();
                                    }

                                    private _process(): boolean {
                                        while (this.helper.x2 >= 0){
                                            if (this.helper.steps > this.maxIterations) {
                                                return false;
                                            }
                                            if (this.helper.x1 == this.helper.x2) {
                                                this.helper.resetSteps();
                                                if (!this.helper.nextSplit()) {
                                                    break;
                                                }
                                            } else {
                                                if (this.fastEigenvalues && this.helper.x2 - this.helper.x1 == 1) {
                                                    this.helper.resetSteps();
                                                    this.helper.eigenvalue2by2(this.helper.x1);
                                                    this.helper.setSubmatrix(this.helper.x2, this.helper.x2);
                                                } else {
                                                    if (this.helper.steps - this.helper.lastExceptional > this.exceptionalThresh) {
                                                        this.helper.exceptionalShift();
                                                    } else {
                                                        this.performStep();
                                                    }
                                                }
                                            }
                                            this.helper.incrementSteps();
                                        }
                                        return true;
                                    }

                                    public performStep(): void {
                                        for (var i: number = this.helper.x2 - 1; i >= this.helper.x1; i--) {
                                            if (this.helper.isZero(i)) {
                                                this.helper.splits[this.helper.numSplits++] = i;
                                                this.helper.x1 = i + 1;
                                                return;
                                            }
                                        }
                                        var lambda: number;
                                        if (this.followingScript) {
                                            if (this.helper.steps > 10) {
                                                this.followingScript = false;
                                                return;
                                            } else {
                                                lambda = this.eigenvalues[this.helper.x2];
                                            }
                                        } else {
                                            lambda = this.helper.computeShift();
                                        }
                                        this.helper.performImplicitSingleStep(lambda, false);
                                    }

                                }

                                export class TridiagonalDecompositionHouseholder_D64 {

                                    private QT: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private N: number;
                                    private w: Float64Array;
                                    private gammas: Float64Array;
                                    private b: Float64Array;
                                    constructor() {
                                        this.N = 1;
                                        this.w = new Float64Array(this.N);
                                        this.b = new Float64Array(this.N);
                                        this.gammas = new Float64Array(this.N);
                                    }

                                    public getQT(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.QT;
                                    }

                                    public getDiagonal(diag: Float64Array, off: Float64Array): void {
                                        for (var i: number = 0; i < this.N; i++) {
                                            diag[i] = this.QT.data[i * this.N + i];
                                            if (i + 1 < this.N) {
                                                off[i] = this.QT.data[i * this.N + i + 1];
                                            }
                                        }
                                    }

                                    public getT(T: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (T == null) {
                                            T = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                        } else {
                                            if (this.N != T.numRows || this.N != T.numCols) {
                                                throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                            } else {
                                                T.zero();
                                            }
                                        }
                                        T.data[0] = this.QT.data[0];
                                        for (var i: number = 1; i < this.N; i++) {
                                            T.set(i, i, this.QT.get(i, i));
                                            var a: number = this.QT.get(i - 1, i);
                                            T.set(i - 1, i, a);
                                            T.set(i, i - 1, a);
                                        }
                                        if (this.N > 1) {
                                            T.data[(this.N - 1) * this.N + this.N - 1] = this.QT.data[(this.N - 1) * this.N + this.N - 1];
                                            T.data[(this.N - 1) * this.N + this.N - 2] = this.QT.data[(this.N - 2) * this.N + this.N - 1];
                                        }
                                        return T;
                                    }

                                    public getQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, transposed: boolean): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        if (Q == null) {
                                            Q = org.kevoree.modeling.util.maths.matrix.CommonOps.identity1D(this.N);
                                        } else {
                                            if (this.N != Q.numRows || this.N != Q.numCols) {
                                                throw new Error("The provided H must have the same dimensions as the decomposed matrix.");
                                            } else {
                                                org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(Q);
                                            }
                                        }
                                        for (var i: number = 0; i < this.N; i++) {
                                            this.w[i] = 0;
                                        }
                                        if (transposed) {
                                            for (var j: number = this.N - 2; j >= 0; j--) {
                                                this.w[j + 1] = 1;
                                                for (var i: number = j + 2; i < this.N; i++) {
                                                    this.w[i] = this.QT.data[j * this.N + i];
                                                }
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N);
                                            }
                                        } else {
                                            for (var j: number = this.N - 2; j >= 0; j--) {
                                                this.w[j + 1] = 1;
                                                for (var i: number = j + 2; i < this.N; i++) {
                                                    this.w[i] = this.QT.get(j, i);
                                                }
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(Q, this.w, this.gammas[j + 1], j + 1, j + 1, this.N, this.b);
                                            }
                                        }
                                        return Q;
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.init(A);
                                        for (var k: number = 1; k < this.N; k++) {
                                            this.similarTransform(k);
                                        }
                                        return true;
                                    }

                                    private similarTransform(k: number): void {
                                        var t: Float64Array = this.QT.data;
                                        var max: number = 0;
                                        var rowU: number = (k - 1) * this.N;
                                        for (var i: number = k; i < this.N; i++) {
                                            var val: number = Math.abs(t[rowU + i]);
                                            if (val > max) {
                                                max = val;
                                            }
                                        }
                                        if (max > 0) {
                                            var tau: number = org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.computeTauAndDivide(k, this.N, t, rowU, max);
                                            var nu: number = t[rowU + k] + tau;
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.divideElements(k + 1, this.N, t, rowU, nu);
                                            t[rowU + k] = 1.0;
                                            var gamma: number = nu / tau;
                                            this.gammas[k] = gamma;
                                            this.householderSymmetric(k, gamma);
                                            t[rowU + k] = -tau * max;
                                        } else {
                                            this.gammas[k] = 0;
                                        }
                                    }

                                    public householderSymmetric(row: number, gamma: number): void {
                                        var startU: number = (row - 1) * this.N;
                                        for (var i: number = row; i < this.N; i++) {
                                            var total: number = 0;
                                            for (var j: number = row; j < i; j++) {
                                                total += this.QT.data[j * this.N + i] * this.QT.data[startU + j];
                                            }
                                            for (var j: number = i; j < this.N; j++) {
                                                total += this.QT.data[i * this.N + j] * this.QT.data[startU + j];
                                            }
                                            this.w[i] = -gamma * total;
                                        }
                                        var alpha: number = 0;
                                        for (var i: number = row; i < this.N; i++) {
                                            alpha += this.QT.data[startU + i] * this.w[i];
                                        }
                                        alpha *= -0.5 * gamma;
                                        for (var i: number = row; i < this.N; i++) {
                                            this.w[i] += alpha * this.QT.data[startU + i];
                                        }
                                        for (var i: number = row; i < this.N; i++) {
                                            var ww: number = this.w[i];
                                            var uu: number = this.QT.data[startU + i];
                                            var rowA: number = i * this.N;
                                            for (var j: number = i; j < this.N; j++) {
                                                this.QT.data[rowA + j] += ww * this.QT.data[startU + j] + this.w[j] * uu;
                                            }
                                        }
                                    }

                                    public init(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        if (A.numRows != A.numCols) {
                                            throw new Error("Must be square");
                                        }
                                        if (A.numCols != this.N) {
                                            this.N = A.numCols;
                                            if (this.w.length < this.N) {
                                                this.w = new Float64Array(this.N);
                                                this.gammas = new Float64Array(this.N);
                                                this.b = new Float64Array(this.N);
                                            }
                                        }
                                        this.QT = A;
                                    }

                                    public inputModified(): boolean {
                                        return true;
                                    }

                                }

                                export class WatchedDoubleStepQRDecomposition_D64 {

                                    public hessenberg: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64;
                                    public algValue: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue;
                                    public algVector: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector;
                                    public H: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public computeVectors: boolean;
                                    constructor(computeVectors: boolean) {
                                        this.hessenberg = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.HessenbergSimilarDecomposition_D64(10);
                                        this.algValue = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvalue();
                                        this.algVector = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigenvector();
                                        this.computeVectors = computeVectors;
                                    }

                                    public decompose(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        if (!this.hessenberg.decompose(A)) {
                                            return false;
                                        }
                                        this.H = this.hessenberg.getH(null);
                                        this.algValue.getImplicitQR().createR = false;
                                        if (!this.algValue.process(this.H)) {
                                            return false;
                                        }
                                        this.algValue.getImplicitQR().createR = true;
                                        if (this.computeVectors) {
                                            return this.algVector.process(this.algValue.getImplicitQR(), this.H, this.hessenberg.getQ(null));
                                        } else {
                                            return true;
                                        }
                                    }

                                    public inputModified(): boolean {
                                        return this.hessenberg.inputModified();
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.algValue.getEigenvalues().length;
                                    }

                                    public getEigenvalue(index: number): org.kevoree.modeling.util.maths.matrix.Complex64F {
                                        return this.algValue.getEigenvalues()[index];
                                    }

                                    public getEigenVector(index: number): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.algVector.getEigenvectors()[index];
                                    }

                                }

                                export class WatchedDoubleStepQREigen {

                                    private rand: java.util.Random = new java.util.Random();
                                    private N: number;
                                    public A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private u: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    private gamma: number;
                                    private _temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public numStepsFind: Int32Array;
                                    public steps: number;
                                    public eigenvalues: org.kevoree.modeling.util.maths.matrix.Complex64F[];
                                    public numEigen: number;
                                    private valueSmall: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.EigenvalueSmall();
                                    private temp: Float64Array = new Float64Array(9);
                                    private printHumps: boolean = false;
                                    public checkHessenberg: boolean = false;
                                    private checkOrthogonal: boolean = false;
                                    private checkUncountable: boolean = false;
                                    private useStandardEq: boolean = false;
                                    private useCareful2x2: boolean = true;
                                    private normalize: boolean = true;
                                    public lastExceptional: number;
                                    public numExceptional: number;
                                    public exceptionalThreshold: number = 20;
                                    public maxIterations: number = this.exceptionalThreshold * 20;
                                    public createR: boolean = true;
                                    public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public incrementSteps(): void {
                                        this.steps++;
                                    }

                                    public setQ(Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        this.Q = Q;
                                    }

                                    private addEigenvalue(v: number): void {
                                        this.numStepsFind[this.numEigen] = this.steps;
                                        this.eigenvalues[this.numEigen].setValues(v, 0);
                                        this.numEigen++;
                                        this.steps = 0;
                                        this.lastExceptional = 0;
                                    }

                                    private addEigenvalue2arg(v: number, i: number): void {
                                        this.numStepsFind[this.numEigen] = this.steps;
                                        this.eigenvalues[this.numEigen].setValues(v, i);
                                        this.numEigen++;
                                        this.steps = 0;
                                        this.lastExceptional = 0;
                                    }

                                    public setChecks(hessenberg: boolean, orthogonal: boolean, uncountable: boolean): void {
                                        this.checkHessenberg = hessenberg;
                                        this.checkOrthogonal = orthogonal;
                                        this.checkUncountable = uncountable;
                                    }

                                    public isZero(x1: number, x2: number): boolean {
                                        var target: number = Math.abs(this.A.get(x1, x2));
                                        var above: number = Math.abs(this.A.get(x1 - 1, x2));
                                        var right: number = Math.abs(this.A.get(x1, x2 + 1));
                                        return target <= 0.5 * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS * (above + right);
                                    }

                                    public setup(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        if (A.numRows != A.numCols) {
                                            throw new Error("Must be square");
                                        }
                                        if (this.N != A.numRows) {
                                            this.N = A.numRows;
                                            this.A = A.copy();
                                            this.u = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                                            this._temp = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(A.numRows, 1);
                                            this.numStepsFind = new Int32Array(A.numRows);
                                        } else {
                                            this.A.setMatrix(A);
                                        }
                                        for (var i: number = 2; i < this.N; i++) {
                                            for (var j: number = 0; j < i - 1; j++) {
                                                this.A.set(i, j, 0);
                                            }
                                        }
                                        this.eigenvalues = new Array();
                                        for (var i: number = 0; i < this.eigenvalues.length; i++) {
                                            this.eigenvalues[i] = new org.kevoree.modeling.util.maths.matrix.Complex64F();
                                        }
                                        this.numEigen = 0;
                                        this.lastExceptional = 0;
                                        this.numExceptional = 0;
                                        this.steps = 0;
                                    }

                                    public exceptionalShift(x1: number, x2: number): void {
                                        if (this.printHumps) {
                                            console.log("Performing exceptional implicit double step");;
                                        }
                                        var val: number = Math.abs(this.A.get(x2, x2));
                                        if (val == 0) {
                                            val = 1;
                                        }
                                        this.numExceptional++;
                                        var p: number = 1 - Math.pow(0.1, this.numExceptional);
                                        val *= p + 2.0 * (1.0 - p) * (this.rand.nextDouble() - 0.5);
                                        if (this.rand.nextBoolean()) {
                                            val = -val;
                                        }
                                        this.performImplicitSingleStep(x1, x2, val);
                                        this.lastExceptional = this.steps;
                                    }

                                    public implicitDoubleStep(x1: number, x2: number): void {
                                        if (this.printHumps) {
                                            console.log("Performing implicit double step");;
                                        }
                                        var z11: number = this.A.get(x2 - 1, x2 - 1);
                                        var z12: number = this.A.get(x2 - 1, x2);
                                        var z21: number = this.A.get(x2, x2 - 1);
                                        var z22: number = this.A.get(x2, x2);
                                        var a11: number = this.A.get(x1, x1);
                                        var a21: number = this.A.get(x1 + 1, x1);
                                        var a12: number = this.A.get(x1, x1 + 1);
                                        var a22: number = this.A.get(x1 + 1, x1 + 1);
                                        var a32: number = this.A.get(x1 + 2, x1 + 1);
                                        if (this.normalize) {
                                            this.temp[0] = a11;
                                            this.temp[1] = a21;
                                            this.temp[2] = a12;
                                            this.temp[3] = a22;
                                            this.temp[4] = a32;
                                            this.temp[5] = z11;
                                            this.temp[6] = z22;
                                            this.temp[7] = z12;
                                            this.temp[8] = z21;
                                            var max: number = Math.abs(this.temp[0]);
                                            for (var j: number = 1; j < this.temp.length; j++) {
                                                if (Math.abs(this.temp[j]) > max) {
                                                    max = Math.abs(this.temp[j]);
                                                }
                                            }
                                            a11 /= max;
                                            a21 /= max;
                                            a12 /= max;
                                            a22 /= max;
                                            a32 /= max;
                                            z11 /= max;
                                            z22 /= max;
                                            z12 /= max;
                                            z21 /= max;
                                        }
                                        var b11: number;
                                        var b21: number;
                                        var b31: number;
                                        if (this.useStandardEq) {
                                            b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) / a21 + a12;
                                            b21 = a11 + a22 - z11 - z22;
                                            b31 = a32;
                                        } else {
                                            b11 = ((a11 - z11) * (a11 - z22) - z21 * z12) + a12 * a21;
                                            b21 = (a11 + a22 - z11 - z22) * a21;
                                            b31 = a32 * a21;
                                        }
                                        this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                                    }

                                    public performImplicitDoubleStep(x1: number, x2: number, real: number, img: number): void {
                                        var a11: number = this.A.get(x1, x1);
                                        var a21: number = this.A.get(x1 + 1, x1);
                                        var a12: number = this.A.get(x1, x1 + 1);
                                        var a22: number = this.A.get(x1 + 1, x1 + 1);
                                        var a32: number = this.A.get(x1 + 2, x1 + 1);
                                        var p_plus_t: number = 2.0 * real;
                                        var p_times_t: number = real * real + img * img;
                                        var b11: number;
                                        var b21: number;
                                        var b31: number;
                                        if (this.useStandardEq) {
                                            b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) / a21 + a12;
                                            b21 = a11 + a22 - p_plus_t;
                                            b31 = a32;
                                        } else {
                                            b11 = (a11 * a11 - p_plus_t * a11 + p_times_t) + a12 * a21;
                                            b21 = (a11 + a22 - p_plus_t) * a21;
                                            b31 = a32 * a21;
                                        }
                                        this.performImplicitDoubleStep5arg(x1, x2, b11, b21, b31);
                                    }

                                    private performImplicitDoubleStep5arg(x1: number, x2: number, b11: number, b21: number, b31: number): void {
                                        if (!this.bulgeDoubleStepQn6arg(x1, b11, b21, b31, 0, false)) {
                                            return;
                                        }
                                        if (this.Q != null) {
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 3, this._temp.data);
                                        }
                                        for (var i: number = x1; i < x2 - 2; i++) {
                                            if (this.bulgeDoubleStepQn(i) && this.Q != null) {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 4, this._temp.data);
                                            }
                                        }
                                        if (x2 - 2 >= 0 && this.bulgeSingleStepQn(x2 - 2) && this.Q != null) {
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x2 - 1, x2 + 1, this._temp.data);
                                        }
                                    }

                                    public performImplicitSingleStep(x1: number, x2: number, eigenvalue: number): void {
                                        if (!this.createBulgeSingleStep(x1, eigenvalue)) {
                                            return;
                                        }
                                        if (this.Q != null) {
                                            org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, x1, x1 + 2, this._temp.data);
                                        }
                                        for (var i: number = x1; i < x2 - 1; i++) {
                                            if (this.bulgeSingleStepQn(i) && this.Q != null) {
                                                org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.Q, this.u.data, this.gamma, 0, i + 1, i + 3, this._temp.data);
                                            }
                                        }
                                    }

                                    public createBulgeSingleStep(x1: number, eigenvalue: number): boolean {
                                        var b11: number = this.A.get(x1, x1) - eigenvalue;
                                        var b21: number = this.A.get(x1 + 1, x1);
                                        var threshold: number = Math.abs(this.A.get(x1, x1)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                        return this.bulgeSingleStepQn5arg(x1, b11, b21, threshold, false);
                                    }

                                    public bulgeDoubleStepQn(i: number): boolean {
                                        var a11: number = this.A.get(i + 1, i);
                                        var a21: number = this.A.get(i + 2, i);
                                        var a31: number = this.A.get(i + 3, i);
                                        var threshold: number = Math.abs(this.A.get(i, i)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                        return this.bulgeDoubleStepQn6arg(i + 1, a11, a21, a31, threshold, true);
                                    }

                                    public bulgeDoubleStepQn6arg(i: number, a11: number, a21: number, a31: number, threshold: number, set: boolean): boolean {
                                        var max: number;
                                        if (this.normalize) {
                                            var absA11: number = Math.abs(a11);
                                            var absA21: number = Math.abs(a21);
                                            var absA31: number = Math.abs(a31);
                                            max = absA11 > absA21 ? absA11 : absA21;
                                            if (absA31 > max) {
                                                max = absA31;
                                            }
                                            if (max <= threshold) {
                                                if (set) {
                                                    this.A.set(i, i - 1, 0);
                                                    this.A.set(i + 1, i - 1, 0);
                                                    this.A.set(i + 2, i - 1, 0);
                                                }
                                                return false;
                                            }
                                            a11 /= max;
                                            a21 /= max;
                                            a31 /= max;
                                        } else {
                                            max = 1;
                                        }
                                        var tau: number = Math.sqrt(a11 * a11 + a21 * a21 + a31 * a31);
                                        if (a11 < 0) {
                                            tau = -tau;
                                        }
                                        var div: number = a11 + tau;
                                        this.u.set(i, 0, 1);
                                        this.u.set(i + 1, 0, a21 / div);
                                        this.u.set(i + 2, 0, a31 / div);
                                        this.gamma = div / tau;
                                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 3, this._temp.data);
                                        if (set) {
                                            this.A.set(i, i - 1, -max * tau);
                                            this.A.set(i + 1, i - 1, 0);
                                            this.A.set(i + 2, i - 1, 0);
                                        }
                                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 3);
                                        return true;
                                    }

                                    public bulgeSingleStepQn(i: number): boolean {
                                        var a11: number = this.A.get(i + 1, i);
                                        var a21: number = this.A.get(i + 2, i);
                                        var threshold: number = Math.abs(this.A.get(i, i)) * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS;
                                        return this.bulgeSingleStepQn5arg(i + 1, a11, a21, threshold, true);
                                    }

                                    public bulgeSingleStepQn5arg(i: number, a11: number, a21: number, threshold: number, set: boolean): boolean {
                                        var max: number;
                                        if (this.normalize) {
                                            max = Math.abs(a11);
                                            if (max < Math.abs(a21)) {
                                                max = Math.abs(a21);
                                            }
                                            if (max <= threshold) {
                                                if (set) {
                                                    this.A.set(i, i - 1, 0);
                                                    this.A.set(i + 1, i - 1, 0);
                                                }
                                                return false;
                                            }
                                            a11 /= max;
                                            a21 /= max;
                                        } else {
                                            max = 1;
                                        }
                                        var tau: number = Math.sqrt(a11 * a11 + a21 * a21);
                                        if (a11 < 0) {
                                            tau = -tau;
                                        }
                                        var div: number = a11 + tau;
                                        this.u.set(i, 0, 1);
                                        this.u.set(i + 1, 0, a21 / div);
                                        this.gamma = div / tau;
                                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultR(this.A, this.u.data, this.gamma, 0, i, i + 2, this._temp.data);
                                        if (set) {
                                            this.A.set(i, i - 1, -max * tau);
                                            this.A.set(i + 1, i - 1, 0);
                                        }
                                        org.kevoree.modeling.util.maths.matrix.solvers.decomposition.QrHelperFunctions_D64.rank1UpdateMultL(this.A, this.u.data, this.gamma, 0, i, i + 2);
                                        return true;
                                    }

                                    public eigen2by2_scale(a11: number, a12: number, a21: number, a22: number): void {
                                        var abs11: number = Math.abs(a11);
                                        var abs22: number = Math.abs(a22);
                                        var abs12: number = Math.abs(a12);
                                        var abs21: number = Math.abs(a21);
                                        var max: number = abs11 > abs22 ? abs11 : abs22;
                                        if (max < abs12) {
                                            max = abs12;
                                        }
                                        if (max < abs21) {
                                            max = abs21;
                                        }
                                        if (max == 0) {
                                            this.valueSmall.value0.real = 0;
                                            this.valueSmall.value0.imaginary = 0;
                                            this.valueSmall.value1.real = 0;
                                            this.valueSmall.value1.imaginary = 0;
                                        } else {
                                            a12 /= max;
                                            a21 /= max;
                                            a11 /= max;
                                            a22 /= max;
                                            if (this.useCareful2x2) {
                                                this.valueSmall.value2x2(a11, a12, a21, a22);
                                            } else {
                                                this.valueSmall.value2x2_fast(a11, a12, a21, a22);
                                            }
                                            this.valueSmall.value0.real *= max;
                                            this.valueSmall.value0.imaginary *= max;
                                            this.valueSmall.value1.real *= max;
                                            this.valueSmall.value1.imaginary *= max;
                                        }
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.numEigen;
                                    }

                                    public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                                        return this.eigenvalues;
                                    }

                                    public addComputedEigen2x2(x1: number, x2: number): void {
                                        this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                                        if (this.checkUncountable && (org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.valueSmall.value0.real) || org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.valueSmall.value1.real))) {
                                            throw new Error("Uncountable");
                                        }
                                        this.addEigenvalue2arg(this.valueSmall.value0.real, this.valueSmall.value0.imaginary);
                                        this.addEigenvalue2arg(this.valueSmall.value1.real, this.valueSmall.value1.imaginary);
                                    }

                                    public isReal2x2(x1: number, x2: number): boolean {
                                        this.eigen2by2_scale(this.A.get(x1, x1), this.A.get(x1, x2), this.A.get(x2, x1), this.A.get(x2, x2));
                                        return this.valueSmall.value0.isReal();
                                    }

                                    public addEigenAt(x1: number): void {
                                        this.addEigenvalue(this.A.get(x1, x1));
                                    }

                                    public printSteps(): void {
                                        for (var i: number = 0; i < this.N; i++) {
                                            console.log("Step[" + i + "] = " + this.numStepsFind[i]);;
                                        }
                                    }

                                }

                                export class WatchedDoubleStepQREigenvalue {

                                    public implicitQR: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                                    public splits: Int32Array;
                                    public numSplits: number;
                                    public x1: number;
                                    public x2: number;
                                    constructor() {
                                        this.implicitQR = new org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen();
                                    }

                                    public setup(A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        this.implicitQR.setup(A);
                                        this.implicitQR.setQ(null);
                                        this.splits = new Int32Array(A.numRows);
                                        this.numSplits = 0;
                                    }

                                    public process(origA: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.setup(origA);
                                        this.x1 = 0;
                                        this.x2 = origA.numRows - 1;
                                        while (this.implicitQR.numEigen < origA.numRows){
                                            if (this.implicitQR.steps > this.implicitQR.maxIterations) {
                                                return false;
                                            }
                                            this.implicitQR.incrementSteps();
                                            if (this.x2 < this.x1) {
                                                this.moveToNextSplit();
                                            } else {
                                                if (this.x2 - this.x1 == 0) {
                                                    this.implicitQR.addEigenAt(this.x1);
                                                    this.x2--;
                                                } else {
                                                    if (this.x2 - this.x1 == 1) {
                                                        this.implicitQR.addComputedEigen2x2(this.x1, this.x2);
                                                        this.x2 -= 2;
                                                    } else {
                                                        if (this.implicitQR.steps - this.implicitQR.lastExceptional > this.implicitQR.exceptionalThreshold) {
                                                            if (org.kevoree.modeling.util.PrimitiveHelper.isNaN(this.implicitQR.A.get(this.x2, this.x2))) {
                                                                return false;
                                                            }
                                                            this.implicitQR.exceptionalShift(this.x1, this.x2);
                                                        } else {
                                                            if (this.implicitQR.isZero(this.x2, this.x2 - 1)) {
                                                                this.implicitQR.addEigenAt(this.x2);
                                                                this.x2--;
                                                            } else {
                                                                this.performIteration();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        return true;
                                    }

                                    private moveToNextSplit(): void {
                                        if (this.numSplits <= 0) {
                                            throw new Error("bad");
                                        }
                                        this.x2 = this.splits[--this.numSplits];
                                        if (this.numSplits > 0) {
                                            this.x1 = this.splits[this.numSplits - 1] + 1;
                                        } else {
                                            this.x1 = 0;
                                        }
                                    }

                                    private performIteration(): void {
                                        var changed: boolean = false;
                                        for (var i: number = this.x2; i > this.x1; i--) {
                                            if (this.implicitQR.isZero(i, i - 1)) {
                                                this.x1 = i;
                                                this.splits[this.numSplits++] = i - 1;
                                                changed = true;
                                                break;
                                            }
                                        }
                                        if (!changed) {
                                            this.implicitQR.implicitDoubleStep(this.x1, this.x2);
                                        }
                                    }

                                    public getNumberOfEigenvalues(): number {
                                        return this.implicitQR.getNumberOfEigenvalues();
                                    }

                                    public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                                        return this.implicitQR.getEigenvalues();
                                    }

                                    public getImplicitQR(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                                        return this.implicitQR;
                                    }

                                }

                                export class WatchedDoubleStepQREigenvector {

                                    public implicit: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen;
                                    public Q: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public eigenvectors: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[];
                                    public eigenvectorTemp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F;
                                    public solver: org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64;
                                    public origEigenvalues: org.kevoree.modeling.util.maths.matrix.Complex64F[];
                                    public N: number;
                                    public splits: Int32Array;
                                    public numSplits: number;
                                    public x1: number;
                                    public x2: number;
                                    public indexVal: number;
                                    public onscript: boolean;
                                    public process(implicit: org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen, A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F, Q_h: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        this.implicit = implicit;
                                        if (this.N != A.numRows) {
                                            this.N = A.numRows;
                                            this.Q = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, this.N);
                                            this.splits = new Int32Array(this.N);
                                            this.origEigenvalues = new Array();
                                            this.eigenvectors = new Array();
                                            this.eigenvectorTemp = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                                            this.solver = new org.kevoree.modeling.util.maths.matrix.solvers.LinearSolverLu_D64(new org.kevoree.modeling.util.maths.matrix.solvers.LUDecompositionAlt_D64());
                                        } else {
                                            this.eigenvectors = new Array();
                                        }
                                        java.lang.System.arraycopy(implicit.eigenvalues, 0, this.origEigenvalues, 0, this.N);
                                        implicit.setup(A);
                                        implicit.setQ(this.Q);
                                        this.numSplits = 0;
                                        this.onscript = true;
                                        if (!this.findQandR()) {
                                            return false;
                                        }
                                        return this.extractVectors(Q_h);
                                    }

                                    public extractVectors(Q_h: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): boolean {
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.memset(this.eigenvectorTemp.data, 0);
                                        var triangular: boolean = true;
                                        for (var i: number = 0; i < this.N; i++) {
                                            var c: org.kevoree.modeling.util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                                            if (triangular && !c.isReal()) {
                                                triangular = false;
                                            }
                                            if (c.isReal() && this.eigenvectors[this.N - i - 1] == null) {
                                                this.solveEigenvectorDuplicateEigenvalue(c.real, i, triangular);
                                            }
                                        }
                                        if (Q_h != null) {
                                            var temp: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                                            for (var i: number = 0; i < this.N; i++) {
                                                var v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = this.eigenvectors[i];
                                                if (v != null) {
                                                    org.kevoree.modeling.util.maths.matrix.CommonOps.mult(Q_h, v, temp);
                                                    this.eigenvectors[i] = temp;
                                                    temp = v;
                                                }
                                            }
                                        }
                                        return true;
                                    }

                                    private solveEigenvectorDuplicateEigenvalue(real: number, first: number, isTriangle: boolean): void {
                                        var scale: number = Math.abs(real);
                                        if (scale == 0) {
                                            scale = 1;
                                        }
                                        this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                                        this.eigenvectorTemp.zero();
                                        if (first > 0) {
                                            if (isTriangle) {
                                                this.solveUsingTriangle(real, first, this.eigenvectorTemp);
                                            } else {
                                                this.solveWithLU(real, first, this.eigenvectorTemp);
                                            }
                                        }
                                        this.eigenvectorTemp.reshapeBoolean(this.N, 1, false);
                                        for (var i: number = first; i < this.N; i++) {
                                            var c: org.kevoree.modeling.util.maths.matrix.Complex64F = this.implicit.eigenvalues[this.N - i - 1];
                                            if (c.isReal() && Math.abs(c.real - real) / scale < 100.0 * org.kevoree.modeling.util.maths.matrix.CommonOps.EPS) {
                                                this.eigenvectorTemp.data[i] = 1;
                                                var v: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(this.N, 1);
                                                org.kevoree.modeling.util.maths.matrix.CommonOps.multTransA(this.Q, this.eigenvectorTemp, v);
                                                this.eigenvectors[this.N - i - 1] = v;
                                                org.kevoree.modeling.util.maths.matrix.CommonOps.normalizeF(v);
                                                this.eigenvectorTemp.data[i] = 0;
                                            }
                                        }
                                    }

                                    private solveUsingTriangle(real: number, index: number, r: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        for (var i: number = 0; i < index; i++) {
                                            this.implicit.A.add(i, i, -real);
                                        }
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.changeSign(r);
                                        org.kevoree.modeling.util.maths.matrix.solvers.TriangularSolver.solveU(this.implicit.A.data, r.data, this.implicit.A.numRows, 0, index);
                                        for (var i: number = 0; i < index; i++) {
                                            this.implicit.A.add(i, i, real);
                                        }
                                    }

                                    private solveWithLU(real: number, index: number, r: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F): void {
                                        var A: org.kevoree.modeling.util.maths.matrix.DenseMatrix64F = new org.kevoree.modeling.util.maths.matrix.DenseMatrix64F(index, index);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.extract6M(this.implicit.A, 0, index, 0, index, A, 0, 0);
                                        for (var i: number = 0; i < index; i++) {
                                            A.add(i, i, -real);
                                        }
                                        r.reshapeBoolean(index, 1, false);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.subvector(this.implicit.A, 0, index, index, false, 0, r);
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.changeSign(r);
                                        if (!this.solver.setA(A)) {
                                            throw new Error("Solve failed");
                                        }
                                        this.solver.solve(r, r);
                                    }

                                    public findQandR(): boolean {
                                        org.kevoree.modeling.util.maths.matrix.CommonOps.setIdentity(this.Q);
                                        this.x1 = 0;
                                        this.x2 = this.N - 1;
                                        this.indexVal = 0;
                                        while (this.indexVal < this.N){
                                            if (!this.findNextEigenvalue()) {
                                                return false;
                                            }
                                        }
                                        return true;
                                    }

                                    private findNextEigenvalue(): boolean {
                                        var foundEigen: boolean = false;
                                        while (!foundEigen && this.implicit.steps < this.implicit.maxIterations){
                                            this.implicit.incrementSteps();
                                            if (this.x2 < this.x1) {
                                                this.moveToNextSplit();
                                            } else {
                                                if (this.x2 - this.x1 == 0) {
                                                    this.implicit.addEigenAt(this.x1);
                                                    this.x2--;
                                                    this.indexVal++;
                                                    foundEigen = true;
                                                } else {
                                                    if (this.x2 - this.x1 == 1 && !this.implicit.isReal2x2(this.x1, this.x2)) {
                                                        this.implicit.addComputedEigen2x2(this.x1, this.x2);
                                                        this.x2 -= 2;
                                                        this.indexVal += 2;
                                                        foundEigen = true;
                                                    } else {
                                                        if (this.implicit.steps - this.implicit.lastExceptional > this.implicit.exceptionalThreshold) {
                                                            this.implicit.exceptionalShift(this.x1, this.x2);
                                                            this.implicit.lastExceptional = this.implicit.steps;
                                                        } else {
                                                            if (this.implicit.isZero(this.x2, this.x2 - 1)) {
                                                                this.implicit.addEigenAt(this.x2);
                                                                foundEigen = true;
                                                                this.x2--;
                                                                this.indexVal++;
                                                            } else {
                                                                this.checkSplitPerformImplicit();
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        return foundEigen;
                                    }

                                    private checkSplitPerformImplicit(): void {
                                        for (var i: number = this.x2; i > this.x1; i--) {
                                            if (this.implicit.isZero(i, i - 1)) {
                                                this.x1 = i;
                                                this.splits[this.numSplits++] = i - 1;
                                                return;
                                            }
                                        }
                                        if (this.onscript) {
                                            if (this.implicit.steps > this.implicit.exceptionalThreshold / 2) {
                                                this.onscript = false;
                                            } else {
                                                var a: org.kevoree.modeling.util.maths.matrix.Complex64F = this.origEigenvalues[this.indexVal];
                                                if (a.isReal()) {
                                                    this.implicit.performImplicitSingleStep(this.x1, this.x2, a.getReal());
                                                } else {
                                                    if (this.x2 < this.N - 2) {
                                                        this.implicit.performImplicitDoubleStep(this.x1, this.x2, a.real, a.imaginary);
                                                    } else {
                                                        this.onscript = false;
                                                    }
                                                }
                                            }
                                        } else {
                                            if (this.x2 - this.x1 >= 1 && this.x2 < this.N - 2) {
                                                this.implicit.implicitDoubleStep(this.x1, this.x2);
                                            } else {
                                                this.implicit.performImplicitSingleStep(this.x1, this.x2, this.implicit.A.get(this.x2, this.x2));
                                            }
                                        }
                                    }

                                    private moveToNextSplit(): void {
                                        if (this.numSplits <= 0) {
                                            throw new Error("bad");
                                        }
                                        this.x2 = this.splits[--this.numSplits];
                                        if (this.numSplits > 0) {
                                            this.x1 = this.splits[this.numSplits - 1] + 1;
                                        } else {
                                            this.x1 = 0;
                                        }
                                    }

                                    public getQ(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F {
                                        return this.Q;
                                    }

                                    public getImplicit(): org.kevoree.modeling.util.maths.matrix.solvers.decomposition.WatchedDoubleStepQREigen {
                                        return this.implicit;
                                    }

                                    public getEigenvectors(): org.kevoree.modeling.util.maths.matrix.DenseMatrix64F[] {
                                        return this.eigenvectors;
                                    }

                                    public getEigenvalues(): org.kevoree.modeling.util.maths.matrix.Complex64F[] {
                                        return this.implicit.eigenvalues;
                                    }

                                }

                            }
                        }
                    }
                    export module structure {
                        export interface KArray1D {

                            size(): number;

                            get(index: number): number;

                            set(index: number, value: number): number;

                            add(index: number, value: number): number;

                        }

                        export interface KArray2D {

                            nbRows(): number;

                            nbColumns(): number;

                            get(rowIndex: number, columnIndex: number): number;

                            set(rowIndex: number, columnIndex: number, value: number): number;

                            add(rowIndex: number, columnIndex: number, value: number): number;

                        }

                        export interface KArray3D {

                            nbRows(): number;

                            nbColumns(): number;

                            nbDeeps(): number;

                            get(rowIndex: number, columnIndex: number, deepIndex: number): number;

                            set(rowIndex: number, columnIndex: number, deepIndex: number, value: number): number;

                            add(p_rowIndex: number, p_columnIndex: number, p_deepIndex: number, value: number): number;

                        }

                        export module impl {
                            export class Array1D implements org.kevoree.modeling.util.maths.structure.KArray1D {

                                private _size: number;
                                private _offset: number;
                                private _segmentIndex: number;
                                private _segment: org.kevoree.modeling.memory.chunk.KObjectChunk;
                                private _metaClass: org.kevoree.modeling.meta.KMetaClass;
                                constructor(p_size: number, p_offset: number, p_segmentIndex: number, p_segment: org.kevoree.modeling.memory.chunk.KObjectChunk, p_metaClass: org.kevoree.modeling.meta.KMetaClass) {
                                    this._size = p_size;
                                    this._offset = p_offset;
                                    this._segmentIndex = p_segmentIndex;
                                    this._segment = p_segment;
                                    this._metaClass = p_metaClass;
                                }

                                public size(): number {
                                    return this._size;
                                }

                                public get(p_index: number): number {
                                    return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + p_index, this._metaClass);
                                }

                                public set(p_index: number, p_value: number): number {
                                    this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + p_index, p_value, this._metaClass);
                                    return p_value;
                                }

                                public add(index: number, value: number): number {
                                    return this.set(index, this.get(index) + value);
                                }

                            }

                            export class Array2D implements org.kevoree.modeling.util.maths.structure.KArray2D {

                                private _nbRows: number;
                                private _nbColumns: number;
                                private _offset: number;
                                private _segmentIndex: number;
                                private _segment: org.kevoree.modeling.memory.chunk.KObjectChunk;
                                private _metaClass: org.kevoree.modeling.meta.KMetaClass;
                                constructor(p_nbRows: number, p_nbColumns: number, p_offset: number, p_segmentIndex: number, p_segment: org.kevoree.modeling.memory.chunk.KObjectChunk, p_metaClass: org.kevoree.modeling.meta.KMetaClass) {
                                    this._nbRows = p_nbRows;
                                    this._nbColumns = p_nbColumns;
                                    this._offset = p_offset;
                                    this._segment = p_segment;
                                    this._segmentIndex = p_segmentIndex;
                                    this._metaClass = p_metaClass;
                                }

                                public nbRows(): number {
                                    return this._nbRows;
                                }

                                public nbColumns(): number {
                                    return this._nbColumns;
                                }

                                public get(p_rowIndex: number, p_columnIndex: number): number {
                                    return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + (p_rowIndex * this._nbColumns) + p_columnIndex, this._metaClass);
                                }

                                public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                                    this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + (p_rowIndex * this._nbColumns) + p_columnIndex, value, this._metaClass);
                                    return value;
                                }

                                public add(rawIndex: number, columnIndex: number, value: number): number {
                                    return this.set(rawIndex, columnIndex, this.get(rawIndex, columnIndex) + value);
                                }

                            }

                            export class Array3D implements org.kevoree.modeling.util.maths.structure.KArray3D {

                                private _nbrows: number;
                                private _nbColumns: number;
                                private _nbDeeps: number;
                                private _offset: number;
                                private _segmentIndex: number;
                                private _segment: org.kevoree.modeling.memory.chunk.KObjectChunk;
                                private _metaClass: org.kevoree.modeling.meta.KMetaClass;
                                constructor(p_nbrows: number, p_nbColumns: number, p_nbDeeps: number, p_offset: number, p_segmentIndex: number, p_segment: org.kevoree.modeling.memory.chunk.KObjectChunk, p_metaClass: org.kevoree.modeling.meta.KMetaClass) {
                                    this._nbrows = p_nbrows;
                                    this._nbColumns = p_nbColumns;
                                    this._nbDeeps = p_nbDeeps;
                                    this._offset = p_offset;
                                    this._segmentIndex = p_segmentIndex;
                                    this._segment = p_segment;
                                    this._metaClass = p_metaClass;
                                }

                                public nbRows(): number {
                                    return this._nbrows;
                                }

                                public nbColumns(): number {
                                    return this._nbColumns;
                                }

                                public nbDeeps(): number {
                                    return this._nbDeeps;
                                }

                                public get(p_rowIndex: number, p_columnIndex: number, p_deepIndex: number): number {
                                    return this._segment.getDoubleArrayElem(this._segmentIndex, this._offset + p_rowIndex * (this._nbColumns * this._nbDeeps) + p_columnIndex * this._nbDeeps + p_deepIndex, this._metaClass);
                                }

                                public set(p_rowIndex: number, p_columnIndex: number, p_deepIndex: number, p_value: number): number {
                                    this._segment.setDoubleArrayElem(this._segmentIndex, this._offset + p_rowIndex * (this._nbColumns * this._nbDeeps) + p_columnIndex * this._nbDeeps + p_deepIndex, p_value, this._metaClass);
                                    return p_value;
                                }

                                public add(p_rowIndex: number, p_columnIndex: number, p_deepIndex: number, value: number): number {
                                    return this.set(p_rowIndex, p_columnIndex, p_deepIndex, this.get(p_rowIndex, p_columnIndex, p_deepIndex) + value);
                                }

                            }

                            export class NativeArray2D implements org.kevoree.modeling.util.maths.structure.KArray2D {

                                private _nbRows: number;
                                private _nbColumns: number;
                                private _back: Float64Array;
                                constructor(p_nbRows: number, p_nbColumns: number) {
                                    this._nbRows = p_nbRows;
                                    this._nbColumns = p_nbColumns;
                                    this._back = new Float64Array(p_nbRows * p_nbColumns);
                                }

                                public nbRows(): number {
                                    return this._nbRows;
                                }

                                public nbColumns(): number {
                                    return this._nbColumns;
                                }

                                public get(p_rowIndex: number, p_columnIndex: number): number {
                                    return this._back[(p_rowIndex * this._nbColumns) + p_columnIndex];
                                }

                                public set(p_rowIndex: number, p_columnIndex: number, value: number): number {
                                    this._back[(p_rowIndex * this._nbColumns) + p_columnIndex] = value;
                                    return value;
                                }

                                public add(rawIndex: number, columnIndex: number, value: number): number {
                                    return this.set(rawIndex, columnIndex, this.get(rawIndex, columnIndex) + value);
                                }

                            }

                        }
                    }
                }
            }
        }
    }
}
export module org {
    export class KevoreeModel extends org.kevoree.modeling.abs.AbstractKModel<org.KevoreeUniverse> {

        private _metaModel: org.kevoree.modeling.meta.KMetaModel;
        constructor(p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
            super(p_manager);
            this._metaModel = new org.kevoree.modeling.meta.impl.MetaModel("Kevoree");
            var tempMetaClasses: org.kevoree.modeling.meta.KMetaClass[] = new Array();
            tempMetaClasses[0] = org.kevoree.meta.MetaNamedElement.getInstance();
            tempMetaClasses[7] = org.kevoree.meta.MetaDictionary.getInstance();
            tempMetaClasses[16] = org.kevoree.meta.MetaPortType.getInstance();
            tempMetaClasses[2] = org.kevoree.meta.MetaNode.getInstance();
            tempMetaClasses[12] = org.kevoree.meta.MetaPort.getInstance();
            tempMetaClasses[13] = org.kevoree.meta.MetaFragmentDictionary.getInstance();
            tempMetaClasses[19] = org.kevoree.meta.MetaNodeType.getInstance();
            tempMetaClasses[10] = org.kevoree.meta.MetaNetworkInfo.getInstance();
            tempMetaClasses[18] = org.kevoree.meta.MetaGroupType.getInstance();
            tempMetaClasses[6] = org.kevoree.meta.MetaInstance.getInstance();
            tempMetaClasses[9] = org.kevoree.meta.MetaValue.getInstance();
            tempMetaClasses[5] = org.kevoree.meta.MetaNamespace.getInstance();
            tempMetaClasses[8] = org.kevoree.meta.MetaTypeDefinition.getInstance();
            tempMetaClasses[15] = org.kevoree.meta.MetaDeployUnit.getInstance();
            tempMetaClasses[21] = org.kevoree.meta.MetaAttributeType.getInstance();
            tempMetaClasses[20] = org.kevoree.meta.MetaChannelType.getInstance();
            tempMetaClasses[4] = org.kevoree.meta.MetaChannel.getInstance();
            tempMetaClasses[14] = org.kevoree.meta.MetaDictionaryType.getInstance();
            tempMetaClasses[3] = org.kevoree.meta.MetaGroup.getInstance();
            tempMetaClasses[11] = org.kevoree.meta.MetaComponent.getInstance();
            tempMetaClasses[17] = org.kevoree.meta.MetaComponentType.getInstance();
            tempMetaClasses[22] = org.kevoree.meta.MetaTypedElement.getInstance();
            tempMetaClasses[1] = org.kevoree.meta.MetaModel.getInstance();
            var tempEnums: org.kevoree.modeling.meta.KMetaEnum[] = new Array();
            tempEnums[0] = org.kevoree.meta.MetaDataType.getInstance();
            (<org.kevoree.modeling.meta.impl.MetaModel>this._metaModel).init(tempMetaClasses, tempEnums);
        }

        public internalCreateUniverse(key: number): org.KevoreeUniverse {
            return new org.KevoreeUniverse(key, this._manager);
        }

        public metaModel(): org.kevoree.modeling.meta.KMetaModel {
            return this._metaModel;
        }

        public internalCreateObject(universe: number, time: number, uuid: number, p_clazz: org.kevoree.modeling.meta.KMetaClass, previousUniverse: number, previousTime: number): org.kevoree.modeling.KObject {
            if (p_clazz == null) {
                return null;
            }
            switch (p_clazz.index()) {
                case 0:
                return new org.kevoree.impl.NamedElementImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 7:
                return new org.kevoree.impl.DictionaryImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 16:
                return new org.kevoree.impl.PortTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 2:
                return new org.kevoree.impl.NodeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 12:
                return new org.kevoree.impl.PortImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 13:
                return new org.kevoree.impl.FragmentDictionaryImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 19:
                return new org.kevoree.impl.NodeTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 10:
                return new org.kevoree.impl.NetworkInfoImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 18:
                return new org.kevoree.impl.GroupTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 6:
                return new org.kevoree.impl.InstanceImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 9:
                return new org.kevoree.impl.ValueImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 5:
                return new org.kevoree.impl.NamespaceImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 8:
                return new org.kevoree.impl.TypeDefinitionImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 15:
                return new org.kevoree.impl.DeployUnitImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 21:
                return new org.kevoree.impl.AttributeTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 20:
                return new org.kevoree.impl.ChannelTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 4:
                return new org.kevoree.impl.ChannelImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 14:
                return new org.kevoree.impl.DictionaryTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 3:
                return new org.kevoree.impl.GroupImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 11:
                return new org.kevoree.impl.ComponentImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 17:
                return new org.kevoree.impl.ComponentTypeImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 22:
                return new org.kevoree.impl.TypedElementImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                case 1:
                return new org.kevoree.impl.ModelImpl(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
                default:
                return new org.kevoree.modeling.meta.impl.GenericObject(universe, time, uuid, p_clazz, this._manager, previousUniverse, previousTime);
            }
        }

        public createNamedElement(universe: number, time: number): org.kevoree.NamedElement {
            return <org.kevoree.NamedElement>this.create(org.kevoree.meta.MetaNamedElement.getInstance(), universe, time);
        }

        public createDictionary(universe: number, time: number): org.kevoree.Dictionary {
            return <org.kevoree.Dictionary>this.create(org.kevoree.meta.MetaDictionary.getInstance(), universe, time);
        }

        public createPortType(universe: number, time: number): org.kevoree.PortType {
            return <org.kevoree.PortType>this.create(org.kevoree.meta.MetaPortType.getInstance(), universe, time);
        }

        public createNode(universe: number, time: number): org.kevoree.Node {
            return <org.kevoree.Node>this.create(org.kevoree.meta.MetaNode.getInstance(), universe, time);
        }

        public createPort(universe: number, time: number): org.kevoree.Port {
            return <org.kevoree.Port>this.create(org.kevoree.meta.MetaPort.getInstance(), universe, time);
        }

        public createFragmentDictionary(universe: number, time: number): org.kevoree.FragmentDictionary {
            return <org.kevoree.FragmentDictionary>this.create(org.kevoree.meta.MetaFragmentDictionary.getInstance(), universe, time);
        }

        public createNodeType(universe: number, time: number): org.kevoree.NodeType {
            return <org.kevoree.NodeType>this.create(org.kevoree.meta.MetaNodeType.getInstance(), universe, time);
        }

        public createNetworkInfo(universe: number, time: number): org.kevoree.NetworkInfo {
            return <org.kevoree.NetworkInfo>this.create(org.kevoree.meta.MetaNetworkInfo.getInstance(), universe, time);
        }

        public createGroupType(universe: number, time: number): org.kevoree.GroupType {
            return <org.kevoree.GroupType>this.create(org.kevoree.meta.MetaGroupType.getInstance(), universe, time);
        }

        public createInstance(universe: number, time: number): org.kevoree.Instance {
            return <org.kevoree.Instance>this.create(org.kevoree.meta.MetaInstance.getInstance(), universe, time);
        }

        public createValue(universe: number, time: number): org.kevoree.Value {
            return <org.kevoree.Value>this.create(org.kevoree.meta.MetaValue.getInstance(), universe, time);
        }

        public createNamespace(universe: number, time: number): org.kevoree.Namespace {
            return <org.kevoree.Namespace>this.create(org.kevoree.meta.MetaNamespace.getInstance(), universe, time);
        }

        public createTypeDefinition(universe: number, time: number): org.kevoree.TypeDefinition {
            return <org.kevoree.TypeDefinition>this.create(org.kevoree.meta.MetaTypeDefinition.getInstance(), universe, time);
        }

        public createDeployUnit(universe: number, time: number): org.kevoree.DeployUnit {
            return <org.kevoree.DeployUnit>this.create(org.kevoree.meta.MetaDeployUnit.getInstance(), universe, time);
        }

        public createAttributeType(universe: number, time: number): org.kevoree.AttributeType {
            return <org.kevoree.AttributeType>this.create(org.kevoree.meta.MetaAttributeType.getInstance(), universe, time);
        }

        public createChannelType(universe: number, time: number): org.kevoree.ChannelType {
            return <org.kevoree.ChannelType>this.create(org.kevoree.meta.MetaChannelType.getInstance(), universe, time);
        }

        public createChannel(universe: number, time: number): org.kevoree.Channel {
            return <org.kevoree.Channel>this.create(org.kevoree.meta.MetaChannel.getInstance(), universe, time);
        }

        public createDictionaryType(universe: number, time: number): org.kevoree.DictionaryType {
            return <org.kevoree.DictionaryType>this.create(org.kevoree.meta.MetaDictionaryType.getInstance(), universe, time);
        }

        public createGroup(universe: number, time: number): org.kevoree.Group {
            return <org.kevoree.Group>this.create(org.kevoree.meta.MetaGroup.getInstance(), universe, time);
        }

        public createComponent(universe: number, time: number): org.kevoree.Component {
            return <org.kevoree.Component>this.create(org.kevoree.meta.MetaComponent.getInstance(), universe, time);
        }

        public createComponentType(universe: number, time: number): org.kevoree.ComponentType {
            return <org.kevoree.ComponentType>this.create(org.kevoree.meta.MetaComponentType.getInstance(), universe, time);
        }

        public createTypedElement(universe: number, time: number): org.kevoree.TypedElement {
            return <org.kevoree.TypedElement>this.create(org.kevoree.meta.MetaTypedElement.getInstance(), universe, time);
        }

        public createModel(universe: number, time: number): org.kevoree.Model {
            return <org.kevoree.Model>this.create(org.kevoree.meta.MetaModel.getInstance(), universe, time);
        }

    }

    export class KevoreeUniverse extends org.kevoree.modeling.abs.AbstractKUniverse<org.KevoreeView, org.KevoreeUniverse> {

        constructor(p_key: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
            super(p_key, p_manager);
        }

        public internal_create(timePoint: number): org.KevoreeView {
            return new org.impl.KevoreeViewImpl(this._universe, timePoint, this._manager);
        }

    }

    export interface KevoreeView extends org.kevoree.modeling.KView {

        createNamedElement(): org.kevoree.NamedElement;

        createDictionary(): org.kevoree.Dictionary;

        createPortType(): org.kevoree.PortType;

        createNode(): org.kevoree.Node;

        createPort(): org.kevoree.Port;

        createFragmentDictionary(): org.kevoree.FragmentDictionary;

        createNodeType(): org.kevoree.NodeType;

        createNetworkInfo(): org.kevoree.NetworkInfo;

        createGroupType(): org.kevoree.GroupType;

        createInstance(): org.kevoree.Instance;

        createValue(): org.kevoree.Value;

        createNamespace(): org.kevoree.Namespace;

        createTypeDefinition(): org.kevoree.TypeDefinition;

        createDeployUnit(): org.kevoree.DeployUnit;

        createAttributeType(): org.kevoree.AttributeType;

        createChannelType(): org.kevoree.ChannelType;

        createChannel(): org.kevoree.Channel;

        createDictionaryType(): org.kevoree.DictionaryType;

        createGroup(): org.kevoree.Group;

        createComponent(): org.kevoree.Component;

        createComponentType(): org.kevoree.ComponentType;

        createTypedElement(): org.kevoree.TypedElement;

        createModel(): org.kevoree.Model;

    }

    export module impl {
        export class KevoreeViewImpl extends org.kevoree.modeling.abs.AbstractKView implements org.KevoreeView {

            constructor(p_universe: number, _time: number, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager) {
                super(p_universe, _time, p_manager);
            }

            public createNamedElement(): org.kevoree.NamedElement {
                return <org.kevoree.NamedElement>this.create(org.kevoree.meta.MetaNamedElement.getInstance());
            }

            public createDictionary(): org.kevoree.Dictionary {
                return <org.kevoree.Dictionary>this.create(org.kevoree.meta.MetaDictionary.getInstance());
            }

            public createPortType(): org.kevoree.PortType {
                return <org.kevoree.PortType>this.create(org.kevoree.meta.MetaPortType.getInstance());
            }

            public createNode(): org.kevoree.Node {
                return <org.kevoree.Node>this.create(org.kevoree.meta.MetaNode.getInstance());
            }

            public createPort(): org.kevoree.Port {
                return <org.kevoree.Port>this.create(org.kevoree.meta.MetaPort.getInstance());
            }

            public createFragmentDictionary(): org.kevoree.FragmentDictionary {
                return <org.kevoree.FragmentDictionary>this.create(org.kevoree.meta.MetaFragmentDictionary.getInstance());
            }

            public createNodeType(): org.kevoree.NodeType {
                return <org.kevoree.NodeType>this.create(org.kevoree.meta.MetaNodeType.getInstance());
            }

            public createNetworkInfo(): org.kevoree.NetworkInfo {
                return <org.kevoree.NetworkInfo>this.create(org.kevoree.meta.MetaNetworkInfo.getInstance());
            }

            public createGroupType(): org.kevoree.GroupType {
                return <org.kevoree.GroupType>this.create(org.kevoree.meta.MetaGroupType.getInstance());
            }

            public createInstance(): org.kevoree.Instance {
                return <org.kevoree.Instance>this.create(org.kevoree.meta.MetaInstance.getInstance());
            }

            public createValue(): org.kevoree.Value {
                return <org.kevoree.Value>this.create(org.kevoree.meta.MetaValue.getInstance());
            }

            public createNamespace(): org.kevoree.Namespace {
                return <org.kevoree.Namespace>this.create(org.kevoree.meta.MetaNamespace.getInstance());
            }

            public createTypeDefinition(): org.kevoree.TypeDefinition {
                return <org.kevoree.TypeDefinition>this.create(org.kevoree.meta.MetaTypeDefinition.getInstance());
            }

            public createDeployUnit(): org.kevoree.DeployUnit {
                return <org.kevoree.DeployUnit>this.create(org.kevoree.meta.MetaDeployUnit.getInstance());
            }

            public createAttributeType(): org.kevoree.AttributeType {
                return <org.kevoree.AttributeType>this.create(org.kevoree.meta.MetaAttributeType.getInstance());
            }

            public createChannelType(): org.kevoree.ChannelType {
                return <org.kevoree.ChannelType>this.create(org.kevoree.meta.MetaChannelType.getInstance());
            }

            public createChannel(): org.kevoree.Channel {
                return <org.kevoree.Channel>this.create(org.kevoree.meta.MetaChannel.getInstance());
            }

            public createDictionaryType(): org.kevoree.DictionaryType {
                return <org.kevoree.DictionaryType>this.create(org.kevoree.meta.MetaDictionaryType.getInstance());
            }

            public createGroup(): org.kevoree.Group {
                return <org.kevoree.Group>this.create(org.kevoree.meta.MetaGroup.getInstance());
            }

            public createComponent(): org.kevoree.Component {
                return <org.kevoree.Component>this.create(org.kevoree.meta.MetaComponent.getInstance());
            }

            public createComponentType(): org.kevoree.ComponentType {
                return <org.kevoree.ComponentType>this.create(org.kevoree.meta.MetaComponentType.getInstance());
            }

            public createTypedElement(): org.kevoree.TypedElement {
                return <org.kevoree.TypedElement>this.create(org.kevoree.meta.MetaTypedElement.getInstance());
            }

            public createModel(): org.kevoree.Model {
                return <org.kevoree.Model>this.create(org.kevoree.meta.MetaModel.getInstance());
            }

        }

    }
    export module kevoree {
        export interface AttributeType extends org.kevoree.modeling.KObject, org.kevoree.TypedElement {

            getDatatype(): org.kevoree.DataType;

            setDatatype(p_obj: org.kevoree.DataType): org.kevoree.AttributeType;

            getDefaultValue(): string;

            setDefaultValue(p_obj: string): org.kevoree.AttributeType;

            getFragmentDependant(): boolean;

            setFragmentDependant(p_obj: boolean): org.kevoree.AttributeType;

            getName(): string;

            setName(p_obj: string): org.kevoree.AttributeType;

            getOptional(): boolean;

            setOptional(p_obj: boolean): org.kevoree.AttributeType;

            addGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.AttributeType;

            removeGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.AttributeType;

            getGenericTypes(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfGenericTypes(): number;

        }

        export interface Channel extends org.kevoree.modeling.KObject, org.kevoree.Instance {

            getName(): string;

            setName(p_obj: string): org.kevoree.Channel;

            getStarted(): boolean;

            setStarted(p_obj: boolean): org.kevoree.Channel;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.Channel;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Channel;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Channel;

            getDictionary(cb: org.kevoree.modeling.KCallback<any>): void;

            setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Channel;

            getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void;

            addPorts(p_obj: org.kevoree.Port): org.kevoree.Channel;

            removePorts(p_obj: org.kevoree.Port): org.kevoree.Channel;

            getPorts(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfPorts(): number;

            addFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Channel;

            removeFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Channel;

            getFragmentDictionaries(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfFragmentDictionaries(): number;

        }

        export interface ChannelType extends org.kevoree.modeling.KObject, org.kevoree.TypeDefinition {

            getName(): string;

            setName(p_obj: string): org.kevoree.ChannelType;

            getAbstract(): boolean;

            setAbstract(p_obj: boolean): org.kevoree.ChannelType;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.ChannelType;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.ChannelType;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.ChannelType;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ChannelType;

            removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ChannelType;

            getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfDeployUnits(): number;

            setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.ChannelType;

            getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface Component extends org.kevoree.modeling.KObject, org.kevoree.Instance {

            getName(): string;

            setName(p_obj: string): org.kevoree.Component;

            getStarted(): boolean;

            setStarted(p_obj: boolean): org.kevoree.Component;

            addOutputs(p_obj: org.kevoree.Port): org.kevoree.Component;

            removeOutputs(p_obj: org.kevoree.Port): org.kevoree.Component;

            getOutputs(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfOutputs(): number;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.Component;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Component;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Component;

            getDictionary(cb: org.kevoree.modeling.KCallback<any>): void;

            addInputs(p_obj: org.kevoree.Port): org.kevoree.Component;

            removeInputs(p_obj: org.kevoree.Port): org.kevoree.Component;

            getInputs(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfInputs(): number;

            setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Component;

            getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface ComponentType extends org.kevoree.modeling.KObject, org.kevoree.TypeDefinition {

            getName(): string;

            setName(p_obj: string): org.kevoree.ComponentType;

            getAbstract(): boolean;

            setAbstract(p_obj: boolean): org.kevoree.ComponentType;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.ComponentType;

            addOutputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType;

            removeOutputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType;

            getOutputs(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfOutputs(): number;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.ComponentType;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.ComponentType;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addInputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType;

            removeInputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType;

            getInputs(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfInputs(): number;

            addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ComponentType;

            removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ComponentType;

            getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfDeployUnits(): number;

            setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.ComponentType;

            getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface DataType extends org.kevoree.modeling.meta.KLiteral {

        }

        export interface DeployUnit extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getHashcode(): string;

            setHashcode(p_obj: string): org.kevoree.DeployUnit;

            getName(): string;

            setName(p_obj: string): org.kevoree.DeployUnit;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.DeployUnit;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.DeployUnit;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.DeployUnit;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addRequiredLibs(p_obj: org.kevoree.DeployUnit): org.kevoree.DeployUnit;

            removeRequiredLibs(p_obj: org.kevoree.DeployUnit): org.kevoree.DeployUnit;

            getRequiredLibs(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfRequiredLibs(): number;

        }

        export interface Dictionary extends org.kevoree.modeling.KObject {

            addValues(p_obj: org.kevoree.Value): org.kevoree.Dictionary;

            removeValues(p_obj: org.kevoree.Value): org.kevoree.Dictionary;

            getValues(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfValues(): number;

        }

        export interface DictionaryType extends org.kevoree.modeling.KObject {

            addAttributes(p_obj: org.kevoree.AttributeType): org.kevoree.DictionaryType;

            removeAttributes(p_obj: org.kevoree.AttributeType): org.kevoree.DictionaryType;

            getAttributes(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfAttributes(): number;

        }

        export interface FragmentDictionary extends org.kevoree.modeling.KObject, org.kevoree.Dictionary {

            setNode(p_obj: org.kevoree.Node): org.kevoree.FragmentDictionary;

            getNode(cb: org.kevoree.modeling.KCallback<any>): void;

            addValues(p_obj: org.kevoree.Value): org.kevoree.FragmentDictionary;

            removeValues(p_obj: org.kevoree.Value): org.kevoree.FragmentDictionary;

            getValues(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfValues(): number;

        }

        export interface Group extends org.kevoree.modeling.KObject, org.kevoree.Instance {

            getName(): string;

            setName(p_obj: string): org.kevoree.Group;

            getStarted(): boolean;

            setStarted(p_obj: boolean): org.kevoree.Group;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.Group;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Group;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addNodes(p_obj: org.kevoree.Node): org.kevoree.Group;

            removeNodes(p_obj: org.kevoree.Node): org.kevoree.Group;

            getNodes(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfNodes(): number;

            setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Group;

            getDictionary(cb: org.kevoree.modeling.KCallback<any>): void;

            setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Group;

            getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void;

            addFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Group;

            removeFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Group;

            getFragmentDictionaries(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfFragmentDictionaries(): number;

        }

        export interface GroupType extends org.kevoree.modeling.KObject, org.kevoree.TypeDefinition {

            getName(): string;

            setName(p_obj: string): org.kevoree.GroupType;

            getAbstract(): boolean;

            setAbstract(p_obj: boolean): org.kevoree.GroupType;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.GroupType;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.GroupType;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.GroupType;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.GroupType;

            removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.GroupType;

            getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfDeployUnits(): number;

            setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.GroupType;

            getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface Instance extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.Instance;

            getStarted(): boolean;

            setStarted(p_obj: boolean): org.kevoree.Instance;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.Instance;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Instance;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Instance;

            getDictionary(cb: org.kevoree.modeling.KCallback<any>): void;

            setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Instance;

            getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface Model extends org.kevoree.modeling.KObject {

            addNodes(p_obj: org.kevoree.Node): org.kevoree.Model;

            removeNodes(p_obj: org.kevoree.Node): org.kevoree.Model;

            getNodes(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfNodes(): number;

            addChannels(p_obj: org.kevoree.Channel): org.kevoree.Model;

            removeChannels(p_obj: org.kevoree.Channel): org.kevoree.Model;

            getChannels(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfChannels(): number;

            addGroups(p_obj: org.kevoree.Group): org.kevoree.Model;

            removeGroups(p_obj: org.kevoree.Group): org.kevoree.Model;

            getGroups(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfGroups(): number;

            addNamespaces(p_obj: org.kevoree.Namespace): org.kevoree.Model;

            removeNamespaces(p_obj: org.kevoree.Namespace): org.kevoree.Model;

            getNamespaces(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfNamespaces(): number;

        }

        export interface NamedElement extends org.kevoree.modeling.KObject {

            getName(): string;

            setName(p_obj: string): org.kevoree.NamedElement;

        }

        export interface Namespace extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.Namespace;

            addTypeDefinitions(p_obj: org.kevoree.TypeDefinition): org.kevoree.Namespace;

            removeTypeDefinitions(p_obj: org.kevoree.TypeDefinition): org.kevoree.Namespace;

            getTypeDefinitions(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfTypeDefinitions(): number;

        }

        export interface NetworkInfo extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.NetworkInfo;

            addValues(p_obj: org.kevoree.Value): org.kevoree.NetworkInfo;

            removeValues(p_obj: org.kevoree.Value): org.kevoree.NetworkInfo;

            getValues(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfValues(): number;

        }

        export interface Node extends org.kevoree.modeling.KObject, org.kevoree.Instance {

            getName(): string;

            setName(p_obj: string): org.kevoree.Node;

            getStarted(): boolean;

            setStarted(p_obj: boolean): org.kevoree.Node;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.Node;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Node;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addComponents(p_obj: org.kevoree.Component): org.kevoree.Node;

            removeComponents(p_obj: org.kevoree.Component): org.kevoree.Node;

            getComponents(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfComponents(): number;

            setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Node;

            getDictionary(cb: org.kevoree.modeling.KCallback<any>): void;

            addChildren(p_obj: org.kevoree.Node): org.kevoree.Node;

            removeChildren(p_obj: org.kevoree.Node): org.kevoree.Node;

            getChildren(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfChildren(): number;

            setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Node;

            getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void;

            addHost(p_obj: org.kevoree.Node): org.kevoree.Node;

            removeHost(p_obj: org.kevoree.Node): org.kevoree.Node;

            getHost(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfHost(): number;

            addGroups(p_obj: org.kevoree.Group): org.kevoree.Node;

            removeGroups(p_obj: org.kevoree.Group): org.kevoree.Node;

            getGroups(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfGroups(): number;

            addNetworks(p_obj: org.kevoree.NetworkInfo): org.kevoree.Node;

            removeNetworks(p_obj: org.kevoree.NetworkInfo): org.kevoree.Node;

            getNetworks(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfNetworks(): number;

        }

        export interface NodeType extends org.kevoree.modeling.KObject, org.kevoree.TypeDefinition {

            getName(): string;

            setName(p_obj: string): org.kevoree.NodeType;

            getAbstract(): boolean;

            setAbstract(p_obj: boolean): org.kevoree.NodeType;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.NodeType;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.NodeType;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.NodeType;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.NodeType;

            removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.NodeType;

            getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfDeployUnits(): number;

            setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.NodeType;

            getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface Port extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.Port;

            addChannels(p_obj: org.kevoree.Channel): org.kevoree.Port;

            removeChannels(p_obj: org.kevoree.Channel): org.kevoree.Port;

            getChannels(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfChannels(): number;

        }

        export interface PortType extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.PortType;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.PortType;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.PortType;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

        }

        export interface TypeDefinition extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.TypeDefinition;

            getAbstract(): boolean;

            setAbstract(p_obj: boolean): org.kevoree.TypeDefinition;

            getVersion(): string;

            setVersion(p_obj: string): org.kevoree.TypeDefinition;

            addMetaData(p_obj: org.kevoree.Value): org.kevoree.TypeDefinition;

            removeMetaData(p_obj: org.kevoree.Value): org.kevoree.TypeDefinition;

            getMetaData(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfMetaData(): number;

            addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.TypeDefinition;

            removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.TypeDefinition;

            getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfDeployUnits(): number;

            setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.TypeDefinition;

            getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void;

        }

        export interface TypedElement extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.TypedElement;

            addGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.TypedElement;

            removeGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.TypedElement;

            getGenericTypes(cb: org.kevoree.modeling.KCallback<any>): void;

            sizeOfGenericTypes(): number;

        }

        export interface Value extends org.kevoree.modeling.KObject, org.kevoree.NamedElement {

            getName(): string;

            setName(p_obj: string): org.kevoree.Value;

            getValue(): string;

            setValue(p_obj: string): org.kevoree.Value;

        }

        export module impl {
            export class AttributeTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.AttributeType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getDatatype(): org.kevoree.DataType {
                    return <org.kevoree.DataType>this.get(org.kevoree.meta.MetaAttributeType.ATT_DATATYPE);
                }

                public setDatatype(p_obj: org.kevoree.DataType): org.kevoree.AttributeType {
                    this.set(org.kevoree.meta.MetaAttributeType.ATT_DATATYPE, p_obj);
                    return this;
                }

                public getDefaultValue(): string {
                    return <string>this.get(org.kevoree.meta.MetaAttributeType.ATT_DEFAULTVALUE);
                }

                public setDefaultValue(p_obj: string): org.kevoree.AttributeType {
                    this.set(org.kevoree.meta.MetaAttributeType.ATT_DEFAULTVALUE, p_obj);
                    return this;
                }

                public getFragmentDependant(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaAttributeType.ATT_FRAGMENTDEPENDANT);
                }

                public setFragmentDependant(p_obj: boolean): org.kevoree.AttributeType {
                    this.set(org.kevoree.meta.MetaAttributeType.ATT_FRAGMENTDEPENDANT, p_obj);
                    return this;
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaAttributeType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.AttributeType {
                    this.set(org.kevoree.meta.MetaAttributeType.ATT_NAME, p_obj);
                    return this;
                }

                public getOptional(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaAttributeType.ATT_OPTIONAL);
                }

                public setOptional(p_obj: boolean): org.kevoree.AttributeType {
                    this.set(org.kevoree.meta.MetaAttributeType.ATT_OPTIONAL, p_obj);
                    return this;
                }

                public addGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.AttributeType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaAttributeType.REF_GENERICTYPES, p_obj);
                    return this;
                }

                public removeGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.AttributeType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaAttributeType.REF_GENERICTYPES, p_obj);
                    return this;
                }

                public getGenericTypes(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaAttributeType.REF_GENERICTYPES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.TypedElement[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.TypedElement>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfGenericTypes(): number {
                    return this.size(org.kevoree.meta.MetaAttributeType.REF_GENERICTYPES);
                }

            }

            export class ChannelImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Channel {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaChannel.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Channel {
                    this.set(org.kevoree.meta.MetaChannel.ATT_NAME, p_obj);
                    return this;
                }

                public getStarted(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaChannel.ATT_STARTED);
                }

                public setStarted(p_obj: boolean): org.kevoree.Channel {
                    this.set(org.kevoree.meta.MetaChannel.ATT_STARTED, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaChannel.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaChannel.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannel.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaChannel.REF_METADATA);
                }

                public setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaChannel.REF_DICTIONARY, p_obj);
                    return this;
                }

                public getDictionary(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannel.REF_DICTIONARY,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Dictionary>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaChannel.REF_TYPEDEFINITION, p_obj);
                    return this;
                }

                public getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannel.REF_TYPEDEFINITION,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.TypeDefinition>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addPorts(p_obj: org.kevoree.Port): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaChannel.REF_PORTS, p_obj);
                    return this;
                }

                public removePorts(p_obj: org.kevoree.Port): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaChannel.REF_PORTS, p_obj);
                    return this;
                }

                public getPorts(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannel.REF_PORTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Port[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Port>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfPorts(): number {
                    return this.size(org.kevoree.meta.MetaChannel.REF_PORTS);
                }

                public addFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaChannel.REF_FRAGMENTDICTIONARIES, p_obj);
                    return this;
                }

                public removeFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Channel {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaChannel.REF_FRAGMENTDICTIONARIES, p_obj);
                    return this;
                }

                public getFragmentDictionaries(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannel.REF_FRAGMENTDICTIONARIES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.FragmentDictionary[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.FragmentDictionary>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfFragmentDictionaries(): number {
                    return this.size(org.kevoree.meta.MetaChannel.REF_FRAGMENTDICTIONARIES);
                }

            }

            export class ChannelTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.ChannelType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaChannelType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.ChannelType {
                    this.set(org.kevoree.meta.MetaChannelType.ATT_NAME, p_obj);
                    return this;
                }

                public getAbstract(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaChannelType.ATT_ABSTRACT);
                }

                public setAbstract(p_obj: boolean): org.kevoree.ChannelType {
                    this.set(org.kevoree.meta.MetaChannelType.ATT_ABSTRACT, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaChannelType.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.ChannelType {
                    this.set(org.kevoree.meta.MetaChannelType.ATT_VERSION, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.ChannelType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaChannelType.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.ChannelType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaChannelType.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannelType.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaChannelType.REF_METADATA);
                }

                public addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ChannelType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaChannelType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ChannelType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaChannelType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannelType.REF_DEPLOYUNITS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfDeployUnits(): number {
                    return this.size(org.kevoree.meta.MetaChannelType.REF_DEPLOYUNITS);
                }

                public setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.ChannelType {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaChannelType.REF_DICTIONARYTYPE, p_obj);
                    return this;
                }

                public getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaChannelType.REF_DICTIONARYTYPE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.DictionaryType>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class ComponentImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Component {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaComponent.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Component {
                    this.set(org.kevoree.meta.MetaComponent.ATT_NAME, p_obj);
                    return this;
                }

                public getStarted(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaComponent.ATT_STARTED);
                }

                public setStarted(p_obj: boolean): org.kevoree.Component {
                    this.set(org.kevoree.meta.MetaComponent.ATT_STARTED, p_obj);
                    return this;
                }

                public addOutputs(p_obj: org.kevoree.Port): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponent.REF_OUTPUTS, p_obj);
                    return this;
                }

                public removeOutputs(p_obj: org.kevoree.Port): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponent.REF_OUTPUTS, p_obj);
                    return this;
                }

                public getOutputs(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponent.REF_OUTPUTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Port[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Port>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfOutputs(): number {
                    return this.size(org.kevoree.meta.MetaComponent.REF_OUTPUTS);
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponent.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponent.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponent.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaComponent.REF_METADATA);
                }

                public setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaComponent.REF_DICTIONARY, p_obj);
                    return this;
                }

                public getDictionary(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponent.REF_DICTIONARY,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Dictionary>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addInputs(p_obj: org.kevoree.Port): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponent.REF_INPUTS, p_obj);
                    return this;
                }

                public removeInputs(p_obj: org.kevoree.Port): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponent.REF_INPUTS, p_obj);
                    return this;
                }

                public getInputs(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponent.REF_INPUTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Port[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Port>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfInputs(): number {
                    return this.size(org.kevoree.meta.MetaComponent.REF_INPUTS);
                }

                public setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Component {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaComponent.REF_TYPEDEFINITION, p_obj);
                    return this;
                }

                public getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponent.REF_TYPEDEFINITION,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.TypeDefinition>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class ComponentTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.ComponentType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaComponentType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.ComponentType {
                    this.set(org.kevoree.meta.MetaComponentType.ATT_NAME, p_obj);
                    return this;
                }

                public getAbstract(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaComponentType.ATT_ABSTRACT);
                }

                public setAbstract(p_obj: boolean): org.kevoree.ComponentType {
                    this.set(org.kevoree.meta.MetaComponentType.ATT_ABSTRACT, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaComponentType.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.ComponentType {
                    this.set(org.kevoree.meta.MetaComponentType.ATT_VERSION, p_obj);
                    return this;
                }

                public addOutputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponentType.REF_OUTPUTS, p_obj);
                    return this;
                }

                public removeOutputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponentType.REF_OUTPUTS, p_obj);
                    return this;
                }

                public getOutputs(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponentType.REF_OUTPUTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.PortType[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.PortType>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfOutputs(): number {
                    return this.size(org.kevoree.meta.MetaComponentType.REF_OUTPUTS);
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponentType.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponentType.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponentType.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaComponentType.REF_METADATA);
                }

                public addInputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponentType.REF_INPUTS, p_obj);
                    return this;
                }

                public removeInputs(p_obj: org.kevoree.PortType): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponentType.REF_INPUTS, p_obj);
                    return this;
                }

                public getInputs(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponentType.REF_INPUTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.PortType[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.PortType>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfInputs(): number {
                    return this.size(org.kevoree.meta.MetaComponentType.REF_INPUTS);
                }

                public addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaComponentType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaComponentType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponentType.REF_DEPLOYUNITS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfDeployUnits(): number {
                    return this.size(org.kevoree.meta.MetaComponentType.REF_DEPLOYUNITS);
                }

                public setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.ComponentType {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaComponentType.REF_DICTIONARYTYPE, p_obj);
                    return this;
                }

                public getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaComponentType.REF_DICTIONARYTYPE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.DictionaryType>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class DataTypeLiteral extends org.kevoree.modeling.meta.impl.MetaLiteral implements org.kevoree.DataType {

                constructor(p_name: string, p_index: number, p_className: string) {
                    super(p_name, p_index, p_className);
                }

            }

            export class DeployUnitImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.DeployUnit {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getHashcode(): string {
                    return <string>this.get(org.kevoree.meta.MetaDeployUnit.ATT_HASHCODE);
                }

                public setHashcode(p_obj: string): org.kevoree.DeployUnit {
                    this.set(org.kevoree.meta.MetaDeployUnit.ATT_HASHCODE, p_obj);
                    return this;
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaDeployUnit.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.DeployUnit {
                    this.set(org.kevoree.meta.MetaDeployUnit.ATT_NAME, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaDeployUnit.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.DeployUnit {
                    this.set(org.kevoree.meta.MetaDeployUnit.ATT_VERSION, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.DeployUnit {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaDeployUnit.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.DeployUnit {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaDeployUnit.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaDeployUnit.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaDeployUnit.REF_METADATA);
                }

                public addRequiredLibs(p_obj: org.kevoree.DeployUnit): org.kevoree.DeployUnit {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaDeployUnit.REF_REQUIREDLIBS, p_obj);
                    return this;
                }

                public removeRequiredLibs(p_obj: org.kevoree.DeployUnit): org.kevoree.DeployUnit {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaDeployUnit.REF_REQUIREDLIBS, p_obj);
                    return this;
                }

                public getRequiredLibs(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaDeployUnit.REF_REQUIREDLIBS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfRequiredLibs(): number {
                    return this.size(org.kevoree.meta.MetaDeployUnit.REF_REQUIREDLIBS);
                }

            }

            export class DictionaryImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Dictionary {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public addValues(p_obj: org.kevoree.Value): org.kevoree.Dictionary {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaDictionary.REF_VALUES, p_obj);
                    return this;
                }

                public removeValues(p_obj: org.kevoree.Value): org.kevoree.Dictionary {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaDictionary.REF_VALUES, p_obj);
                    return this;
                }

                public getValues(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaDictionary.REF_VALUES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfValues(): number {
                    return this.size(org.kevoree.meta.MetaDictionary.REF_VALUES);
                }

            }

            export class DictionaryTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.DictionaryType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public addAttributes(p_obj: org.kevoree.AttributeType): org.kevoree.DictionaryType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaDictionaryType.REF_ATTRIBUTES, p_obj);
                    return this;
                }

                public removeAttributes(p_obj: org.kevoree.AttributeType): org.kevoree.DictionaryType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaDictionaryType.REF_ATTRIBUTES, p_obj);
                    return this;
                }

                public getAttributes(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaDictionaryType.REF_ATTRIBUTES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.AttributeType[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.AttributeType>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfAttributes(): number {
                    return this.size(org.kevoree.meta.MetaDictionaryType.REF_ATTRIBUTES);
                }

            }

            export class FragmentDictionaryImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.FragmentDictionary {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public setNode(p_obj: org.kevoree.Node): org.kevoree.FragmentDictionary {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaFragmentDictionary.REF_NODE, p_obj);
                    return this;
                }

                public getNode(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaFragmentDictionary.REF_NODE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Node>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addValues(p_obj: org.kevoree.Value): org.kevoree.FragmentDictionary {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaFragmentDictionary.REF_VALUES, p_obj);
                    return this;
                }

                public removeValues(p_obj: org.kevoree.Value): org.kevoree.FragmentDictionary {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaFragmentDictionary.REF_VALUES, p_obj);
                    return this;
                }

                public getValues(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaFragmentDictionary.REF_VALUES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfValues(): number {
                    return this.size(org.kevoree.meta.MetaFragmentDictionary.REF_VALUES);
                }

            }

            export class GroupImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Group {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaGroup.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Group {
                    this.set(org.kevoree.meta.MetaGroup.ATT_NAME, p_obj);
                    return this;
                }

                public getStarted(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaGroup.ATT_STARTED);
                }

                public setStarted(p_obj: boolean): org.kevoree.Group {
                    this.set(org.kevoree.meta.MetaGroup.ATT_STARTED, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaGroup.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaGroup.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroup.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaGroup.REF_METADATA);
                }

                public addNodes(p_obj: org.kevoree.Node): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaGroup.REF_NODES, p_obj);
                    return this;
                }

                public removeNodes(p_obj: org.kevoree.Node): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaGroup.REF_NODES, p_obj);
                    return this;
                }

                public getNodes(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroup.REF_NODES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Node[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Node>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfNodes(): number {
                    return this.size(org.kevoree.meta.MetaGroup.REF_NODES);
                }

                public setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaGroup.REF_DICTIONARY, p_obj);
                    return this;
                }

                public getDictionary(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroup.REF_DICTIONARY,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Dictionary>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaGroup.REF_TYPEDEFINITION, p_obj);
                    return this;
                }

                public getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroup.REF_TYPEDEFINITION,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.TypeDefinition>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaGroup.REF_FRAGMENTDICTIONARIES, p_obj);
                    return this;
                }

                public removeFragmentDictionaries(p_obj: org.kevoree.FragmentDictionary): org.kevoree.Group {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaGroup.REF_FRAGMENTDICTIONARIES, p_obj);
                    return this;
                }

                public getFragmentDictionaries(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroup.REF_FRAGMENTDICTIONARIES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.FragmentDictionary[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.FragmentDictionary>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfFragmentDictionaries(): number {
                    return this.size(org.kevoree.meta.MetaGroup.REF_FRAGMENTDICTIONARIES);
                }

            }

            export class GroupTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.GroupType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaGroupType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.GroupType {
                    this.set(org.kevoree.meta.MetaGroupType.ATT_NAME, p_obj);
                    return this;
                }

                public getAbstract(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaGroupType.ATT_ABSTRACT);
                }

                public setAbstract(p_obj: boolean): org.kevoree.GroupType {
                    this.set(org.kevoree.meta.MetaGroupType.ATT_ABSTRACT, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaGroupType.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.GroupType {
                    this.set(org.kevoree.meta.MetaGroupType.ATT_VERSION, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.GroupType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaGroupType.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.GroupType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaGroupType.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroupType.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaGroupType.REF_METADATA);
                }

                public addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.GroupType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaGroupType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.GroupType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaGroupType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroupType.REF_DEPLOYUNITS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfDeployUnits(): number {
                    return this.size(org.kevoree.meta.MetaGroupType.REF_DEPLOYUNITS);
                }

                public setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.GroupType {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaGroupType.REF_DICTIONARYTYPE, p_obj);
                    return this;
                }

                public getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaGroupType.REF_DICTIONARYTYPE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.DictionaryType>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class InstanceImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Instance {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaInstance.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Instance {
                    this.set(org.kevoree.meta.MetaInstance.ATT_NAME, p_obj);
                    return this;
                }

                public getStarted(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaInstance.ATT_STARTED);
                }

                public setStarted(p_obj: boolean): org.kevoree.Instance {
                    this.set(org.kevoree.meta.MetaInstance.ATT_STARTED, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.Instance {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaInstance.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Instance {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaInstance.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaInstance.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaInstance.REF_METADATA);
                }

                public setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Instance {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaInstance.REF_DICTIONARY, p_obj);
                    return this;
                }

                public getDictionary(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaInstance.REF_DICTIONARY,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Dictionary>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Instance {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaInstance.REF_TYPEDEFINITION, p_obj);
                    return this;
                }

                public getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaInstance.REF_TYPEDEFINITION,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.TypeDefinition>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class ModelImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Model {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public addNodes(p_obj: org.kevoree.Node): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaModel.REF_NODES, p_obj);
                    return this;
                }

                public removeNodes(p_obj: org.kevoree.Node): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaModel.REF_NODES, p_obj);
                    return this;
                }

                public getNodes(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaModel.REF_NODES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Node[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Node>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfNodes(): number {
                    return this.size(org.kevoree.meta.MetaModel.REF_NODES);
                }

                public addChannels(p_obj: org.kevoree.Channel): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaModel.REF_CHANNELS, p_obj);
                    return this;
                }

                public removeChannels(p_obj: org.kevoree.Channel): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaModel.REF_CHANNELS, p_obj);
                    return this;
                }

                public getChannels(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaModel.REF_CHANNELS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Channel[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Channel>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfChannels(): number {
                    return this.size(org.kevoree.meta.MetaModel.REF_CHANNELS);
                }

                public addGroups(p_obj: org.kevoree.Group): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaModel.REF_GROUPS, p_obj);
                    return this;
                }

                public removeGroups(p_obj: org.kevoree.Group): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaModel.REF_GROUPS, p_obj);
                    return this;
                }

                public getGroups(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaModel.REF_GROUPS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Group[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Group>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfGroups(): number {
                    return this.size(org.kevoree.meta.MetaModel.REF_GROUPS);
                }

                public addNamespaces(p_obj: org.kevoree.Namespace): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaModel.REF_NAMESPACES, p_obj);
                    return this;
                }

                public removeNamespaces(p_obj: org.kevoree.Namespace): org.kevoree.Model {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaModel.REF_NAMESPACES, p_obj);
                    return this;
                }

                public getNamespaces(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaModel.REF_NAMESPACES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Namespace[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Namespace>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfNamespaces(): number {
                    return this.size(org.kevoree.meta.MetaModel.REF_NAMESPACES);
                }

            }

            export class NamedElementImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.NamedElement {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaNamedElement.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.NamedElement {
                    this.set(org.kevoree.meta.MetaNamedElement.ATT_NAME, p_obj);
                    return this;
                }

            }

            export class NamespaceImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Namespace {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaNamespace.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Namespace {
                    this.set(org.kevoree.meta.MetaNamespace.ATT_NAME, p_obj);
                    return this;
                }

                public addTypeDefinitions(p_obj: org.kevoree.TypeDefinition): org.kevoree.Namespace {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNamespace.REF_TYPEDEFINITIONS, p_obj);
                    return this;
                }

                public removeTypeDefinitions(p_obj: org.kevoree.TypeDefinition): org.kevoree.Namespace {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNamespace.REF_TYPEDEFINITIONS, p_obj);
                    return this;
                }

                public getTypeDefinitions(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNamespace.REF_TYPEDEFINITIONS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.TypeDefinition[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.TypeDefinition>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfTypeDefinitions(): number {
                    return this.size(org.kevoree.meta.MetaNamespace.REF_TYPEDEFINITIONS);
                }

            }

            export class NetworkInfoImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.NetworkInfo {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaNetworkInfo.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.NetworkInfo {
                    this.set(org.kevoree.meta.MetaNetworkInfo.ATT_NAME, p_obj);
                    return this;
                }

                public addValues(p_obj: org.kevoree.Value): org.kevoree.NetworkInfo {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNetworkInfo.REF_VALUES, p_obj);
                    return this;
                }

                public removeValues(p_obj: org.kevoree.Value): org.kevoree.NetworkInfo {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNetworkInfo.REF_VALUES, p_obj);
                    return this;
                }

                public getValues(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNetworkInfo.REF_VALUES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfValues(): number {
                    return this.size(org.kevoree.meta.MetaNetworkInfo.REF_VALUES);
                }

            }

            export class NodeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Node {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaNode.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Node {
                    this.set(org.kevoree.meta.MetaNode.ATT_NAME, p_obj);
                    return this;
                }

                public getStarted(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaNode.ATT_STARTED);
                }

                public setStarted(p_obj: boolean): org.kevoree.Node {
                    this.set(org.kevoree.meta.MetaNode.ATT_STARTED, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_METADATA);
                }

                public addComponents(p_obj: org.kevoree.Component): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_COMPONENTS, p_obj);
                    return this;
                }

                public removeComponents(p_obj: org.kevoree.Component): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_COMPONENTS, p_obj);
                    return this;
                }

                public getComponents(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_COMPONENTS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Component[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Component>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfComponents(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_COMPONENTS);
                }

                public setDictionary(p_obj: org.kevoree.Dictionary): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaNode.REF_DICTIONARY, p_obj);
                    return this;
                }

                public getDictionary(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_DICTIONARY,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.Dictionary>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addChildren(p_obj: org.kevoree.Node): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_CHILDREN, p_obj);
                    return this;
                }

                public removeChildren(p_obj: org.kevoree.Node): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_CHILDREN, p_obj);
                    return this;
                }

                public getChildren(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_CHILDREN,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Node[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Node>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfChildren(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_CHILDREN);
                }

                public setTypeDefinition(p_obj: org.kevoree.TypeDefinition): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaNode.REF_TYPEDEFINITION, p_obj);
                    return this;
                }

                public getTypeDefinition(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_TYPEDEFINITION,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.TypeDefinition>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

                public addHost(p_obj: org.kevoree.Node): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_HOST, p_obj);
                    return this;
                }

                public removeHost(p_obj: org.kevoree.Node): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_HOST, p_obj);
                    return this;
                }

                public getHost(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_HOST,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Node[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Node>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfHost(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_HOST);
                }

                public addGroups(p_obj: org.kevoree.Group): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_GROUPS, p_obj);
                    return this;
                }

                public removeGroups(p_obj: org.kevoree.Group): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_GROUPS, p_obj);
                    return this;
                }

                public getGroups(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_GROUPS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Group[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Group>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfGroups(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_GROUPS);
                }

                public addNetworks(p_obj: org.kevoree.NetworkInfo): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNode.REF_NETWORKS, p_obj);
                    return this;
                }

                public removeNetworks(p_obj: org.kevoree.NetworkInfo): org.kevoree.Node {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNode.REF_NETWORKS, p_obj);
                    return this;
                }

                public getNetworks(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNode.REF_NETWORKS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.NetworkInfo[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.NetworkInfo>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfNetworks(): number {
                    return this.size(org.kevoree.meta.MetaNode.REF_NETWORKS);
                }

            }

            export class NodeTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.NodeType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaNodeType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.NodeType {
                    this.set(org.kevoree.meta.MetaNodeType.ATT_NAME, p_obj);
                    return this;
                }

                public getAbstract(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaNodeType.ATT_ABSTRACT);
                }

                public setAbstract(p_obj: boolean): org.kevoree.NodeType {
                    this.set(org.kevoree.meta.MetaNodeType.ATT_ABSTRACT, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaNodeType.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.NodeType {
                    this.set(org.kevoree.meta.MetaNodeType.ATT_VERSION, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.NodeType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNodeType.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.NodeType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNodeType.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNodeType.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaNodeType.REF_METADATA);
                }

                public addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.NodeType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaNodeType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.NodeType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaNodeType.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNodeType.REF_DEPLOYUNITS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfDeployUnits(): number {
                    return this.size(org.kevoree.meta.MetaNodeType.REF_DEPLOYUNITS);
                }

                public setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.NodeType {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaNodeType.REF_DICTIONARYTYPE, p_obj);
                    return this;
                }

                public getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaNodeType.REF_DICTIONARYTYPE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.DictionaryType>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class PortImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Port {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaPort.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Port {
                    this.set(org.kevoree.meta.MetaPort.ATT_NAME, p_obj);
                    return this;
                }

                public addChannels(p_obj: org.kevoree.Channel): org.kevoree.Port {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaPort.REF_CHANNELS, p_obj);
                    return this;
                }

                public removeChannels(p_obj: org.kevoree.Channel): org.kevoree.Port {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaPort.REF_CHANNELS, p_obj);
                    return this;
                }

                public getChannels(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaPort.REF_CHANNELS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Channel[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Channel>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfChannels(): number {
                    return this.size(org.kevoree.meta.MetaPort.REF_CHANNELS);
                }

            }

            export class PortTypeImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.PortType {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaPortType.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.PortType {
                    this.set(org.kevoree.meta.MetaPortType.ATT_NAME, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.PortType {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaPortType.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.PortType {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaPortType.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaPortType.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaPortType.REF_METADATA);
                }

            }

            export class TypeDefinitionImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.TypeDefinition {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaTypeDefinition.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.TypeDefinition {
                    this.set(org.kevoree.meta.MetaTypeDefinition.ATT_NAME, p_obj);
                    return this;
                }

                public getAbstract(): boolean {
                    return <boolean>this.get(org.kevoree.meta.MetaTypeDefinition.ATT_ABSTRACT);
                }

                public setAbstract(p_obj: boolean): org.kevoree.TypeDefinition {
                    this.set(org.kevoree.meta.MetaTypeDefinition.ATT_ABSTRACT, p_obj);
                    return this;
                }

                public getVersion(): string {
                    return <string>this.get(org.kevoree.meta.MetaTypeDefinition.ATT_VERSION);
                }

                public setVersion(p_obj: string): org.kevoree.TypeDefinition {
                    this.set(org.kevoree.meta.MetaTypeDefinition.ATT_VERSION, p_obj);
                    return this;
                }

                public addMetaData(p_obj: org.kevoree.Value): org.kevoree.TypeDefinition {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaTypeDefinition.REF_METADATA, p_obj);
                    return this;
                }

                public removeMetaData(p_obj: org.kevoree.Value): org.kevoree.TypeDefinition {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaTypeDefinition.REF_METADATA, p_obj);
                    return this;
                }

                public getMetaData(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaTypeDefinition.REF_METADATA,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.Value[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.Value>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfMetaData(): number {
                    return this.size(org.kevoree.meta.MetaTypeDefinition.REF_METADATA);
                }

                public addDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.TypeDefinition {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaTypeDefinition.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public removeDeployUnits(p_obj: org.kevoree.DeployUnit): org.kevoree.TypeDefinition {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaTypeDefinition.REF_DEPLOYUNITS, p_obj);
                    return this;
                }

                public getDeployUnits(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaTypeDefinition.REF_DEPLOYUNITS,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.DeployUnit[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.DeployUnit>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfDeployUnits(): number {
                    return this.size(org.kevoree.meta.MetaTypeDefinition.REF_DEPLOYUNITS);
                }

                public setDictionaryType(p_obj: org.kevoree.DictionaryType): org.kevoree.TypeDefinition {
                    this.mutate(org.kevoree.modeling.KActionType.SET, org.kevoree.meta.MetaTypeDefinition.REF_DICTIONARYTYPE, p_obj);
                    return this;
                }

                public getDictionaryType(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaTypeDefinition.REF_DICTIONARYTYPE,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        if (kObjects.length > 0) {
                            cb(<org.kevoree.DictionaryType>kObjects[0]);
                        } else {
                            cb(null);
                        }
                    });
                }

            }

            export class TypedElementImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.TypedElement {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaTypedElement.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.TypedElement {
                    this.set(org.kevoree.meta.MetaTypedElement.ATT_NAME, p_obj);
                    return this;
                }

                public addGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.TypedElement {
                    this.mutate(org.kevoree.modeling.KActionType.ADD, org.kevoree.meta.MetaTypedElement.REF_GENERICTYPES, p_obj);
                    return this;
                }

                public removeGenericTypes(p_obj: org.kevoree.TypedElement): org.kevoree.TypedElement {
                    this.mutate(org.kevoree.modeling.KActionType.REMOVE, org.kevoree.meta.MetaTypedElement.REF_GENERICTYPES, p_obj);
                    return this;
                }

                public getGenericTypes(cb: org.kevoree.modeling.KCallback<any>): void {
                    if (cb == null) {
                        return;
                    }
                    this.ref(org.kevoree.meta.MetaTypedElement.REF_GENERICTYPES,  (kObjects : org.kevoree.modeling.KObject[]) => {
                        var casted: org.kevoree.TypedElement[] = new Array();
                        for (var i: number = 0; i < kObjects.length; i++) {
                            casted[i] = <org.kevoree.TypedElement>kObjects[i];
                        }
                        cb(casted);
                    });
                }

                public sizeOfGenericTypes(): number {
                    return this.size(org.kevoree.meta.MetaTypedElement.REF_GENERICTYPES);
                }

            }

            export class ValueImpl extends org.kevoree.modeling.abs.AbstractKObject implements org.kevoree.Value {

                constructor(p_universe: number, p_time: number, p_uuid: number, p_metaClass: org.kevoree.modeling.meta.KMetaClass, p_manager: org.kevoree.modeling.memory.manager.internal.KInternalDataManager, p_previousUniverse: number, p_previoustTime: number) {
                    super(p_universe, p_time, p_uuid, p_metaClass, p_manager, p_previousUniverse, p_previoustTime);
                }

                public getName(): string {
                    return <string>this.get(org.kevoree.meta.MetaValue.ATT_NAME);
                }

                public setName(p_obj: string): org.kevoree.Value {
                    this.set(org.kevoree.meta.MetaValue.ATT_NAME, p_obj);
                    return this;
                }

                public getValue(): string {
                    return <string>this.get(org.kevoree.meta.MetaValue.ATT_VALUE);
                }

                public setValue(p_obj: string): org.kevoree.Value {
                    this.set(org.kevoree.meta.MetaValue.ATT_VALUE, p_obj);
                    return this;
                }

            }

        }
        export module meta {
            export class MetaAttributeType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaAttributeType = null;
                public static ATT_DATATYPE: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("datatype", 0, 0, false, 0, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_DEFAULTVALUE: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("defaultValue", 1, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_FRAGMENTDEPENDANT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("fragmentDependant", 2, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 3, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_OPTIONAL: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("optional", 4, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_OP_DICTIONARYTYPE_ATTRIBUTES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_DictionaryType_attributes", 5, false, false, 14, "attributes", 21);
                public static REF_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("genericTypes", 6, true, false, 22, "op_AttributeType_genericTypes", 21);
                public static REF_OP_ATTRIBUTETYPE_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_AttributeType_genericTypes", 7, false, false, 21, "genericTypes", 21);
                public static REF_OP_TYPEDELEMENT_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_TypedElement_genericTypes", 8, false, false, 22, "genericTypes", 21);
                public static getInstance(): org.kevoree.meta.MetaAttributeType {
                    if (MetaAttributeType.INSTANCE == null) {
                        MetaAttributeType.INSTANCE = new org.kevoree.meta.MetaAttributeType();
                    }
                    return MetaAttributeType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.AttributeType", 21, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaAttributeType.ATT_DATATYPE;
                    temp_all[1] = MetaAttributeType.ATT_DEFAULTVALUE;
                    temp_all[2] = MetaAttributeType.ATT_FRAGMENTDEPENDANT;
                    temp_all[3] = MetaAttributeType.ATT_NAME;
                    temp_all[4] = MetaAttributeType.ATT_OPTIONAL;
                    temp_all[5] = MetaAttributeType.REF_OP_DICTIONARYTYPE_ATTRIBUTES;
                    temp_all[6] = MetaAttributeType.REF_GENERICTYPES;
                    temp_all[7] = MetaAttributeType.REF_OP_ATTRIBUTETYPE_GENERICTYPES;
                    temp_all[8] = MetaAttributeType.REF_OP_TYPEDELEMENT_GENERICTYPES;
                    this.init(temp_all);
                }

            }

            export class MetaChannel extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaChannel = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_STARTED: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("started", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 2, true, false, 9, "op_Channel_metaData", 4);
                public static REF_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionary", 3, true, true, 7, "op_Channel_dictionary", 4);
                public static REF_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinition", 4, true, true, 8, "op_Channel_typeDefinition", 4);
                public static REF_OP_MODEL_CHANNELS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Model_channels", 5, false, false, 1, "channels", 4);
                public static REF_PORTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("ports", 6, true, false, 12, "channels", 4);
                public static REF_FRAGMENTDICTIONARIES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("fragmentDictionaries", 7, true, false, 13, "op_Channel_fragmentDictionaries", 4);
                public static getInstance(): org.kevoree.meta.MetaChannel {
                    if (MetaChannel.INSTANCE == null) {
                        MetaChannel.INSTANCE = new org.kevoree.meta.MetaChannel();
                    }
                    return MetaChannel.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Channel", 4, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaChannel.ATT_NAME;
                    temp_all[1] = MetaChannel.ATT_STARTED;
                    temp_all[2] = MetaChannel.REF_METADATA;
                    temp_all[3] = MetaChannel.REF_DICTIONARY;
                    temp_all[4] = MetaChannel.REF_TYPEDEFINITION;
                    temp_all[5] = MetaChannel.REF_OP_MODEL_CHANNELS;
                    temp_all[6] = MetaChannel.REF_PORTS;
                    temp_all[7] = MetaChannel.REF_FRAGMENTDICTIONARIES;
                    this.init(temp_all);
                }

            }

            export class MetaChannelType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaChannelType = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_ABSTRACT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("abstract", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_TypeDefinition_metaData", 20);
                public static REF_OP_NODE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_typeDefinition", 4, false, false, 2, "typeDefinition", 20);
                public static REF_OP_INSTANCE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_typeDefinition", 5, false, false, 6, "typeDefinition", 20);
                public static REF_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("deployUnits", 6, true, false, 15, "op_TypeDefinition_deployUnits", 20);
                public static REF_OP_NAMESPACE_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Namespace_typeDefinitions", 7, false, false, 5, "typeDefinitions", 20);
                public static REF_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionaryType", 8, true, true, 14, "op_TypeDefinition_dictionaryType", 20);
                public static REF_OP_COMPONENT_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_typeDefinition", 9, false, false, 11, "typeDefinition", 20);
                public static REF_OP_CHANNEL_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_typeDefinition", 10, false, false, 4, "typeDefinition", 20);
                public static getInstance(): org.kevoree.meta.MetaChannelType {
                    if (MetaChannelType.INSTANCE == null) {
                        MetaChannelType.INSTANCE = new org.kevoree.meta.MetaChannelType();
                    }
                    return MetaChannelType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.ChannelType", 20, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaChannelType.ATT_NAME;
                    temp_all[1] = MetaChannelType.ATT_ABSTRACT;
                    temp_all[2] = MetaChannelType.ATT_VERSION;
                    temp_all[3] = MetaChannelType.REF_METADATA;
                    temp_all[4] = MetaChannelType.REF_OP_NODE_TYPEDEFINITION;
                    temp_all[5] = MetaChannelType.REF_OP_INSTANCE_TYPEDEFINITION;
                    temp_all[6] = MetaChannelType.REF_DEPLOYUNITS;
                    temp_all[7] = MetaChannelType.REF_OP_NAMESPACE_TYPEDEFINITIONS;
                    temp_all[8] = MetaChannelType.REF_DICTIONARYTYPE;
                    temp_all[9] = MetaChannelType.REF_OP_COMPONENT_TYPEDEFINITION;
                    temp_all[10] = MetaChannelType.REF_OP_CHANNEL_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaComponent extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaComponent = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_STARTED: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("started", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_OUTPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("outputs", 2, true, false, 12, "op_Component_outputs", 11);
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_Component_metaData", 11);
                public static REF_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionary", 4, true, true, 7, "op_Component_dictionary", 11);
                public static REF_INPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("inputs", 5, true, false, 12, "op_Component_inputs", 11);
                public static REF_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinition", 6, true, true, 8, "op_Component_typeDefinition", 11);
                public static REF_OP_NODE_COMPONENTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_components", 7, false, false, 2, "components", 11);
                public static getInstance(): org.kevoree.meta.MetaComponent {
                    if (MetaComponent.INSTANCE == null) {
                        MetaComponent.INSTANCE = new org.kevoree.meta.MetaComponent();
                    }
                    return MetaComponent.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Component", 11, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaComponent.ATT_NAME;
                    temp_all[1] = MetaComponent.ATT_STARTED;
                    temp_all[2] = MetaComponent.REF_OUTPUTS;
                    temp_all[3] = MetaComponent.REF_METADATA;
                    temp_all[4] = MetaComponent.REF_DICTIONARY;
                    temp_all[5] = MetaComponent.REF_INPUTS;
                    temp_all[6] = MetaComponent.REF_TYPEDEFINITION;
                    temp_all[7] = MetaComponent.REF_OP_NODE_COMPONENTS;
                    this.init(temp_all);
                }

            }

            export class MetaComponentType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaComponentType = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_ABSTRACT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("abstract", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_OUTPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("outputs", 3, true, false, 16, "op_ComponentType_outputs", 17);
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 4, true, false, 9, "op_TypeDefinition_metaData", 17);
                public static REF_OP_NODE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_typeDefinition", 5, false, false, 2, "typeDefinition", 17);
                public static REF_OP_INSTANCE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_typeDefinition", 6, false, false, 6, "typeDefinition", 17);
                public static REF_INPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("inputs", 7, true, false, 16, "op_ComponentType_inputs", 17);
                public static REF_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("deployUnits", 8, true, false, 15, "op_TypeDefinition_deployUnits", 17);
                public static REF_OP_NAMESPACE_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Namespace_typeDefinitions", 9, false, false, 5, "typeDefinitions", 17);
                public static REF_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionaryType", 10, true, true, 14, "op_TypeDefinition_dictionaryType", 17);
                public static REF_OP_COMPONENT_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_typeDefinition", 11, false, false, 11, "typeDefinition", 17);
                public static REF_OP_CHANNEL_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_typeDefinition", 12, false, false, 4, "typeDefinition", 17);
                public static getInstance(): org.kevoree.meta.MetaComponentType {
                    if (MetaComponentType.INSTANCE == null) {
                        MetaComponentType.INSTANCE = new org.kevoree.meta.MetaComponentType();
                    }
                    return MetaComponentType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.ComponentType", 17, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaComponentType.ATT_NAME;
                    temp_all[1] = MetaComponentType.ATT_ABSTRACT;
                    temp_all[2] = MetaComponentType.ATT_VERSION;
                    temp_all[3] = MetaComponentType.REF_OUTPUTS;
                    temp_all[4] = MetaComponentType.REF_METADATA;
                    temp_all[5] = MetaComponentType.REF_OP_NODE_TYPEDEFINITION;
                    temp_all[6] = MetaComponentType.REF_OP_INSTANCE_TYPEDEFINITION;
                    temp_all[7] = MetaComponentType.REF_INPUTS;
                    temp_all[8] = MetaComponentType.REF_DEPLOYUNITS;
                    temp_all[9] = MetaComponentType.REF_OP_NAMESPACE_TYPEDEFINITIONS;
                    temp_all[10] = MetaComponentType.REF_DICTIONARYTYPE;
                    temp_all[11] = MetaComponentType.REF_OP_COMPONENT_TYPEDEFINITION;
                    temp_all[12] = MetaComponentType.REF_OP_CHANNEL_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaDataType extends org.kevoree.modeling.meta.impl.MetaEnum implements org.kevoree.modeling.KType {

                public static BOOLEAN: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("BOOLEAN", 0, "org.kevoree.DataType");
                public static CHAR: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("CHAR", 1, "org.kevoree.DataType");
                public static DECIMAL: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("DECIMAL", 2, "org.kevoree.DataType");
                public static INTEGER: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("INTEGER", 3, "org.kevoree.DataType");
                public static LIST: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("LIST", 4, "org.kevoree.DataType");
                public static STRING: org.kevoree.DataType = new org.kevoree.impl.DataTypeLiteral("STRING", 5, "org.kevoree.DataType");
                private static INSTANCE: org.kevoree.meta.MetaDataType;
                public static getInstance(): org.kevoree.meta.MetaDataType {
                    if (MetaDataType.INSTANCE == null) {
                        MetaDataType.INSTANCE = new org.kevoree.meta.MetaDataType();
                    }
                    return MetaDataType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.DataType", 0);
                    var p_lits_arr: org.kevoree.modeling.meta.KLiteral[] = new Array();
                    p_lits_arr[0] = MetaDataType.BOOLEAN;
                    p_lits_arr[1] = MetaDataType.CHAR;
                    p_lits_arr[2] = MetaDataType.DECIMAL;
                    p_lits_arr[3] = MetaDataType.INTEGER;
                    p_lits_arr[4] = MetaDataType.LIST;
                    p_lits_arr[5] = MetaDataType.STRING;
                    this.init(p_lits_arr);
                }

            }

            export class MetaDeployUnit extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaDeployUnit = null;
                public static ATT_HASHCODE: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("hashcode", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 1, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_DeployUnit_metaData", 15);
                public static REF_OP_TYPEDEFINITION_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_TypeDefinition_deployUnits", 4, false, false, 8, "deployUnits", 15);
                public static REF_REQUIREDLIBS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("requiredLibs", 5, true, false, 15, "op_DeployUnit_requiredLibs", 15);
                public static REF_OP_GROUPTYPE_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_GroupType_deployUnits", 6, false, false, 18, "deployUnits", 15);
                public static REF_OP_DEPLOYUNIT_REQUIREDLIBS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_DeployUnit_requiredLibs", 7, false, false, 15, "requiredLibs", 15);
                public static REF_OP_NODETYPE_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_NodeType_deployUnits", 8, false, false, 19, "deployUnits", 15);
                public static getInstance(): org.kevoree.meta.MetaDeployUnit {
                    if (MetaDeployUnit.INSTANCE == null) {
                        MetaDeployUnit.INSTANCE = new org.kevoree.meta.MetaDeployUnit();
                    }
                    return MetaDeployUnit.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.DeployUnit", 15, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaDeployUnit.ATT_HASHCODE;
                    temp_all[1] = MetaDeployUnit.ATT_NAME;
                    temp_all[2] = MetaDeployUnit.ATT_VERSION;
                    temp_all[3] = MetaDeployUnit.REF_METADATA;
                    temp_all[4] = MetaDeployUnit.REF_OP_TYPEDEFINITION_DEPLOYUNITS;
                    temp_all[5] = MetaDeployUnit.REF_REQUIREDLIBS;
                    temp_all[6] = MetaDeployUnit.REF_OP_GROUPTYPE_DEPLOYUNITS;
                    temp_all[7] = MetaDeployUnit.REF_OP_DEPLOYUNIT_REQUIREDLIBS;
                    temp_all[8] = MetaDeployUnit.REF_OP_NODETYPE_DEPLOYUNITS;
                    this.init(temp_all);
                }

            }

            export class MetaDictionary extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaDictionary = null;
                public static REF_OP_COMPONENT_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_dictionary", 0, false, false, 11, "dictionary", 7);
                public static REF_OP_NODE_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_dictionary", 1, false, false, 2, "dictionary", 7);
                public static REF_OP_INSTANCE_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_dictionary", 2, false, false, 6, "dictionary", 7);
                public static REF_VALUES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("values", 3, true, false, 9, "op_Dictionary_values", 7);
                public static REF_OP_CHANNEL_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_dictionary", 4, false, false, 4, "dictionary", 7);
                public static getInstance(): org.kevoree.meta.MetaDictionary {
                    if (MetaDictionary.INSTANCE == null) {
                        MetaDictionary.INSTANCE = new org.kevoree.meta.MetaDictionary();
                    }
                    return MetaDictionary.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Dictionary", 7, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaDictionary.REF_OP_COMPONENT_DICTIONARY;
                    temp_all[1] = MetaDictionary.REF_OP_NODE_DICTIONARY;
                    temp_all[2] = MetaDictionary.REF_OP_INSTANCE_DICTIONARY;
                    temp_all[3] = MetaDictionary.REF_VALUES;
                    temp_all[4] = MetaDictionary.REF_OP_CHANNEL_DICTIONARY;
                    this.init(temp_all);
                }

            }

            export class MetaDictionaryType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaDictionaryType = null;
                public static REF_OP_NODETYPE_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_NodeType_dictionaryType", 0, false, false, 19, "dictionaryType", 14);
                public static REF_ATTRIBUTES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("attributes", 1, true, false, 21, "op_DictionaryType_attributes", 14);
                public static REF_OP_TYPEDEFINITION_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_TypeDefinition_dictionaryType", 2, false, false, 8, "dictionaryType", 14);
                public static REF_OP_GROUPTYPE_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_GroupType_dictionaryType", 3, false, false, 18, "dictionaryType", 14);
                public static getInstance(): org.kevoree.meta.MetaDictionaryType {
                    if (MetaDictionaryType.INSTANCE == null) {
                        MetaDictionaryType.INSTANCE = new org.kevoree.meta.MetaDictionaryType();
                    }
                    return MetaDictionaryType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.DictionaryType", 14, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaDictionaryType.REF_OP_NODETYPE_DICTIONARYTYPE;
                    temp_all[1] = MetaDictionaryType.REF_ATTRIBUTES;
                    temp_all[2] = MetaDictionaryType.REF_OP_TYPEDEFINITION_DICTIONARYTYPE;
                    temp_all[3] = MetaDictionaryType.REF_OP_GROUPTYPE_DICTIONARYTYPE;
                    this.init(temp_all);
                }

            }

            export class MetaFragmentDictionary extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaFragmentDictionary = null;
                public static REF_NODE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("node", 0, true, true, 2, "op_FragmentDictionary_node", 13);
                public static REF_OP_COMPONENT_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_dictionary", 1, false, false, 11, "dictionary", 13);
                public static REF_OP_NODE_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_dictionary", 2, false, false, 2, "dictionary", 13);
                public static REF_OP_INSTANCE_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_dictionary", 3, false, false, 6, "dictionary", 13);
                public static REF_VALUES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("values", 4, true, false, 9, "op_Dictionary_values", 13);
                public static REF_OP_GROUP_FRAGMENTDICTIONARIES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Group_fragmentDictionaries", 5, false, false, 3, "fragmentDictionaries", 13);
                public static REF_OP_CHANNEL_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_dictionary", 6, false, false, 4, "dictionary", 13);
                public static REF_OP_CHANNEL_FRAGMENTDICTIONARIES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_fragmentDictionaries", 7, false, false, 4, "fragmentDictionaries", 13);
                public static getInstance(): org.kevoree.meta.MetaFragmentDictionary {
                    if (MetaFragmentDictionary.INSTANCE == null) {
                        MetaFragmentDictionary.INSTANCE = new org.kevoree.meta.MetaFragmentDictionary();
                    }
                    return MetaFragmentDictionary.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.FragmentDictionary", 13, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaFragmentDictionary.REF_NODE;
                    temp_all[1] = MetaFragmentDictionary.REF_OP_COMPONENT_DICTIONARY;
                    temp_all[2] = MetaFragmentDictionary.REF_OP_NODE_DICTIONARY;
                    temp_all[3] = MetaFragmentDictionary.REF_OP_INSTANCE_DICTIONARY;
                    temp_all[4] = MetaFragmentDictionary.REF_VALUES;
                    temp_all[5] = MetaFragmentDictionary.REF_OP_GROUP_FRAGMENTDICTIONARIES;
                    temp_all[6] = MetaFragmentDictionary.REF_OP_CHANNEL_DICTIONARY;
                    temp_all[7] = MetaFragmentDictionary.REF_OP_CHANNEL_FRAGMENTDICTIONARIES;
                    this.init(temp_all);
                }

            }

            export class MetaGroup extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaGroup = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_STARTED: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("started", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 2, true, false, 9, "op_Instance_metaData", 3);
                public static REF_NODES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("nodes", 3, true, false, 2, "groups", 3);
                public static REF_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionary", 4, true, true, 7, "op_Instance_dictionary", 3);
                public static REF_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinition", 5, true, true, 8, "op_Instance_typeDefinition", 3);
                public static REF_OP_MODEL_GROUPS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Model_groups", 6, false, false, 1, "groups", 3);
                public static REF_FRAGMENTDICTIONARIES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("fragmentDictionaries", 7, true, false, 13, "op_Group_fragmentDictionaries", 3);
                public static getInstance(): org.kevoree.meta.MetaGroup {
                    if (MetaGroup.INSTANCE == null) {
                        MetaGroup.INSTANCE = new org.kevoree.meta.MetaGroup();
                    }
                    return MetaGroup.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Group", 3, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaGroup.ATT_NAME;
                    temp_all[1] = MetaGroup.ATT_STARTED;
                    temp_all[2] = MetaGroup.REF_METADATA;
                    temp_all[3] = MetaGroup.REF_NODES;
                    temp_all[4] = MetaGroup.REF_DICTIONARY;
                    temp_all[5] = MetaGroup.REF_TYPEDEFINITION;
                    temp_all[6] = MetaGroup.REF_OP_MODEL_GROUPS;
                    temp_all[7] = MetaGroup.REF_FRAGMENTDICTIONARIES;
                    this.init(temp_all);
                }

            }

            export class MetaGroupType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaGroupType = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_ABSTRACT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("abstract", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_GroupType_metaData", 18);
                public static REF_OP_NODE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_typeDefinition", 4, false, false, 2, "typeDefinition", 18);
                public static REF_OP_INSTANCE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_typeDefinition", 5, false, false, 6, "typeDefinition", 18);
                public static REF_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("deployUnits", 6, true, false, 15, "op_GroupType_deployUnits", 18);
                public static REF_OP_NAMESPACE_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Namespace_typeDefinitions", 7, false, false, 5, "typeDefinitions", 18);
                public static REF_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionaryType", 8, true, true, 14, "op_GroupType_dictionaryType", 18);
                public static REF_OP_COMPONENT_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_typeDefinition", 9, false, false, 11, "typeDefinition", 18);
                public static REF_OP_CHANNEL_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_typeDefinition", 10, false, false, 4, "typeDefinition", 18);
                public static getInstance(): org.kevoree.meta.MetaGroupType {
                    if (MetaGroupType.INSTANCE == null) {
                        MetaGroupType.INSTANCE = new org.kevoree.meta.MetaGroupType();
                    }
                    return MetaGroupType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.GroupType", 18, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaGroupType.ATT_NAME;
                    temp_all[1] = MetaGroupType.ATT_ABSTRACT;
                    temp_all[2] = MetaGroupType.ATT_VERSION;
                    temp_all[3] = MetaGroupType.REF_METADATA;
                    temp_all[4] = MetaGroupType.REF_OP_NODE_TYPEDEFINITION;
                    temp_all[5] = MetaGroupType.REF_OP_INSTANCE_TYPEDEFINITION;
                    temp_all[6] = MetaGroupType.REF_DEPLOYUNITS;
                    temp_all[7] = MetaGroupType.REF_OP_NAMESPACE_TYPEDEFINITIONS;
                    temp_all[8] = MetaGroupType.REF_DICTIONARYTYPE;
                    temp_all[9] = MetaGroupType.REF_OP_COMPONENT_TYPEDEFINITION;
                    temp_all[10] = MetaGroupType.REF_OP_CHANNEL_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaInstance extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaInstance = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_STARTED: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("started", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 2, true, false, 9, "op_Instance_metaData", 6);
                public static REF_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionary", 3, true, true, 7, "op_Instance_dictionary", 6);
                public static REF_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinition", 4, true, true, 8, "op_Instance_typeDefinition", 6);
                public static getInstance(): org.kevoree.meta.MetaInstance {
                    if (MetaInstance.INSTANCE == null) {
                        MetaInstance.INSTANCE = new org.kevoree.meta.MetaInstance();
                    }
                    return MetaInstance.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Instance", 6, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaInstance.ATT_NAME;
                    temp_all[1] = MetaInstance.ATT_STARTED;
                    temp_all[2] = MetaInstance.REF_METADATA;
                    temp_all[3] = MetaInstance.REF_DICTIONARY;
                    temp_all[4] = MetaInstance.REF_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaModel extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaModel = null;
                public static REF_NODES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("nodes", 0, true, false, 2, "op_Model_nodes", 1);
                public static REF_CHANNELS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("channels", 1, true, false, 4, "op_Model_channels", 1);
                public static REF_GROUPS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("groups", 2, true, false, 3, "op_Model_groups", 1);
                public static REF_NAMESPACES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("namespaces", 3, true, false, 5, "op_Model_namespaces", 1);
                public static getInstance(): org.kevoree.meta.MetaModel {
                    if (MetaModel.INSTANCE == null) {
                        MetaModel.INSTANCE = new org.kevoree.meta.MetaModel();
                    }
                    return MetaModel.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Model", 1, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaModel.REF_NODES;
                    temp_all[1] = MetaModel.REF_CHANNELS;
                    temp_all[2] = MetaModel.REF_GROUPS;
                    temp_all[3] = MetaModel.REF_NAMESPACES;
                    this.init(temp_all);
                }

            }

            export class MetaNamedElement extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaNamedElement = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static getInstance(): org.kevoree.meta.MetaNamedElement {
                    if (MetaNamedElement.INSTANCE == null) {
                        MetaNamedElement.INSTANCE = new org.kevoree.meta.MetaNamedElement();
                    }
                    return MetaNamedElement.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.NamedElement", 0, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaNamedElement.ATT_NAME;
                    this.init(temp_all);
                }

            }

            export class MetaNamespace extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaNamespace = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinitions", 1, true, false, 8, "op_Namespace_typeDefinitions", 5);
                public static REF_OP_MODEL_NAMESPACES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Model_namespaces", 2, false, false, 1, "namespaces", 5);
                public static getInstance(): org.kevoree.meta.MetaNamespace {
                    if (MetaNamespace.INSTANCE == null) {
                        MetaNamespace.INSTANCE = new org.kevoree.meta.MetaNamespace();
                    }
                    return MetaNamespace.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Namespace", 5, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaNamespace.ATT_NAME;
                    temp_all[1] = MetaNamespace.REF_TYPEDEFINITIONS;
                    temp_all[2] = MetaNamespace.REF_OP_MODEL_NAMESPACES;
                    this.init(temp_all);
                }

            }

            export class MetaNetworkInfo extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaNetworkInfo = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_VALUES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("values", 1, true, false, 9, "op_NetworkInfo_values", 10);
                public static REF_OP_NODE_NETWORKS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_networks", 2, false, false, 2, "networks", 10);
                public static getInstance(): org.kevoree.meta.MetaNetworkInfo {
                    if (MetaNetworkInfo.INSTANCE == null) {
                        MetaNetworkInfo.INSTANCE = new org.kevoree.meta.MetaNetworkInfo();
                    }
                    return MetaNetworkInfo.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.NetworkInfo", 10, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaNetworkInfo.ATT_NAME;
                    temp_all[1] = MetaNetworkInfo.REF_VALUES;
                    temp_all[2] = MetaNetworkInfo.REF_OP_NODE_NETWORKS;
                    this.init(temp_all);
                }

            }

            export class MetaNode extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaNode = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_STARTED: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("started", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 2, true, false, 9, "op_Node_metaData", 2);
                public static REF_OP_MODEL_NODES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Model_nodes", 3, false, false, 1, "nodes", 2);
                public static REF_COMPONENTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("components", 4, true, false, 11, "op_Node_components", 2);
                public static REF_DICTIONARY: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionary", 5, true, true, 7, "op_Node_dictionary", 2);
                public static REF_CHILDREN: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("children", 6, true, false, 2, "host", 2);
                public static REF_OP_FRAGMENTDICTIONARY_NODE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_FragmentDictionary_node", 7, false, false, 13, "node", 2);
                public static REF_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("typeDefinition", 8, true, true, 8, "op_Node_typeDefinition", 2);
                public static REF_HOST: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("host", 9, true, false, 2, "children", 2);
                public static REF_GROUPS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("groups", 10, true, false, 3, "nodes", 2);
                public static REF_NETWORKS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("networks", 11, true, false, 10, "op_Node_networks", 2);
                public static getInstance(): org.kevoree.meta.MetaNode {
                    if (MetaNode.INSTANCE == null) {
                        MetaNode.INSTANCE = new org.kevoree.meta.MetaNode();
                    }
                    return MetaNode.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Node", 2, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaNode.ATT_NAME;
                    temp_all[1] = MetaNode.ATT_STARTED;
                    temp_all[2] = MetaNode.REF_METADATA;
                    temp_all[3] = MetaNode.REF_OP_MODEL_NODES;
                    temp_all[4] = MetaNode.REF_COMPONENTS;
                    temp_all[5] = MetaNode.REF_DICTIONARY;
                    temp_all[6] = MetaNode.REF_CHILDREN;
                    temp_all[7] = MetaNode.REF_OP_FRAGMENTDICTIONARY_NODE;
                    temp_all[8] = MetaNode.REF_TYPEDEFINITION;
                    temp_all[9] = MetaNode.REF_HOST;
                    temp_all[10] = MetaNode.REF_GROUPS;
                    temp_all[11] = MetaNode.REF_NETWORKS;
                    this.init(temp_all);
                }

            }

            export class MetaNodeType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaNodeType = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_ABSTRACT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("abstract", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_NodeType_metaData", 19);
                public static REF_OP_NODE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_typeDefinition", 4, false, false, 2, "typeDefinition", 19);
                public static REF_OP_INSTANCE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_typeDefinition", 5, false, false, 6, "typeDefinition", 19);
                public static REF_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("deployUnits", 6, true, false, 15, "op_NodeType_deployUnits", 19);
                public static REF_OP_NAMESPACE_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Namespace_typeDefinitions", 7, false, false, 5, "typeDefinitions", 19);
                public static REF_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionaryType", 8, true, true, 14, "op_NodeType_dictionaryType", 19);
                public static REF_OP_COMPONENT_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_typeDefinition", 9, false, false, 11, "typeDefinition", 19);
                public static REF_OP_CHANNEL_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_typeDefinition", 10, false, false, 4, "typeDefinition", 19);
                public static getInstance(): org.kevoree.meta.MetaNodeType {
                    if (MetaNodeType.INSTANCE == null) {
                        MetaNodeType.INSTANCE = new org.kevoree.meta.MetaNodeType();
                    }
                    return MetaNodeType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.NodeType", 19, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaNodeType.ATT_NAME;
                    temp_all[1] = MetaNodeType.ATT_ABSTRACT;
                    temp_all[2] = MetaNodeType.ATT_VERSION;
                    temp_all[3] = MetaNodeType.REF_METADATA;
                    temp_all[4] = MetaNodeType.REF_OP_NODE_TYPEDEFINITION;
                    temp_all[5] = MetaNodeType.REF_OP_INSTANCE_TYPEDEFINITION;
                    temp_all[6] = MetaNodeType.REF_DEPLOYUNITS;
                    temp_all[7] = MetaNodeType.REF_OP_NAMESPACE_TYPEDEFINITIONS;
                    temp_all[8] = MetaNodeType.REF_DICTIONARYTYPE;
                    temp_all[9] = MetaNodeType.REF_OP_COMPONENT_TYPEDEFINITION;
                    temp_all[10] = MetaNodeType.REF_OP_CHANNEL_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaPort extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaPort = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_CHANNELS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("channels", 1, true, false, 4, "ports", 12);
                public static REF_OP_COMPONENT_OUTPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_outputs", 2, false, false, 11, "outputs", 12);
                public static REF_OP_COMPONENT_INPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_inputs", 3, false, false, 11, "inputs", 12);
                public static getInstance(): org.kevoree.meta.MetaPort {
                    if (MetaPort.INSTANCE == null) {
                        MetaPort.INSTANCE = new org.kevoree.meta.MetaPort();
                    }
                    return MetaPort.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Port", 12, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaPort.ATT_NAME;
                    temp_all[1] = MetaPort.REF_CHANNELS;
                    temp_all[2] = MetaPort.REF_OP_COMPONENT_OUTPUTS;
                    temp_all[3] = MetaPort.REF_OP_COMPONENT_INPUTS;
                    this.init(temp_all);
                }

            }

            export class MetaPortType extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaPortType = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 1, true, false, 9, "op_PortType_metaData", 16);
                public static REF_OP_COMPONENTTYPE_INPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_ComponentType_inputs", 2, false, false, 17, "inputs", 16);
                public static REF_OP_COMPONENTTYPE_OUTPUTS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_ComponentType_outputs", 3, false, false, 17, "outputs", 16);
                public static getInstance(): org.kevoree.meta.MetaPortType {
                    if (MetaPortType.INSTANCE == null) {
                        MetaPortType.INSTANCE = new org.kevoree.meta.MetaPortType();
                    }
                    return MetaPortType.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.PortType", 16, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaPortType.ATT_NAME;
                    temp_all[1] = MetaPortType.REF_METADATA;
                    temp_all[2] = MetaPortType.REF_OP_COMPONENTTYPE_INPUTS;
                    temp_all[3] = MetaPortType.REF_OP_COMPONENTTYPE_OUTPUTS;
                    this.init(temp_all);
                }

            }

            export class MetaTypeDefinition extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaTypeDefinition = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_ABSTRACT: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("abstract", 1, 0, false, -1, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VERSION: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("version", 2, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("metaData", 3, true, false, 9, "op_TypeDefinition_metaData", 8);
                public static REF_OP_NODE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_typeDefinition", 4, false, false, 2, "typeDefinition", 8);
                public static REF_OP_INSTANCE_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_typeDefinition", 5, false, false, 6, "typeDefinition", 8);
                public static REF_DEPLOYUNITS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("deployUnits", 6, true, false, 15, "op_TypeDefinition_deployUnits", 8);
                public static REF_OP_NAMESPACE_TYPEDEFINITIONS: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Namespace_typeDefinitions", 7, false, false, 5, "typeDefinitions", 8);
                public static REF_DICTIONARYTYPE: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("dictionaryType", 8, true, true, 14, "op_TypeDefinition_dictionaryType", 8);
                public static REF_OP_COMPONENT_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_typeDefinition", 9, false, false, 11, "typeDefinition", 8);
                public static REF_OP_CHANNEL_TYPEDEFINITION: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_typeDefinition", 10, false, false, 4, "typeDefinition", 8);
                public static getInstance(): org.kevoree.meta.MetaTypeDefinition {
                    if (MetaTypeDefinition.INSTANCE == null) {
                        MetaTypeDefinition.INSTANCE = new org.kevoree.meta.MetaTypeDefinition();
                    }
                    return MetaTypeDefinition.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.TypeDefinition", 8, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaTypeDefinition.ATT_NAME;
                    temp_all[1] = MetaTypeDefinition.ATT_ABSTRACT;
                    temp_all[2] = MetaTypeDefinition.ATT_VERSION;
                    temp_all[3] = MetaTypeDefinition.REF_METADATA;
                    temp_all[4] = MetaTypeDefinition.REF_OP_NODE_TYPEDEFINITION;
                    temp_all[5] = MetaTypeDefinition.REF_OP_INSTANCE_TYPEDEFINITION;
                    temp_all[6] = MetaTypeDefinition.REF_DEPLOYUNITS;
                    temp_all[7] = MetaTypeDefinition.REF_OP_NAMESPACE_TYPEDEFINITIONS;
                    temp_all[8] = MetaTypeDefinition.REF_DICTIONARYTYPE;
                    temp_all[9] = MetaTypeDefinition.REF_OP_COMPONENT_TYPEDEFINITION;
                    temp_all[10] = MetaTypeDefinition.REF_OP_CHANNEL_TYPEDEFINITION;
                    this.init(temp_all);
                }

            }

            export class MetaTypedElement extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaTypedElement = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("genericTypes", 1, true, false, 22, "op_TypedElement_genericTypes", 22);
                public static REF_OP_ATTRIBUTETYPE_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_AttributeType_genericTypes", 2, false, false, 21, "genericTypes", 22);
                public static REF_OP_TYPEDELEMENT_GENERICTYPES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_TypedElement_genericTypes", 3, false, false, 22, "genericTypes", 22);
                public static getInstance(): org.kevoree.meta.MetaTypedElement {
                    if (MetaTypedElement.INSTANCE == null) {
                        MetaTypedElement.INSTANCE = new org.kevoree.meta.MetaTypedElement();
                    }
                    return MetaTypedElement.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.TypedElement", 22, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaTypedElement.ATT_NAME;
                    temp_all[1] = MetaTypedElement.REF_GENERICTYPES;
                    temp_all[2] = MetaTypedElement.REF_OP_ATTRIBUTETYPE_GENERICTYPES;
                    temp_all[3] = MetaTypedElement.REF_OP_TYPEDELEMENT_GENERICTYPES;
                    this.init(temp_all);
                }

            }

            export class MetaValue extends org.kevoree.modeling.meta.impl.MetaClass {

                private static INSTANCE: org.kevoree.meta.MetaValue = null;
                public static ATT_NAME: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("name", 0, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static ATT_VALUE: org.kevoree.modeling.meta.KMetaAttribute = new org.kevoree.modeling.meta.impl.MetaAttribute("value", 1, 0, false, -2, org.kevoree.modeling.extrapolation.impl.DiscreteExtrapolation.instance());
                public static REF_OP_PORTTYPE_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_PortType_metaData", 2, false, false, 16, "metaData", 9);
                public static REF_OP_DEPLOYUNIT_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_DeployUnit_metaData", 3, false, false, 15, "metaData", 9);
                public static REF_OP_NODETYPE_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_NodeType_metaData", 4, false, false, 19, "metaData", 9);
                public static REF_OP_GROUPTYPE_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_GroupType_metaData", 5, false, false, 18, "metaData", 9);
                public static REF_OP_TYPEDEFINITION_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_TypeDefinition_metaData", 6, false, false, 8, "metaData", 9);
                public static REF_OP_COMPONENT_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Component_metaData", 7, false, false, 11, "metaData", 9);
                public static REF_OP_INSTANCE_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Instance_metaData", 8, false, false, 6, "metaData", 9);
                public static REF_OP_CHANNEL_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Channel_metaData", 9, false, false, 4, "metaData", 9);
                public static REF_OP_DICTIONARY_VALUES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Dictionary_values", 10, false, false, 7, "values", 9);
                public static REF_OP_NETWORKINFO_VALUES: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_NetworkInfo_values", 11, false, false, 10, "values", 9);
                public static REF_OP_NODE_METADATA: org.kevoree.modeling.meta.KMetaReference = new org.kevoree.modeling.meta.impl.MetaReference("op_Node_metaData", 12, false, false, 2, "metaData", 9);
                public static getInstance(): org.kevoree.meta.MetaValue {
                    if (MetaValue.INSTANCE == null) {
                        MetaValue.INSTANCE = new org.kevoree.meta.MetaValue();
                    }
                    return MetaValue.INSTANCE;
                }

                constructor() {
                    super("org.kevoree.Value", 9, null);
                    var temp_all: org.kevoree.modeling.meta.KMeta[] = new Array();
                    temp_all[0] = MetaValue.ATT_NAME;
                    temp_all[1] = MetaValue.ATT_VALUE;
                    temp_all[2] = MetaValue.REF_OP_PORTTYPE_METADATA;
                    temp_all[3] = MetaValue.REF_OP_DEPLOYUNIT_METADATA;
                    temp_all[4] = MetaValue.REF_OP_NODETYPE_METADATA;
                    temp_all[5] = MetaValue.REF_OP_GROUPTYPE_METADATA;
                    temp_all[6] = MetaValue.REF_OP_TYPEDEFINITION_METADATA;
                    temp_all[7] = MetaValue.REF_OP_COMPONENT_METADATA;
                    temp_all[8] = MetaValue.REF_OP_INSTANCE_METADATA;
                    temp_all[9] = MetaValue.REF_OP_CHANNEL_METADATA;
                    temp_all[10] = MetaValue.REF_OP_DICTIONARY_VALUES;
                    temp_all[11] = MetaValue.REF_OP_NETWORKINFO_VALUES;
                    temp_all[12] = MetaValue.REF_OP_NODE_METADATA;
                    this.init(temp_all);
                }

            }

        }
    }
}
