const fs = require('fs');
const path = require('path');
const rimraf = require('rimraf');
const readFile = require('./read-file');
const writeFile = require('./write-file');
const exec = require('./exec');
const exists = require('./exists');
const mkdirp = require('./mkdirp');

const KEVOREE_PKG = JSON.stringify({
  name: 'kevoree-module',
  private: true,
  description: 'This file has been auto-generated by Kevoree to prevent npm from logging useless stuff'
});

function NPMResolver(modulesPath, logger, skipIntegrityCheck) {
  if (!modulesPath || !logger) {
    throw new Error('NPMResolver constructor needs: modulesPath and Kevoree logger');
  }
  this.modulesPath = modulesPath;
  this.log = logger;
  this.log.debug('DeployUnits install directory: ' + this.modulesPath);
  try {
    // prevent npm from installing module in the root of this.modulesPath
    fs.unlinkSync(path.resolve(modulesPath, 'package.json'));
  } catch (ignore) { /*noop*/ }
  this.skipIntegrityCheck = Boolean(skipIntegrityCheck);
}

NPMResolver.prototype = {
  resolve(deployUnit) {
    const options = {
      duName: deployUnit.name,
      logName: deployUnit.name + '@' + deployUnit.version + ' (' + deployUnit.hashcode.substr(0, 8) + ')',
      name: deployUnit.name + '@' + deployUnit.version,
      path: path.resolve(this.modulesPath, 'deploy_units', deployUnit.name, deployUnit.version),
      hashcode: deployUnit.hashcode
    };
    return mkdirp(options.path)
      .then(() => {
        // lets try to check if the current directory contains the library
        // so that we can install it with the local content
        return readFile(path.resolve('.', 'package.json'))
          .then((data) => {
            const pkg = JSON.parse(data);
            if (pkg.name === deployUnit.name) {
              // current directory contains the library we want to resolve
              options.name = path.resolve('.');
              return this.preInstall(options);
            } else {
              // unable to find module locally, lets try to resolve it from npm registry
              return this.preInstall(options);
            }
          }, () => {
            // unable to require current directory package.json,
            // lets try to resolve module from npm registry
            return this.preInstall(options);
          });
      });
  },

  uninstall(deployUnit) {
    const modulePath = path.resolve(this.modulesPath, 'deploy_units', deployUnit.name, deployUnit.version);
    return rimraf(modulePath)
      .catch((err) => {
        this.log.error(err);
        throw new Error('NPMResolver failed to uninstall ' + modulePath);
      });
  },

  preInstall(options) {
    return exists(options.name, options.path, options.hashcode, this.skipIntegrityCheck)
      .then(({ exists, hashes }) => {
        if (exists) {
          // module is already installed: check integrity
          if (!hashes) {
            // already installed
            this.log.debug(options.logName + ' already installed');
          } else {
            // integrity check failed: try to re-install
            this.log.error('Installed ' + options.name + ' (' + hashes.local + ') differs from model (' + hashes.model + ')');
            return this.install(options);
          }
        } else {
          // module is not installed: install it
          return this.install(options);
        }
      })
      .then(() => {
        return this.loadClass(path.join(options.path, 'node_modules', options.duName));
      })
      .catch(() => {
        throw new Error('Unable to install ' + options.logName);
      });
  },

  install(options) {
    this.log.debug('Installing ' + options.logName);
    return writeFile(path.join(options.path, 'package.json'), KEVOREE_PKG)
      .then(() => {
        return exec(options.name, options.path)
          .then(() => {
            this.log.info(options.logName + ' installed');
          },
          (err) => {
            this.log.error(options.logName + ' installation failed \n' + err.stderr);
            throw err;
          });
      });
  },

  loadClass(pkgPath) {
    // resolve deployUnit module (require it) and call callback
    return Promise.resolve()
      .then(() => {
        delete require.cache[pkgPath];
        try {
          return require(pkgPath);
        } catch (err) {
          this.log.error('Unable to require(\'' + pkgPath + '\')');
          throw err;
        }
      });
  },

  toString() {
    return 'NPMResolver';
  }
};

module.exports = NPMResolver;
