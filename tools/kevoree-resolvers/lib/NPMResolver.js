'use strict';

var fs = require('fs');
var path = require('path');
var mkdirp = require('mkdirp');
var rimraf = require('rimraf');
var exec = require('./exec');
var exists = require('./exists');

var KEVOREE_PKG = JSON.stringify({
  name: 'kevoree-module',
  private: true,
  description: 'This package.json has been auto-generated by Kevoree to prevent npm from logging useless stuff'
});

function NPMResolver(modulesPath, logger, skipIntegrityCheck) {
  if (!modulesPath || !logger) {
    throw new Error('NPMResolver constructor needs: modulesPath and Kevoree logger');
  }
  this.modulesPath = modulesPath;
  this.log = logger;
	this.log.debug('DeployUnits install directory: ' + this.modulesPath);
  try {
    // prevent npm from installing module in the root of this.modulesPath
    fs.unlinkSync(path.resolve(modulesPath, 'package.json'));
  } catch (ignore) {/*noop*/}
	this.skipIntegrityCheck = Boolean(skipIntegrityCheck);
}

NPMResolver.prototype.resolve = function resolve(deployUnit, forceInstall, callback) {
	if (!callback) {
		// "forceInstall" parameter is not specified (optional)
		callback = forceInstall;
	}

	var options = {
    duName: deployUnit.name,
		name: deployUnit.name + '@' + deployUnit.version,
		path: path.resolve(this.modulesPath, 'deploy_units', deployUnit.name, deployUnit.version),
		hashcode: deployUnit.hashcode
	};

	mkdirp(options.path, (err) => {
		if (err) {
			callback(err);
		} else {
			// lets try to check if the current directory contains the library
			// so that we can install it with the local content
			fs.readFile(path.resolve('.', 'package.json'), (err, data) => {
				if (err) {
					// unable to require current directory package.json, lets try to resolve module from npm registry
					this.npmLoad(options, callback);
				} else {
					var pkg = JSON.parse(data);
					if (pkg.name === deployUnit.name) {
						// current directory contains the library we want to resolve
						options.name = path.resolve('.');
						this.npmLoad(options, callback);
					} else {
						// unable to find module locally, lets try to resolve it from npm registry
						this.npmLoad(options, callback);
					}
				}
			});
		}
	});
};

NPMResolver.prototype.uninstall = function uninstall(deployUnit, callback) {
  var modulePath = path.resolve(this.modulesPath, 'deploy_units', deployUnit.name, deployUnit.version);
  rimraf(modulePath, (err) => {
    if (err) {
      callback(new Error('NPMResolver failed to delete ' + modulePath));
    } else {
      callback();
    }
  });
};

NPMResolver.prototype.npmLoad = function npmLoad(options, callback) {
	var start = new Date().getTime();
	exists(options.name, options.path, options.hashcode, this.skipIntegrityCheck, (err, doesExist, hashError) => {
		if (err) {
			callback(err);
		} else {
			if (doesExist && hashError) {
				this.log.debug(options.name + ' local hashcode differs from model');
				this.log.debug('local=' + hashError.local + ' model=' + hashError.model);
			}

			if (doesExist && !hashError) {
				this.log.debug(options.name + ' found in ' + options.path + ' (' + (new Date().getTime() - start) + 'ms)');
				this.loadClass(path.join(options.path, 'node_modules', options.duName), callback);
				return;
			}

			this.log.debug(options.name + ' installing...');
      fs.writeFileSync(path.join(options.path, 'package.json'), KEVOREE_PKG);
      exec('npm', [ 'install', options.name, '--silent'], {
        cwd: options.path,
        stdio: ['ignore', 'ignore', process.stderr]
      }, (err) => {
        if (err) {
          this.log.error(options.name + ' installation failed');
          this.log.error(new Error('Unable to install DeployUnit ' + options.name).stack);
          callback(err);
        } else {
          this.log.info(options.name + ' installed (' + (new Date().getTime() - start) + 'ms)');
          exists(options.name, options.path, options.hashcode, this.skipIntegrityCheck, (err, doesExist, hashError) => {
            if (err) {
              callback(err);
            } else {
              if (doesExist && !hashError) {
                this.loadClass(path.join(options.path, 'node_modules', options.duName), callback);
              } else {
                this.log.error('installed ' + options.name + ' differs from registry (hash)');
                callback(new Error('Deployunit ' + options.name + ' integrity check failed'));
              }
            }
          });
        }
      });
		}
	});
};

NPMResolver.prototype.loadClass = function loadClass(pkgPath, callback) {
	// resolve deployUnit module (require it) and call callback
	delete require.cache[pkgPath];
	var error,
		Class;
	try {
		Class = require(pkgPath);
	} catch (err) {
		error = err;
		this.log.error('Unable to require(\'' + pkgPath + '\')');
	}
	callback(error, Class);
};

NPMResolver.prototype.toString = function toString() {
	return 'NPMResolver';
};

module.exports = NPMResolver;
